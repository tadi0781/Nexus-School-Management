# --- Imports ---
import logging
import os
import io
import csv
import string
import random
from collections import defaultdict
from datetime import datetime, timedelta, timezone,date
from calendar import monthrange
from functools import wraps
import uuid
from logging.handlers import RotatingFileHandler
import humanize
from markupsafe import Markup
from collections import defaultdict
from flask import (
    Flask,
    abort,
    flash,
    redirect,
    render_template,
    request,
    session,
    url_for,
    make_response,
    jsonify,  # Keep for future AJAX
    send_from_directory,
    current_app,
)
from flask_login import (
    LoginManager,
    UserMixin,
    current_user,
    login_required,
    login_user,
    logout_user,
)
from flask_migrate import Migrate
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy
from flask_wtf import FlaskForm
from flask_wtf.file import FileAllowed, FileField
from flask_socketio import SocketIO, emit, join_room, leave_room

# Keep if using
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.routing import BuildError
from werkzeug.utils import secure_filename  # For file uploads
from werkzeug.urls import url_parse  # For safe redirects
from werkzeug.exceptions import NotFound  # For send_from_directory
from flask_wtf.csrf import CSRFProtect, generate_csrf as wtf_generate_csrf
from sqlalchemy import (
    desc,
    exc,
    func,
    select,
    over,
    event,
    UniqueConstraint,
    Index,
    or_,
    and_,
    text,
    Column,
    Integer,
    String,
    ForeignKey,
    Date,
    Boolean,
    Text,
    case,
    literal_column,
)
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import joinedload, relationship
from sqlalchemy.ext.associationproxy import association_proxy

from wtforms import (
    BooleanField,
    DateField,
    FieldList,
    FormField,
    PasswordField,
    SelectField,
    StringField,
    SubmitField,
    TextAreaField,
    IntegerField,
    FloatField,
    HiddenField,
    RadioField,
    # FileField is already imported via flask_wtf.file
)
from wtforms.validators import (
    DataRequired,
    Email,
    EqualTo,
    Length,
    Optional,
    Regexp,
    ValidationError,
    NumberRange,
    URL,
)

# =================================================================
# GEMINI 3 PRO: PHASE 3.1 - High-Performance Caching with Redis
# =================================================================
from flask_caching import Cache

# --- Application Setup ---
app = Flask(__name__)

# Configure cache (moved *after* app creation)
config = {
    "DEBUG": True,
    "CACHE_TYPE": "RedisCache",
    "CACHE_REDIS_URL": "redis://localhost:6379/0",
    "CACHE_DEFAULT_TIMEOUT": 300,  # Default 5-minute cache
}
app.config.from_mapping(config)
cache = Cache(app)


# --- (Your Session Configuration) ---
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"


# --- (Your General Application Configuration - SECRET_KEY, SQLALCHEMY_DATABASE_URI) ---
app.config["ENV_MODE"] = os.getenv("APP_ENV", "development")
if app.config["ENV_MODE"] == "development":
    app.config["SECRET_KEY"] = (
        "your_strong_development_secret_key_here"  # CHANGE THIS IN PRODUCTION
    )
    app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 0
    app.config["TEMPLATES_AUTO_RELOAD"] = True
    app.debug = True
    print("Running in development mode")
else:
    app.config["SECRET_KEY"] = os.getenv("SECRET_KEY")
    if not app.config["SECRET_KEY"]:
        raise ValueError("No SECRET_KEY set for Flask application in production")
    app.debug = True
    print(f"Running in {app.config['ENV_MODE']} mode")

# NOTE: SQLALCHEMY_DATABASE_URI and TRACK_MODIFICATIONS are now set *before* db initialization
app.config["SQLALCHEMY_DATABASE_URI"] = 'postgresql://nexus:classicboy0781@localhost/nexus'
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False


# --- Initialize SQLAlchemy  ---
db = SQLAlchemy()
db.init_app(app)  # Initialize SQLAlchemy with the app


# Development-specific settings (already mostly covered above, but ensures clarity)
# Removed redundant settings - Keeping only what's truly needed

# --- ADDED: Social Media File Upload Configuration ---
# Define directory for uploaded files (create if it doesn't exist)
UPLOAD_FOLDER = os.path.join(app.root_path, "uploads", "social_files")
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

# Optional: Configure max file size (e.g., 16MB)
app.config["MAX_CONTENT_LENGTH"] = 16 * 1024 * 1024  # 16 megabytes
# --- END ADDED ---


# --- ADDED THIS LOGGING SETUP SECTION ---
# Configure basic logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]",
)
app.logger.setLevel(logging.INFO)

# Optional: Configure file handler for production logging
if not app.debug:
    file_handler = RotatingFileHandler("app.log", maxBytes=1024000, backupCount=10)
    file_handler.setFormatter(
        logging.Formatter(
            "%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]"
        )
    )
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.info("Nexus school management system startup")

Session(app)
socketio = SocketIO(app)
csrf = CSRFProtect(app)
# --- PART 1 END ---
# --- PART 2 START: Model Definitions ---


class Role(db.Model):
    __tablename__ = "role"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)

    users = db.relationship("User", back_populates="role", lazy="dynamic")
    secret_codes = db.relationship("SecretCode", back_populates="role", lazy=True)

    def __repr__(self):
        return f"<Role {self.name}>"

# In app.py, replace the old Lab model with this one

class Lab(db.Model):
    __tablename__ = "lab"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False, index=True)

    # --- NEW STRUCTURED FIELDS ---
    # This helps us identify if it's a classroom or a subject-specific lab.
    lab_type = db.Column(db.String(50), nullable=True, index=True) # e.g., 'classroom', 'subject'
    
    # These fields will be populated for 'classroom' type labs.
    grade = db.Column(db.String(10), nullable=True)
    section = db.Column(db.String(10), nullable=True)
    
    # This field will be populated for 'subject' type labs.
    subject = db.Column(db.String(100), nullable=True)
    # --- END OF NEW FIELDS ---

    # This relationship remains the same.
    lab_assignments = db.relationship("User", back_populates="lab", lazy="dynamic")

    def __repr__(self):
        return f"<Lab {self.name}>"


class AssetCategory(db.Model):
    __tablename__ = "asset_category"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    description = db.Column(db.Text)

    assets = db.relationship("Asset", back_populates="category", lazy="dynamic")
    # channels = db.relationship('Channel', back_populates='category', lazy='dynamic')

    def __repr__(self):
        return f"<AssetCategory {self.name}>"


# ADD THIS NEW MODEL DEFINITION:
class SocialCategory(db.Model):
    __tablename__ = "social_category"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    description = db.Column(db.Text)

    channels = db.relationship(
        "Channel", back_populates="social_category", lazy="dynamic"
    )

    def __repr__(self):
        return f"<SocialCategory {self.name}>"

class Message(db.Model):
    __tablename__ = "message"
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    receiver_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    sender_role = db.Column(db.String(50))
    receiver_role = db.Column(db.String(50))
    # BEGIN MODIFY - Task E1.4 (Message Model)
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey("social_files.id", ondelete="SET NULL"), nullable=True)
    file = db.relationship("File", foreign_keys=[file_id], backref=db.backref("direct_message_attachment", uselist=False, lazy="joined", cascade="all, delete-orphan"))
    timestamp = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), index=True
    )
    is_read = db.Column(db.Boolean, default=False, index=True)

    sender = db.relationship(
        "User", foreign_keys=[sender_id], back_populates="sent_messages"
    )
    receiver = db.relationship(
        "User", foreign_keys=[receiver_id], back_populates="received_messages"
    )

    def __repr__(self):
        return (
            f"<Message from {self.sender_id} to {self.receiver_id} at {self.timestamp}>"
        )

    __table_args__ = (
        db.Index("idx_message_pair", "sender_id", "receiver_id"),
        db.Index("idx_message_status", "is_read"),
        db.Index("idx_message_timestamp", "timestamp"),
    )

# --- NEW MODELS: Task System (Ordered correctly) ---


# Define UserTask first as Task depends on it for relationship definition
class UserTask(db.Model):
    __tablename__ = "user_task"
    id = db.Column(db.Integer, primary_key=True)
    task_id = db.Column(
        db.Integer, db.ForeignKey("task.id"), nullable=False, index=True
    )  # <-- FK to task
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # <-- FK to assigned user

    assigned_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    assigned_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False
    )  # <-- FK to assigning user

    # Status specific to THIS user's assignment
    status = db.Column(
        db.String(30), nullable=False, default="Open", index=True
    )  # e.g., 'Open', 'In Progress', 'Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Accepted', 'Review Rejected'
    completion_notes = db.Column(
        db.Text, nullable=True
    )  # Notes from assigned user (Completed, Delayed, Rejected)
    last_status_update_at = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
        nullable=False,
    )

    reviewed_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True
    )  # <-- FK to the reviewer

    reviewed_at = db.Column(db.DateTime, nullable=True)
    reviewer_notes = db.Column(
        db.Text, nullable=True
    )  # Notes from creator during review

    # Relationships
    # Note: task relationship must be defined *after* Task class is defined, but SQLAlchemy allows string name
    task = db.relationship("Task", back_populates="user_assignments")

    # Specify the foreign_keys for the 'user' relationship to point to user_id
    user = db.relationship(
        "User",
        foreign_keys=[user_id],  # Use the user_id column
        back_populates="assigned_tasks",  # Ensure this back_populates exists on User model
    )

    # Specify the foreign_keys for the 'assigned_by' relationship to point to assigned_by_id
    assigned_by = db.relationship(
        "User",
        foreign_keys=[assigned_by_id],  # Use the assigned_by_id column
        back_populates="assigned_tasks_instances",  # Ensure this back_populates exists on User model
    )

    # ADD a new relationship for the 'reviewed_by' foreign key (Fix from previous exchange)
    reviewed_by = db.relationship(
        "User",
        foreign_keys=[reviewed_by_id],  # Use the reviewed_by_id column
        back_populates="reviewed_tasks_instances",  # This will be defined on the User model
    )

    history = db.relationship(
        "TaskHistory",
        back_populates="user_task",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    __table_args__ = (
        db.UniqueConstraint(
            "task_id", "user_id", name="_task_user_uc"
        ),  # A user gets one instance per task instruction
        db.Index("idx_user_task_user_status", "user_id", "status"),
        db.Index("idx_user_task_task_status", "task_id", "status"),
        db.Index(
            "idx_user_task_reviewed_by", "reviewed_by_id"
        ),  # Optional: Add index for reviewed_by
    )

    def __repr__(self):
        return f"<UserTask ID:{self.id} Task:{self.task_id} User:{self.user_id} Status:'{self.status}'>"


# Define Task after UserTask
class Task(db.Model):
    __tablename__ = "task"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    urgency = db.Column(
        db.String(20), nullable=False, default="Medium"
    )  # e.g., 'Low', 'Medium', 'High', 'Critical'
    due_date = db.Column(db.Date, nullable=True)  # Overall task due datehkj

    created_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    last_updated_at = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
        nullable=False,
    )

    # Relationships
    created_by = db.relationship("User", back_populates="created_tasks")
    # UserTask is defined BEFORE Task now, so the string name 'UserTask' is resolvable
    user_assignments = db.relationship(
        "UserTask", back_populates="task", lazy="dynamic", cascade="all, delete-orphan"
    )

    __table_args__ = (
        db.Index("idx_task_creator", "created_by_id"),
        db.Index("idx_task_created_at", "created_at"),
    )

    def __repr__(self):
        return (
            f"<Task ID:{self.id} Title:'{self.title}' CreatedBy:{self.created_by_id}>"
        )


# Define TaskHistory after UserTask (as it depends on UserTask)
class TaskHistory(db.Model):
    __tablename__ = "task_history"
    id = db.Column(db.Integer, primary_key=True)
    user_task_id = db.Column(
        db.Integer, db.ForeignKey("user_task.id"), nullable=False, index=True
    )
    changed_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False
    )  # User who initiated the change

    old_status = db.Column(
        db.String(30), nullable=True
    )  # Can be null for initial assignment
    new_status = db.Column(db.String(30), nullable=False)
    action = db.Column(
        db.String(50), nullable=False
    )  # e.g., 'Assigned', 'Status Update', 'Review Accepted', 'Review Rejected'
    notes = db.Column(
        db.Text, nullable=True
    )  # Notes relevant to this history entry (e.g., copied from completion_notes or reviewer_notes)

    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )

    # Relationships
    user_task = db.relationship("UserTask", back_populates="history")
    changed_by = db.relationship("User", back_populates="task_history_entries")

    __table_args__ = (
        db.Index("idx_task_history_usertask_ts", "user_task_id", "timestamp"),
    )

    def __repr__(self):
        return f"<TaskHistory ID:{self.id} UserTask:{self.user_task_id} Action:'{self.action}' New Status:'{self.new_status}'>"


# --- ADD THIS NEW MODEL DEFINITION (e.g., after UserChannelCategory) ---


class UserChannelPreference(db.Model):
    """
    Association object for user-specific preferences on a channel,
    like pinning, archiving, or assigning to a custom category.
    """

    __tablename__ = "user_channel_preference"

    # Composite Primary Key
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id", ondelete="CASCADE"), primary_key=True
    )
    channel_id = db.Column(
        db.Integer,
        db.ForeignKey("social_channels.id", ondelete="CASCADE"),
        primary_key=True,
    )

    # Preference columns
    is_pinned = db.Column(db.Boolean, default=False, nullable=False, index=True)
    pinned_order = db.Column(db.Integer, nullable=True)
    is_archived = db.Column(db.Boolean, default=False, nullable=False, index=True)
    is_hidden = db.Column(db.Boolean, default=False, nullable=False)
    last_accessed_at = db.Column(db.DateTime, nullable=True)

    # Foreign key to the user's custom category for this channel
    user_category_id = db.Column(
        db.Integer,
        db.ForeignKey("user_channel_category.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    # Relationships
    user = db.relationship("User", back_populates="channel_preferences")
    channel = db.relationship("Channel", back_populates="user_preferences")
    user_channel_category = db.relationship(
        "UserChannelCategory", back_populates="channel_assignments"
    )

    __table_args__ = (
        db.Index("idx_user_channel_pref_user_pinned", "user_id", "is_pinned"),
    )

    def __repr__(self):
        return f"<UserChannelPreference User:{self.user_id} Channel:{self.channel_id} Pinned:{self.is_pinned}>"


# --- END OF NEW MODEL ---

ROLE_PERMISSIONS = {
    'system_admin': [
        'REPORT_ASSET', 'EDIT_ASSET', 'DELETE_ASSET', 'MANAGE_CATEGORIES', 'VIEW_ALL_REPORTS'
    ],
    'hr_ceo': [
        'REPORT_ASSET', 'EDIT_ASSET', 'DELETE_ASSET', 'MANAGE_CATEGORIES', 'VIEW_ALL_REPORTS'
    ],
    'school_executive': [
        'REPORT_ASSET',
    ],
    'government': [
        'REPORT_ASSET',
    ],
    'teacher': [
        'REPORT_ASSET',
    ],
    'librarian': [
        'REPORT_ASSET',
    ],
    'talent_club': [
        'REPORT_ASSET',
        # The 'DELETE_ASSET' permission is granted, but the route itself
        # will perform a stricter check (e.g., is_tc_leader and owns the asset).
        'DELETE_ASSET',
    ],
    'student': [
        'REPORT_ASSET',
        # Similar to talent_club, the route performs the final check.
        'DELETE_ASSET',
    ],
    'parent': [] # Parents cannot interact with the asset system
}
# Define User Model (includes all previous relationships + the fix)
        
class SocialGroup(db.Model):
    __tablename__ = "social_group"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    description = db.Column(db.Text, nullable=True)
    owner_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    profile_photo_url = db.Column(db.String(255), nullable=True)
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    owner = db.relationship("User", back_populates="owned_groups")
    
    # FIX: Ensure this relationship points to the correct class "SocialGroupMember"
    members = db.relationship(
        "SocialGroupMember",
        back_populates="group",
        cascade="all, delete-orphan",
        lazy="dynamic",
    )
    
    messages = db.relationship(
        "GroupMessage",
        back_populates="group",
        cascade="all, delete-orphan",
        lazy="dynamic",
    )

    def __repr__(self):
        return f"<SocialGroup {self.id}: {self.name}>"
# Social Media Group Membership (The correct one)
class SocialGroupMember(db.Model):
    __tablename__ = "social_group_member"
    
    # FIX: Changed from "social_groups.id" to match the actual table name "social_group.id"
    group_id = db.Column(
        db.Integer, db.ForeignKey("social_group.id"), primary_key=True
    )
    
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), primary_key=True)

    role = db.Column(db.String(20), default="member", nullable=False)
    joined_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    group = db.relationship(
        "SocialGroup", back_populates="members"
    )
    user = db.relationship(
        "User", back_populates="social_group_memberships", foreign_keys=[user_id]
    )

    __table_args__ = (UniqueConstraint("group_id", "user_id", name="_group_user_uc"),)

    def __repr__(self):
        return f"<SocialGroupMember UserID:{self.user_id} in GroupID:{self.group_id} as {self.role}>"
        
class SecretCode(db.Model):
    __tablename__ = "secret_code"
    id = db.Column(db.Integer, primary_key=True)
    code = db.Column(db.String(255), unique=True, nullable=False, index=True) # Assumes you expanded this
    full_name = db.Column(db.String(120), nullable=False)
    role_id = db.Column(db.Integer, db.ForeignKey("role.id"), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id", ondelete="SET NULL"), nullable=True, index=True)
    grade = db.Column(db.String(10), nullable=True) 
    section = db.Column(db.String(10), nullable=True) 
    is_used = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    
    role = db.relationship("Role", back_populates="secret_codes")
    user = db.relationship("User", back_populates="secret_code")

    def __repr__(self):
        return f"<SecretCode {self.code} (User: {self.user.username if self.user else 'Unused'})>"
class TeacherProfile(db.Model):
    __tablename__ = "teacher_profile"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    # The secret_code_id and relationship are now completely removed.
    
    subject = db.Column(db.String(100), nullable=False)
    salary = db.Column(db.Float, nullable=True)
    grade = db.Column(db.Integer, nullable=True)
    section = db.Column(db.Integer, nullable=True) # Changed to Integer to match DB

    user = db.relationship("User", back_populates="teacher_profiles")

    def __repr__(self):
        return f"<TeacherProfile UserID: {self.user_id}, Subject: {self.subject}>"
class Student(db.Model):
    __tablename__ = "students"

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), unique=True)
    grade = db.Column(db.String(10))
    section = db.Column(db.Integer)
    # Add other student-specific fields

    # Relationship to User
    user = db.relationship("User", backref=db.backref("student", uselist=False))


# ... (rest of your app.py code) ...
class ParentStudent(db.Model):
    """Association table between parents and their students"""

    __tablename__ = "parent_student"
    parent_id = db.Column(db.Integer, db.ForeignKey("parent.id"), primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey("user.id"), primary_key=True)
    verification_status = db.Column(db.String(20), default="pending")
    relationship = db.Column(db.String(50))
    verified_at = db.Column(db.DateTime, nullable=True)

    parent = db.relationship("Parent", back_populates="student_associations")
    student = db.relationship("User", back_populates="parent_associations")


class Parent(db.Model):
    __tablename__ = "parent"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), unique=True, nullable=False
    )

    preferred_contact_method = db.Column(db.String(20), default="email")
    receive_grade_updates = db.Column(db.Boolean, default=True)
    receive_behavior_updates = db.Column(db.Boolean, default=True)

    user = db.relationship("User", back_populates="parent_profile")
    student_associations = db.relationship(
        "ParentStudent", back_populates="parent", cascade="all, delete-orphan"
    )
    students = association_proxy(
        "student_associations",
        "student",
        creator=lambda student: ParentStudent(student=student),
    )


class BehaviorRecord(db.Model):
    __tablename__ = "behavior_record"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    recorded_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    date = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    behavior_type = db.Column(db.String(50), nullable=False)
    description = db.Column(db.Text, nullable=False)
    severity = db.Column(db.String(20), default="Medium", nullable=False)
    resolution = db.Column(db.Text, nullable=True)
    is_resolved = db.Column(db.Boolean, default=False, nullable=False, index=True)

    student = db.relationship(
        "User", foreign_keys=[student_id], back_populates="behavior_records"
    )
    recorded_by = db.relationship(
        "User",
        foreign_keys=[recorded_by_id],
        back_populates="recorded_behavior_records",
    )

    __table_args__ = (db.Index("idx_behavior_student_date", "student_id", "date"),)

    def __repr__(self):
        return f"<BehaviorRecord ID:{self.id} Student:{self.student_id} Type:{self.behavior_type} Date:{self.date.strftime('%Y-%m-%d')}>"


# --- NEW MODELS: Request System ---


class Request(db.Model):
    __tablename__ = "request"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    request_type = db.Column(
        db.String(50), nullable=False
    )  # e.g., 'Deficiency', 'Purchase', 'General'
    urgency = db.Column(
        db.String(20), nullable=False, default="Medium"
    )  # e.g., 'Low', 'Medium', 'High', 'Critical'

    requester_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    current_handler_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True, index=True
    )
    last_forwarded_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True, index=True
    )  # Who last forwarded it

    status = db.Column(
        db.String(20), nullable=False, default="Pending", index=True
    )  # e.g., 'Pending', 'Approved', 'On Progress', 'Denied', 'Resolved'
    tier = db.Column(
        db.Integer, nullable=False, default=1, index=True
    )  # 1: HR/CEO, 2: School Exec, 3: Government

    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    last_updated_at = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
        nullable=False,
    )

    resolution_notes = db.Column(
        db.Text, nullable=True
    )  # Notes from handlers during review/resolution
    denial_reason = db.Column(
        db.Text, nullable=True
    )  # Reason for denial, if status is 'Denied'

    # Relationships
    requester = db.relationship(
        "User", foreign_keys=[requester_id], back_populates="submitted_requests"
    )
    current_handler = db.relationship(
        "User", foreign_keys=[current_handler_id], back_populates="assigned_requests"
    )
    last_forwarded_by = db.relationship(
        "User", foreign_keys=[last_forwarded_by_id], back_populates="forwarded_requests"
    )

    history = db.relationship(
        "RequestHistory",
        back_populates="request",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    __table_args__ = (
        db.Index("idx_request_status_tier", "status", "tier"),
        db.Index("idx_request_requester_status", "requester_id", "status"),
    )

    def __repr__(self):
        return f"<Request ID:{self.id} Title:'{self.title}' Status:'{self.status}' Tier:{self.tier}>"


class RequestHistory(db.Model):
    __tablename__ = "request_history"
    id = db.Column(db.Integer, primary_key=True)
    request_id = db.Column(
        db.Integer, db.ForeignKey("request.id"), nullable=False, index=True
    )
    changed_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    old_status = db.Column(
        db.String(20), nullable=True
    )  # Can be null if first entry (Submitted)
    new_status = db.Column(db.String(20), nullable=False)
    action = db.Column(
        db.String(50), nullable=False
    )  # e.g., 'Submitted', 'Reviewed', 'Forwarded', 'Resolved', 'Denied', 'Edited'
    notes = db.Column(db.Text, nullable=True)  # Specific notes for this history entry
    timestamp = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    request = db.relationship("Request", back_populates="history")
    changed_by = db.relationship("User", back_populates="request_history_entries")

    __table_args__ = (
        db.Index("idx_request_history_request_ts", "request_id", "timestamp"),
    )

    def __repr__(self):
        return f"<RequestHistory ID:{self.id} Request:{self.request_id} Action:'{self.action}' New Status:'{self.new_status}'>"


# --- END NEW MODELS ---


# Around line 694 in your app.py
class Asset(db.Model):
    __tablename__ = "asset"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, index=True)
    description = db.Column(db.Text, nullable=True)
    quantity = db.Column(db.Integer, nullable=False, default=1)
    purchase_cost = db.Column(db.Float, nullable=True)
    condition = db.Column(db.String(50), nullable=False, default="New")
    is_consumable = db.Column(db.Boolean, nullable=False, default=False)
    expiry_date = db.Column(db.Date, nullable=True)
    last_maintenance_date = db.Column(db.Date, nullable=True)
    status = db.Column(
        db.String(50), nullable=False, default="Pending Review", index=True
    )
    location_description = db.Column(db.String(255), nullable=True)

    # --- ADD THE FOLLOWING LINE ---
    created_at = db.Column(
        db.DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    # --- END OF ADDED LINE ---

    added_by_user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True, index=True
    )
    category_id = db.Column(
        db.Integer, db.ForeignKey("asset_category.id"), nullable=True, index=True
    )
    lab_id = db.Column(db.Integer, db.ForeignKey("lab.id"), nullable=True, index=True)

    category = db.relationship("AssetCategory", back_populates="assets")
    added_by_user = db.relationship(
        "User", foreign_keys=[added_by_user_id], back_populates="added_assets"
    )
    lab = db.relationship("Lab", backref=db.backref("assets", lazy="dynamic"))

    reports = db.relationship(
        "AssetReport",
        back_populates="asset",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    book_checkouts = db.relationship(
        "BookCheckout",
        back_populates="asset",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    borrowed_by = db.relationship(
        "BorrowedAsset", back_populates="asset", lazy="dynamic"
    )

    def __repr__(self):
        return f"<Asset ID:{self.id} Name:{self.name} Status:{self.status}>"


class AssetReport(db.Model):
    __tablename__ = "asset_reports"
    id = db.Column(db.Integer, primary_key=True)
    asset_id = db.Column(
        db.Integer, db.ForeignKey("asset.id"), nullable=True, index=True
    )
    reported_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    report_date = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    damage_description = db.Column(db.Text, nullable=False)
    date_of_damage = db.Column(db.Date, nullable=True)
    quantity_damaged = db.Column(db.Integer, default=1, nullable=False)
    status = db.Column(db.String(50), default="Pending", nullable=False, index=True)
    resolution_notes = db.Column(db.Text, nullable=True)
    resolved_by_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    resolved_date = db.Column(db.DateTime, nullable=True)

    asset = db.relationship("Asset", back_populates="reports")
    reporter = db.relationship(
        "User", foreign_keys=[reported_by_id], back_populates="submitted_reports"
    )
    resolver = db.relationship(
        "User", foreign_keys=[resolved_by_id], back_populates="resolved_reports"
    )

    __table_args__ = (
        db.Index("idx_asset_report_status", "status"),
        db.Index("idx_asset_report_asset", "asset_id"),
        db.Index("idx_asset_report_reporter", "reported_by_id"),
        db.Index("idx_asset_report_date", "report_date"),
        db.Index("idx_asset_report_resolver", "resolved_by_id"),
    )

    def __repr__(self):
        return (
            f"<AssetReport ID:{self.id} for Asset:{self.asset_id} Status:{self.status}>"
        )


class BookCheckout(db.Model):
    __tablename__ = "book_checkout"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    asset_id = db.Column(
        db.Integer, db.ForeignKey("asset.id"), nullable=False, index=True
    )
    checkout_date = db.Column(
        db.Date, nullable=False, default=lambda: datetime.now(timezone.utc).date()
    )
    due_date = db.Column(db.Date, nullable=False)
    return_date = db.Column(db.Date, nullable=True)
    returned = db.Column(db.Boolean, default=False, nullable=False, index=True)

    user = db.relationship("User", back_populates="book_checkouts")
    asset = db.relationship("Asset", back_populates="book_checkouts")

    __table_args__ = (
        db.Index("idx_book_checkout_dates", "checkout_date", "due_date", "return_date"),
    )

    def __repr__(self):
        return f"<BookCheckout UserID: {self.user_id}, AssetID: {self.asset_id}, Due: {self.due_date}, Returned: {self.returned}>"


# --- START ADDITION: TalentClub Model ---
# --- NEW MODELS: Talent Club Subsystem ---


class TalentClub(db.Model):
    __tablename__ = "talent_club_instances"  # Renamed for clarity
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False, index=True)
    description = db.Column(db.Text, nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)  # Added for club photo
    owner_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The creator/primary manager of THIS club instance
    social_category_id = db.Column(
        db.Integer, db.ForeignKey("social_category.id"), nullable=False, index=True
    )  # Category of the club
    level = db.Column(db.Integer, default=1, nullable=False)  # Club level
    warning_count = db.Column(db.Integer, default=0, nullable=False)  # Warning count
    is_active = db.Column(
        db.Boolean, default=True, nullable=False
    )  # For soft deletion (e.g., after too many warnings)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    owner = db.relationship(
        "User", back_populates="owned_talent_clubs"
    )  # Link back to User owner
    social_category = db.relationship("SocialCategory")  # Link to category

    # Relationships to new associated models
    # CORRECTED: Removed lazy='dynamic'
    memberships = db.relationship(
        "TalentClubMembership", back_populates="club", cascade="all, delete-orphan"
    )
    follows = db.relationship(
        "TalentClubFollow", back_populates="club", cascade="all, delete-orphan"
    )

    feed = db.relationship(
        "TalentClubFeed",
        back_populates="talent_club",
        uselist=False,
        cascade="all, delete-orphan",
    )  # Link to its content feed
    warnings = db.relationship(
        "TalentClubWarning",
        back_populates="club",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )  # Keep lazy='dynamic' if you perform sub-filtering often here

    def __repr__(self):
        return f"<TalentClub ID:{self.id} Name:'{self.name}' Level:{self.level} Active:{self.is_active}>"


# ... (rest of app.py) ...
class TalentClubMembership(db.Model):
    __tablename__ = (
        "talent_club_memberships"  # Link users to specific clubs (official members)
    )
    talent_club_id = db.Column(
        db.Integer, db.ForeignKey("talent_club_instances.id"), primary_key=True
    )
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), primary_key=True)
    role = db.Column(
        db.String(20), default="member", nullable=False
    )  # Role within THIS club (creator, admin, member)
    joined_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    is_active = db.Column(
        db.Boolean, default=True, nullable=False
    )  # Allow suspending membership within a club

    # Relationships
    club = db.relationship("TalentClub", back_populates="memberships")
    user = db.relationship(
        "User", back_populates="tc_memberships", foreign_keys=[user_id]
    )

    __table_args__ = (
        UniqueConstraint("talent_club_id", "user_id", name="_tc_membership_uc"),
    )

    def __repr__(self):
        return f"<TalentClubMembership ClubID:{self.talent_club_id} UserID:{self.user_id} as {self.role}>"


class TalentClubFollow(db.Model):
    __tablename__ = (
        "talent_club_follows"  # Link users to specific clubs they follow (not members)
    )
    id = db.Column(db.Integer, primary_key=True)  # Added ID as PK
    talent_club_id = db.Column(
        db.Integer,
        db.ForeignKey("talent_club_instances.id"),
        nullable=False,
        index=True,
    )
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    followed_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    receive_notifications = db.Column(
        db.Boolean, default=True, nullable=False
    )  # Toggle for content notifications

    # Relationships
    club = db.relationship("TalentClub", back_populates="follows")
    user = db.relationship("User", back_populates="tc_follows", foreign_keys=[user_id])

    __table_args__ = (
        UniqueConstraint("talent_club_id", "user_id", name="_tc_follow_uc"),
    )
    __mapper_args__ = {
        "confirm_deleted_rows": False
    }  # Avoids a warning with bulk updates

    def __repr__(self):
        return f"<TalentClubFollow ClubID:{self.talent_club_id} UserID:{self.user_id}>"


class TalentClubFeed(db.Model):
    __tablename__ = (
        "talent_club_feeds"  # Content feed for a specific TalentClub instance
    )
    id = db.Column(db.Integer, primary_key=True)
    talent_club_id = db.Column(
        db.Integer,
        db.ForeignKey("talent_club_instances.id"),
        unique=True,
        nullable=False,
    )  # Link to the club

    allow_comments = db.Column(
        db.Boolean, default=True, nullable=False
    )  # Feed settings
    allow_reactions = db.Column(db.Boolean, default=True, nullable=False)

    # Relationships
    talent_club = db.relationship("TalentClub", back_populates="feed")
    posts = db.relationship(
        "TalentClubFeedPost",
        back_populates="feed",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<TalentClubFeed ID:{self.id} for Club ID:{self.talent_club_id}>"


class TalentClubFeedPost(db.Model):
    __tablename__ = "talent_club_feed_posts"  # Posts within a TalentClub feed
    id = db.Column(db.Integer, primary_key=True)
    feed_id = db.Column(
        db.Integer, db.ForeignKey("talent_club_feeds.id"), nullable=False, index=True
    )
    author_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # Must be a club member with posting rights
    content = db.Column(db.Text, nullable=True)  # Text content
    file_id = db.Column(
        db.Integer,
        db.ForeignKey("social_files.id"),
        unique=True,
        nullable=True,
        index=True,
    )  # Link to existing File model
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    # Relationships
    feed = db.relationship("TalentClubFeed", back_populates="posts")
    author = db.relationship("User")  # Link to the user who posted
    file = db.relationship("File", uselist=False)  # Link to attached file

    comments = db.relationship(
        "TalentClubFeedComment",
        back_populates="post",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    reactions = db.relationship(
        "TalentClubFeedReaction",
        back_populates="post",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<TalentClubFeedPost ID:{self.id} FeedID:{self.feed_id} AuthorID:{self.author_id}>"


class TalentClubFeedComment(db.Model):
    __tablename__ = "talent_club_feed_comments"  # Comments on a TalentClub feed post
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(
        db.Integer,
        db.ForeignKey("talent_club_feed_posts.id"),
        nullable=False,
        index=True,
    )
    author_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )

    # Relationships
    post = db.relationship("TalentClubFeedPost", back_populates="comments")
    author = db.relationship("User")

    def __repr__(self):
        return f"<TalentClubFeedComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"


class TalentClubFeedReaction(db.Model):
    __tablename__ = "talent_club_feed_reactions"  # Reactions on a TalentClub feed post
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(
        db.Integer, db.ForeignKey("talent_club_feed_posts.id"), nullable=False
    )
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False
    )  # User who reacted
    emoji = db.Column(db.String(50), nullable=False)  # The emoji string
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    post = db.relationship("TalentClubFeedPost", back_populates="reactions")
    user = db.relationship("User")

    __table_args__ = (
        UniqueConstraint("post_id", "user_id", "emoji", name="_tc_post_user_emoji_uc"),
    )

    def __repr__(self):
        return f"<TalentClubFeedReaction ID:{self.id} PostID:{self.post_id} UserID:{self.user_id} Emoji:{self.emoji}>"


class TalentClubCommunity(db.Model):
    __tablename__ = "talent_club_community"  # The single global TC Community group
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(
        db.String(100), unique=True, nullable=False
    )  # e.g. "TC Community Group"
    description = db.Column(db.String(255), nullable=True)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    messages = db.relationship(
        "TalentClubCommunityMessage",
        back_populates="community",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    members = db.relationship(
        "TalentClubCommunityMember",
        back_populates="community",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<TalentClubCommunity ID:{self.id} Name:'{self.name}'>"


class TalentClubCommunityMember(db.Model):
    __tablename__ = "talent_club_community_members"  # Users in the TC Community group
    community_id = db.Column(
        db.Integer, db.ForeignKey("talent_club_community.id"), primary_key=True
    )
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id", ondelete="CASCADE"), primary_key=True
    )  # ADDED ondelete='CASCADE'
    role = db.Column(
        db.String(20), default="member", nullable=False
    )  # e.g. 'admin', 'member'
    joined_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    community = db.relationship("TalentClubCommunity", back_populates="members")
    user = db.relationship("User")  # Link to user

    __table_args__ = (
        UniqueConstraint("community_id", "user_id", name="_tcc_membership_uc"),
    )

    def __repr__(self):
        return f"<TalentClubCommunityMember CommID:{self.community_id} UserID:{self.user_id} as {self.role}>"


class TalentClubCommunityMessage(db.Model):
    __tablename__ = (
        "talent_club_community_messages"  # Messages in the TC Community group
    )
    id = db.Column(db.Integer, primary_key=True)
    community_id = db.Column(
        db.Integer,
        db.ForeignKey("talent_club_community.id"),
        nullable=False,
        index=True,
    )
    author_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # Must be a TCC member
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(
        db.Integer,
        db.ForeignKey("social_files.id"),
        unique=True,
        nullable=True,
        index=True,
    )  # Link to existing File model
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    # Relationships
    community = db.relationship("TalentClubCommunity", back_populates="messages")
    author = db.relationship("User")  # Link to author
    file = db.relationship("File", uselist=False)  # Link to attached file

    def __repr__(self):
        return f"<TalentClubCommunityMessage ID:{self.id} CommID:{self.community_id} AuthorID:{self.author_id}>"


class TalentClubProposal(db.Model):
    __tablename__ = "talent_club_proposals"  # Proposal for a new club instance
    id = db.Column(db.Integer, primary_key=True)
    creator_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The user initiating the proposal
    name = db.Column(db.String(100), nullable=False)  # Proposed name
    description = db.Column(db.Text, nullable=False)  # Proposed description
    social_category_id = db.Column(
        db.Integer, db.ForeignKey("social_category.id"), nullable=False, index=True
    )  # Proposed category
    proposal_file_id = db.Column(
        db.Integer, db.ForeignKey("social_files.id"), unique=True, nullable=True
    )  # Optional attachment (reusing File model)
    status = db.Column(
        db.String(30), default="pending_leader_review", nullable=False, index=True
    )  # pending_leader_review, pending_members_accept, accepted, rejected
    leader_review_notes = db.Column(
        db.Text, nullable=True
    )  # Notes from TC Leader review
    reviewed_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True, index=True
    )  # The TC Leader who reviewed
    reviewed_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    creator = db.relationship(
        "User", back_populates="tc_proposals_created", foreign_keys=[creator_id]
    )
    social_category = db.relationship("SocialCategory")
    proposal_file = db.relationship("File", uselist=False)
    mentioned_members = db.relationship(
        "TalentClubMention",
        back_populates="proposal",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )  # Students mentioned in the proposal
    reviewed_by = db.relationship("User", foreign_keys=[reviewed_by_id])

    def __repr__(self):
        return f"<TalentClubProposal ID:{self.id} Name:'{self.name}' Status:'{self.status}' Creator:{self.creator_id}>"


class TalentClubMention(db.Model):
    __tablename__ = "talent_club_proposal_mentions"  # Students mentioned in a proposal
    id = db.Column(db.Integer, primary_key=True)  # Added PK for notification linking
    proposal_id = db.Column(
        db.Integer,
        db.ForeignKey("talent_club_proposals.id"),
        nullable=False,
        index=True,
    )
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The student user being mentioned
    status = db.Column(
        db.String(20), default="pending", nullable=False, index=True
    )  # pending, accepted, rejected
    responded_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    proposal = db.relationship("TalentClubProposal", back_populates="mentioned_members")
    user = db.relationship(
        "User", back_populates="tc_mentions_received", foreign_keys=[user_id]
    )

    __table_args__ = (
        UniqueConstraint("proposal_id", "user_id", name="_tc_proposal_mention_uc"),
    )

    def __repr__(self):
        return f"<TalentClubMention ID:{self.id} ProposalID:{self.proposal_id} UserID:{self.user_id} Status:'{self.status}'>"


class TalentClubWarning(db.Model):
    __tablename__ = "talent_club_warnings"  # Warnings issued to a TalentClub instance
    id = db.Column(db.Integer, primary_key=True)
    talent_club_id = db.Column(
        db.Integer,
        db.ForeignKey("talent_club_instances.id"),
        nullable=False,
        index=True,
    )
    issued_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # Should be the TC Leader
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    club = db.relationship("TalentClub", back_populates="warnings")
    issued_by = db.relationship("User")

    def __repr__(self):
        return f"<TalentClubWarning ID:{self.id} ClubID:{self.talent_club_id} IssuedBy:{self.issued_by_id} at {self.issued_at}>"


# Optional Models for more detailed Ban/Penalty tracking
class TalentClubBan(db.Model):
    __tablename__ = "talent_club_bans"  # System-wide TC bans/mutes
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The TC Member banned/muted
    issued_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The TC Leader or Admin
    type = db.Column(db.String(20), nullable=False)  # e.g., 'ban', 'mute'
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    expires_at = db.Column(db.DateTime, nullable=True)  # Null for permanent ban

    # Relationships
    user = db.relationship(
        "User", foreign_keys=[user_id], back_populates="tc_bans_received"
    )
    issued_by = db.relationship(
        "User", foreign_keys=[issued_by_id], back_populates="tc_bans_issued"
    )

    def __repr__(self):
        return f"<TalentClubBan ID:{self.id} User:{self.user_id} Type:'{self.type}' IssuedBy:{self.issued_by_id}>"


class TalentClubPenalty(db.Model):
    __tablename__ = "talent_club_penalties"  # System-wide TC penalties (if needed, distinct from bans/warnings)
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The TC Member penalized
    issued_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The TC Leader or Admin
    type = db.Column(
        db.String(50), nullable=False
    )  # e.g., 'points_deduction', 'feature_restriction'
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    expires_at = db.Column(db.DateTime, nullable=True)  # For temporary penalties

    # Relationships
    user = db.relationship(
        "User", foreign_keys=[user_id], back_populates="tc_penalties_received"
    )
    issued_by = db.relationship(
        "User", foreign_keys=[issued_by_id], back_populates="tc_penalties_issued"
    )

    def __repr__(self):
        return f"<TalentClubPenalty ID:{self.id} User:{self.user_id} Type:'{self.type}' IssuedBy:{self.issued_by_id}>"


class TalentClubLeaderElection(db.Model):
    __tablename__ = (
        "tc_leader_elections"  # Tracks elections for the system-wide TC Leader
    )
    id = db.Column(db.Integer, primary_key=True)
    initiated_by_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # HR/CEO who started it
    initiated_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    concluded_at = db.Column(db.DateTime, nullable=True)
    status = db.Column(
        db.String(20), default="active", nullable=False, index=True
    )  # active, concluded, cancelled
    elected_leader_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True, index=True
    )  # The user who won

    # Relationships
    initiated_by = db.relationship(
        "User",
        foreign_keys=[initiated_by_id],
        back_populates="tc_leader_election_initiated",
    )
    elected_leader = db.relationship(
        "User", foreign_keys=[elected_leader_id]
    )  # User who won
    votes = db.relationship(
        "TalentClubLeaderVote",
        back_populates="election",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<TalentClubLeaderElection ID:{self.id} Status:'{self.status}' Initiated:{self.initiated_at.strftime('%Y-%m-%d')}>"


class TalentClubLeaderVote(db.Model):
    __tablename__ = "tc_leader_votes"  # Individual votes in a TC Leader election
    id = db.Column(db.Integer, primary_key=True)  # Added PK
    election_id = db.Column(
        db.Integer, db.ForeignKey("tc_leader_elections.id"), nullable=False, index=True
    )
    voter_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The user who voted (must be is_tc_member)
    candidate_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )  # The user they voted for (must be is_tc_member)
    voted_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    election = db.relationship("TalentClubLeaderElection", back_populates="votes")
    voter = db.relationship(
        "User", foreign_keys=[voter_id], back_populates="tc_leader_votes_cast"
    )
    candidate = db.relationship(
        "User", foreign_keys=[candidate_id]
    )  # The candidate user

    __table_args__ = (
        UniqueConstraint("election_id", "voter_id", name="_tc_leader_vote_uc"),
    )  # Each voter gets one vote per election

    def __repr__(self):
        return f"<TalentClubLeaderVote ID:{self.id} Election:{self.election_id} Voter:{self.voter_id} Candidate:{self.candidate_id}>"


class BorrowedAsset(db.Model):  # Added BorrowedAsset model
    __tablename__ = "borrowed_asset"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    asset_id = db.Column(
        db.Integer, db.ForeignKey("asset.id"), nullable=False, index=True
    )
    checkout_date = db.Column(
        db.Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False
    )
    due_date = db.Column(db.Date, nullable=False)
    return_date = db.Column(db.Date, nullable=True)
    returned = db.Column(db.Boolean, default=False, nullable=False, index=True)

    user = db.relationship("User", back_populates="borrowed_assets")
    asset = db.relationship("Asset", back_populates="borrowed_by")

    def __repr__(self):
        return f"<BorrowedAsset UserID: {self.user_id}, AssetID: {self.asset_id}, Due: {self.due_date}, Returned: {self.returned}>"


class Notification(db.Model):
    __tablename__ = "notification"
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    receiver_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), index=True
    )
    is_read = db.Column(db.Boolean, default=False, nullable=False, index=True)
    link_url = db.Column(db.String(255), nullable=True)

    sender = db.relationship(
        "User", foreign_keys=[sender_id], back_populates="sent_notifications"
    )
    receiver = db.relationship(
        "User", foreign_keys=[receiver_id], back_populates="received_notifications"
    )
    notification_type = db.Column(
        db.String(50), nullable=True
    )  # e.g., 'chat', 'general', 'request', 'tc_invite', 'tc_warning', 'tc_level_change', 'tc_vote_open', 'tc_vote_result'
    related_object_id = db.Column(
        db.Integer, nullable=True, index=True
    )  # ID of related object (e.g., TalentClubMention ID for invite, TalentClub ID for warning/level, Election ID for vote)
    __table_args__ = (
        db.Index("idx_notification_receiver_read", "receiver_id", "is_read"),
    )

    def __repr__(self):
        return f"<Notification from {self.sender_id} to {self.receiver_id} at {self.timestamp}>"


class Attendance(db.Model):  # Student Attendance
    __tablename__ = "student_attendance"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    date = db.Column(
        db.Date,
        default=lambda: datetime.now(timezone.utc).date(),
        nullable=False,
        index=True,
    )
    status = db.Column(db.String(10), default="Present", nullable=False)
    notes = db.Column(db.Text)

    student = db.relationship("User", back_populates="attendance_entries")

    __table_args__ = (
        db.UniqueConstraint("student_id", "date", name="_student_date_uc"),
    )

    def __repr__(self):
        return f"<StudentAttendance StudentID: {self.student_id}, Date: {self.date}, Status: {self.status}>"


class StaffAttendance(db.Model):  # Staff Attendance
    __tablename__ = "staff_attendance"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False, index=True)
    date = Column(
        Date,
        default=lambda: datetime.now(timezone.utc).date(),
        nullable=False,
        index=True,
    )
    present = Column(Boolean, default=False, nullable=False)
    notes = Column(Text)

    user = relationship("User", back_populates="staff_attendance_records")

    __table_args__ = (
        db.UniqueConstraint("user_id", "date", name="_staff_attendance_uc"),
    )

    def __repr__(self):
        status = "Present" if self.present else "Absent"
        return f"<StaffAttendance UserID: {self.user_id}, Date: {self.date}, Status: {status}>"


class File(db.Model):
    __tablename__ = "social_files"
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(255), nullable=False)
    original_filename = db.Column(db.String(255), nullable=False)
    mimetype = db.Column(db.String(100), nullable=True)
    filepath = db.Column(db.String(255), unique=True, nullable=False)
    size = db.Column(db.BigInteger, nullable=False)
    uploaded_by_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    uploaded_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    global_post_attachment = db.relationship(
        "GlobalPost", back_populates="attached_file", uselist=False
    )
    # --- End of File model addition ---
    uploader = db.relationship("User", back_populates="uploaded_social_files")
    channel_post = db.relationship("ChannelPost", back_populates="file", uselist=False)
    group_message = db.relationship(
        "GroupMessage", back_populates="file", uselist=False
    )

    def get_download_url(self):
        try:
            from flask import url_for

            return url_for("download_social_file", file_id=self.id, _external=True)
        except RuntimeError:
            print(
                f"Warning: url_for called outside application context for File {self.id}"
            )
            return f"/social/files/download/{self.id}"


# --- NEW FORMS: Task System ---
# In app.py, near your other form definitions

# In app.py, near your other form definitions
# In app.py, near your other form definitions

class RecipientSelectionForm(FlaskForm):
    """
    Handles the recipient selection. This form now explicitly includes the
    hidden field that our JavaScript will populate.
    """
    # This field will be populated by JavaScript before the form is submitted.
    recipient_id_list = HiddenField(validators=[DataRequired(message="Please select at least one recipient.")])

# In app.py, replace the old CreateTaskForm

class CreateTaskForm(FlaskForm):
    """Form for creating a new task, now with a unified assignee picker."""

    title = StringField("Task Title", validators=[DataRequired(), Length(max=255)])
    description = TextAreaField(
        "Detailed Description", validators=[DataRequired(), Length(min=10, max=2000)]
    )
    due_date = DateField(
        "Due Date (YYYY-MM-DD) (Optional)", format="%Y-%m-%d", validators=[Optional()]
    )
    urgency = SelectField(
        "Urgency",
        choices=[
            ("Low", "Low"),
            ("Medium", "Medium"),
            ("High", "High"),
            ("Critical", "Critical"),
        ],
        default="Medium",
        validators=[DataRequired()],
    )

    # This single hidden field will be populated by our JavaScript picker.
    # It will contain a comma-separated list like: "user:123,role:teacher,grade_section:9-A"
    assignees_data = HiddenField("Assignees Data")
    
    submit = SubmitField("Create Task")

    def validate_due_date(self, field):
        if field.data and field.data < datetime.now(timezone.utc).date():
            raise ValidationError("Due date cannot be in the past.")
            
class UpdateUserTaskStatusForm(FlaskForm):
    """Form for an assigned user to update their task status."""

    status = SelectField(
        "Update Status",
        validators=[DataRequired()],
        choices=[
            ("In Progress", "In Progress"),
            ("Completed (Pending Review)", "Completed"),
            ("Delayed (Pending Review)", "Delayed"),
            (
                "Rejected (Pending Review)",
                "Cannot Complete",
            ),  # Renamed to clarify user cannot/will not do it
        ],
    )  # 'Open' status is default, not a choice here

    completion_notes = TextAreaField(
        "Notes / Reason for Status", validators=[Optional(), Length(max=1000)]
    )
    submit = SubmitField("Submit Status Update")

    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        # Custom validation: Require notes if status is Delayed or Rejected
        if (
            self.status.data
            in ["Delayed (Pending Review)", "Rejected (Pending Review)"]
            and not self.completion_notes.data
        ):
            self.completion_notes.errors.append(
                "Reason/notes are required for Delayed or Cannot Complete statuses."
            )
            return False

        return True


class ReviewUserTaskForm(FlaskForm):
    """Form for the task creator to review a user's status update."""

    review_outcome = SelectField(
        "Review Outcome",
        validators=[DataRequired()],
        choices=[
            ("Accepted", "Accept Completion/Status"),
            ("Review Rejected", "Reject Completion/Status"),
        ],
    )
    reviewer_notes = TextAreaField(
        "Reviewer Notes (Optional)", validators=[Optional(), Length(max=1000)]
    )
    submit = SubmitField("Submit Review")

    # Custom validation: Require notes if review is Rejected
    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        if (
            self.review_outcome.data == "Review Rejected"
            and not self.reviewer_notes.data
        ):
            self.reviewer_notes.errors.append(
                "Reviewer notes are required if the review is rejected."
            )
            return False

        return True


# Channel Models
# START MODIFICATION (Channel Model)
# START MODIFICATION (Channel Model - REMOVING TC Link)
class Channel(db.Model):
    __tablename__ = "social_channels"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True, index=True)
    bio = db.Column(db.Text, nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)
    owner_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    social_category_id = db.Column(
        db.Integer, db.ForeignKey("social_category.id"), nullable=False, index=True
    )
    type = db.Column(db.String(20), default="private", nullable=False)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    allow_comments = db.Column(db.Boolean, default=True, nullable=False)
    allow_reactions = db.Column(db.Boolean, default=True, nullable=False)
    user_preferences = db.relationship(
        "UserChannelPreference",
        back_populates="channel",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    owner = db.relationship(
        "User", foreign_keys=[owner_id], back_populates="owned_channels"
    )
    social_category = db.relationship("SocialCategory", back_populates="channels")
    subscribers = db.relationship(
        "ChannelSubscriber",
        back_populates="channel",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    posts = db.relationship(
        "ChannelPost",
        back_populates="channel",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<Channel ID:{self.id} Name:'{self.name}' Type:'{self.type}'>"

# --- START OF FIX: ADD THE MISSING MODEL HERE ---
class ChannelSubscriber(db.Model):
    __tablename__ = "social_channel_subscribers"
    channel_id = db.Column(
        db.Integer, db.ForeignKey("social_channels.id"), primary_key=True
    )
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), primary_key=True)
    role = db.Column(db.String(20), default="subscriber", nullable=False) # e.g., 'owner', 'admin', 'subscriber'
    subscribed_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    user = db.relationship("User", back_populates="channel_subscriptions")
    channel = db.relationship("Channel", back_populates="subscribers")

    __table_args__ = (
        UniqueConstraint("channel_id", "user_id", name="_channel_user_uc"),
    )

    def __repr__(self):
        return f"<ChannelSubscriber UserID: {self.user_id} in ChannelID: {self.channel_id} as {self.role}>"
# --- END OF FIX ---


# add THIS NEW MODEL ---
# --- User Channel Category Model ---
# ... (rest of your models) ...

class UserChannelCategory(db.Model):
    __tablename__ = "user_channel_category"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer,
        db.ForeignKey("user.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    name = db.Column(db.String(100), nullable=False)
    order = db.Column(
        db.Integer, default=0, nullable=False
    )  # For user-defined category order
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Security features
    security_type = db.Column(
        db.String(20), nullable=True
    )  # e.g., 'none', 'pin_code', 'pattern'
    security_payload_hash = db.Column(
        db.String(255), nullable=True
    )  # Increased length for robust hashes

    _metadata = db.Column(db.JSON, nullable=True)  # For icon, color, etc.

    # --- START OF FIX ---
    # ADD THE MISSING 'user' RELATIONSHIP HERE
    # This creates the two-way link that back_populates requires.
    user = db.relationship("User", back_populates="custom_channel_categories")
    # --- END OF FIX ---

    # channel_assignments: channels this user has put into this category
    channel_assignments = db.relationship(
        "UserChannelPreference", back_populates="user_channel_category", lazy="dynamic"
    )

    __table_args__ = (
        db.UniqueConstraint("user_id", "name", name="_user_category_name_uc"),
        db.Index("idx_user_channel_category_user_order", "user_id", "order"),
    )

    def __repr__(self):
        return f"<UserChannelCategory ID:{self.id} UserID:{self.user_id} Name:'{self.name}'>"

    def set_security_payload(self, plain_payload):
        """Hashes and sets the security payload."""
        if plain_payload:
            # Ensure generate_password_hash is imported from werkzeug.security
            self.security_payload_hash = generate_password_hash(plain_payload)
        else:
            self.security_payload_hash = None

    def check_security_payload(self, plain_payload_attempt):
        """Checks a plain payload attempt against the stored hash."""
        if not self.security_payload_hash or not plain_payload_attempt:
            return False
        # Ensure check_password_hash is imported from werkzeug.security
        return check_password_hash(self.security_payload_hash, plain_payload_attempt)


# --- END User Channel Category Model ---

# --- User Saved Item Model (Polymorphic) ---


class UserSavedItem(db.Model):
    __tablename__ = "user_saved_item"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer,
        db.ForeignKey("user.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    # item_type stores the model name as a string, e.g., 'GlobalPost', 'ChannelPost', 'DirectMessage'
    item_type = db.Column(db.String(50), nullable=False, index=True)
    item_id = db.Column(
        db.Integer, nullable=False, index=True
    )  # ID of the actual saved item
    saved_at = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    notes = db.Column(db.Text, nullable=True)  # Optional user notes
    custom_tags = db.Column(db.JSON, nullable=True)  # Future: user-defined tags

    # --- START OF FIX ---
    # ADD THE MISSING 'user' RELATIONSHIP HERE
    # This creates the two-way link that `back_populates` requires.
    user = db.relationship("User", back_populates="saved_items")
    # --- END OF FIX ---

    __table_args__ = (
        db.UniqueConstraint(
            "user_id", "item_type", "item_id", name="_user_saved_item_uc"
        ),
        db.Index(
            "idx_user_item_type_id", "user_id", "item_type", "item_id"
        ),  # For efficient querying
    )

    def __repr__(self):
        return f"<UserSavedItem UserID:{self.user_id} Type:'{self.item_type}' ItemID:{self.item_id}>"

    # Polymorphic loading helper (optional, but highly recommended for convenience)
    def get_actual_item(self):
        """
        Dynamically fetches the actual saved item based on item_type and item_id.
        Returns the SQLAlchemy object or None if not found/type is unknown.
        Requires models to be imported or accessible in the scope where this is called.
        """
        # Ensure model names match exactly how they are defined (case-sensitive)
        model_map = {
            "GlobalPost": GlobalPost,
            "ChannelPost": ChannelPost,
            "GroupMessage": GroupMessage,
            "DirectMessage": Message,  # Assuming 'DirectMessage' refers to your existing 'Message' model
            "TalentClubFeedPost": TalentClubFeedPost,
            "TalentClubCommunityMessage": TalentClubCommunityMessage,
            # Add other saveable models here
        }
        ModelClass = model_map.get(self.item_type)
        if ModelClass:
            return db.session.get(ModelClass, self.item_id)
        app.logger.warning(
            f"Unknown item_type '{self.item_type}' for UserSavedItem ID {self.id}."
        )
        return None


# --- END User Saved Item Model ---

# In app.py, find and replace the entire GlobalPost class


class GlobalPost(db.Model):
    __tablename__ = "global_post"
    id = db.Column(db.Integer, primary_key=True)
    author_id = db.Column(
        db.Integer,
        db.ForeignKey("user.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(
        db.Integer,
        db.ForeignKey("social_files.id", ondelete="SET NULL"),
        nullable=True,
        unique=True,
        index=True,
    )
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    is_edited = db.Column(db.Boolean, default=False, nullable=False)
    visibility = db.Column(
        db.String(20), default="public", nullable=False, index=True
    )  # 'public', 'connections_only', 'private'
    allow_comments = db.Column(db.Boolean, default=True, nullable=False)
    allow_likes = db.Column(db.Boolean, default=True, nullable=False)
    shared_post_id = db.Column(
        db.Integer,
        db.ForeignKey("global_post.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )  # For reposts
    _metadata = db.Column(
        db.JSON, nullable=True
    )  # For future: location, polls, link previews

    # --- START OF FIX ---
    # ADD THE MISSING 'author' AND 'attached_file' RELATIONSHIPS HERE
    # This creates the two-way links that back_populates requires.
    author = db.relationship("User", back_populates="global_posts")
    attached_file = db.relationship("File", back_populates="global_post_attachment")
    # --- END OF FIX ---

    # Relationships for comments and likes
    comments = db.relationship(
        "GlobalComment",
        back_populates="post",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    likes = db.relationship(
        "GlobalLike",
        back_populates="post",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    # For shared posts: relationship to the original post
    original_shared_post = db.relationship(
        "GlobalPost",
        remote_side=[id],
        backref=db.backref("shares", lazy="dynamic"),
        uselist=False,
    )  # A post is a share of ONE original post

    def __repr__(self):
        return f"<GlobalPost ID:{self.id} AuthorID:{self.author_id} Visibility:'{self.visibility}'>"

    def get_share_url(self):  # Consistent with other post types
        try:
            from flask import url_for

            # Define a route like 'view_global_post_redirect' similar to channel/group posts
            return url_for("view_global_post_redirect", post_id=self.id, _external=True)
        except RuntimeError:
            # Fallback if url_for fails outside request context (e.g. in a model method called by a script)
            return f"/global_posts/{self.id}/view"  # Example placeholder URL


# In app.py, find and replace the entire GlobalComment class


class GlobalComment(db.Model):
    __tablename__ = "global_comment"
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(
        db.Integer,
        db.ForeignKey("global_post.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    author_id = db.Column(
        db.Integer,
        db.ForeignKey("user.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    parent_comment_id = db.Column(
        db.Integer,
        db.ForeignKey("global_comment.id", ondelete="CASCADE"),
        nullable=True,
        index=True,
    )  # Threaded comments
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    is_edited = db.Column(db.Boolean, default=False, nullable=False)
    _metadata = db.Column(db.JSON, nullable=True)  # For reactions on comments, etc.

    # Relationships
    post = db.relationship("GlobalPost", back_populates="comments")

    # --- START OF FIX ---
    # ADD THE MISSING 'author' RELATIONSHIP HERE
    # This creates the two-way link that back_populates requires.
    author = db.relationship("User", back_populates="global_comments")
    # --- END OF FIX ---

    # For threaded comments: relationship to parent and replies
    replies = db.relationship(
        "GlobalComment",
        backref=db.backref("parent", remote_side=[id]),
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<GlobalComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"


# In app.py, find and replace the entire GlobalLike class


class GlobalLike(db.Model):
    __tablename__ = "global_like"
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(
        db.Integer, db.ForeignKey("global_post.id", ondelete="CASCADE"), nullable=False
    )
    user_id = db.Column(
        db.Integer, db.ForeignKey("user.id", ondelete="CASCADE"), nullable=False
    )
    timestamp = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    # Relationships
    post = db.relationship("GlobalPost", back_populates="likes")

    # --- START OF FIX ---
    # ADD THE MISSING 'user' RELATIONSHIP HERE
    # This creates the two-way link that back_populates requires.
    user = db.relationship("User", back_populates="global_likes")
    # --- END OF FIX ---

    __table_args__ = (
        db.UniqueConstraint("post_id", "user_id", name="_global_post_user_like_uc"),
        db.Index(
            "idx_global_like_post_user", "post_id", "user_id"
        ),  # Index for the unique constraint
    )

    def __repr__(self):
        return f"<GlobalLike ID:{self.id} PostID:{self.post_id} UserID:{self.user_id}>"

# --- User Saved Item Model (Polymorphic) ---

class ChannelPost(db.Model):
    __tablename__ = "social_channel_posts"
    id = db.Column(db.Integer, primary_key=True)
    channel_id = db.Column(
        db.Integer, db.ForeignKey("social_channels.id"), nullable=False, index=True
    )
    author_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(
        db.Integer,
        db.ForeignKey("social_files.id"),
        nullable=True,
        unique=True,
        index=True,
    )
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    channel = db.relationship(
        "Channel", back_populates="posts", foreign_keys=[channel_id]
    )
    author = db.relationship(
        "User", foreign_keys=[author_id], back_populates="channel_posts"
    )
    file = db.relationship("File", back_populates="channel_post", uselist=False)

    comments = db.relationship(
        "ChannelComment",
        back_populates="post",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    reactions = db.relationship(
        "ChannelReaction",
        back_populates="post",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    def get_share_url(self):
        try:
            from flask import url_for

            return url_for(
                "view_social_channel_post_redirect", post_id=self.id, _external=True
            )
        except RuntimeError:
            print(
                f"Warning: url_for called outside application context for ChannelPost {self.id}"
            )
            return f"/social/posts/{self.id}/view"

    def __repr__(self):
        return f"<ChannelPost ID:{self.id} ChannelID:{self.channel_id} AuthorID:{self.author_id}>"

class ChannelComment(db.Model):
    __tablename__ = "social_channel_comments"
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(
        db.Integer, db.ForeignKey("social_channel_posts.id"), nullable=False
    )
    author_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )

    post = db.relationship("ChannelPost", back_populates="comments")
    author = db.relationship(
        "User", back_populates="channel_comments", foreign_keys=[author_id]
    )

    def __repr__(self):
        return f"<ChannelComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"


class ChannelReaction(db.Model):
    __tablename__ = "social_channel_reactions"
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(
        db.Integer, db.ForeignKey("social_channel_posts.id"), nullable=False
    )
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    emoji = db.Column(db.String(50), nullable=False)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )

    post = db.relationship("ChannelPost", back_populates="reactions")
    user = db.relationship("User", back_populates="channel_reactions")

    __table_args__ = (
        UniqueConstraint("post_id", "user_id", "emoji", name="_post_user_emoji_uc"),
    )

    def __repr__(self):
        return f"<ChannelReaction ID:{self.id} PostID:{self.post_id} UserID:{self.user_id} Emoji:{self.emoji}>"


class GroupMessage(db.Model):  # Corrected model name
    __tablename__ = "social_group_messages"
    id = db.Column(db.Integer, primary_key=True)
    group_id = db.Column(
        db.Integer, db.ForeignKey("social_group.id"), nullable=False, index=True
    )  # FK points to social_groups
    author_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(
        db.Integer,
        db.ForeignKey("social_files.id"),
        nullable=True,
        unique=True,
        index=True,
    )
    timestamp = db.Column(
        db.DateTime,
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    group = db.relationship(
        "SocialGroup", back_populates="messages", foreign_keys=[group_id]
    )  # Corrected relationship target and added FK
    author = db.relationship(
        "User", foreign_keys=[author_id], back_populates="group_messages"
    )
    file = db.relationship("File", back_populates="group_message", uselist=False)

    def get_share_url(self):
        try:
            from flask import url_for

            return url_for(
                "view_social_group_message_redirect", message_id=self.id, _external=True
            )
        except RuntimeError:
            print(
                f"Warning: url_for called outside application context for GroupMessage {self.id}"
            )
            return f"/social/messages/{self.id}/view"

    def __repr__(self):
        return f"<GroupMessage ID:{self.id} GroupID:{self.group_id} AuthorID:{self.author_id}>"


# In your models.py file

class Mark(db.Model):
    __tablename__ = "mark"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=False, index=True
    )
    subject = db.Column(db.String(100), nullable=False, index=True)
    semester_1 = db.Column(db.Float, nullable=True)
    semester_2 = db.Column(db.Float, nullable=True)
    total = db.Column(db.Float, nullable=True)
    average = db.Column(db.Float, nullable=True, index=True)
    rank = db.Column(db.Integer, nullable=True)

    student = db.relationship("User", back_populates="marks")

    __table_args__ = (
        db.UniqueConstraint("student_id", "subject", name="_student_subject_uc"),
        db.Index("idx_mark_subject_average", "subject", "average"),
    )

    # --- NEW METHOD ADDED HERE ---
    def update_derived_fields(self):
        """
        Calculates total and average based on semester scores.
        Handles cases where one or both scores might be missing.
        """
        s1 = self.semester_1
        s2 = self.semester_2
        
        # Determine how many valid scores we have for the average calculation
        num_scores = 0
        current_total = 0

        if s1 is not None:
            num_scores += 1
            current_total += s1
        
        if s2 is not None:
            num_scores += 1
            current_total += s2

        if num_scores > 0:
            self.total = current_total
            self.average = current_total / num_scores
        else:
            # If both scores are None, reset the calculated fields
            self.total = None
            self.average = None
    # --- END OF NEW METHOD ---

    def __repr__(self):
        return f"<Mark StudentID: {self.student_id}, Subject: {self.subject}, Avg: {self.average}>"
        
class User(db.Model, UserMixin):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=True, index=True)
    password_hash = db.Column(db.String(128), nullable=False)
    first_name = db.Column(db.String(50), nullable=True)
    last_name = db.Column(db.String(50), nullable=True)
    full_name = db.Column(db.String(120), nullable=False, index=True)
    date_of_birth = db.Column(db.Date, nullable=True)
    gender = db.Column(db.String(20), nullable=True)
    phone = db.Column(db.String(20), nullable=True)
    address = db.Column(db.Text, nullable=True)
    is_active = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(
        db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False
    )
    last_login = db.Column(db.DateTime, nullable=True)
    is_leader = db.Column(db.Boolean, default=False, nullable=False)
    force_password_change = db.Column(db.Boolean, default=False, nullable=False)
    is_tc_leader = db.Column(db.Boolean, default=False, nullable=False)
    is_tc_member = db.Column(db.Boolean, default=False, nullable=False)
    leader_id = db.Column(
        db.Integer, db.ForeignKey("user.id"), nullable=True, index=True
    )
    age = db.Column(db.Integer, nullable=True)
    sex = db.Column(db.String(20), nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)
    grade = db.Column(db.Integer, nullable=True, index=True)
    section = db.Column(db.Integer, nullable=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey("role.id"), nullable=False)
    lab_id = db.Column(db.Integer, db.ForeignKey("lab.id"), nullable=True)
    teacher_profiles = db.relationship("TeacherProfile", back_populates="user", lazy="dynamic", cascade="all, delete-orphan")
    # ... inside the User model ...
    secret_code = db.relationship("SecretCode", back_populates="user", uselist=False)
# ... other relationships ...
    channel_preferences = db.relationship(
        "UserChannelPreference",
        back_populates="user",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    custom_channel_categories = db.relationship(
        "UserChannelCategory",
        back_populates="user",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    saved_items = db.relationship(
        "UserSavedItem",
        back_populates="user",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    global_posts = db.relationship(
        "GlobalPost",
        foreign_keys="GlobalPost.author_id",
        back_populates="author",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    global_comments = db.relationship(
        "GlobalComment",
        foreign_keys="GlobalComment.author_id",
        back_populates="author",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    global_likes = db.relationship(
        "GlobalLike",
        foreign_keys="GlobalLike.user_id",
        back_populates="user",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    role = db.relationship("Role", back_populates="users")
    lab = db.relationship("Lab", back_populates="lab_assignments")
    leader = db.relationship(
        "User", remote_side=[id], backref=db.backref("followers", lazy="dynamic")
    )
    sent_messages = db.relationship(
        "Message",
        foreign_keys=[Message.sender_id],
        back_populates="sender",
        lazy="dynamic",
    )
    received_messages = db.relationship(
        "Message",
        foreign_keys=[Message.receiver_id],
        back_populates="receiver",
        lazy="dynamic",
    )
    submitted_requests = db.relationship(
        "Request",
        foreign_keys="Request.requester_id",
        back_populates="requester",
        lazy="dynamic",
    )
    assigned_requests = db.relationship(
        "Request",
        foreign_keys="Request.current_handler_id",
        back_populates="current_handler",
        lazy="dynamic",
    )
    forwarded_requests = db.relationship(
        "Request",
        foreign_keys="Request.last_forwarded_by_id",
        back_populates="last_forwarded_by",
        lazy="dynamic",
    )
    request_history_entries = db.relationship(
        "RequestHistory", back_populates="changed_by", lazy="dynamic"
    )
    staff_attendance_records = db.relationship(
        "StaffAttendance", back_populates="user", lazy="dynamic"
    )
    attendance_entries = db.relationship(
        "Attendance", back_populates="student", lazy="dynamic"
    )
    parent_profile = db.relationship("Parent", back_populates="user", uselist=False)
    sent_notifications = db.relationship(
        "Notification",
        foreign_keys="Notification.sender_id",
        back_populates="sender",
        lazy="dynamic",
    )
    received_notifications = db.relationship(
        "Notification",
        foreign_keys="Notification.receiver_id",
        back_populates="receiver",
        lazy="dynamic",
    )
    marks = db.relationship("Mark", back_populates="student", lazy="dynamic")
    added_assets = db.relationship(
        "Asset", back_populates="added_by_user", lazy="dynamic"
    )
    submitted_reports = db.relationship(
        "AssetReport",
        foreign_keys="AssetReport.reported_by_id",
        back_populates="reporter",
        lazy="dynamic",
    )
    resolved_reports = db.relationship(
        "AssetReport",
        foreign_keys="AssetReport.resolved_by_id",
        back_populates="resolver",
        lazy="dynamic",
    )
    book_checkouts = db.relationship(
        "BookCheckout", back_populates="user", lazy="dynamic"
    )
    borrowed_assets = db.relationship(
        "BorrowedAsset", back_populates="user", lazy="dynamic"
    )
    channel_posts = db.relationship(
        "ChannelPost", back_populates="author", lazy="dynamic"
    )
    channel_comments = db.relationship(
        "ChannelComment", back_populates="author", lazy="dynamic"
    )
    channel_reactions = db.relationship(
        "ChannelReaction", back_populates="user", lazy="dynamic"
    )
    group_messages = db.relationship(
        "GroupMessage", back_populates="author", lazy="dynamic"
    )
    social_group_memberships = db.relationship(
        "SocialGroupMember", back_populates="user", lazy="dynamic"
    )
    owned_channels = db.relationship("Channel", back_populates="owner", lazy="dynamic")
    # In app.py, inside the User model class

    # --- ADD THIS LINE FOR THE WEATHER FEATURE ---
    home_city = db.Column(db.String(100), nullable=True)
    # --- END OF ADDITION ---
    # FIX: Renamed 'owned_social_groups' to 'owned_groups' to match the SocialGroup model.
    # Also added cascade for better data integrity.
    owned_groups = db.relationship(
        "SocialGroup",
        back_populates="owner",
        lazy="dynamic",
        cascade="all, delete-orphan"
    )

    uploaded_social_files = db.relationship(
        "File", back_populates="uploader", lazy="dynamic"
    )
    parent_associations = db.relationship("ParentStudent", back_populates="student")
    behavior_records = db.relationship(
        "BehaviorRecord",
        foreign_keys="BehaviorRecord.student_id",
        back_populates="student",
        lazy="dynamic",
    )
    recorded_behavior_records = db.relationship(
        "BehaviorRecord",
        foreign_keys="BehaviorRecord.recorded_by_id",
        back_populates="recorded_by",
        lazy="dynamic",
    )
    channel_subscriptions = db.relationship(
        "ChannelSubscriber", back_populates="user", lazy="dynamic"
    )
    tc_memberships = db.relationship(
        "TalentClubMembership",
        back_populates="user",
        #lazy="dynamic",
        cascade="all, delete-orphan",
    )
    tc_follows = db.relationship(
        "TalentClubFollow",
        back_populates="user",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    owned_talent_clubs = db.relationship(
        "TalentClub", back_populates="owner", lazy="dynamic"
    )
    tc_leader_election_initiated = db.relationship(
        "TalentClubLeaderElection",
        foreign_keys="TalentClubLeaderElection.initiated_by_id",
        back_populates="initiated_by",
        lazy="dynamic",
    )
    tc_leader_votes_cast = db.relationship(
        "TalentClubLeaderVote",
        foreign_keys="TalentClubLeaderVote.voter_id",
        back_populates="voter",
        lazy="dynamic",
    )
    tc_bans_issued = db.relationship(
        "TalentClubBan",
        foreign_keys="TalentClubBan.issued_by_id",
        back_populates="issued_by",
        lazy="dynamic",
    )
    tc_bans_received = db.relationship(
        "TalentClubBan",
        foreign_keys="TalentClubBan.user_id",
        back_populates="user",
        lazy="dynamic",
    )
    tc_penalties_issued = db.relationship(
        "TalentClubPenalty",
        foreign_keys="TalentClubPenalty.issued_by_id",
        back_populates="issued_by",
        lazy="dynamic",
    )
    tc_penalties_received = db.relationship(
        "TalentClubPenalty",
        foreign_keys="TalentClubPenalty.user_id",
        back_populates="user",
        lazy="dynamic",
    )
    tc_proposals_created = db.relationship(
        "TalentClubProposal",
        foreign_keys="TalentClubProposal.creator_id",
        back_populates="creator",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    tc_mentions_received = db.relationship(
        "TalentClubMention",
        back_populates="user",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )
    created_tasks = db.relationship(
        "Task", back_populates="created_by", lazy="dynamic"
    )
    assigned_tasks_instances = db.relationship(
        "UserTask",
        foreign_keys="UserTask.assigned_by_id",
        back_populates="assigned_by",
        lazy="dynamic",
    )
    assigned_tasks = db.relationship(
        "UserTask",
        foreign_keys="UserTask.user_id",
        back_populates="user",
        lazy="dynamic",
    )
    task_history_entries = db.relationship(
        "TaskHistory", back_populates="changed_by", lazy="dynamic"
    )
    reviewed_tasks_instances = db.relationship(
        "UserTask",
        foreign_keys="UserTask.reviewed_by_id",
        back_populates="reviewed_by",
        lazy="dynamic",
    )

    def set_password(self, password):
        from werkzeug.security import generate_password_hash
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        from werkzeug.security import check_password_hash
        return check_password_hash(self.password_hash, password)

    def has_permission(self, permission):
        if not self.role:
            return False
        role_perms = ROLE_PERMISSIONS.get(self.role.name.lower(), [])
        return permission in role_perms

    def is_channel_member(self, channel):
        if not channel or not self.is_authenticated:
            return False
        try:
            return (
                db.session.scalar(
                    select(ChannelSubscriber).where(
                        ChannelSubscriber.channel_id == channel.id,
                        ChannelSubscriber.user_id == self.id,
                    )
                )
                is not None
            )
        except Exception as e:
            current_app.logger.error(
                f"Error in is_channel_member for user {self.id}, channel {channel.id}: {e}",
                exc_info=True,
            )
            return False

    def get_channel_role(self, channel):
        if not channel or not self.is_authenticated:
            return None
        try:
            subscription = db.session.scalar(
                select(ChannelSubscriber)
                .where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.user_id == self.id,
                )
                .options(
                    joinedload(ChannelSubscriber.user),
                    joinedload(ChannelSubscriber.channel),
                )
            )
            return subscription.role if subscription else None
        except Exception as e:
            current_app.logger.error(
                f"Error in get_channel_role for user {self.id}, channel {channel.id}: {e}",
                exc_info=True,
            )
            return None

    def is_group_member(self, group):
        if not group or not self.is_authenticated:
            return False
        try:
            return (
                db.session.scalar(
                    select(SocialGroupMember).where(
                        SocialGroupMember.group_id == group.id,
                        SocialGroupMember.user_id == self.id,
                    )
                )
                is not None
            )
        except Exception as e:
            current_app.logger.error(
                f"Error in is_group_member for user {self.id}, group {group.id}: {e}",
                exc_info=True,
            )
            return False

    def get_group_role(self, group):
        if not group or not self.is_authenticated:
            return None
        try:
            membership = db.session.scalar(
                select(SocialGroupMember)
                .where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.user_id == self.id,
                )
                .options(
                    joinedload(SocialGroupMember.user),
                    joinedload(SocialGroupMember.group),
                )
            )
            return membership.role if membership else None
        except Exception as e:
            current_app.logger.error(
                f"Error in get_group_role for user {self.id}, group {group.id}: {e}",
                exc_info=True,
            )
            return None

    def __repr__(self):
        return f"<User ID:{self.id} Username:'{self.username}' Role:'{self.role.name if self.role else 'N/A'}'>"        

# --- PART 2 END: Model Definitions ---

# --- PART 3 START: SQLAlchemy Init, LoginManager, Core Helpers & Context ---

migrate = Migrate(app, db)

# Initialize LoginManager *AFTER* the User model is defined and db is initialized
login_manager = LoginManager(app)
login_manager.login_view = "login"
login_manager.login_message_category = "info"


# ... rest of PART 3 ...
@login_manager.user_loader
def load_user(user_id):
    """Required by Flask-Login to load a user from the user ID stored in the session."""
    if user_id is not None:
        # Use db.session.get for retrieving by primary key
        # Ensure user is active before loading
        user = db.session.get(User, int(user_id))
        if user and user.is_active:
            return user
    return None  # Return None if user_id is invalid or user is not found/inactive


# --- Helper Functions (Consolidated and placed here) ---

# Helper to get roles a given role can send to or receive from (used by Notification & Chat helpers)
# --- Helper Functions (Consolidated and placed here) ---


# Helper to get roles a given role can send to or receive from (used by Notification & Chat helpers)
# UPDATED: Now takes a 'user' object instead of separate 'role_name' and 'is_leader'
def get_allowed_roles_helper(config_dict, direction, user):
    """Helper to get roles a given role can send to or receive from based on a config dictionary."""
    if not user or not user.is_authenticated or not user.role:
        return []  # No permissions for unauthenticated or rol-less users

    role_name_lower = user.role.name.lower()
    perms = config_dict.get(role_name_lower, {})

    # --- NEW TC Leader Send Override (Applies only to 'send_to') ---
    if direction == "send_to":
        if user.is_tc_leader:
            # If the user is the system-wide TC Leader, they can send chat/notifications to:
            # 1. Other Talent Club members (primary role 'student', is_tc_member=True) -> target role 'student'
            # 2. Other Talent Club role users (e.g. coordinators, other leaders) -> target role 'talent_club'
            # 3. HR/CEO users -> target role 'hr_ceo'
            # This overrides any more restrictive send_to rules for the specific roles listed here.
            return [
                "student",
                "talent_club",
                "hr_ceo",
            ]  # Specific roles the leader can send *to*.

    # --- Logic for other users OR for the 'receive_from' direction ---

    # Resolve specific permissions based on primary role and exceptions (if applicable)
    specific_perms = perms
    if "exceptions" in perms:
        # Check for role-specific exceptions based on boolean flags on the user object
        # Order matters: prioritize the most specific exception if multiple apply
        # Assuming tc_leader and tc_member on a student use the 'tc_member' exception primarily,
        # unless a nested exception is defined. For simplicity, let's rely on the config.
        # The helper as written looks for a direct match in the 'exceptions' dictionary key.

        # Prioritize 'tc_member' exception for 'student' role
        if (
            role_name_lower == "student"
            and user.is_tc_member
            and "tc_member" in perms["exceptions"]
        ):
            specific_perms = perms["exceptions"]["tc_member"]
        # Check 'leader' exception for 'student' role (applies if is_leader is True and tc_member isn't primary exception)
        elif (
            role_name_lower == "student"
            and user.is_leader
            and "leader" in perms["exceptions"]
        ):
            specific_perms = perms["exceptions"]["leader"]
        # Check 'tc_leader' exception for 'talent_club' role
        elif (
            role_name_lower == "talent_club"
            and user.is_tc_leader
            and "tc_leader" in perms["exceptions"]
        ):
            specific_perms = perms["exceptions"]["tc_leader"]
        # Add more exception checks here for other roles/leader types if they emerge
        # E.g., if a 'teacher' could also be 'is_tc_member', you'd need an exception for that.

    # Get the permissions dictionary for the determined direction (send_to or receive_from)
    direction_perms = specific_perms.get(direction, {})

    # Resolve the final list of allowed roles based on 'all', 'specific', or 'none'
    if direction_perms.get("all"):
        exceptions = [exc.lower() for exc in direction_perms.get("exceptions", [])]
        # Use the global VALID_ROLE_NAMES defined earlier (assumed to exist)
        # from flask import current_app # Need current_app if VALID_ROLE_NAMES is in app.config
        return [r.lower() for r in VALID_ROLE_NAMES if r.lower() not in exceptions]
    elif direction_perms.get("specific"):
        return [r.lower() for r in direction_perms.get("specific", [])]
    else:  # 'none' or not defined
        return []


# Specific helper for Chat permissions
# UPDATED: Now takes a 'user' object
def get_allowed_chat_roles(direction, user):
    # Access app config within the function if needed
    from flask import (
        current_app,
    )  # This import is often needed if run standalone or in contexts.

    # Pass the user object directly to the general helper
    return get_allowed_roles_helper(CHAT_PERMISSIONS, direction, user)


# Specific helper for Notification permissions
# UPDATED: Now takes a 'user' object
def get_allowed_notification_roles(direction, user):
    # Access app config within the function if needed
    from flask import (
        current_app,
    )  # This import is often needed if run standalone or in contexts.

    # Pass the user object directly to the general helper
    return get_allowed_roles_helper(NOTIFICATION_PERMISSIONS, direction, user)


# --- NEW HELPER FUNCTIONS: Talent Club Subsystem ---


def is_tc_leader(user):
    """Checks if the given user is the current system-wide Talent Club Leader."""
    if not user or not user.is_authenticated:
        return False
    # Direct check on the flag on the user object is sufficient
    return user.is_tc_leader


def get_tc_community_group():
    """Fetches the single Talent Club Community group instance."""
    # This group should be created during initial setup/seeding
    return db.session.scalar(select(TalentClubCommunity).limit(1))


def is_tc_community_member(user):
    """Checks if a user is a member of the main TC Community group."""
    if not user or not user.is_authenticated or not user.is_tc_member:
        return False

    community_group = get_tc_community_group()
    if not community_group:
        app.logger.warning("Talent Club Community group not found in DB.")
        return False

    membership_record = db.session.scalar(
        select(TalentClubCommunityMember)
        .where(
            TalentClubCommunityMember.community_id == community_group.id,
            TalentClubCommunityMember.user_id == user.id,
        )
        .limit(1)  # Optimization: only need to find one record
    )
    return membership_record is not None  # True if a record was found, False otherwise


def add_to_tc_community_group(user):
    """Adds a user to the TC Community group if they are a TC member and not already added."""
    if not user or not user.is_tc_member:
        app.logger.warning(
            f"Attempted to add non-TC member user {user.id if user else 'N/A'} to TC Community."
        )
        return False

    community_group = get_tc_community_group()
    if not community_group:
        app.logger.error("Talent Club Community group not found. Cannot add member.")
        return False

    # Check if already a member
    if is_tc_community_member(user):
        app.logger.debug(f"User {user.id} already in TC Community group.")
        return True  # Already done

    try:
        member_entry = TalentClubCommunityMember(
            community=community_group,
            user=user,
            role="member",  # Default role
            joined_at=datetime.now(timezone.utc),
        )
        db.session.add(member_entry)
        db.session.commit()
        app.logger.info(
            f"User {user.id} added to TC Community group ID {community_group.id}."
        )
        return True
    except IntegrityError:
        db.session.rollback()
        app.logger.warning(
            f"IntegrityError adding user {user.id} to TC Community group {community_group.id} (already member?)."
        )
        # This might happen if is_tc_community_member check failed due to cache, or concurrent op
        return False  # Or True if you assume the exception means they are already in
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error adding user {user.id} to TC Community group {community_group.id}: {e}",
            exc_info=True,
        )
        return False


def notify_tc_member(
    receiver_user,
    sender_user,
    content,
    notification_type,
    related_object_id=None,
    link_url=None,
):
    """
    Sends a notification specifically within the Talent Club subsystem.
    Checks if receiver is a TC member and if notification type/sender is allowed within TC context (optional check).
    """
    if not receiver_user or not receiver_user.is_tc_member:
        # Cannot notify non-TC members via this helper
        app.logger.warning(
            f"Attempted to send TC notification to non-TC member user {receiver_user.id if receiver_user else 'N/A'}."
        )
        return False

    # Optional: Add specific checks based on TC notification types and sender roles
    # For now, assume if you are allowed to send TC notifications, you can use this.
    # The main NOTIFICATION_PERMISSIONS config can be updated to reflect TC-specific flows.
    # E.g., TC Leader can send tc_warning/tc_level_change to TC Members.
    # A proposal creator can send tc_invite to mentioned members.

    # Let's use the general notification permission checks, assuming sender is allowed to notify the receiver's role.
    # The `notification_type` adds context but doesn't automatically bypass role permissions.

    # Use 'system' user as sender if sender_user is None (e.g., automated warnings)
    sender = sender_user
    if not sender:
        sender = db.session.scalar(select(User).filter_by(username="system"))
        if not sender:
            app.logger.error("System user not found for TC notification sender.")
            return False

    # Re-use the existing notification permission check
    if not is_notification_allowed(sender, receiver_user):
        app.logger.warning(
            f"TC Notification not allowed: Sender {sender.username} ({sender.role.name if sender.role else 'N/A'}) to Receiver {receiver_user.username} ({receiver_user.role.name if receiver_user.role else 'N/A'})."
        )
        return False

    try:
        notification = Notification(
            sender_id=sender.id,
            receiver_id=receiver_user.id,
            content=content,
            link_url=link_url,
            timestamp=datetime.now(timezone.utc),
            is_read=False,
            notification_type=notification_type,  # Store the specific type
            related_object_id=related_object_id,  # Store related object ID
        )
        db.session.add(notification)
        db.session.commit()  # Commit immediately for notifications
        app.logger.info(
            f"TC Notification sent (Type: {notification_type}, Related ID: {related_object_id}) to user {receiver_user.id} by sender {sender.id}."
        )
        return True

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error sending TC notification (Type: {notification_type}, Related ID: {related_object_id}) to user {receiver_user.id}: {e}",
            exc_info=True,
        )
        return False


# Helper for TC Leader to check if a user is eligible to be banned/muted
def is_eligible_for_tc_ban_mute(user_to_check):
    """Checks if a user is a TC member and thus eligible for TC-specific bans/mutes."""
    # Only TC members can receive TC-specific bans/mutes applied by the TC Leader
    return user_to_check and user_to_check.is_tc_member


# Helper for TC Leader to check if a user is currently banned/muted
def is_currently_banned_muted(user):
    """Checks if a user has an active TC ban or mute."""
    if not user:
        return False

    # Check for active bans/mutes (expires_at is null or in the future)
    active_ban = db.session.scalar(
        select(TalentClubBan)
        .where(
            TalentClubBan.user_id == user.id,
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc),
            ),
        )
        .limit(1)  # Just need to find one
    )
    return active_ban is not None


# Helper to get eligible candidates for TC Leader election (users who are is_tc_member = True)
def get_tc_leader_candidates():
    """Fetches all active users who are Talent Club members."""
    return db.session.scalars(
        select(User)
        .where(User.is_tc_member == True, User.is_active == True)
        .order_by(User.full_name)
    ).all()


# Helper to find the active TC Leader election
def get_active_tc_leader_election():
    """Finds the current active Talent Club Leader election."""
    return db.session.scalar(
        select(TalentClubLeaderElection)
        .where(TalentClubLeaderElection.status == "active")
        .order_by(TalentClubLeaderElection.initiated_at.desc())
        .limit(1)  # Should be only one active at a time
    )


# Specific helper for Chat permissions check
# UPDATED: Now takes sender_user and receiver_user objects
def is_chat_allowed(sender_user, receiver_user):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    if not receiver_user or not receiver_user.role:
        return False

    allowed_to_send = get_allowed_chat_roles("send_to", sender_user)
    allowed_to_receive = get_allowed_chat_roles("receive_from", receiver_user)

    return (
        receiver_user.role.name.lower() in allowed_to_send
        and sender_user.role.name.lower() in allowed_to_receive
    )


# Specific helper for Notification permissions check
# UPDATED: Now takes sender_user and receiver_user objects
def is_notification_allowed(sender_user, receiver_user):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    if not receiver_user or not receiver_user.role:
        return False

    allowed_to_send = get_allowed_notification_roles("send_to", sender_user)
    allowed_to_receive = get_allowed_notification_roles("receive_from", receiver_user)

    return (
        receiver_user.role.name.lower() in allowed_to_send
        and sender_user.role.name.lower() in allowed_to_receive
    )


# Helper to check if sender is allowed to send notifications to receiver role (Used in send_notification_to_user)
# UPDATED: Now takes sender_user object and receiver_role_name (string)
def can_send(sender_user, receiver_role_name):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    allowed_roles = get_allowed_notification_roles("send_to", sender_user)
    return receiver_role_name.lower() in allowed_roles


# Helper to check if receiver is allowed to receive notifications from sender role (Used in send_notification_to_user)
# UPDATED: Now takes receiver_user object and sender_role_name (string)
def can_receive(receiver_user, sender_role_name):
    if not receiver_user or not receiver_user.role:
        return False
    allowed_roles = get_allowed_notification_roles("receive_from", receiver_user)
    return sender_role_name.lower() in allowed_roles


# Helper to determine which assets a user should see based on their role (Implemented in Part 2/Previous block)
# Keeping the definition here for reference, but the function body was already provided.
# def get_user_assets_query(user):
#     pass # Body is in Part 2


# Placeholder Notification Helpers (These now need actual implementations or placeholders)
# ADDING SIMPLE PLACEHOLDERS HERE
def notify_hr_ceo_new_asset(asset):
    """Placeholder to notify HR/CEO about a new asset."""
    try:
        with app.app_context():  # Ensure context if called outside a request handler
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            if not hr_ceo_role:
                app.logger.warning("HR/CEO role not found for new asset notification.")
                return  # Cannot notify if role doesn't exist

            hr_ceos = db.session.scalars(
                select(User).where(User.role == hr_ceo_role, User.is_active == True)
            ).all()

            if not hr_ceos:
                app.logger.warning(
                    "No active HR/CEO users found for new asset notification."
                )
                return  # Cannot notify if no HR/CEOs exist

            message_content = f"A new asset '{asset.name}' (ID: {asset.id}) has been added and is pending review."
            link_url = url_for("edit_asset", asset_id=asset.id)  # Link to the edit page

            # Create a notification for each HR/CEO
            notifications = []
            for hr_ceo in hr_ceos:
                # Check if notification is allowed based on permission config (HR/CEO can receive from any role that can add assets)
                # Sender role is the role of the user who added the asset (asset.added_by_user.role)
                sender_role_name = (
                    asset.added_by_user.role.name.lower()
                    if asset.added_by_user and asset.added_by_user.role
                    else "unknown"
                )
                receiver_role_name = hr_ceo_role.name.lower()

                if is_notification_allowed(asset.added_by_user, hr_ceo):
                    notification = Notification(
                        sender_id=asset.added_by_user_id
                        or db.session.scalar(
                            select(User.id).filter_by(username="system")
                        ),  # Link sender to user who added, or a system user if not linked
                        receiver_id=hr_ceo.id,
                        content=message_content,
                        link_url=link_url,
                        timestamp=datetime.now(timezone.utc),
                        is_read=False,
                    )
                    notifications.append(notification)

            if notifications:
                db.session.add_all(notifications)
                db.session.commit()
                app.logger.info(
                    f"Notified {len(notifications)} HR/CEO(s) about new asset ID {asset.id}."
                )

    except Exception as e:
        # Log the error but don't roll back the main transaction that added the asset
        app.logger.error(
            f"Error sending new asset notification for asset ID {asset.id}: {e}",
            exc_info=True,
        )
        db.session.rollback()  # Rollback only the notification transaction if any commits happened here


def notify_hr_ceo_new_report(report):
    """Placeholder to notify HR/CEO about a new asset report."""
    try:
        with app.app_context():  # Ensure context
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            if not hr_ceo_role:
                app.logger.warning("HR/CEO role not found for new report notification.")
                return

            hr_ceos = db.session.scalars(
                select(User).where(User.role == hr_ceo_role, User.is_active == True)
            ).all()

            if not hr_ceos:
                app.logger.warning(
                    "No active HR/CEO users found for new report notification."
                )
                return

            asset_name = report.asset.name if report.asset else "General Asset"
            message_content = f"A new asset report (ID: {report.id}) has been submitted for '{asset_name}'. Status: {report.status}."
            link_url = url_for(
                "resolve_asset_report", report_id=report.id
            )  # Link to the resolve page

            notifications = []
            for hr_ceo in hr_ceos:
                # Check if notification is allowed
                sender_role_name = (
                    report.reporter.role.name.lower()
                    if report.reporter and report.reporter.role
                    else "unknown"
                )
                receiver_role_name = hr_ceo_role.name.lower()

                if is_notification_allowed(sender_role_name, receiver_role_name):
                    notification = Notification(
                        sender_id=report.reported_by_id
                        or db.session.scalar(
                            select(User.id).filter_by(username="system")
                        ),  # Link sender to reporter, or system user
                        receiver_id=hr_ceo.id,
                        content=message_content,
                        link_url=link_url,
                        timestamp=datetime.now(timezone.utc),
                        is_read=False,
                    )
                    notifications.append(notification)

            if notifications:
                db.session.add_all(notifications)
                db.session.commit()
                app.logger.info(
                    f"Notified {len(notifications)} HR/CEO(s) about new report ID {report.id}."
                )

    except Exception as e:
        app.logger.error(
            f"Error sending new report notification for report ID {report.id}: {e}",
            exc_info=True,
        )
        db.session.rollback()


def notify_reporter_report_update(report):
    """Placeholder to notify the reporter when their asset report is updated."""
    try:
        with app.app_context():  # Ensure context
            reporter = report.reporter  # Get the user who reported
            if not reporter or not reporter.is_active:
                app.logger.warning(
                    f"Reporter user {report.reported_by_id} not found or inactive for report update notification (Report ID: {report.id})."
                )
                return  # Cannot notify if reporter is missing or inactive

            # Prevent notifying the reporter if the updater is the reporter themselves (e.g., admin editing their own test report)
            if current_user and current_user.id == reporter.id:
                app.logger.debug(
                    f"Skipping reporter notification for report ID {report.id}: updater is the reporter ({reporter.username})."
                )
                return

            # Check if notification is allowed
            sender_role_name = (
                current_user.role.name.lower() if current_user.role else "unknown"
            )
            receiver_role_name = (
                reporter.role.name.lower() if reporter.role else "unknown"
            )

            if not is_notification_allowed(sender_role_name, receiver_role_name):
                app.logger.warning(
                    f"Notification not allowed for report update (Report ID: {report.id}): {sender_role_name} cannot send to {receiver_role_name}."
                )
                return

            asset_name = report.asset.name if report.asset else "General Asset"
            message_content = f"Your report (ID: {report.id}) for '{asset_name}' has been updated. New status: {report.status}."
            if report.resolution_notes:
                message_content += f" Notes: {report.resolution_notes[:100]}..."  # Truncate notes for notification

            link_url = url_for(
                "list_asset_reports"
            )  # Link to the reports list (reporter might not have resolve access)
            # Or link to a specific report detail page if one exists for non-admin users

            notification = Notification(
                sender_id=current_user.id,  # The user resolving the report is the sender
                receiver_id=reporter.id,
                content=message_content,
                link_url=link_url,
                timestamp=datetime.now(timezone.utc),
                is_read=False,
            )
            db.session.add(notification)
            db.session.commit()
            app.logger.info(
                f"Notified reporter {reporter.username} about update to report ID {report.id}."
            )

    except Exception as e:
        app.logger.error(
            f"Error sending reporter notification for report ID {report.id}: {e}",
            exc_info=True,
        )
        db.session.rollback()


# Unread counts (These now need actual implementations or placeholders)
# ADDING SIMPLE PLACEHOLDERS HERE that query the database
def get_unread_message_count(user_id):
    """Returns the count of unread messages for a user."""
    try:
        with app.app_context():  # Ensure context if called outside request
            # Use db.session.scalar(select(func.count())...) for counting
            count = db.session.scalar(
                select(func.count(Message.id)).where(
                    Message.receiver_id == user_id, Message.is_read == False
                )
            )
            return count if count is not None else 0  # Return 0 if no messages found
    except Exception as e:
        app.logger.error(
            f"Error fetching unread message count for user {user_id}: {e}",
            exc_info=True,
        )
        return 0  # Return 0 on error


def get_unread_notifications_count(user_id):
    """Returns the count of unread notifications for a user."""
    try:
        with app.app_context():  # Ensure context if called outside request
            # Use db.session.scalar(select(func.count())...) for counting
            count = db.session.scalar(
                select(func.count(Notification.id)).where(
                    Notification.receiver_id == user_id, Notification.is_read == False
                )
            )
            return (
                count if count is not None else 0
            )  # Return 0 if no notifications found
    except Exception as e:
        app.logger.error(
            f"Error fetching unread notification count for user {user_id}: {e}",
            exc_info=True,
        )
        return 0  # Return 0 on error


# Save uploaded file (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def save_uploaded_file(file_storage):
    """
    Placeholder to save an uploaded file securely to disk and create a File DB entry.
    Returns the File object (not committed) or None on failure.
    """
    if not file_storage:
        flash("No file provided for upload.", "warning")
        return None

    # Get filename securely
    original_filename = secure_filename(file_storage.filename)
    if not original_filename:
        flash("Invalid filename.", "danger")
        return None

    # Generate a unique internal filename using UUID
    # Keep the original extension (or attempt to guess mimetype)
    file_extension = os.path.splitext(original_filename)[1].lower()
    unique_filename = str(uuid.uuid4()) + file_extension

    # Build the full path to save the file within the UPLOAD_FOLDER configured in app.py
    # Assumes app.config['UPLOAD_FOLDER'] is correctly set
    if not app.config.get("UPLOAD_FOLDER"):
        app.logger.error("UPLOAD_FOLDER not configured in app.py")
        flash("File upload failed: Server configuration error.", "danger")
        return None

    save_directory = app.config["UPLOAD_FOLDER"]
    save_path_full = os.path.join(save_directory, unique_filename)

    # Check max file size (optional, but good practice)
    file_storage.seek(0, os.SEEK_END)  # Move cursor to end to get size
    file_size = file_storage.tell()  # Get file size
    file_storage.seek(0)  # Reset cursor to beginning for saving

    max_size = app.config.get("MAX_CONTENT_LENGTH", 16 * 1024 * 1024)  # Default to 16MB
    if file_size > max_size:
        flash(
            f"File size exceeds the maximum allowed size ({max_size / (1024 * 1024):.0f} MB).",
            "danger",
        )
        return None

    # Basic allowed file type check (optional, but recommended)
    # Could inspect mimetype or check extensions
    # Example extension check:
    ALLOWED_SOCIAL_EXTENSIONS = {
        "txt",
        "pdf",
        "doc",
        "docx",
        "xls",
        "xlsx",
        "ppt",
        "pptx",
        "zip",
        "rar",
        "jpg",
        "jpeg",
        "png",
        "gif",
        "mp4",
        "mp3",
        "wav",
        "odt",
        "ods",
        "odp",
    }
    if file_extension.strip(".") not in ALLOWED_SOCIAL_EXTENSIONS:
        flash(
            f"File type '{file_extension}' is not allowed for upload. Allowed types: {', '.join(ALLOWED_SOCIAL_EXTENSIONS)}",
            "danger",
        )
        return None

    try:
        # Save the file to the filesystem
        file_storage.save(save_path_full)

        # Get mimetype (optional, can be None)
        mimetype = file_storage.mimetype

        # Create a new File database record
        new_file = File(
            filename=unique_filename,  # Store the unique server-side filename
            original_filename=original_filename,  # Store the user's original filename
            mimetype=mimetype,
            # Store the filepath relative to the app root for portability
            # This path will be used by send_from_directory
            filepath=os.path.join("uploads", "social_files", unique_filename),
            size=file_size,
            uploaded_by_id=current_user.id,  # Link to the user who uploaded
            uploaded_at=datetime.now(timezone.utc),
        )

        # Do NOT commit here. The calling route is responsible for adding and committing
        # this File object along with the associated message/post.
        # db.session.add(new_file) # The calling route will add it
        app.logger.info(
            f"File '{original_filename}' saved to '{save_path_full}' by user {current_user.id}. Size: {file_size} bytes."
        )
        return new_file  # Return the uncommitted DB object

    except Exception as e:
        # Log the error and cleanup the saved file if it exists
        app.logger.error(
            f"Error saving uploaded file '{original_filename}' for user {current_user.id}: {e}",
            exc_info=True,
        )
        if os.path.exists(save_path_full):
            try:
                os.remove(save_path_full)
            except Exception as cleanup_e:
                app.logger.error(
                    f"Error cleaning up failed upload file {save_path_full}: {cleanup_e}"
                )

        flash(
            "File upload failed due to an internal error. Please try again.", "danger"
        )
        return None


# Can access social media file (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def can_access_file(user, file):
    """
    Placeholder to check if a user has permission to access a specific social file.
    Logic depends on where the file is linked (channel, group) and user's membership/role.
    """
    if not user or not user.is_authenticated or not file:
        return False  # Must be logged in and file must exist

    # Check if the user uploaded the file
    if file.uploaded_by_id == user.id:
        return True

    # Check if the file is linked to a Channel Post
    if file.channel_post:
        # User can access if they are a member of the channel the post is in
        return user.is_channel_member(file.channel_post.channel)

    # Check if the file is linked to a Group Message
    if file.group_message:
        # User can access if they are a member of the group the message is in
        return user.is_group_member(file.group_message.group)

    # If the file is not linked to any post/message, maybe only the uploader or admin can access?
    # For now, assume unlinked files are not publicly accessible unless uploaded by the user.
    # Add administrative bypass for system_admin, hr_ceo etc.
    if user.role and user.role.name.lower() in ["system_admin", "hr_ceo"]:
        return True

    # If none of the above conditions are met, access is denied
    return False


# Can view behavior records (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
# In Part 3, the can_view_behavior_records helper function remains as previously updated:
def can_view_behavior_records(viewer, student):
    """
    Determines if a 'viewer' user has permission to view the
    behavior records of a 'student' user.
    (All authenticated users can view behavior records).
    """
    if not viewer or not viewer.is_authenticated or not student:
        return False
    return True  # All authenticated users can view behavior records


# Notify student and parents of behavior record (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def notify_student_and_parents(student, behavior_record):
    """
    Placeholder to send notifications about a new behavior record to the student and their verified parents.
    """
    try:
        with app.app_context():  # Ensure context
            # Build the notification content
            message_content = f"A new behavior record has been added for you. Type: {behavior_record.behavior_type}, Severity: {behavior_record.severity}."
            # Optional: Add a link to view the behavior record details page (if one exists for students/parents)
            # link_url = url_for('view_behavior_record', record_id=behavior_record.id) # Example link

            # Notify the student
            # Check if notification is allowed (e.g. 'teacher'/'hr_ceo'/etc. sending to 'student')
            sender_role_name = (
                behavior_record.recorded_by.role.name.lower()
                if behavior_record.recorded_by and behavior_record.recorded_by.role
                else "unknown"
            )
            receiver_role_name = (
                student.role.name.lower() if student.role else "unknown"
            )

            if is_notification_allowed(sender_role_name, receiver_role_name):
                notification_student = Notification(
                    sender_id=behavior_record.recorded_by_id,  # The user who recorded it
                    receiver_id=student.id,
                    content=message_content,
                    link_url=None,  # Add link_url if applicable
                    timestamp=datetime.now(timezone.utc),
                    is_read=False,
                )
                db.session.add(notification_student)
                app.logger.info(
                    f"Notified student {student.username} about new behavior record ID {behavior_record.id}."
                )
            else:
                app.logger.warning(
                    f"Notification not allowed for student {student.username} about behavior record {behavior_record.id} from sender role {sender_role_name}."
                )

            # Notify verified parents of the student
            if (
                student.parent_associations
            ):  # Check if the student has parent associations
                parent_associations = db.session.scalars(
                    select(ParentStudent).filter_by(
                        student_id=student.id, verification_status="verified"
                    )
                ).all()

                parent_message_content = f"A new behavior record has been added for your child, {student.full_name or student.username}. Type: {behavior_record.behavior_type}, Severity: {behavior_record.severity}."
                # Optional: Add a link to view the behavior record from the parent dashboard/student profile
                # link_url_parent = url_for('parent_view_student_behavior', student_id=student.id) # Example link

                for assoc in parent_associations:
                    parent = (
                        assoc.parent.user
                    )  # Get the Parent User object from the association
                    if (
                        parent
                        and parent.is_active
                        and parent.role
                        and parent.role.name.lower() == "parent"
                    ):
                        # Check if notification is allowed (e.g. 'teacher'/'hr_ceo'/etc. sending to 'parent')
                        # Sender role is the role of the user who recorded it
                        receiver_role_name_parent = parent.role.name.lower()

                        if is_notification_allowed(
                            sender_role_name, receiver_role_name_parent
                        ):
                            notification_parent = Notification(
                                sender_id=behavior_record.recorded_by_id,  # The user who recorded it
                                receiver_id=parent.id,
                                content=parent_message_content,
                                link_url=None,  # Add link_url_parent if applicable
                                timestamp=datetime.now(timezone.utc),
                                is_read=False,
                            )
                            db.session.add(notification_parent)
                            app.logger.info(
                                f"Notified parent {parent.username} about new behavior record ID {behavior_record.id} for child {student.username}."
                            )
                        else:
                            app.logger.warning(
                                f"Notification not allowed for parent {parent.username} about behavior record {behavior_record.id} from sender role {sender_role_name}."
                            )

            db.session.commit()  # Commit all notifications (student and parents)

    except Exception as e:
        # Log the error but don't roll back the main transaction that added the behavior record
        app.logger.error(
            f"Error sending behavior record notifications for student {student.id}, record ID {behavior_record.id}: {e}",
            exc_info=True,
        )
        db.session.rollback()  # Rollback only the notification transaction


# Helper to save social media files (distinct from profile photos, defined in Part 12)
# Keeping definition here for reference, but the actual function body was provided in Part 12.
# def save_uploaded_file(file_storage):
#      pass # Body is in Part 12


# Helper to save profile photos (defined in Part 12)
# Keeping definition here for reference, but the actual function body was provided in Part 12.
# def save_profile_photo(file_storage):
#      pass # Body is in Part 12


# --- END PART 3 ---

# --- PART 4 START: WTForms Definitions ---
# ... (WTForms definitions from your code) ...
# --- END PART 4 ---

# --- PART 5 START: Authentication Routes ---
# ... (Authentication routes from your code) ...
# --- END PART 5 ---

# --- PART 6 START: Role Dashboards & Core Navigation ---
# ... (Role Dashboards & Core Navigation routes from your code) ...
# --- END PART 6 ---

# --- PART 7 START: Teacher/Librarian Specific Features ---
# ... (Teacher/Librarian Specific Features routes from your code) ...
# --- END PART 7 ---

# --- PART 8 START: HR/CEO & System Admin Management Features ---
# ... (HR/CEO & System Admin Management Features routes from your code) ...
# --- END PART 8 ---

# --- PART 9 START: Book Checkout & Management ---
# ... (Book Checkout & Management routes from your code) ...
# --- END PART 9 ---

# --- PART 10 START: Chat and Contacts ---
# ... (Chat and Contacts routes from your code) ...
# --- END PART 10 ---

# --- PART 11 START: Notifications ---
# ... (Notifications routes from your code) ...
# --- END PART 11 ---

# --- Group Routes ---
# ... (Group routes from your code) ...
# --- PART 12 END: Social Media Features ---

# --- PART 13 START: Settings ---
# ... (Settings routes from your code) ...
# --- PART 13 END: Settings ---

# --- PART 14 START: Analytics (Placeholder/Basic) ---
# ... (Analytics routes from your code) ...
# --- PART 14 END: Analytics (Placeholder/Basic) ---

# --- PART 15 START: CLI Commands, Error Handlers, and Main Execution ---
# ... (CLI Commands, Error Handlers, and Main Execution from your code) ...
# --- PART 15 END ---

# --- PART 4 START: WTForms Definitions ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models like User, AssetCategory, Lab are defined.
# - Helpers like get_social_categories are defined.
# - SQLAlchemy imports (select, func, etc.) and WTForms imports are available.


# START MODIFICATION (get_social_categories helper)
def get_social_categories():
    """Helper to query and format social categories for select fields."""
    # Requires an active application context and initialized db
    try:
        with app.app_context():  # Ensure context if called during app setup
            return db.session.scalars(
                select(SocialCategory).order_by(SocialCategory.name)
            ).all()  # MODIFIED: Query SocialCategory
    except Exception as e:
        # Log or handle the error appropriately
        app.logger.error(f"Error fetching social categories: {e}")
        return []  # Return empty list on error


# END MODIFICATION (get_social_categories helper)


# Add this new helper function
def get_asset_categories():
    """Helper to query and format asset categories for select fields."""
    try:
        with app.app_context():  # Ensure context if called during app setup
            return db.session.scalars(
                select(AssetCategory).order_by(AssetCategory.name)
            ).all()
    except Exception as e:
        app.logger.error(f"Error fetching asset categories: {e}")
        return []


# ... (rest of get_social_categories and @app.context_processor) ...


# --- Custom Jinja Filters ---
@app.template_filter("datetimeformat")
def datetimeformat(value, format="%Y-%m-%d %H:%M"):
    """Formats a datetime object to a string."""
    if isinstance(value, datetime):
        # Ensure timezone-aware conversion if needed, or assume UTC as per model defaults
        # For simplicity, direct format assuming UTC or naive UTC objects
        return value.strftime(format)
    if isinstance(value, str):  # Basic attempt to handle string dates
        try:
            # Handle common ISO format with Z or offset
            dt_obj = datetime.fromisoformat(value.replace("Z", "+00:00"))
            return dt_obj.strftime(format)
        except ValueError:
            pass  # Fall through if parsing fails
    return (
        value if value is not None else ""
    )  # Return original value or empty string if None


@app.template_filter("dateformat")
def dateformat_filter(value, format="%Y-%m-%d"):
    """Formats a date or datetime object to a date string."""
    if isinstance(value, (datetime, Date)):
        return value.strftime(format)
    return value if value is not None else ""


# --- Role Management Decorator ---
def role_required(*required_roles):
    """Decorator to restrict access to routes based on user roles."""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash("Please log in to access this page.", "warning")
                return redirect(url_for("login", next=request.url))

            user_role_name = (
                current_user.role.name.lower() if current_user.role else None
            )
            normalized_required_roles = [role.lower() for role in required_roles]

            if user_role_name not in normalized_required_roles:
                app.logger.warning(
                    f"User {current_user.username} (Role: {user_role_name}) "
                    f"attempted to access restricted route requiring roles: {required_roles}"
                )
                abort(403)  # Forbidden
            return f(*args, **kwargs)

        return decorated_function

    return decorator


def tc_member_required(f):
    """Decorator to restrict access to routes to users who are Talent Club members."""

    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check if the user is marked as a Talent Club member
        if not current_user.is_tc_member:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC restricted route {request.path} but is not a TC member."
            )
            flash("You must be a Talent Club member to access this area.", "warning")
            # Redirect them back to their dashboard or a page prompting them to join TC
            # Redirect to a generic TC join page if it exists, or fallback
            return redirect(
                url_for("student_dashboard")
            )  # Assuming students start here

        return f(*args, **kwargs)

    return decorated_function


# --- Define VALID_ROLES GLOBALLY (Needed for permission configs and helpers) ---
VALID_ROLES = [
    ("system_admin", "System Administrator (Full Access)"),
    ("school_executive", "School Executive Board Member"),
    ("government", "Government Compliance Officer"),
    ("hr_ceo", "HR & Academic CEO"),
    ("teacher", "Teaching Staff"),
    ("librarian", "Library Management"),
    ("talent_club", "Talent Club Coordinator"),
    ("student", "Enrolled Student"),
    ("parent", "Student Parent/Guardian"),
]
# Make VALID_ROLES available in the app config for easier access in helpers
app.config["VALID_ROLES"] = VALID_ROLES
# Extract just the role names for easier lookup
VALID_ROLE_NAMES = [role[0] for role in VALID_ROLES]


# --- Permission Configurations (Chat & Notification) ---

# --- Permission Configurations (Chat & Notification) ---

# Updated CHAT_PERMISSIONS configuration
CHAT_PERMISSIONS = {
    # Role: { 'send_to': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'receive_from': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'exceptions': {'leader': {'send_to': {...}, 'receive_from': {...}}} }
    "government": {
        "send_to": {"specific": ["hr_ceo", "school_executive"]},  # UPDATED
        "receive_from": {"specific": ["school_executive", "government"]},
    },
    "school_executive": {
        "send_to": {
            "all": True,
            "exceptions": ["student", "talent_club"],
        },  # UPDATED (added 'student')
        "receive_from": {"all": True, "exceptions": ["government", "talent_club"]},
    },
    "system_admin": {  # No explicit rules provided for System Admin, keeping previous configuration
        "send_to": {"all": True, "exceptions": ["government", "talent_club"]},
        "receive_from": {"all": True, "exceptions": ["government", "talent_club"]},
    },
    "student": {
        "send_to": {"none": True},  # Default students cannot send notifications
        "receive_from": {
            "specific": [
                "system_admin",
                "government",
                "hr_ceo",
                "school_executive",
                "teacher",
                "librarian",
                "talent_club",
            ]
        },  # Receives from relevant staff roles and Talent Club leaders
        "exceptions": {
            "tc_member": {  # Talent Club Member Exception (Students who opted-in)
                "send_to": {
                    "specific": ["student", "talent_club"]
                },  # MODIFIED: Can send general chat to other students (who are TC members) and Talent Club role users (TC Leader, coordinators)
                "receive_from": {
                    "specific": [
                        "student",
                        "talent_club",
                        "hr_ceo",
                        "teacher",
                        "librarian",
                        "school_executive",
                        "system_admin",
                    ]
                },  # MODIFIED: Can receive from TC network, HR/CEO, and other relevant staff roles. Explicitly listing allows more control than 'all' with exceptions.
            },
            "leader": {  # Student Leaders Exception (keep existing if any)
                "send_to": {"specific": ["student", "hr_ceo", "system_admin"]},
                "receive_from": {
                    "all": True,
                    "exceptions": [
                        "government",
                        "talent_club",
                        "school_executive",
                        "parent",
                    ],
                },  # Keep as is or adjust
            },
        },
    },
    "teacher": {
        "send_to": {
            "all": True,
            "exceptions": ["government", "talent_club"],
        },  # UPDATED (removed 'student')
        "receive_from": {"all": True, "exceptions": ["government", "talent_club"]},
    },
    "hr_ceo": {
        "send_to": {
            "all": True,
            "exceptions": ["government", "student", "talent_club"],
        },  # UPDATED (added 'student')
        "receive_from": {
            "all": True,
            "exceptions": ["government", "student", "talent_club"],
        },  # UPDATED (added 'student')
    },
    "parent": {
        "send_to": {"specific": ["teacher", "hr_ceo", "parent"]},
        "receive_from": {
            "specific": [
                "teacher",
                "hr_ceo",
                "parent",
                "school_executive",
                "system_admin",
            ]
        },
    },
    "librarian": {
        "send_to": {
            "all": True,
            "exceptions": ["government", "talent_club", "student", "parent"],
        },  # UPDATED (added 'parent')
        "receive_from": {"all": True, "exceptions": ["government", "talent_club"]},
    },
    "talent_club": {  # Talent Club Role (e.g. System-wide Coordinators, or the Leader's role)
        "send_to": {
            "none": True
        },  # MODIFIED: Default Talent Club role users (non-leader) CANNOT send chat
        "receive_from": {
            "specific": [
                "student",
                "talent_club",
                "hr_ceo",
                "teacher",
                "librarian",
                "school_executive",
                "system_admin",
            ]
        },  # MODIFIED: Can receive from TC network and relevant staff/admin
        "exceptions": {
            "tc_leader": {  # Talent Club Leaders Exception (users with talent_club role AND is_tc_leader=True)
                # NOTE: 'send_to' here is LESS important now because the helper overrides it globally
                # if user.is_tc_leader is True. Keeping it here for documentation/clarity.
                "send_to": {"specific": ["student", "talent_club", "hr_ceo"]},
                "receive_from": {
                    "specific": [
                        "student",
                        "talent_club",
                        "hr_ceo",
                        "teacher",
                        "librarian",
                        "school_executive",
                        "system_admin",
                    ]
                },  # MODIFIED: Same broad receiving as default Talent Club role user
            }
        },
    },
}
NOTIFICATION_PERMISSIONS = {
    # Role: { 'send_to': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'receive_from': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]} }
    "government": {
        "send_to": {"all": True},  # Full permission to send
        "receive_from": {"none": True},  # Government receives no notifications
    },
    "school_executive": {
        "send_to": {
            "all": True,
            "exceptions": ["government"],
        },  # Can send to all except government
        "receive_from": {
            "all": True,
            "exceptions": ["student", "parent", "talent_club"],
        },  # Receives from all who can send (except non-senders)
    },
    "system_admin": {
        "send_to": {"all": True},  # Can send to all
        "receive_from": {
            "all": True,
            "exceptions": ["student", "parent", "talent_club"],
        },  # Receives from all who can send (except non-senders)
    },
    "hr_ceo": {
        "send_to": {
            "all": True,
            "exceptions": ["school_executive", "government"],
        },  # Can send to all except school_executive and government
        "receive_from": {
            "all": True,
            "exceptions": ["student", "parent", "talent_club"],
        },  # Receives from all who can send (except non-senders)
    },
    "teacher": {
        "send_to": {
            "specific": ["student", "parent"]
        },  # Teachers notify students and parents
        "receive_from": {
            "specific": ["system_admin", "government", "hr_ceo", "school_executive"]
        },  # Receives from these staff roles
    },
    "librarian": {
        "send_to": {"specific": ["student"]},  # Librarian notifies students
        "receive_from": {
            "specific": ["system_admin", "government", "hr_ceo", "school_executive"]
        },  # Receives from these staff roles
    },
    "talent_club": {
        "send_to": {
            "none": True
        },  # Regular Talent Club members cannot send notifications
        "receive_from": {
            "specific": [
                "system_admin",
                "government",
                "hr_ceo",
                "school_executive",
                "talent_club",
            ]
        },  # Receives from relevant staff and other Talent Club members (leaders)
        "exceptions": {
            "tc_leader": {  # Talent Club Leaders Exception (uses is_tc_leader)
                "send_to": {
                    "specific": ["talent_club"]
                }  # Leader can send to other Talent Club members
            }
        },
    },
    "student": {
        "send_to": {"none": True},  # Students cannot send notifications
        "receive_from": {
            "specific": [
                "system_admin",
                "government",
                "hr_ceo",
                "school_executive",
                "teacher",
                "librarian",
                "talent_club",
            ]
        },  # Receives from relevant staff roles and Talent Club leaders
    },
    "parent": {
        "send_to": {"none": True},  # Parents cannot send notifications
        "receive_from": {
            "specific": [
                "system_admin",
                "government",
                "hr_ceo",
                "school_executive",
                "teacher",
            ]
        },  # Receives from relevant staff roles
    },
}

# --- NEW CONFIGURATIONS: Talent Club Subsystem ---

# Configuration for allowed roles/members to post in a specific Talent Club's feed channel
# Key is the TalentClubMembership role name (lowercase)
TALENT_CLUB_POSTING_PERMISSIONS = {
    "creator": True,
    "admin": True,
    "member": False,  # Default members cannot post
}

# --- NEW CONFIGURATIONS: Task System ---

TASK_CREATOR_ROLES = [
    "hr_ceo",
    "system_admin",
    "school_executive",
]  # Define which roles can create tasks
# You can add other roles here if needed, e.g., 'teacher' for class tasks.

# Define valid statuses for UserTask for clarity
USER_TASK_STATUSES = [
    "Open",
    "In Progress",
    "Completed (Pending Review)",
    "Delayed (Pending Review)",
    "Rejected (Pending Review)",
    "Accepted",  # Creator accepted completion/status update
    "Review Rejected",  # Creator rejected status update, task is sent back
]

TASK_HISTORY_ACTIONS = [
    "Assigned",
    "Status Update",  # User updated status to In Progress, Completed, Delayed, Rejected
    "Review Accepted",  # Creator accepted user's status update
    "Review Rejected",  # Creator rejected user's status update
]

# --- NEW HELPER FUNCTIONS: Task System ---


def get_allowed_task_creators():
    """Fetches User objects for roles allowed to create tasks."""
    with app.app_context():  # Ensure context
        return db.session.scalars(
            select(User)
            .join(Role)
            .where(Role.name.in_(TASK_CREATOR_ROLES), User.is_active == True)
            .order_by(User.full_name)
        ).all()

def tc_leader_required(f):
    """Decorator to restrict access to routes to the system-wide Talent Club Leader."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check the user's 'is_tc_leader' flag
        if not hasattr(current_user, 'is_tc_leader') or not current_user.is_tc_leader:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC Leader restricted route {request.path} but is not the leader."
            )
            flash("You must be the Talent Club Leader to access this page.", "danger")
            # Redirect to the main TC dashboard for regular members, or another appropriate page
            return redirect(url_for('talent_club_dashboard_member_view'))

        return f(*args, **kwargs)
    return decorated_function



def get_assignable_users():
    """Fetches User objects eligible for individual task assignment (e.g., all active users except creators?)."""
    # For simplicity, let's allow assigning to all active users except system admins
    with app.app_context():  # Ensure context
        system_admin_role = db.session.scalar(
            select(Role).filter_by(name="system_admin")
        )
        query = select(User).where(User.is_active == True)
        if system_admin_role:
            query = query.where(User.role != system_admin_role)
        return db.session.scalars(query.order_by(User.full_name)).all()
    # You might want more granular control here based on roles that can receive tasks


def get_assignable_roles():
    """Returns a list of valid role names that can be targets for group assignment."""
    # For V1, let's make all standard roles assignable as groups, maybe exclude admins?
    # Or, keep it simple and allow assigning to any defined role in VALID_ROLE_NAMES
    return [
        role_name for role_name, _ in VALID_ROLES
    ]  # Use the global VALID_ROLES defined earlier


def get_assignable_grade_sections():
    """Fetches distinct grade-section pairs for student group assignment."""
    with app.app_context():  # Ensure context
        # Query active students for their grade/section pairs
        stmt = (
            select(User.grade, User.section)
            .join(Role)
            .filter(Role.name == "student")
            .where(
                User.is_active == True, User.grade.isnot(None), User.section.isnot(None)
            )
            .distinct()
            .order_by(User.grade, User.section)
        )
        return db.session.execute(stmt).all()  # Returns list of (grade, section) tuples


def log_user_task_history(
    user_task, changed_by_user, old_status, new_status, action, notes=None
):
    """
    Logs an action to the TaskHistory for a given UserTask.
    This function should be called within a database session.
    """
    history_entry = TaskHistory(
        user_task=user_task,  # Link to the UserTask object
        changed_by=changed_by_user,  # Link to the User who made the change
        old_status=old_status,
        new_status=new_status,
        action=action,
        notes=notes,
        timestamp=datetime.now(timezone.utc),
    )
    db.session.add(history_entry)
    # Note: Commit should be handled by the calling route, not here.


def notify_task_assigned(user_task):
    """Sends a notification to a user that a task has been assigned to them."""
    with app.app_context():  # Ensure context
        try:
            receiver = user_task.user  # The assigned user
            sender = (
                user_task.assigned_by
            )  # The user who assigned this instance (usually creator)
            if not receiver or not receiver.is_active:
                app.logger.warning(
                    f"Cannot notify inactive user {receiver.id if receiver else 'N/A'} about assigned task {user_task.task_id}."
                )
                return
            if not sender:
                sender = db.session.scalar(
                    select(User).filter_by(username="system")
                )  # Fallback to system user
                if not sender:
                    app.logger.error(
                        "System user not found for task assignment notification sender."
                    )
                    return

            notification_content = (
                f"You have been assigned a new task: '{user_task.task.title}'."
            )
            link_url = url_for(
                "view_user_task", user_task_id=user_task.id
            )  # Link to the user's task detail page

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(sender, receiver):
                notification = Notification(
                    sender_id=sender.id,
                    receiver_id=receiver.id,
                    content=notification_content,
                    link_url=link_url,
                    timestamp=datetime.now(timezone.utc),
                    is_read=False,
                    notification_type="task_assigned",  # Specific type
                    related_object_id=user_task.id,  # Link to the UserTask instance
                )
                db.session.add(notification)
                db.session.commit()  # Commit notification immediately
                app.logger.info(
                    f"Notification sent to user {receiver.id} about assigned task {user_task.id}."
                )
            else:
                app.logger.warning(
                    f"Notification not allowed for task assignment: Sender '{sender.role.name if sender.role else 'N/A'}' to Receiver '{receiver.role.name if receiver.role else 'N/A'}'."
                )

        except Exception as e:
            db.session.rollback()  # Rollback only the notification transaction
            app.logger.error(
                f"Error sending task assigned notification for UserTask {user_task.id}: {e}",
                exc_info=True,
            )


def notify_user_task_status_update(user_task):
    """Sends a notification to the task creator when an assigned user updates status."""
    with app.app_context():  # Ensure context
        try:
            creator = user_task.task.created_by  # The task creator (receiver)
            assigned_user = user_task.user  # The user who updated status (sender)
            if not creator or not creator.is_active:
                app.logger.warning(
                    f"Cannot notify inactive creator {creator.id if creator else 'N/A'} about status update for UserTask {user_task.id}."
                )
                return
            # Assigned user must be active to be the sender
            if not assigned_user or not assigned_user.is_active:
                app.logger.warning(
                    f"Assigned user {assigned_user.id if assigned_user else 'N/A'} for UserTask {user_task.id} is inactive. Cannot use as notification sender."
                )
                assigned_user = db.session.scalar(
                    select(User).filter_by(username="system")
                )  # Fallback sender

            notification_content = f"Status update for task '{user_task.task.title}' by {assigned_user.full_name or assigned_user.username}: '{user_task.status}'."
            link_url = url_for(
                "review_user_task", user_task_id=user_task.id
            )  # Link to the review page for this UserTask instance

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(assigned_user, creator):
                notification = Notification(
                    sender_id=assigned_user.id,
                    receiver_id=creator.id,
                    content=notification_content,
                    link_url=link_url,
                    timestamp=datetime.now(timezone.utc),
                    is_read=False,
                    notification_type="task_status_update",  # Specific type
                    related_object_id=user_task.id,  # Link to the UserTask instance
                )
                db.session.add(notification)
                db.session.commit()  # Commit notification immediately
                app.logger.info(
                    f"Notification sent to creator {creator.id} about status update for UserTask {user_task.id}."
                )
            else:
                app.logger.warning(
                    f"Notification not allowed for task status update: Sender '{assigned_user.role.name if assigned_user.role else 'N/A'}' to Receiver '{creator.role.name if creator.role else 'N/A'}'."
                )

        except Exception as e:
            db.session.rollback()  # Rollback only the notification transaction
            app.logger.error(
                f"Error sending task status update notification for UserTask {user_task.id}: {e}",
                exc_info=True,
            )


def notify_user_task_review_result(user_task):
    """Sends a notification to the assigned user about the creator's review outcome."""
    with app.app_context():  # Ensure context
        try:
            assigned_user = user_task.user  # The assigned user (receiver)
            creator = user_task.task.created_by  # The task creator (sender/reviewer)
            if not assigned_user or not assigned_user.is_active:
                app.logger.warning(
                    f"Cannot notify inactive user {assigned_user.id if assigned_user else 'N/A'} about review result for UserTask {user_task.id}."
                )
                return
            # Creator must be active to be the sender
            if not creator or not creator.is_active:
                app.logger.warning(
                    f"Creator {creator.id if creator else 'N/A'} for UserTask {user_task.id} is inactive. Cannot use as notification sender."
                )
                creator = db.session.scalar(
                    select(User).filter_by(username="system")
                )  # Fallback sender

            review_outcome_text = (
                user_task.status
            )  # e.g., 'Accepted', 'Review Rejected'
            notification_content = f"Review for your task assignment '{user_task.task.title}': Status is now '{review_outcome_text}'."
            if user_task.reviewer_notes:
                notification_content += f" Notes: {user_task.reviewer_notes[:100]}..."

            link_url = url_for(
                "view_user_task", user_task_id=user_task.id
            )  # Link back to the user's task detail page

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(creator, assigned_user):
                notification = Notification(
                    sender_id=creator.id,
                    receiver_id=assigned_user.id,
                    content=notification_content,
                    link_url=link_url,
                    timestamp=datetime.now(timezone.utc),
                    is_read=False,
                    notification_type="task_review_result",  # Specific type
                    related_object_id=user_task.id,  # Link to the UserTask instance
                )
                db.session.add(notification)
                db.session.commit()  # Commit notification immediately
                app.logger.info(
                    f"Notification sent to user {assigned_user.id} about review result for UserTask {user_task.id}."
                )
            else:
                app.logger.warning(
                    f"Notification not allowed for task review result: Sender '{creator.role.name if creator.role else 'N/A'}' to Receiver '{assigned_user.role.name if assigned_user.role else 'N/A'}'."
                )

        except Exception as e:
            db.session.rollback()  # Rollback only the notification transaction
            app.logger.error(
                f"Error sending task review result notification for UserTask {user_task.id}: {e}",
                exc_info=True,
            )


# Assignment helpers that create UserTask instances and trigger initial notifications/history
def assign_task_to_users(
    task,
    user_ids,
    assigned_by_user,
    assignment_type="individual",
    assignment_detail=None,
):
    """Assigns a Task to a list of specific user IDs."""
    assigned_count = 0
    # Fetch actual user objects to ensure they exist and are active
    users_to_assign = db.session.scalars(
        select(User).where(User.id.in_(user_ids), User.is_active == True)
    ).all()

    if not users_to_assign:
        app.logger.warning(
            f"No active users found for assignment to task {task.id} with IDs {user_ids}."
        )
        return 0  # No users assigned

    try:
        for user in users_to_assign:
            # Check if a UserTask already exists for this specific task and user
            existing_assignment = db.session.scalar(
                select(UserTask).filter_by(task=task, user=user).limit(1)
            )
            if existing_assignment:
                app.logger.warning(
                    f"User {user.username} already has an assignment for task {task.id}. Skipping duplicate assignment."
                )
                continue  # Skip if already assigned

            new_assignment = UserTask(
                task=task,
                user=user,
                assigned_by=assigned_by_user,
                assignment_type=assignment_type,
                assignment_detail=assignment_detail,
                status="Open",  # Initial status
                assigned_at=datetime.now(timezone.utc),
                last_status_update_at=datetime.now(timezone.utc),
            )
            db.session.add(new_assignment)
            db.session.flush()  # Flush to get UserTask ID for history

            # Log initial assignment history
            log_user_task_history(
                new_assignment,
                assigned_by_user,
                None,
                "Open",
                "Assigned",
                task.description[:100] + "..." if task.description else None,
            )

            assigned_count += 1
            # Notify user after assignment (each notification commit is separate)
            notify_task_assigned(new_assignment)

        db.session.commit()  # Commit all new UserTask entries and history entries added in this function call

        app.logger.info(
            f"Task {task.id} assigned to {assigned_count} users by {assigned_by_user.username}."
        )
        return assigned_count  # Return count of successfully assigned users

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error assigning task {task.id} to users by {assigned_by_user.username}: {e}",
            exc_info=True,
        )
        return 0  # Return 0 on error


def assign_task_to_role(task, role_name, assigned_by_user):
    """Assigns a Task to all active users in a specific role."""
    role = db.session.scalar(select(Role).filter_by(name=role_name))
    if not role:
        app.logger.warning(f"Role '{role_name}' not found for task assignment.")
        return 0  # No users assigned

    # Find all active users in this role
    users_in_role = db.session.scalars(
        select(User).where(User.role == role, User.is_active == True)
    ).all()

    if not users_in_role:
        app.logger.info(
            f"No active users found in role '{role_name}' for task assignment {task.id}."
        )
        return 0  # No users to assign

    user_ids = [user.id for user in users_in_role]
    return assign_task_to_users(
        task,
        user_ids,
        assigned_by_user,
        assignment_type="group_role",
        assignment_detail=role_name,
    )


def assign_task_to_grade_section(task, grade, section, assigned_by_user):
    """Assigns a Task to all active students in a specific grade and section."""
    # Find all active students in this grade and section
    student_role = db.session.scalar(select(Role).filter_by(name="student"))
    if not student_role:
        app.logger.error("Student role not found for grade/section assignment.")
        return 0

    users_in_class = db.session.scalars(
        select(User).where(
            User.role == student_role,
            User.grade == grade,
            User.section == section,
            User.is_active == True,
        )
    ).all()

    if not users_in_class:
        app.logger.info(
            f"No active students found in grade {grade}, section {section} for task assignment {task.id}."
        )
        return 0  # No users to assign

    user_ids = [user.id for user in users_in_class]
    return assign_task_to_users(
        task,
        user_ids,
        assigned_by_user,
        assignment_type="group_section",
        assignment_detail=f"{grade}-{section}",
    )


# --- END NEW HELPER FUNCTIONS ---

# Configuration for Talent Club levels
TALENT_CLUB_LEVELS = [
    1,
    2,
    3,
    4,
    5,  # Example levels
    # Define level names if using strings instead of integers:
    # ('Level 1', 1), ('Level 2', 2), ...
]

# Configuration for ban/mute types if using the models
TALENT_CLUB_BAN_TYPES = ["ban", "mute"]  # Corresponds to TalentClubBan.type

# Configuration for penalty types if using the models
TALENT_CLUB_PENALTY_TYPES = [
    "warning_points",
    "temporary_restriction",
]  # Corresponds to TalentClubPenalty.type

# Constant for the name of the main Talent Club Community group
TC_COMMUNITY_GROUP_NAME = "Talent Club Community"


# --- NEW: Request System Permissions Configuration ---
REQUEST_SYSTEM_PERMISSIONS = {
    "can_initiate": [
        "librarian",
        "student_leader",
        "teacher",
        "talent_club_leader",
    ],  # Roles that can start a request
    "tier_handlers": {  # Maps tier to the role responsible for handling that tier
        1: "hr_ceo",
        2: "school_executive",
        3: "government",
    },
    "forward_paths": {  # Maps current handler role to next handler role for forwarding
        "hr_ceo": "school_executive",
        "school_executive": "government",
    },
    "final_tiers": ["government"],  # Roles that cannot forward further
    "resolver_roles": [
        "hr_ceo",
        "school_executive",
    ],  # Roles that can mark a request as 'Resolved' at their tier
}

# --- END NEW: Request System Permissions Configuration ---

# --- NEW: Request System Helper Functions ---


def log_request_history(
    request_obj, changed_by_user, old_status, new_status, action, notes=None
):
    """
    Logs an action to the RequestHistory for a given request.
    This function should be called within a database session.
    """
    history_entry = RequestHistory(
        request_id=request_obj.id,
        changed_by_id=changed_by_user.id,
        old_status=old_status,
        new_status=new_status,
        action=action,
        notes=notes,
        timestamp=datetime.now(timezone.utc),
    )
    db.session.add(history_entry)
    # Note: Commit should be handled by the calling route, not here,
    # so that the history entry is committed along with the request changes.


def notify_request_event(
    request_obj, event_type, old_status=None, changed_by_user=None
):
    """
    Sends notifications related to a request event (submission, status change, forward).
    Leverages the existing Notification model and `send_notification_to_user` logic.
    Assumes `send_notification_to_user` (or `Notification` creation) handles permissions
    between sender/receiver roles based on NOTIFICATION_PERMISSIONS.
    """
    with app.app_context():  # Ensure app context for DB operations and url_for
        try:
            sender = (
                changed_by_user
                if changed_by_user
                else db.session.scalar(select(User).filter_by(username="system"))
            )  # Use a 'system' user if no specific changed_by
            if not sender:
                app.logger.error(
                    "System user not found for request notification sender."
                )
                return

            notification_content = ""
            receiver_user_id = None
            link_url = url_for(
                "view_request_detail", request_id=request_obj.id
            )  # Link to the request detail page

            if event_type == "Submitted":
                notification_content = f"A new request '{request_obj.title}' (ID: {request_obj.id}) has been submitted by {request_obj.requester.full_name or request_obj.requester.username} and is awaiting your review."
                receiver_user_id = (
                    request_obj.current_handler_id
                )  # Notify the assigned handler
            elif event_type == "Status_Updated":
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been updated. New status: '{request_obj.status}'."
                receiver_user_id = (
                    request_obj.requester_id
                )  # Notify the original requester
            elif event_type == "Forwarded":
                notification_content = f"A request '{request_obj.title}' (ID: {request_obj.id}) has been forwarded to you for review by {sender.full_name or sender.username}."
                receiver_user_id = (
                    request_obj.current_handler_id
                )  # Notify the new handler
            elif event_type == "Resolved":
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been successfully resolved."
                receiver_user_id = (
                    request_obj.requester_id
                )  # Notify requester of resolution
            elif event_type == "Denied":
                notification_content = (
                    f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been denied. Reason: {request_obj.denial_reason[:100]}..."
                    if request_obj.denial_reason
                    else "Your request has been denied."
                )
                receiver_user_id = (
                    request_obj.requester_id
                )  # Notify requester of denial

            if receiver_user_id:
                receiver = db.session.get(User, receiver_user_id)
                if receiver and receiver.is_active and receiver.role:
                    # Check permission using the can_send / can_receive helpers
                    # These helpers are already defined in Part 3 and use NOTIFICATION_PERMISSIONS
                    # The `send_notification_to_user` route implicitly handles permission checks when creating the notification.
                    # Here, we are constructing the notification object directly.
                    # So, we should check `can_send` and `can_receive` here or trust the overall permission config.
                    # For simplicity, we'll assume the notification config dictates who should *get* these, and the sender is typically a system/admin or authorized handler.

                    # It's better to explicitly check if the sender can send to the receiver's role
                    # This check is crucial for ensuring valid notifications are created.
                    if can_send(sender, receiver.role.name) and can_receive(
                        receiver, sender.role.name
                    ):
                        notification = Notification(
                            sender_id=sender.id,
                            receiver_id=receiver.id,
                            content=notification_content,
                            link_url=link_url,
                            timestamp=datetime.now(timezone.utc),
                            is_read=False,
                        )
                        db.session.add(notification)
                        db.session.commit()
                        app.logger.info(
                            f"Notification '{event_type}' sent for request ID {request_obj.id} to user {receiver.id}."
                        )
                    else:
                        app.logger.warning(
                            f"Notification not allowed for request ID {request_obj.id}: Sender '{sender.role.name}' to Receiver '{receiver.role.name}'."
                        )
                else:
                    app.logger.warning(
                        f"Receiver user (ID: {receiver_user_id}) for request ID {request_obj.id} notification not found or inactive."
                    )
            else:
                app.logger.warning(
                    f"No valid receiver_user_id for request ID {request_obj.id} event '{event_type}'."
                )

        except Exception as e:
            db.session.rollback()  # Rollback notification creation if it fails
            app.logger.error(
                f"Error in notify_request_event for request ID {request_obj.id}, event '{event_type}': {e}",
                exc_info=True,
            )


def get_request_permissions(user_obj, request_obj=None):
    """
    Determines detailed permissions for a user regarding the request system or a specific request.
    Returns a dictionary of boolean flags.
    """
    permissions = {
        "can_create_request": False,
        "can_review": False,  # Can review requests in their inbox
        "can_forward": False,  # Can forward to next tier
        "can_resolve": False,  # Can mark as 'Resolved'
        "can_deny": False,  # Can mark as 'Denied'
        "can_see_history": False,  # Can view full history of a request
        "is_handler_for_request": False,  # True if request_obj.current_handler_id == user_obj.id
        "is_requester_of_request": False,  # True if request_obj.requester_id == user_obj.id
    }

    if not user_obj or not user_obj.is_authenticated or not user_obj.role:
        return permissions  # No permissions for unauthenticated or rol-less users

    user_role_name = user_obj.role.name.lower()

    # Determine can_create_request (initial submission)
    # Check for student leader and talent club leader roles
    if user_role_name == "student" and user_obj.is_leader:
        permissions["can_create_request"] = True
    elif user_role_name == "talent_club" and user_obj.is_tc_leader:
        permissions["can_create_request"] = True
    elif user_role_name in REQUEST_SYSTEM_PERMISSIONS["can_initiate"]:
        # This will cover 'librarian', 'teacher'
        permissions["can_create_request"] = True

    #  override for review/management (System Admin has full control)
    is_global_admin = user_role_name in [
        "system_admin",
        "hr_ceo",
    ]  # HR/CEO can also manage (Tier 1 handler)

    # Permissions related to a specific request
    if request_obj:
        permissions["is_requester_of_request"] = request_obj.requester_id == user_obj.id
        permissions["is_handler_for_request"] = (
            request_obj.current_handler_id == user_obj.id
        )

        # Anyone related to the request can see its history
        if (
            permissions["is_requester_of_request"]
            or permissions["is_handler_for_request"]
            or is_global_admin
        ):
            permissions["can_see_history"] = True

        # Reviewer permissions
        if permissions["is_handler_for_request"] or is_global_admin:
            # A user can review if they are the current handler or a .
            # However, if it's already Denied/Resolved at the current tier, they can't 'review' further directly.
            if request_obj.status not in ["Denied", "Resolved"]:
                permissions["can_review"] = True
                permissions["can_deny"] = True  # Handlers can always deny at their tier

                # Specific actions based on tier
                if request_obj.tier == 1 and user_role_name == "hr_ceo":
                    permissions["can_forward"] = True  # Can forward to School Exec
                    permissions["can_resolve"] = True  # Can resolve (final for HR/CEO)
                elif request_obj.tier == 2 and user_role_name == "school_executive":
                    permissions["can_forward"] = True  # Can forward to Government
                    permissions["can_resolve"] = (
                        True  # Can resolve (final for School Exec)
                    )
                elif request_obj.tier == 3 and user_role_name == "government":
                    # Government can only approve/deny (no 'On Progress' or 'Resolve' in the same sense, 'Approved' is final)
                    # And they cannot forward
                    permissions["can_resolve"] = (
                        True  # Denotes 'Approved' as final action
                    )
                    permissions["can_forward"] = False  # Explicitly cannot forward

        # HR/CEO and School Exec can initiate requests directly to the next tier
        if (
            user_role_name == "hr_ceo" and not request_obj.id
        ):  # Not editing an existing request, initiating new
            permissions["can_create_request"] = True
        elif (
            user_role_name == "school_executive" and not request_obj.id
        ):  # Not editing an existing request, initiating new
            permissions["can_create_request"] = True

    return permissions


# Helper to get users of a specific role (re-using existing pattern)
# This was implicitly assumed to be available. If not, add this:
def get_users_in_role(role_name):
    """Fetches all active users belonging to a specific role."""
    with app.app_context():
        role = db.session.scalar(select(Role).filter_by(name=role_name))
        if role:
            return db.session.scalars(
                select(User)
                .where(User.role == role, User.is_active == True)
                .order_by(User.full_name)
            ).all()
    return []


# --- END NEW: Request System Helper Function ---

class CreateTalentClubProposalForm(FlaskForm):
    """Form for submitting a proposal to create a new Talent Club instance."""

    name = StringField("Club Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField(
        "Description", validators=[DataRequired(), Length(min=10, max=500)]
    )
    social_category_id = SelectField(
        "Category", coerce=int, validators=[DataRequired()]
    )
    proposal_file = FileField(
        "Proposal Document (Optional)",
        validators=[
            Optional(),
            FileAllowed(["pdf", "doc", "docx", "txt", "odt"], "Documents only!"),
        ],
    )

    # --- THIS IS THE FIX ---
    # We add a HiddenField to the form. This makes `form.mentioned_member_ids` a valid
    # attribute that the template and route can access. The DataRequired validator
    # will ensure that the JavaScript successfully populates this field before submission.
    mentioned_member_ids = HiddenField(
        "Mentioned Members",
        validators=[DataRequired(message="You must select at least one initial member.")]
    )
    # --- END OF FIX ---

    submit = SubmitField("Submit Proposal")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.social_category_id.choices = [
            (c.id, c.name) for c in get_social_categories()
        ]
        if not self.social_category_id.choices:
            self.social_category_id.choices = [("", "No categories available")]


class EditTalentClubProfileForm(FlaskForm):
    """Form for editing an existing Talent Club instance profile."""

    name = StringField("Club Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField(
        "Profile Photo (Optional)",
        validators=[
            Optional(),
            FileAllowed(["jpg", "png", "jpeg", "gif", "webp"], "Images only!"),
        ],
    )  # Reuse photo helper logic
    social_category_id = SelectField(
        "Category", coerce=int, validators=[DataRequired()]
    )

    # Options from TalentClubFeed linked settings (will be edited via the linked channel's settings if implemented)
    # For simplicity, we won't include linked channel settings here unless explicitly needed.
    # allow_comments = BooleanField("Allow Comments on Posts") # These fields belong on the linked Channel/Feed

    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.social_category_id.choices = [
            (c.id, c.name) for c in get_social_categories()
        ]
        if not self.social_category_id.choices:
            self.social_category_id.choices = [("", "No categories available")]

    # Add custom validation for name uniqueness if needed (excluding self)


class TalentClubLeaderVoteForm(FlaskForm):
    """Form for TC Members to vote for the System-wide TC Leader."""

    candidate_id = SelectField(
        "Select Your Candidate", coerce=int, validators=[DataRequired()]
    )
    submit = SubmitField("Cast Vote")

    def __init__(self, *args, candidates=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate candidate choices with eligible users (is_tc_member=True)
        if candidates is not None:
            self.candidate_id.choices = [
                (u.id, f"{u.full_name} ({u.username})") for u in candidates
            ]
        else:
            self.candidate_id.choices = [(0, "No candidates available")]


class TalentClubWarningForm(FlaskForm):
    """Form for the TC Leader to issue a warning to a Talent Club."""

    reason = TextAreaField(
        "Reason for Warning", validators=[DataRequired(), Length(min=10, max=500)]
    )
    submit = SubmitField("Issue Warning")


class TalentClubLevelForm(FlaskForm):
    """Form for the TC Leader to change a Talent Club's level."""

    # Levels could be integer input or select from predefined levels
    level = IntegerField(
        "New Level", validators=[DataRequired(), NumberRange(min=1)]
    )  # Assuming minimum level 1
    # Alternatively, if levels are tiered strings:
    # level = SelectField("New Level", choices=[('Level 1', 'Level 1'), ('Level 2', 'Level 2'), ...], validators=[DataRequired()])
    submit = SubmitField("Set Level")


# Optional forms for Ban/Penalty (basic versions)
class TalentClubBanMuteForm(FlaskForm):
    """Form for the TC Leader to ban or mute a TC Member."""

    ban_type = SelectField(
        "Action Type",
        choices=[("ban", "Ban (Remove from TC)"), ("mute", "Mute (Restrict Posting)")],
        validators=[DataRequired()],
    )
    reason = TextAreaField(
        "Reason", validators=[DataRequired(), Length(min=10, max=500)]
    )
    duration_days = IntegerField(
        "Duration (days, leave empty for permanent)",
        validators=[Optional(), NumberRange(min=1)],
    )
    submit = SubmitField("Apply Action")


# Placeholder for a Penalty form if different from Ban/Mute
# class TalentClubPenaltyForm(FlaskForm):
#      pass

# --- Authentication Forms ---


class PreForm(FlaskForm):
    """Form for initial registration code verification."""

    code = StringField("Registration Code", validators=[DataRequired()])
    submit = SubmitField("Verify Code")


class CompleteRegistrationForm(FlaskForm):
    """Form for completing user registration after code verification."""

    # Use the full_name field added to the User model in Part 2
    full_name = StringField("Full Name", validators=[DataRequired(), Length(max=120)])
    username = StringField(
        "Username",
        validators=[
            DataRequired(),
            Length(min=4, max=80),
            Regexp(
                "^[A-Za-z0-9_]+$",
                message="Username can only contain letters, numbers, and underscores.",
            ),
        ],
    )
    # Email is now nullable on User model, but required by this form
    email = StringField("Email", validators=[DataRequired(), Email(), Length(max=120)])

    password = PasswordField(
        "Password",
        validators=[
            DataRequired(),
            Length(min=8, message="Password must be at least 8 characters long."),
            # Optional: Add complexity validators here
            # Example: Regexp('^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\W_]).+$', message="Password must include uppercase, lowercase, number, and special character.")
        ],
    )
    password2 = PasswordField(
        "Confirm Password",
        validators=[
            DataRequired(),
            EqualTo("password", message="Passwords must match."),
        ],
    )

    # --- Fields Corresponding to User Model Additions ---
    # These match nullable columns added to User in Part 2
    age = IntegerField(
        "Age",
        validators=[
            Optional(),
            NumberRange(min=5, max=100, message="Please enter a valid age."),
        ],
    )
    sex = SelectField(
        "Sex",
        choices=[
            ("", "Select..."),
            ("Male", "Male"),
            ("Female", "Female"),
            ("Other", "Other"),
            ("Prefer Not to Say", "Prefer Not to Say"),
        ],
        validators=[Optional()],
    )
    profile_photo_url = StringField(
        "Profile Photo URL (Optional)", validators=[Optional(), Length(max=255)]
    )
    # If you added grade/section to User model for students in Part 2, add fields here if needed
    # grade = StringField("Grade", validators=[Optional(), Length(max=10)])
    # section = StringField("Section", validators=[Optional(), Length(max=10)])

    submit = SubmitField("Complete Registration")

    # Custom validation for username and email uniqueness
    def validate_username(self, username_field):
        # Check if the chosen username already exists in the database (case-insensitive)
        user = db.session.scalar(
            select(User).filter(
                func.lower(User.username) == func.lower(username_field.data.strip())
            )
        )
        if user:
            raise ValidationError(
                "This username is already taken. Please choose a different one."
            )

    def validate_email(self, email_field):
        # Check if email exists (case-insensitive), assuming email is required by this form
        if email_field.data:  # Only validate if email is provided
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.email) == func.lower(email_field.data.strip())
                )
            )
            if user:
                raise ValidationError(
                    "This email address is already used. Please use a different one."
                )


class LoginForm(FlaskForm):
    """Form for user login."""

    username = StringField(
        "Username", validators=[DataRequired(), Length(min=3, max=80)]
    )
    password = PasswordField("Password", validators=[DataRequired()])
    submit = SubmitField("Login")


class ChangePasswordForm(FlaskForm):
    """Form for a logged-in user to change their password (requires current password)."""

    current_password = PasswordField("Current Password", validators=[DataRequired()])
    new_password = PasswordField(
        "New Password",
        validators=[
            DataRequired(),
            Length(min=8, message="New password must be at least 8 characters long."),
            # Optional: Add custom complexity validators here
        ],
    )
    confirm_new_password = PasswordField(
        "Confirm New Password",
        validators=[
            DataRequired(),
            EqualTo("new_password", message="Passwords must match."),
        ],
    )
    submit = SubmitField("Change Password")


class ForcedChangePasswordForm(FlaskForm):
    """Form for a user forced to change their password (does not require current password)."""

    new_password = PasswordField(
        "New Password",
        validators=[
            DataRequired(),
            Length(min=8, message="New password must be at least 8 characters long."),
            # Optional: Add complexity validators here
        ],
    )
    confirm_new_password = PasswordField(
        "Confirm New Password",
        validators=[
            DataRequired(),
            EqualTo("new_password", message="Passwords must match."),
        ],
    )
    submit = SubmitField("Set New Password")


# --- Settings Form ---
class UniversalSettingsForm(FlaskForm):
    """Form for editing universal user profile and settings."""

    # Profile Fields (from User model)
    full_name = StringField("Full Name", validators=[DataRequired(), Length(max=120)])
    username = StringField(
        "Username",
        validators=[
            DataRequired(),
            Length(min=4, max=80),
            Regexp(
                "^[A-Za-z0-9_]+$",
                message="Username can only contain letters, numbers, and underscores.",
            ),
        ],
    )
    email = StringField("Email", validators=[Optional(), Email(), Length(max=120)])

    # Additional Profile Fields (from User model - matching nullable columns)
    age = IntegerField(
        "Age",
        validators=[
            Optional(),
            NumberRange(min=5, max=100, message="Please enter a valid age."),
        ],
    )
    sex = SelectField(
        "Sex",
        choices=[("", "Select..."), ("Male", "Male"), ("Female", "Female")],
        validators=[Optional()],
    )

    # Talent Club Status (Display only - handled by join/leave button elsewhere)
    is_tc_member_display = BooleanField(
        "Talent Club Member", render_kw={"disabled": "disabled"}
    )  # Display status, not editable here

    profile_visibility = SelectField(
        "Profile Visibility",
        choices=[
            ("everyone", "Everyone"),
            ("teachers", "Teachers Only"),
            ("students", "Students Only"),
            ("private", "Only Me"),
        ],
        validators=[Optional()],  # If profile_visibility is nullable
    )
    data_analytics = BooleanField("Allow anonymous usage data collection")
    data_research = BooleanField("Allow academic research participation")
    profile_photo = FileField(
        "Update Profile Photo",
        validators=[
            Optional(),
            FileAllowed(["jpg", "png", "jpeg", "gif", "webp"], "Images only!"),
        ],
    )

    submit = SubmitField("Save Changes")

    def __init__(self, original_username=None, original_email=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.original_username = original_username
        self.original_email = original_email

    def validate_username(self, username_field):
        if (
            username_field.data.lower() != (self.original_username or "").lower()
        ):  # Handle case where original_username is None
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.username)
                    == func.lower(username_field.data.strip()),
                    User.id != current_user.id,
                )
            )
            if user:
                raise ValidationError("This username is already taken.")

    def validate_email(self, email_field):
        original_email_lower = (self.original_email or "").lower()
        submitted_email_lower = (email_field.data or "").lower()

        if (
            submitted_email_lower and submitted_email_lower != original_email_lower
        ):  # Check for change and not empty
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.email) == submitted_email_lower,
                    User.id != current_user.id,
                )
            )
            if user:
                raise ValidationError(
                    "This email address is already used by another account."
                )


# --- NEW FORMS: Request System ---


class CreateRequestForm(FlaskForm):
    """Form for submitting a new request."""

    title = StringField("Request Title", validators=[DataRequired(), Length(max=255)])
    description = TextAreaField(
        "Detailed Description", validators=[DataRequired(), Length(min=10, max=2000)]
    )
    request_type = SelectField(
        "Request Type",
        choices=[
            ("Deficiency", "Deficiency"),
            ("Purchase", "Purchase"),
            ("General", "General"),
            # Add more types if needed, e.g., 'Maintenance', 'Staffing', 'Curriculum'
        ],
        validators=[DataRequired()],
    )
    urgency = SelectField(
        "Urgency",
        choices=[
            ("Low", "Low"),
            ("Medium", "Medium"),
            ("High", "High"),
            ("Critical", "Critical"),
        ],
        default="Medium",
        validators=[DataRequired()],
    )
    submit = SubmitField("Submit Request")


class ReviewRequestForm(FlaskForm):
    """Form for handlers to review and process requests."""

    status = SelectField(
        "Status", validators=[DataRequired()]
    )  # Choices populated dynamically in route
    resolution_notes = TextAreaField(
        "Resolution Notes (Optional)", validators=[Optional(), Length(max=1000)]
    )
    denial_reason = TextAreaField(
        "Reason for Denial (Required if 'Denied')",
        validators=[Optional(), Length(max=500)],
    )
    forward_to_user_id = SelectField(
        "Forward To (Optional)", coerce=int, validators=[Optional()]
    )  # Choices populated dynamically

    submit = SubmitField("Update Request")

    def __init__(
        self, *args, current_user_role_name, request_tier, request_status, **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.current_user_role_name = current_user_role_name  # Store for validation
        self.request_tier = request_tier
        self.request_status = request_status  # Store for validation

        # Dynamically populate status choices based on current handler's role and request tier
        # These reflect the allowed transitions for each tier.
        if request_tier == 1 and current_user_role_name == "hr_ceo":
            self.status.choices = [
                ("Approved", "Approve"),
                ("On Progress", "Mark On Progress"),
                ("Denied", "Deny"),
                ("Resolved", "Resolve (Final for HR/CEO)"),
                (
                    "Forward",
                    "Forward to School Executive",
                ),  # This is an action, not a status in DB, handled as transition
            ]
        elif request_tier == 2 and current_user_role_name == "school_executive":
            self.status.choices = [
                ("Approved", "Approve"),
                ("On Progress", "Mark On Progress"),
                ("Denied", "Deny"),
                ("Resolved", "Resolve (Final for School Executive)"),
                ("Forward", "Forward to Government"),
            ]
        elif request_tier == 3 and current_user_role_name == "government":
            self.status.choices = [
                ("Approved", "Accept (Final for Government)"),  # Equivalent to resolved
                ("Denied", "Deny (Final for Government)"),
            ]
        else:  # Fallback or for s seeing the form
            self.status.choices = [
                ("Pending", "Pending"),
                ("Approved", "Approved"),
                ("On Progress", "On Progress"),
                ("Denied", "Denied"),
                ("Resolved", "Resolved"),
            ]

        # Conditionally make denial_reason required
        # This will be validated on form.validate_on_submit()
        if self.status.data == "Denied":
            self.denial_reason.validators = [
                DataRequired(
                    message="Denial reason is required if status is 'Denied'."
                ),
                Length(max=500),
            ]
        else:
            self.denial_reason.validators = [Optional(), Length(max=500)]

    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        # Custom validation for forwarding and denying
        if self.status.data == "Forward":
            # Check if there are choices for forward_to_user_id (meaning populate was called)
            if not self.forward_to_user_id.choices or self.forward_to_user_id.data == 0:
                self.forward_to_user_id.errors.append(
                    "Please select a user to forward the request to."
                )
                return False

        if self.status.data == "Denied" and not self.denial_reason.data:
            self.denial_reason.errors.append(
                "Denial reason is required if status is 'Denied'."
            )
            return False

        return True


# --- END NEW FORMS ---


# --- Behavior Record Form ---
class BehaviorRecordForm(FlaskForm):
    """Form for adding/editing a student behavior record."""

    behavior_type = SelectField(
        "Behavior Type",
        choices=[
            ("Positive", "Positive Behavior"),
            ("Needs Improvement", "Needs Improvement"),
            ("Concern", "Behavior Concern"),
        ],
        validators=[DataRequired()],
    )
    description = TextAreaField(
        "Description", validators=[DataRequired(), Length(max=1000)]
    )
    severity = SelectField(
        "Severity",
        choices=[("Low", "Low"), ("Medium", "Medium"), ("High", "High")],
        default="Medium",
        validators=[DataRequired()],  # Added DataRequired
    )
    resolution = TextAreaField(
        "Resolution (if applicable)", validators=[Optional(), Length(max=1000)]
    )
    is_resolved = BooleanField("Mark as resolved")  # Checkbox
    submit = SubmitField("Save Record")


# --- Attendance Form (for Teachers/Librarians marking student attendance) ---
# Helper form for FieldList in AttendanceForm - only used to structure the FieldList
class StudentAttendanceSubForm(FlaskForm):
    # No fields here. The actual status/notes fields are generated dynamically in the template
    # with names like status_{{ student.id }} and notes_{{ student.id }}
    pass


class AttendanceForm(FlaskForm):
    """Form structure for marking attendance for multiple students."""

    # FieldList to indicate that multiple student entries are expected.
    # The data for these entries is *not* automatically populated or validated by WTForms
    # in the typical way; it is read directly from request.form in the route.
    students = FieldList(FormField(StudentAttendanceSubForm), min_entries=0)

    # The date is typically passed via URL args or a hidden field, not a validated form field here
    # date = DateField("Date", format="%Y-%m-%d") # Not used with current route logic

    submit = SubmitField("Save Attendance")

    # __init__ is needed to dynamically add entries to the FieldList for rendering the template correctly
    def __init__(self, *args, students=None, **kwargs):
        super().__init__(*args, **kwargs)
        if students is not None:
            # Clear any existing entries added by default or previous processing
            while len(self.students.entries) > 0:
                self.students.pop_entry()

            # Append a new entry (a subform) for each student object passed in
            for student in students:
                # The 'data' dictionary here is just to conceptually link the subform
                # entry to the student ID for rendering purposes, not for WTForms data processing.
                self.students.append_entry(data={"student_id": student.id})


# --- Asset Management Forms ---


# Helper to get Labs for SelectFields
def get_labs():
    """Helper to query and format labs for select fields."""
    try:
        with app.app_context():
            return db.session.scalars(select(Lab).order_by(Lab.name)).all()
    except Exception as e:
        app.logger.error(f"Error fetching labs: {e}")
        return []


# app.py

# ... (near other helper functions like get_social_categories, get_labs) ...


# BEGIN IMPLEMENTATION - Task D1 (Helper for AddAssetForm)
def get_asset_categories():  # New Helper
    """Helper to query and format asset categories for select fields."""
    try:
        with app.app_context():
            return db.session.scalars(
                select(AssetCategory).order_by(AssetCategory.name)
            ).all()
    except Exception as e:
        app.logger.error(f"Error fetching asset categories: {e}")
        return []


# END IMPLEMENTATION - Task D1 (Helper for AddAssetForm)


# ... (existing AddAssetForm) ...
class AddAssetForm(FlaskForm):
    """Form for adding a new asset."""

    name = StringField("Asset Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    quantity = IntegerField(
        "Quantity", default=1, validators=[DataRequired(), NumberRange(min=1)]
    )
    purchase_cost = FloatField(
        "Purchase Cost (Optional)", validators=[Optional(), NumberRange(min=0)]
    )
    condition = SelectField(
        "Condition",
        choices=[
            ("New", "New"),
            ("Good", "Good"),
            ("Fair", "Fair"),
            ("Poor", "Poor"),
            ("Needs Repair", "Needs Repair"),
            ("Broken", "Broken"),
        ],
        default="New",
        validators=[DataRequired()],
    )
    is_consumable = BooleanField("Is Consumable?")
    expiry_date = DateField(
        "Expiry Date (YYYY-MM-DD) (if consumable)",
        format="%Y-%m-%d",
        validators=[Optional()],
    )
    last_maintenance_date = DateField(
        "Last Maintenance Date (YYYY-MM-DD) (if applicable)",
        format="%Y-%m-%d",
        validators=[Optional()],
    )

    # BEGIN IMPLEMENTATION - Task D1 (Modify AddAssetForm)
    suggested_category_id = SelectField(
        "Suggested Category (Optional)", coerce=int, validators=[Optional()]
    )
    # END IMPLEMENTATION - Task D1 (Modify AddAssetForm)

    suggested_lab_id = SelectField(
        "Suggested Lab/Location (Optional)", coerce=int, validators=[Optional()]
    )
    location_description = StringField(
        "Specific Location Details (Optional)", validators=[Optional(), Length(max=255)]
    )

    submit = SubmitField("Add Asset")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # BEGIN IMPLEMENTATION - Task D1 (Modify AddAssetForm __init__)
        # Populate category choices dynamically using the new helper
        self.suggested_category_id.choices = [
            (0, "--- Select Category (Optional) ---")
        ] + [
            (c.id, c.name) for c in get_asset_categories()
        ]  # Use new helper
        if (
            not self.suggested_category_id.choices
            or len(self.suggested_category_id.choices) == 1
        ):
            self.suggested_category_id.choices = [(0, "No asset categories available")]
        # END IMPLEMENTATION - Task D1 (Modify AddAssetForm __init__)

        # Populate lab choices dynamically
        self.suggested_lab_id.choices = [(0, "--- Select Location (Optional) ---")] + [
            (l.id, l.name) for l in get_labs()
        ]
        if not self.suggested_lab_id.choices or len(self.suggested_lab_id.choices) == 1:
            self.suggested_lab_id.choices = [(0, "No labs available")]

    # BEGIN IMPLEMENTATION - Task D1 (Add validator for expiry_date)
    def validate_expiry_date(self, field):
        if (
            self.is_consumable.data
            and field.data
            and field.data < datetime.now(timezone.utc).date()
        ):
            raise ValidationError("Expiry date for consumables cannot be in the past.")

    # END IMPLEMENTATION - Task D1 (Add validator for expiry_date)


# ... (route add_asset) ...
# Ensure the add_asset route in app.py correctly instantiates and uses AddAssetForm.
# The route logic to determine final_category_id and final_lab_id based on user role
# and form.suggested_category_id.data / form.suggested_lab_id.data is complex and already
# outlined in the provided app.py. This part just ensures the form fields are correct.
# In app.py


class ReportAssetForm(FlaskForm):
    """Form for reporting an issue with an asset (specific or general)."""

    damage_description = TextAreaField(
        "Description of Damage/Issue", validators=[DataRequired(), Length(max=1000)]
    )
    date_of_damage = DateField(
        "Approximate Date of Damage/Issue (YYYY-MM-DD)",
        format="%Y-%m-%d",
        validators=[Optional()],
    )
    quantity_damaged = IntegerField(
        "Quantity Damaged/Affected",
        default=1,
        validators=[DataRequired(), NumberRange(min=1)],
    )
    submit = SubmitField("Submit Report")

    def validate_date_of_damage(self, field):
        """Ensure date of damage is not in the future."""
        if field.data and field.data > datetime.now(timezone.utc).date():
            raise ValidationError("Date of damage cannot be in the future.")


class EditAssetForm(FlaskForm):
    """Form for HR/CEO/Admin to edit and review an asset."""

    # Name should probably be editable by admin
    name = StringField("Asset Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    quantity = IntegerField(
        "Quantity", validators=[DataRequired(), NumberRange(min=0)]
    )  # Quantity can be 0
    purchase_cost = FloatField(
        "Purchase Cost (Optional)", validators=[Optional(), NumberRange(min=0)]
    )
    # Category and Status are key fields for HR/Admin to manage
    category_id = SelectField(
        "Category", coerce=int, validators=[DataRequired()]
    )  # Now required
    status = SelectField(
        "Status",
        choices=[
            ("Pending Review", "Pending Review"),
            ("Available", "Available"),  # Added Available
            ("CheckedOut", "CheckedOut"),
            ("Under Maintenance", "Under Maintenance"),
            ("Retired", "Retired"),
            ("Lost", "Lost"),
        ],
        validators=[DataRequired()],
    )
    condition = SelectField(
        "Condition",
        choices=[
            ("New", "New"),
            ("Good", "Good"),
            ("Fair", "Fair"),
            ("Poor", "Poor"),
            ("Needs Repair", "Needs Repair"),
            ("Broken", "Broken"),
        ],
        validators=[DataRequired()],
    )
    is_consumable = BooleanField("Is Consumable?")
    expiry_date = DateField(
        "Expiry Date (YYYY-MM-DD) (if consumable)",
        format="%Y-%m-%d",
        validators=[Optional()],
    )
    last_maintenance_date = DateField(
        "Last Maintenance Date (YYYY-MM-DD) (if applicable)",
        format="%Y-%m-%d",
        validators=[Optional()],
    )
    # Lab assignment is managed by HR/Admin here
    lab_id = SelectField(
        "Assigned Lab/Location (Optional)", coerce=int, validators=[Optional()]
    )
    location_description = StringField(
        "Specific Location Details (Optional)", validators=[Optional(), Length(max=255)]
    )

    # added_by_user_id is informational, not editable here

    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices (required for HR/Admin)
        self.category_id.choices = [
            (c.id, c.name) for c in get_social_categories()
        ]  # Re-using helper
        # Populate lab choices (optional for HR/Admin)
        self.lab_id.choices = [(0, "--- Select Location (Optional) ---")] + [
            (l.id, l.name) for l in get_labs()
        ]

    def validate_expiry_date(self, field):
        # If the asset is consumable, the expiry date might be required or validated further
        # Basic validation: Ensure expiry date is in the future if set for a new/active consumable asset
        # This form can edit, so maybe only validate if setting a *future* date is required.
        pass  # Add specific logic if needed


class ResolveReportForm(FlaskForm):
    """Form for HR/CEO/Admin to update the status and notes of an asset report."""

    status = SelectField(
        "Report Status",
        choices=[
            ("Pending", "Pending"),
            ("In Progress", "In Progress"),
            ("Resolved", "Resolved"),
            ("Rejected", "Rejected"),
        ],
        validators=[DataRequired()],
    )
    resolution_notes = TextAreaField(
        "Resolution Notes", validators=[Optional(), Length(max=1000)]
    )  # Increased length
    # Option to link report to an asset if it was a general report (requires search/select field)
    # For V1, skip complex linking via this form. Linking happens when resolving.
    # link_to_asset_id = SelectField("Link to Asset (Optional)", coerce=int, validators=[Optional()]) # Example if implementing linking here
    submit = SubmitField("Update Report Status")

    # If linking is implemented, need __init__ to populate link_to_asset_id choices
    # def __init__(self, *args, **kwargs):
    #      super().__init__(*args, **kwargs)
    #      self.link_to_asset_id.choices = [(0, '--- Select Asset (Search not implemented) ---')] + [
    #          (a.id, f"{a.name} ({a.id})") for a in db.session.scalars(select(Asset)).limit(100).all() # Limit for large databases
    #      ]


class CSRFProtectForm(FlaskForm):
    """A minimal form used only for CSRF protection on pages with dynamic fields."""
    pass

# --- Asset Category Management Forms ---
class AddCategoryForm(FlaskForm):
    """Form for adding a new asset category."""

    name = StringField("Category Name", validators=[DataRequired(), Length(max=50)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=200)])
    submit = SubmitField("Add Category")


class EditCategoryForm(FlaskForm):
    """Form for editing an existing asset category."""

    name = StringField("Category Name", validators=[DataRequired(), Length(max=50)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=200)])
    submit = SubmitField("Save Changes")


# Around line 2387 in your app.py
class BookCheckoutForm(FlaskForm):
    """Form for checking out a book asset with proper empty state handling."""

    asset_id = SelectField(
        "Select Book",
        coerce=int,
        validators=[Optional()],  # Remains Optional
        choices=[],  # Initialize empty, populated by __init__
        description="Available books will appear here",
    )

    user_id = SelectField(
        "Select User (for Librarians)",
        coerce=int,
        validators=[Optional()],
        choices=[],  # Initialize empty, populated by __init__
    )

    due_date = DateField(
        "Due Date",
        format="%Y-%m-%d",
        validators=[DataRequired()],
        render_kw={
            "min": lambda: datetime.now(timezone.utc).date().isoformat()
        },  # Use lambda for dynamic min date
    )

    submit = SubmitField("Checkout Book")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # It's good practice to call these population methods after super().__init__
        self._populate_asset_choices()
        self._populate_user_choices()

    def _populate_asset_choices(self):
        """Populate book choices with proper empty state handling"""
        # Using app.app_context() is good if this form might be instantiated outside a request context,
        # but within a request context (like in a Flask route), it's usually not strictly necessary
        # as the context is already active. However, it doesn't harm.
        with app.app_context():
            book_category = db.session.scalar(
                select(AssetCategory).filter_by(name="Books")
            )

            available_books = []
            if book_category:
                available_books = db.session.scalars(
                    select(Asset)
                    .where(
                        Asset.category_id == book_category.id,
                        Asset.status == "Available",
                        Asset.quantity > 0,
                    )
                    .order_by(Asset.name)
                ).all()

            if not available_books:
                self.asset_id.choices = []  # IMPORTANT: Set to empty list
                self.asset_id.render_kw = {
                    "disabled": True,
                    "class": "form-select",  # Base class, template handles tom-select & is-invalid
                    # The placeholder will be handled by the template or TomSelect default.
                    # If you want to override it when no books:
                    # "placeholder": "No books available for checkout"
                }
                # Optionally add a form-level error if no books is a "validation" issue for the form's purpose
                # self.asset_id.errors.append("No books are currently available for checkout.")
            else:
                self.asset_id.choices = [
                    (a.id, f"{a.name} (Available: {a.quantity})")
                    for a in available_books
                ]
                self.asset_id.render_kw = {
                    "class": "form-select"  # Base class
                    # Placeholder from template: "Search and select a book..."
                }

    def _populate_user_choices(self):
        """Populate user choices for librarians"""
        # Default to hidden, and enable for librarians
        self.user_id.render_kw = {"class": "form-select d-none"}  # Start hidden
        self.user_id.choices = []  # Default to empty

        if current_user.is_authenticated and hasattr(current_user, "role"):
            if current_user.role.name.lower() == "librarian":
                with app.app_context():
                    users = db.session.scalars(
                        select(User)
                        .join(Role)
                        .where(
                            Role.name.in_(
                                ["student", "teacher"]
                            ),  # Users who can check out books
                            User.is_active == True,
                        )
                        .order_by(User.full_name)
                    ).all()

                if not users:
                    # self.user_id.choices remains []
                    self.user_id.render_kw.update(
                        {  # Update existing render_kw
                            "disabled": True,
                            # "placeholder": "No users available for selection" # If you want to override template/TomSelect
                        }
                    )
                else:
                    self.user_id.choices = [
                        (u.id, f"{u.full_name} ({u.username})") for u in users
                    ]
                    # "placeholder": "--- Select User ---" # If you want to override template/TomSelect

                # Make visible for librarian
                current_classes = self.user_id.render_kw.get("class", "")
                self.user_id.render_kw["class"] = current_classes.replace(
                    "d-none", ""
                ).strip()

    def validate_due_date(self, field):
        """Ensure due date is not in the past."""
        if field.data and field.data < datetime.now(timezone.utc).date():
            raise ValidationError("Due date cannot be in the past.")

    # Added custom validation for asset_id if it's not Optional anymore for submission
    # (though the original had Optional(), so this might not be needed if that stays)
    def validate_asset_id(self, field):
        # If the field is not Optional and no books were available (choices is empty),
        # it would fail DataRequired. If it's Optional, this validation is not strictly needed
        # unless you want a specific message when it's disabled due to no books.
        if (
            not self.asset_id.choices and not self.asset_id.validators[0].optional
        ):  # Check if not optional
            raise ValidationError("No books available to select.")


# --- Student Leader Assignment Form ---
class AssignLeaderForm(FlaskForm):
    """Form for assigning students to a student leader."""

    # SelectField for choosing a student leader from the list of existing leaders
    leader = SelectField("Select Leader", coerce=int, validators=[DataRequired()])
    # Students to assign are selected via checkboxes in the template, not defined as form fields here.
    submit = SubmitField("Assign Students")

    def __init__(self, *args, current_leaders=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate the leader dropdown with current student leaders
        # current_leaders should be a list of User objects who are leaders
        if current_leaders is not None:  # Check if list was provided
            self.leader.choices = [
                (
                    l.id,
                    f"{l.full_name} (Grade {l.grade or 'N/A'}, Section {l.section or 'N/A'})",
                )
                for l in current_leaders
            ]
        else:
            # If no leaders are passed (e.g., empty DB), provide a default empty choice
            self.leader.choices = [
                (0, "--- No Leaders Found ---")
            ]  # Use 0 as a placeholder value

# In your forms.py or routes.py
from flask_wtf import FlaskForm
from wtforms import SubmitField

# This form is intentionally simple. Its main job is to provide CSRF protection.
class MarksEntryForm(FlaskForm):
    # You can add a submit field here, but it's not strictly necessary
    # as the button is hardcoded in the template. Having it can be good practice.
    submit = SubmitField('Save All Marks')
# In app.py

from wtforms.validators import Optional, URL, Length, DataRequired

# ... other imports


class NotificationForm(FlaskForm):
    """Form for composing and sending a notification message."""

    content = TextAreaField(
        "Message Content", validators=[DataRequired(), Length(min=1, max=1000)]
    )
    # FIX: This field is now implemented with a URL validator.
    link_url = StringField(
        "Link URL (Optional)",
        validators=[
            Optional(),
            URL(message="Please enter a valid URL."),
            Length(max=255),
        ],
    )
    submit = SubmitField("Send Notification")


# --- Social Media Forms --- (Copied from previous parts for completeness here)
# START MODIFICATION (CreateChannelForm)
class CreateChannelForm(FlaskForm):
    name = StringField("Channel Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField(
        "Profile Photo (Optional)",
        validators=[
            Optional(),
            FileAllowed(["jpg", "png", "jpeg", "gif"], "Images only!"),
        ],
    )
    channel_type = SelectField(
        "Channel Type",
        choices=[("public", "Public"), ("private", "Private")],
        validators=[DataRequired()],
    )
    social_category_id = SelectField(
        "Category", coerce=int, validators=[DataRequired()]
    )  # MODIFIED: Field name changed to social_category_id and is required
    allow_comments = BooleanField("Allow Comments on Posts", default=True)
    allow_reactions = BooleanField("Allow Reactions on Posts", default=True)
    submit = SubmitField("Create Channel")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # MODIFIED: Removed optional '--- Select Category ---' as it's now required. Access social_category_id.
        self.social_category_id.choices = [
            (c.id, c.name) for c in get_social_categories()
        ]
        # If no categories exist, add a dummy entry to prevent errors, but form will still be invalid due to DataRequired
        if not self.social_category_id.choices:
            self.social_category_id.choices = [("", "No categories available")]


# END MODIFICATION (CreateChannelForm)
# START MODIFICATION (EditChannelForm)
class EditChannelForm(FlaskForm):
    name = StringField("Channel Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField(
        "Profile Photo (Optional)",
        validators=[
            Optional(),
            FileAllowed(["jpg", "png", "jpeg", "gif"], "Images only!"),
        ],
    )
    social_category_id = SelectField(
        "Category", coerce=int, validators=[DataRequired()]
    )  # MODIFIED: Field name changed to social_category_id and is required
    allow_comments = BooleanField("Allow Comments on Posts")
    allow_reactions = BooleanField("Allow Reactions on Posts")
    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # MODIFIED: Removed optional '--- Select Category ---' as it's now required. Access social_category_id.
        self.social_category_id.choices = [
            (c.id, c.name) for c in get_social_categories()
        ]
        if not self.social_category_id.choices:
            self.social_category_id.choices = [("", "No categories available")]


# END MODIFICATION (EditChannelForm)
class CreateGroupForm(FlaskForm):
    name = StringField("Group Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField(
        "Profile Photo (Optional)",
        validators=[
            Optional(),
            FileAllowed(["jpg", "png", "jpeg", "gif"], "Images only!"),
        ],
    )
    submit = SubmitField("Create Group")


# In app.py, replace the existing EditGroupForm with this complete version.


class EditGroupForm(FlaskForm):
    """
    Form for editing a social group's settings.
    Includes the 'is_active' field to allow for archiving/deactivating.
    """

    name = StringField("Group Name", validators=[DataRequired(), Length(max=100)])
    # The template uses 'description', so we ensure the form field matches.
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField(
        "Change Group Photo (Optional)",
        validators=[
            Optional(),
            FileAllowed(["jpg", "png", "jpeg", "gif", "webp"], "Images only!"),
        ],
    )
    # FIX: This field was missing, now it's implemented.
    is_active = BooleanField("Group is Active")
    submit = SubmitField("Save Group Changes")

    def __init__(self, original_group_name=None, *args, **kwargs):
        """
        Custom init to store the original name for validation.
        This prevents a "name already exists" error when saving without changing the name.
        """
        super().__init__(*args, **kwargs)
        self.original_group_name = original_group_name

    def validate_name(self, name_field):
        """
        Custom validator to ensure the new name doesn't conflict with another group's name.
        """
        new_name = name_field.data.strip()
        # Only check for uniqueness if the name has actually been changed.
        if new_name.lower() != (self.original_group_name or "").lower():
            existing_group = db.session.scalar(
                select(SocialGroup).where(
                    func.lower(SocialGroup.name) == new_name.lower()
                )
            )
            if existing_group:
                raise ValidationError(
                    "A group with this name already exists. Please choose another."
                )


class PostContentForm(FlaskForm):
    """Form for posting content (text and/or file) in channels/groups."""

    content = TextAreaField("Your message", validators=[Optional(), Length(max=2000)])
    attached_file = FileField("Attach File (Optional)")
    submit = SubmitField("Send")

    # Custom validation: Require EITHER content OR file
    def validate(self, extra_validators=None):
        # Run standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)

        # If standard validation fails, don't proceed with custom validation
        if not initial_validation:
            return False

        # Now, check our custom requirement: EITHER content OR attached_file
        # file.data will be a FileStorage object if a file was uploaded, otherwise None
        if not self.content.data and not self.attached_file.data:
            # Add an error message to a field, e.g., the content field
            # Using `self.content.errors` is standard practice
            self.content.errors.append("Message content or a file must be provided.")
            # Indicate that the form is now invalid due to custom validation
            return False

        # If standard validation passed AND at least one field has data, the form is valid
        return True


class CommentForm(FlaskForm):
    """Form for adding a comment to a post."""

    content = TextAreaField(
        "Your comment", validators=[DataRequired(), Length(max=500)]
    )
    submit = SubmitField("Comment")


# --- END PART 4 ---

# --- PART 5 START: Authentication Routes ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, SecretCode are defined.
# - Forms: PreForm, CompleteRegistrationForm, LoginForm, ChangePasswordForm, ForcedChangePasswordForm are defined.
# - Helpers: get_unread_message_count, get_unread_notifications_count are defined and potentially used in context processor.
# - role_required decorator is defined.
# - url_for is available.

# --- (After app = Flask(__name__) and before routes) ---

# Global Constants (if you want to access them in templates easily)
# TASK_CREATOR_ROLES was defined in your original app.py for backend logic.
# Making it available to templates if needed, e.g. to conditionally show a "Create Task" button.
TASK_CREATOR_ROLES = ["hr_ceo", "system_admin", "school_executive"]

# This part enables CSRF protection for your forms
csrf = CSRFProtect(app)  # Make sure this is initialized if not alread


@app.context_processor
def inject_global_vars():
    """Injects common variables into all Jinja2 templates."""
    unread_messages_count_val = 0
    unread_notifications_count_val = 0

    # Ensure current_user is available and authenticated before querying DB
    if hasattr(current_user, "is_authenticated") and current_user.is_authenticated:
        try:
            unread_messages_count_val = get_unread_message_count(current_user.id)
            unread_notifications_count_val = get_unread_notifications_count(
                current_user.id
            )

        except Exception as e:
            # Use app.logger if available and configured
            logger = getattr(current_app, "logger", None)
            if logger:
                logger.error(
                    f"Error fetching counts/permissions for user {current_user.id} in context processor: {e}"
                )
            else:  # Fallback print if logger not set up on current_app
                print(
                    f"ERROR in context_processor: Error fetching counts/permissions for user {current_user.id}: {e}"
                )

            unread_messages_count_val = "Err"
            unread_notifications_count_val = "Err"

    # Define the lambda function here for clarity and correct scope
    # Ensure 'csrf' is your CSRFProtect instance (e.g., from flask_wtf.csrf import CSRFProtect; csrf = CSRFProtect(app))
    # and wtf_generate_csrf is imported correctly.
    csrf_token_value_lambda = lambda: wtf_generate_csrf() if csrf else ""

    return {
        "now": datetime.now(timezone.utc),
        "current_year": datetime.now(timezone.utc).year,
        "unread_messages_count": unread_messages_count_val,
        "unread_notifications_count": unread_notifications_count_val,
        "TASK_CREATOR_ROLES": TASK_CREATOR_ROLES,  # Makes this list available in templates
        # This provides a function to get the CSRF token string
        "get_csrf_token_value": csrf_token_value_lambda,
    }


@app.template_filter("humanize_time_diff")
def humanize_time_diff_filter(dt, default="just now"):
    """
    Converts a datetime object or a parsable datetime string to a human-readable relative time.
    e.g., "5 minutes ago", "2 hours ago", "3 days ago".
    """
    if not dt:
        return default

    # If dt is already a datetime object, ensure it's offset-aware (UTC)
    if isinstance(dt, datetime):
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
    # If dt is a string, try to parse it
    elif isinstance(dt, str):
        try:
            # Attempt to parse ISO format, common from JS new Date().toISOString()
            dt_parsed = datetime.fromisoformat(dt.replace("Z", "+00:00"))
            dt = dt_parsed  # Use the parsed datetime object
        except ValueError:
            # Fallback for other potential string formats if necessary, or return default
            app.logger.warning(
                f"Could not parse datetime string for humanize_time_diff: {dt}"
            )
            return default  # Or format dt as string if parsing fails but it's a date
    else:  # Not a datetime object or string
        return default

    now = datetime.now(timezone.utc)
    try:
        diff = now - dt
        if diff.total_seconds() < 0:  # Datetime is in the future
            return f"in {humanize.naturaldelta(-diff)}"  # "in 5 minutes"
        if diff.total_seconds() < 60:  # Less than a minute
            return default  # "just now"
        return humanize.naturaltime(diff)
    except (TypeError, ValueError) as e:
        app.logger.error(f"Error humanizing time diff for {dt}: {e}")
        return default


@app.template_filter("nl2br")
def nl2br_filter(s):
    """Converts newlines in a string to HTML <br> tags."""
    if not s:
        return ""
    return Markup(str(s).replace("\n", "<br>\n"))


@app.route("/")
def home():
    if current_user.is_authenticated:
        # This correctly redirects to role_redirect which then sends them to their dashboard
        return redirect(url_for("role_redirect"))
    else:
        # Instantiate LoginForm to pass to the index.html template
        form = LoginForm()  # Make sure LoginForm is defined/imported in your app.py
        return render_template(
            "index.html",
            title="Welcome to Nexus - Kechene Debre Selam G.S.S.",
            form=form,
        )


@app.route("/pre_register", methods=["GET", "POST"])
def pre_register():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    form = PreForm()  # Make sure PreForm is defined/imported

    if form.validate_on_submit():
        code_input = form.code.data.strip()
        # Using joinedload(SecretCode.role) to eager load the role
        secret_code = db.session.scalar(
            select(SecretCode)
            .filter(
                func.lower(SecretCode.code) == func.lower(code_input),
                SecretCode.is_used == False,
            )
            .options(joinedload(SecretCode.role))
        )

        if secret_code:
            session["pre_reg_code_id"] = secret_code.id
            session["pre_reg_full_name"] = secret_code.full_name
            session["pre_reg_role_id"] = secret_code.role_id
            session["pre_reg_code_value"] = secret_code.code
            app.logger.info(
                f"Pre-registration code '{code_input[:2]}...{code_input[-2:]}' (ID: {secret_code.id}) found. Proceeding to confirmation."
            )
            return redirect(url_for("confirm_identity"))
        else:
            flash("Invalid or already used registration code.", "danger")
            app.logger.warning(
                f"Failed pre-registration attempt with code '{code_input[:2]}...{code_input[-2:]}'."
            )
            # No need to return render_template here again, the final one handles GET and failed POST

    # For GET request or if form validation failed on POST
    return render_template(
        "auth/pre_register.html", form=form, title="Pre-Register - Nexus"
    )


@app.route("/confirm-identity")
def confirm_identity():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    code_id = session.get("pre_reg_code_id")
    full_name = session.get("pre_reg_full_name")
    role_id = session.get("pre_reg_role_id")
    code_value = session.get("pre_reg_code_value")

    if not all([code_id, full_name, role_id, code_value]):  # Simplified check
        flash(
            "Pre-registration session expired or invalid. Please start over.", "danger"
        )
        # Clear potentially incomplete session data
        session.pop("pre_reg_code_id", None)
        session.pop("pre_reg_full_name", None)
        session.pop("pre_reg_role_id", None)
        session.pop("pre_reg_code_value", None)
        return redirect(url_for("pre_register"))

    secret_code = db.session.get(SecretCode, code_id)
    # Fetch the Role object to get its name
    role_obj = db.session.get(Role, role_id) if role_id else None

    if (
        not secret_code
        or secret_code.is_used
        or secret_code.full_name != full_name
        or secret_code.role_id != role_id
        or secret_code.code != code_value
        or not role_obj
    ):
        flash(
            "Pre-registration data mismatch, code used, or role invalid. Please start over.",
            "danger",
        )
        session.pop("pre_reg_code_id", None)
        session.pop("pre_reg_full_name", None)
        session.pop("pre_reg_role_id", None)
        session.pop("pre_reg_code_value", None)
        return redirect(url_for("pre_register"))

    # Prepare role name for display
    display_role_name = (
        role_obj.name.replace("_", " ").title() if role_obj else "Unknown Role"
    )

    return render_template(
        "auth/confirm_identity.html",
        full_name=full_name,
        role_name=display_role_name,  # Pass formatted role name
        title="Confirm Your Identity - Nexus",
    )


@app.route("/handle-confirmation", methods=["POST"])
def handle_confirmation():
    """Processes the user's confirmation choice."""
    # Retrieve data from session
    code_id = session.get("pre_reg_code_id")
    full_name = session.get("pre_reg_full_name")
    role_id = session.get("pre_reg_role_id")
    code_value = session.get("pre_reg_code_value")

    # Check if essential session data is present
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    if not code_id or not full_name or not role_id or not code_value:
        flash(
            "Pre-registration session expired or invalid. Please start over.", "danger"
        )
        return redirect(url_for("pre_register"))

    # Re-validate the code against the database just in case it was used between pages
    secret_code = db.session.get(SecretCode, code_id)
    if not secret_code or secret_code.is_used or secret_code.code != code_value:
        flash(
            "Pre-registration data mismatch or code used. Please start over.", "danger"
        )
        # Clear session data if code is invalid or used
        session.pop("pre_reg_code_id", None)
        session.pop("pre_reg_full_name", None)
        session.pop("pre_reg_role_id", None)
        session.pop("pre_reg_code_value", None)
        return redirect(url_for("pre_register"))

    # Process the confirmation response from the form
    if request.form.get("confirmation") == "yes":
        # User confirmed identity, proceed to complete registration
        # Session data is kept and will be validated again in complete_registration
        app.logger.info(
            f"Identity confirmed for code ID {code_id}. Redirecting to complete registration."
        )
        return redirect(url_for("complete_registration"))
    else:
        # User declined or submitted form incorrectly
        flash(
            "Identity confirmation declined. Please start over or contact school administration.",
            "info",
        )
        # Clear session data as registration flow is abandoned
        session.pop("pre_reg_code_id", None)
        session.pop("pre_reg_full_name", None)
        session.pop("pre_reg_role_id", None)
        session.pop("pre_reg_code_value", None)
        app.logger.warning(f"Identity confirmation declined for code ID {code_id}.")
        return redirect(url_for("home"))  # Redirect back to the home page

# In app.py, replace the entire complete_registration route

@app.route("/complete-registration", methods=["GET", "POST"])
def complete_registration():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    # --- Step 1: Validate the pre-registration session data ---
    code_value = session.get("pre_reg_code_value")
    if not code_value:
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        return redirect(url_for("pre_register"))

    # --- Step 2: Find the User linked to this secret code ---
    # Your import script has already created the User and linked them. We just need to find them.
    user_to_update = db.session.scalar(
        select(User).join(SecretCode).where(
            SecretCode.code == code_value,
            SecretCode.is_used == False # IMPORTANT: Ensure code hasn't been used yet
        )
    )

    if not user_to_update:
        flash("Secret code is invalid, already used, or not linked to a user. Please contact an administrator.", "danger")
        session.pop("pre_reg_code_value", None)
        return redirect(url_for("pre_register"))

    # --- Step 3: Handle the form ---
    form = CompleteRegistrationForm()

    if form.validate_on_submit():
        try:
            # --- THIS IS THE FIX ---
            # We are now UPDATING the user we found, NOT creating a new one.

            # Update fields from the form
            user_to_update.username = form.username.data.strip()
            user_to_update.email = form.email.data.strip()
            user_to_update.set_password(form.password.data)
            
            # Update optional fields
            user_to_update.age = form.age.data
            user_to_update.sex = form.sex.data if form.sex.data else None
            user_to_update.profile_photo_url = form.profile_photo_url.data.strip() if form.profile_photo_url.data else None
            
            # The user is now fully set up
            user_to_update.force_password_change = False # They have now set their password
            user_to_update.is_active = True

            # Mark the secret code as used
            secret_code = user_to_update.secret_code
            if secret_code:
                secret_code.is_used = True

            # Commit the UPDATES to the database
            db.session.commit()

            # --- Step 4: Clean up and redirect ---
            session.pop("pre_reg_code_value", None)

            flash("Registration complete! Please log in with your new username and password.", "success")
            app.logger.info(
                f"User '{user_to_update.username}' (ID: {user_to_update.id}) completed registration."
            )
            return redirect(url_for("login"))

        except IntegrityError:
            db.session.rollback()
            flash("Registration failed: That username or email is already in use. Please choose another.", "danger")
        
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error during complete registration for user ID {user_to_update.id}: {e}",
                exc_info=True,
            )
            flash("An unexpected error occurred during registration. Please try again.", "danger")

    # For GET request, pre-fill the form with existing data if available
    form.full_name.data = user_to_update.full_name
    form.email.data = user_to_update.email or ''

    return render_template(
        "auth/complete_registration.html",
        form=form,
        pre_reg_full_name=user_to_update.full_name,
        title="Complete Your Registration - Nexus",
    )
@app.route("/role-redirect")
@login_required
def role_redirect():
    """
    Redirects authenticated users to their primary role dashboard.
    Students (including TC members) will initially go to the student_dashboard.
    If a student is a TC member, they will also be processed for TC community group membership.
    Flexibility to access other dashboards (like Talent Club for eligible students)
    is handled by the frontend navigation.
    """

    ROLE_DASHBOARD_ENDPOINTS = {
        "student": "student_dashboard",  # ALL students go here first
        "teacher": "teacher_dashboard",
        "system_admin": "system_admin_dashboard",
        "hr_ceo": "hr_ceo_dashboard",
        "school_executive": "school_exec_dashboard",
        "government": "government_dashboard",
        "librarian": "librarian_dashboard",
        "talent_club": "talent_club_dashboard",  # For users whose ROLE is 'talent_club' (e.g., coordinators)
        "parent": "parent_dashboard",
    }

    user_role_name = current_user.role.name.lower() if current_user.role else None
    destination_endpoint = None

    # 1. Handle TC Community Group enrollment for students who are TC members
    # This happens regardless of their initial redirect destination if they are a student TC member.
    if user_role_name == "student" and current_user.is_tc_member:
        if not is_tc_community_member(current_user):  # is_tc_community_member helper
            add_to_tc_community_group(current_user)  # add_to_tc_community_group helper
            app.logger.info(
                f"Student TC Member {current_user.username} processed for TC Community Group membership."
            )

    # 2. Determine destination endpoint based on primary role
    if user_role_name:
        destination_endpoint = ROLE_DASHBOARD_ENDPOINTS.get(user_role_name)
        if destination_endpoint:
            app.logger.info(
                f"User {current_user.username} (Role: {user_role_name}, TC Member: {current_user.is_tc_member}) initial redirect to primary role dashboard: {destination_endpoint}."
            )
        else:
            app.logger.warning(
                f"No dashboard endpoint defined in ROLE_DASHBOARD_ENDPOINTS for role: {user_role_name}. Redirecting to fallback."
            )
            destination_endpoint = "fallback_dashboard"
    else:
        app.logger.warning(
            f"User {current_user.username} has no role assigned. Redirecting to fallback."
        )
        destination_endpoint = "fallback_dashboard"

    # 3. Perform the redirect
    try:
        return redirect(url_for(destination_endpoint))
    except BuildError:
        app.logger.error(
            f"BuildError: Dashboard endpoint '{destination_endpoint}' not found for role '{user_role_name}'. Redirecting to fallback."
        )
        flash(
            f"Configuration error: Your role dashboard ('{destination_endpoint}') is not defined. Contact administration.",
            "danger",
        )
        return redirect(url_for("fallback_dashboard"))
    except Exception as e:
        app.logger.error(
            f"Unexpected error during role redirect for user {current_user.username} (ID: {current_user.id}): {e}",
            exc_info=True,
        )
        flash(
            "An unexpected error occurred during redirection. Please try logging in again.",
            "danger",
        )
        return redirect(url_for("login"))


@app.route("/login", methods=["GET", "POST"])
def login():
    """Handles user login."""
    # If user is already authenticated, redirect to their dashboard
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    form = LoginForm()  # Use the LoginForm defined in Part 4

    if form.validate_on_submit():
        # Get username input (keep original case for logging, use lower for lookup)
        username_input = form.username.data.strip()
        username_lower = username_input.lower()

        # Log the login attempt
        app.logger.info(
            f"Login attempt for username: '{username_input}' from IP: {request.remote_addr}"
        )

        # Find user by lowercase username
        user = db.session.scalar(
            select(User)
            .filter(func.lower(User.username) == username_lower)
            .options(joinedload(User.role))  # Eager load role
        )

        if user:
            # Check if user is active BEFORE checking password
            if not user.is_active:
                app.logger.warning(
                    f"Login failed for inactive user: '{username_input}' (ID: {user.id}) from IP: {request.remote_addr}"
                )
                flash(
                    "Your account is inactive. Please contact administration.", "danger"
                )
                return render_template("auth/login.html", title="Login", form=form)

            # User is active, now check password using the method from User model (Part 2)
            if user.check_password(form.password.data):
                # Password is correct and user is active - Login the user
                login_user(user)  # Logs the user in using Flask-Login
                app.logger.info(
                    f"Login successful for user: '{username_input}' (ID: {user.id}, Role: {user.role.name if user.role else 'N/A'}) from IP: {request.remote_addr}"
                )

                # Update last login timestamp (optional, but good practice)
                user.last_login = datetime.now(timezone.utc)
                db.session.commit()

                # Check if user is required to change password (flag on User model from Part 2)
                if user.force_password_change:
                    flash("You must change your password before continuing.", "warning")
                    # Store the intended 'next' URL so we can redirect there after forced change
                    # Get the 'next' parameter from the URL query string (if any)
                    next_url = request.args.get("next") or url_for(
                        "role_redirect"
                    )  # Default to dashboard
                    session["_forced_change_next"] = (
                        next_url  # Store the URL in the session
                    )
                    app.logger.debug(
                        f"User {user.id} needs forced password change. Storing next URL: {next_url}"
                    )
                    # Redirect to the forced password change page
                    return redirect(url_for("change_password_forced"))

                # If no forced change, proceed to intended destination
                # Check for a 'next' parameter in the URL query string (e.g., /login?next=/some-page)
                next_page = request.args.get("next")
                if next_page:
                    try:
                        # Basic security check: ensure the next_page is a local path starting with /
                        # Use werkzeug.urls.url_parse for safer validation
                        target = url_parse(next_page)
                        if (
                            not target.scheme and not target.netloc
                        ):  # Check if it's a relative path
                            app.logger.debug(f"Redirecting to 'next' page: {next_page}")
                            return redirect(next_page)
                        else:
                            # Log suspicious activity if an external URL is attempted
                            app.logger.warning(
                                f"Invalid 'next' URL '{next_page}' provided during login (not a local path). Falling back to role redirect."
                            )
                            # Fall through to default redirect below
                    except Exception as e:  # Catch parsing errors etc.
                        app.logger.error(
                            f"Unexpected error parsing 'next' URL '{next_page}': {e}. Falling back.",
                            exc_info=True,
                        )

                # Default redirect if no valid 'next' page parameter or no force change required
                app.logger.debug(
                    "No valid 'next' page or forced change, redirecting to role dashboard."
                )
                return redirect(url_for("role_redirect"))

            else:
                # Invalid password
                app.logger.warning(
                    f"Login failed for username: '{username_input}' (Invalid password) from IP: {request.remote_addr}"
                )
                flash(
                    "Invalid username or password.", "danger"
                )  # Use a generic message for security
        else:
            # User not found
            app.logger.warning(
                f"Login failed for username: '{username_input}' (User not found) from IP: {request.remote_addr}"
            )
            flash(
                "Invalid username or password.", "danger"
            )  # Use a generic message for security

    # For GET request or failed POST validation (e.g., empty fields)
    # Render the login template again, which will display any flash messages and form errors.
    return render_template("auth/login.html", title="Login", form=form)


@app.route("/logout")
@login_required  # User must be logged in to log out
def logout():
    """Handles user logout securely."""
    try:
        # Get username before logging out for logging purposes
        username = (
            current_user.username
            if current_user.is_authenticated
            else "N/A (unauthenticated)"
        )

        # Log the logout attempt
        app.logger.info(
            f"Logout attempt for user: {username} from IP: {request.remote_addr}"
        )

        # Clear Flask-Login's session
        logout_user()

        # Clear Flask-Session data to remove any lingering information
        session.clear()

        # Create a response object for the redirect
        response = make_response(redirect(url_for("login")))

        # Add security headers to prevent browser caching of potentially sensitive pages
        response.headers["Cache-Control"] = (
            "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
        )
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "-1"  # Historical date

        # Log the successful logout event
        app.logger.info(
            f"Secure logout successful for user: {username} from IP: {request.remote_addr}"
        )

        flash("You have been securely logged out.", "success")
        return response

    except Exception as e:
        # Log any unexpected errors during the logout process
        username = (
            current_user.username
            if current_user.is_authenticated
            else "N/A (unauthenticated)"
        )
        app.logger.error(
            f"Error during logout for user {username}: {str(e)}", exc_info=True
        )
        flash(
            "An error occurred during logout. Please clear your browser cache.",
            "danger",
        )
        # Even if an error occurs, attempt to redirect to the login page
        response = make_response(redirect(url_for("login")))
        # Add headers even on error to attempt cache clearing
        response.headers["Cache-Control"] = (
            "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
        )
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "-1"
        return response


@app.route("/change-password", methods=["GET", "POST"])
@login_required
def change_password():
    form = ChangePasswordForm()  # Your ChangePasswordForm
    if form.validate_on_submit():
        if not current_user.check_password(form.current_password.data):
            flash("Incorrect current password.", "danger")
        elif current_user.check_password(form.new_password.data):
            flash("New password cannot be the same as your current password.", "danger")
        else:
            try:
                current_user.set_password(form.new_password.data)
                current_user.force_password_change = False  # Clear flag if it was set
                db.session.commit()
                flash("Your password has been changed successfully.", "success")
                app.logger.info(
                    f"Password changed successfully for user {current_user.username} (ID: {current_user.id})."
                )
                return redirect(url_for("settings"))  # Redirect to settings page
            except Exception as e:
                db.session.rollback()
                app.logger.error(
                    f"Error changing password for user {current_user.username}: {e}",
                    exc_info=True,
                )
                flash("An unexpected error occurred. Please try again.", "danger")

    return render_template(
        "auth/change_password.html", form=form, title="Change Password - Nexus"
    )


@app.route("/change-password-forced", methods=["GET", "POST"])
@login_required
def change_password_forced():
    if not current_user.force_password_change:
        flash("Password change not required at this time.", "info")
        return redirect(url_for("role_redirect"))

    form = ForcedChangePasswordForm()  # Your ForcedChangePasswordForm
    if form.validate_on_submit():
        # Optional: Check if new password is same as old one, if User model has password_hash already
        # This is less critical here as the goal is to set *any* new password.
        try:
            current_user.set_password(form.new_password.data)
            current_user.force_password_change = False  # CRITICAL: Clear the flag
            db.session.commit()
            flash(
                "Your new password has been set successfully. You can now access the system.",
                "success",
            )
            app.logger.info(
                f"Forced password change completed for user {current_user.username}."
            )

            next_page = session.pop("_forced_change_next", None)
            if next_page:
                try:
                    target = url_parse(next_page)
                    if not target.scheme and not target.netloc:
                        return redirect(next_page)
                    else:
                        app.logger.warning(
                            f"Invalid stored 'next' URL '{next_page}' after forced password change. Falling back."
                        )
                except Exception as e:
                    app.logger.error(
                        f"Error parsing 'next' URL '{next_page}': {e}. Falling back.",
                        exc_info=True,
                    )
            return redirect(url_for("role_redirect"))  # Default redirect
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error during forced password change for user {current_user.username}: {e}",
                exc_info=True,
            )
            flash("An unexpected error occurred. Please try again.", "danger")

    return render_template(
        "auth/change_password_forced.html", form=form, title="Set New Password - Nexus"
    )


# --- Fallback Dashboard (Needed for role_redirect) ---
@app.route("/dashboard")  # Or your specific fallback URL
@login_required
def fallback_dashboard():
    flash(
        "Your role-specific dashboard may not be fully configured or is currently unavailable. Displaying a generic dashboard.",
        "info",
    )
    return render_template("dashboard_fallback.html", title="Dashboard - Nexus")


# --- PART 5 END ---

# --- PART 6 START: Role Dashboards & Core Navigation ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Message, Notification, BorrowedAsset, Attendance, Mark, TeacherProfile, Asset, AssetCategory, BehaviorRecord, Parent, ParentStudent are defined.
# - Helpers: get_unread_message_count, get_unread_notifications_count, get_user_assets_query are defined and potentially used in context processor.
# - role_required decorator is defined.
# - url_for, request, flash, render_template, redirect, abort, jsonify are available.
# - The context processor injects unread message/notification counts and `current_user`.
# In app.py, find and REPLACE the student_dashboard function with this definitive version.

@app.route("/student/dashboard")
@login_required
@role_required("student")
def student_dashboard():
    # --- Data Fetching (remains the same) ---
    user_id = current_user.id
    teachers = []
    teachers_count = 0
    if current_user.grade and current_user.section:
        teachers = db.session.scalars(
            select(User)
            .join(User.teacher_profiles)
            .where(
                TeacherProfile.grade == current_user.grade,
                TeacherProfile.section == current_user.section,
                User.is_active == True,
                User.role.has(Role.name == "teacher"),
            )
            .distinct()
            .order_by(User.full_name)
        ).all()
        teachers_count = len(teachers)

    borrowed_books = db.session.scalars(
        select(BookCheckout) 
        .where(BookCheckout.user_id == user_id, BookCheckout.returned == False)
        .options(
            joinedload(BookCheckout.asset).joinedload(Asset.category)
        )
        .order_by(BookCheckout.due_date.asc())
    ).all()

    recent_attendance = db.session.scalars(
        select(Attendance)
        .where(Attendance.student_id == user_id)
        .order_by(Attendance.date.desc())
        .limit(5)
    ).all()

    marks_records = db.session.scalars(
        select(Mark)
        .where(Mark.student_id == user_id)
        .order_by(Mark.subject)
    ).all()

    actionable_task_statuses = [
        "Open", "In Progress", "Completed (Pending Review)",
        "Delayed (Pending Review)", "Rejected (Pending Review)", "Review Rejected",
    ]
    my_tasks = db.session.scalars(
        select(UserTask)
        .join(UserTask.task)
        .where(
            UserTask.user_id == user_id, UserTask.status.in_(actionable_task_statuses)
        )
        .options(
            joinedload(UserTask.task).joinedload(Task.created_by)
        )
        .order_by(
            Task.due_date.asc().nulls_last(), UserTask.assigned_at.asc()
        )
    ).all()
    
    activity_styles = {
        'task_assigned': {'icon': 'bi-list-task', 'badge_color': 'primary'},
        'task_review_result': {'icon': 'bi-patch-check-fill', 'badge_color': 'success'},
        'behavior_recorded': {'icon': 'bi-person-exclamation', 'badge_color': 'warning'},
        'general_announcement_student': {'icon': 'bi-megaphone-fill', 'badge_color': 'info'},
        'default': {'icon': 'bi-bell-fill', 'badge_color': 'secondary'}
    }
    raw_notifications = db.session.scalars(
        select(Notification)
        .where(Notification.receiver_id == user_id)
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()
    recent_activities = []
    for notification in raw_notifications:
        style = activity_styles.get(notification.notification_type, activity_styles['default'])
        recent_activities.append({
            'icon': style['icon'],
            'badge_color': style['badge_color'],
            'content': notification.content,
            'timestamp': notification.timestamp,
            'link_url': notification.link_url
        })
    # --- End of Data Fetching ---

    # Instantiate a simple form to provide the CSRF token.
    join_tc_form = CSRFOnlyForm()
    
    return render_template(
        "student/dashboard.html",
        title="Student Dashboard - Nexus",
        teachers=teachers,
        teachers_count=teachers_count,
        borrowed_books=borrowed_books,
        recent_attendance=recent_attendance,
        marks_records=marks_records,
        my_tasks=my_tasks,
        recent_activities=recent_activities,
        join_tc_form=join_tc_form, # <-- THIS LINE IS THE FIX
    )
@app.route("/teacher/student/<int:user_id>/profile")  # Example path
@login_required
@role_required("teacher")  # Or any role that should see this teacher-centric view
def teacher_student_profile_view(user_id):
    student = db.get_or_404(User, user_id, description="Student not found.")
    if not student.role or student.role.name.lower() != "student":
        flash("The specified user is not a student.", "warning")
        abort(404)  # Or redirect

    # --- Data specific to Teacher's view of this student ---
    # Current teacher's profile (to check if they teach this student)
    # This logic assumes a teacher might have multiple profiles (grade/section/subject combinations)
    teacher_profiles_for_this_student = [
        tp
        for tp in current_user.teacher_profiles
        if tp.grade == student.grade and tp.section == student.section
    ]
    # For simplicity, let's assume the first matching profile or any match grants "teaches this student" status
    teacher_teaches_this_student = bool(teacher_profiles_for_this_student)
    # If a specific subject context is needed:
    # teacher_teaches_subject_to_student = any(tp.subject == "SomeSpecificSubject" for tp in teacher_profiles_for_this_student)

    # Get student's marks (all subjects, or filter by subjects teacher teaches)
    student_marks_query = select(Mark).where(Mark.student_id == student.id)
    # Optional: Filter by subjects this teacher teaches, if applicable
    # taught_subjects = {tp.subject for tp in teacher_profiles_for_this_student if tp.subject}
    # if taught_subjects:
    #     student_marks_query = student_marks_query.where(Mark.subject.in_(taught_subjects))
    student_marks = db.session.scalars(student_marks_query.order_by(Mark.subject)).all()

    # Get student's recent attendance (e.g., last 10 records)
    student_attendance = db.session.scalars(
        select(Attendance)
        .where(Attendance.student_id == student.id)
        .order_by(Attendance.date.desc())
        .limit(10)
    ).all()

    # Get student's recent behavior records (e.g., last 5)
    student_behavior_records = db.session.scalars(
        select(BehaviorRecord)
        .where(BehaviorRecord.student_id == student.id)
        .options(joinedload(BehaviorRecord.recorded_by))  # Eager load who recorded it
        .order_by(BehaviorRecord.date.desc())
        .limit(5)
    ).all()

    # Get the current teacher's profile if needed by template (e.g. to check section)
    # This is slightly different from teacher_profiles_for_this_student
    # current_teacher_primary_profile = current_user.teacher_profiles.first() # Or some other logic
    # Using a simplified version for the template logic
    teacher_profile_context = current_user.teacher_profiles.filter_by(
        grade=student.grade, section=student.section
    ).first()

    return render_template(
        "teacher/student_profile_view.html",
        student=student,
        student_marks=student_marks,
        student_attendance=student_attendance,
        student_behavior_records=student_behavior_records,
        teacher_profile=teacher_profile_context,  # Pass current teacher's relevant profile
        # permissions=get_request_permissions(current_user) # If quick links use it
        title=f"Profile: {student.full_name or student.username} - Nexus",
    )
@app.route("/teacher/my-classroom")
@login_required
@role_required("teacher")
def teacher_select_classroom():
    """
    Shows a teacher a list of their assigned classes, with options to manage
    marks or attendance for each. This is the new central hub.
    """
    # Fetch all teacher profiles and aggregate them by (grade, subject)
    profiles = current_user.teacher_profiles.order_by(
        TeacherProfile.grade, TeacherProfile.subject, TeacherProfile.section
    ).all()
    
    assignments = {}
    if not profiles:
        # If no profiles, render the page with an empty list
        return render_template('teacher/my_classroom.html', assignments=[], title="My Classroom")

    for profile in profiles:
        key = (profile.grade, profile.subject)
        if key not in assignments:
            assignments[key] = {
                'grade': profile.grade,
                'subject': profile.subject,
                'sections': []
            }
        # Add the section to the list for this assignment, avoiding duplicates
        if profile.section not in assignments[key]['sections']:
            assignments[key]['sections'].append(profile.section)
            
    # Sort the aggregated assignments for display
    sorted_assignments = sorted(assignments.values(), key=lambda x: (x['grade'], x['subject']))
    
    return render_template('teacher/my_classroom.html', assignments=sorted_assignments, title="My Classroom")


@app.route("/teacher/select-section-for-attendance/<grade>/<subject>")
@login_required
@role_required("teacher")
def select_section_for_attendance(grade, subject):
    """
    After a teacher selects a class (Grade/Subject), this page shows the specific
    sections they teach for that class, allowing them to pick one for attendance.
    """
    # Fetch only the profiles for the selected grade and subject
    profiles = current_user.teacher_profiles.filter_by(grade=grade, subject=subject).order_by(TeacherProfile.section).all()
    
    if not profiles:
        flash("You are not assigned to any sections for this grade and subject.", "danger")
        return redirect(url_for('teacher_select_classroom'))
        
    return render_template(
        'teacher/select_section.html', 
        profiles=profiles, 
        grade=grade, 
        subject=subject, 
        title="Select Section for Attendance"
    )  
# In app.py, replace the ENTIRE old teacher_dashboard function with this one.
#
# REPLACE YOUR ENTIRE teacher_dashboard FUNCTION WITH THIS ONE
#
# REPLACE your teacher_dashboard function with THIS TEST CODE
#
@app.route("/teacher/dashboard")
@login_required
@role_required("teacher")
def teacher_dashboard():
    # --- THIS IS THE FINAL DIAGNOSTIC TEST ---
    print("\n" + "="*50)
    print("--- RUNNING DIAGNOSTIC TEST FROM INSIDE THE FLASK APP ---")

    # TEST 1: The original query using the logged-in user
    print(f"INFO: current_user is '{current_user.username}' with ID {current_user.id}")
    original_query_profiles = db.session.scalars(
        select(TeacherProfile).where(TeacherProfile.user_id == current_user.id)
    ).all()
    print(f"RESULT 1 (Using current_user.id): Found {len(original_query_profiles)} profiles.")
    print(original_query_profiles)

    # TEST 2: The hardcoded query for user ID 1589
    hardcoded_user_id = 1589
    print(f"\nINFO: Now running a hardcoded test for user ID {hardcoded_user_id}...")
    hardcoded_query_profiles = db.session.scalars(
        select(TeacherProfile).where(TeacherProfile.user_id == hardcoded_user_id)
    ).all()
    print(f"RESULT 2 (Using hardcoded ID 1589): Found {len(hardcoded_query_profiles)} profiles.")
    print(hardcoded_query_profiles)
    print("="*50 + "\n")

    # For the test, we will use the original query's result to render the page
    all_profiles = original_query_profiles

    # The rest of your function logic remains the same...
    assignments = {}
    unique_student_ids = set()
    if not all_profiles:
        flash("You are not currently assigned to any classes. Please contact an administrator.", "warning")
        pass
    else:
        for profile in all_profiles:
            key = (profile.grade, profile.subject)
            if key not in assignments:
                assignments[key] = {'grade': profile.grade, 'subject': profile.subject, 'sections': []}
            if profile.section not in assignments[key]['sections']:
                assignments[key]['sections'].append(profile.section)
            students_in_section = db.session.scalars(select(User.id).join(Role).where(Role.name == 'student', User.grade == profile.grade, User.section == profile.section, User.is_active == True)).all()
            unique_student_ids.update(students_in_section)
    
    total_students_count = len(unique_student_ids)
    sorted_assignments = sorted(assignments.values(), key=lambda x: (int(x['grade']), x['subject']))
    lab_name = current_user.lab.name if current_user.lab else "Not Assigned"
    actionable_task_statuses = ["Open", "In Progress", "Completed (Pending Review)", "Delayed (Pending Review)", "Rejected (Pending Review)", "Review Rejected"]
    my_tasks = db.session.scalars(select(UserTask).join(UserTask.task).where(UserTask.user_id == current_user.id, UserTask.status.in_(actionable_task_statuses)).options(joinedload(UserTask.task).joinedload(Task.created_by)).order_by(Task.due_date.asc().nulls_last(), UserTask.assigned_at.asc())).all()
    teacher_activity_types = ["task_status_update_for_creator", "request_submitted_to_handler", "general_announcement_teacher",]
    recent_activities = db.session.scalars(select(Notification).where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(teacher_activity_types)).options(joinedload(Notification.sender)).order_by(Notification.timestamp.desc()).limit(5)).all()
    permissions = get_request_permissions(current_user)

    return render_template(
        "teacher/dashboard.html",
        title="Teacher Dashboard",
        assignments=sorted_assignments,
        students_count=total_students_count,
        lab_name=lab_name,
        my_tasks=my_tasks,
        recent_activities=recent_activities,
        permissions=permissions
    )
    
@app.route("/saved-items")
@login_required
def view_saved_items():
    """Renders the main page for the user to view their saved items."""
    # This page will use the API endpoint `/api/v1/saved_items` to fetch
    # and display the content dynamically with JavaScript.

    # We can pass initial data if needed, but for a dynamic page,
    # just rendering the template is often enough.

    # Get a list of the user's saved item types for the filter dropdown
    saved_item_types = (
        db.session.query(UserSavedItem.item_type.distinct())
        .filter_by(user_id=current_user.id)
        .all()
    )
    # The result is a list of tuples, e.g., [('GlobalPost',), ('ChannelPost',)]. We extract the first element.
    filter_options = [item[0] for item in saved_item_types]

    return render_template(
        "saved_items/view.html", filter_options=filter_options, title="My Saved Items"
    )

# In app.py, find and REPLACE the librarian_dashboard function

@app.route("/librarian/dashboard")
@login_required
@role_required("librarian")
def librarian_dashboard():
    """
    Librarian specific dashboard, now serving as the main hub for the Kiosk system.
    """
    if current_user.role_id != 6: # Ensure correct role ID for librarian
        abort(403)
        
    # --- Data for Stat Cards (existing logic) ---
    book_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
    book_category_id = book_category.id if book_category else None
    
    total_books = db.session.scalar(select(func.sum(Asset.quantity)).where(Asset.category_id == book_category_id)) or 0
    available_books = db.session.scalar(select(func.sum(Asset.quantity)).where(Asset.category_id == book_category_id, Asset.status == "Available")) or 0
    checked_out_books = db.session.scalar(select(func.count(BookCheckout.id)).join(Asset).where(Asset.category_id == book_category_id, BookCheckout.returned == False)) or 0
    open_library_reports = db.session.scalar(select(func.count(AssetReport.id)).join(Asset).where(Asset.category_id == book_category_id, AssetReport.status.in_(["Pending", "In Progress"]))) or 0

    # --- NEW: Data for Integrated Kiosk ---
    kiosk_form = KioskAttendanceForm()
    today = datetime.now(timezone.utc).date()
    
    present_students_log = db.session.scalars(
        select(LibraryLog)
        .options(joinedload(LibraryLog.user).joinedload(User.role))
        .where(LibraryLog.date == today, LibraryLog.check_out_time.is_(None))
        .order_by(LibraryLog.check_in_time.asc())
    ).all()
    
    # You can pass other data like recent_activities if your template uses it
    recent_activities = [] # Placeholder

    return render_template(
        "librarian/dashboard.html",
        title="Librarian Dashboard",
        total_books=total_books,
        available_books=available_books,
        checked_out_books=checked_out_books,
        open_library_reports=open_library_reports,
        kiosk_form=kiosk_form,  # Pass the kiosk form
        present_students_log=present_students_log, # Pass the list of present students
        recent_activities=recent_activities, # Pass any recent activity data
        # 'permissions' is not used in the provided template, so it can be omitted
    )
@app.route("/hr_ceo/dashboard")
@login_required
@role_required("hr_ceo")  # Assuming "hr_ceo" is the role name
def hr_ceo_dashboard():
    student_count = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    teacher_count = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )
    student_leader_count = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(
                Role.name == "student", User.is_leader == True, User.is_active == True
            )
        )
        or 0
    )

    pending_assets = (
        db.session.scalar(
            select(func.count(Asset.id)).where(Asset.status == "Pending Review")
        )
        or 0
    )
    reports_open = (
        db.session.scalar(
            select(func.count(AssetReport.id)).where(
                AssetReport.status.in_(["Pending", "In Progress"])
            )
        )
        or 0
    )

    my_assigned_tasks_count = (
        db.session.scalar(
            select(func.count(Task.id)).where(Task.created_by_id == current_user.id)
            # Optionally filter by tasks that are not yet fully completed by all assignees
        )
        or 0
    )

    requests_inbox_count = (
        db.session.scalar(
            select(func.count(Request.id)).where(
                Request.current_handler_id == current_user.id,
                Request.tier == 1,  # HR/CEO is Tier 1
                Request.status.in_(
                    ["Pending", "Approved", "On Progress"]
                ),  # Actionable requests
            )
        )
        or 0
    )

    # Recent admin activities (placeholder - e.g., recent important system notifications or audit logs)
    admin_activity_types = [
        "new_user_registered",
        "system_error_report",
        "asset_approved",
        "request_tier1_escalated",
    ]
    recent_activities = db.session.scalars(
        select(Notification)  # Or from a dedicated AuditLog model if you have one
        .where(
            Notification.receiver_id == current_user.id,
            Notification.notification_type.in_(admin_activity_types),
        )
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()

    return render_template(
        "hr_ceo/dashboard.html",
        title="HR & Academics Dashboard - Nexus",
        student_count=student_count,
        teacher_count=teacher_count,
        student_leader_count=student_leader_count,
        pending_assets=pending_assets,
        reports_open=reports_open,
        my_assigned_tasks_count=my_assigned_tasks_count,
        requests_inbox_count=requests_inbox_count,
        recent_activities=recent_activities,
    )


@app.route("/school_exec/dashboard")
@login_required
@role_required("school_executive")
def school_exec_dashboard():
    """School Executive specific dashboard."""
    # Unread counts are in context processor via inject_global_vars

    # Relevant stats for School Executive overview
    student_count = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    teacher_count = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )
    total_users = (
        db.session.scalar(select(func.count(User.id)).where(User.is_active == True))
        or 0
    )

    total_assets = db.session.scalar(select(func.count(Asset.id))) or 0
    open_reports = (
        db.session.scalar(
            select(func.count(AssetReport.id)).where(
                AssetReport.status.in_(["Pending", "In Progress"])
            )
        )
        or 0
    )

    # --- ADDED/CORRECTED SECTION ---
    # Count requests assigned to this School Executive (Tier 2 handler)
    # Ensure Request model and current_user are available
    requests_inbox_count = 0
    if (
        current_user.is_authenticated
        and current_user.role.name.lower() == "school_executive"
    ):
        requests_inbox_count = (
            db.session.scalar(
                select(func.count(Request.id)).where(
                    Request.current_handler_id == current_user.id,
                    Request.tier == 2,  # Tier 2 for School Executive
                    Request.status.in_(
                        ["Pending", "Approved", "On Progress"]
                    ),  # Actionable requests
                )
            )
            or 0
        )

    # Placeholder for recent_executive_activities - define it even if empty for now
    # Populate this with actual activity data similar to other dashboards
    recent_executive_activities = []
    # Example:
    # relevant_notification_types = ['request_tier2_escalated', 'system_policy_updated', 'major_incident_report']
    # activities_raw = db.session.scalars(
    #     select(Notification)
    #     .where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(relevant_notification_types))
    #     .options(joinedload(Notification.sender))
    #     .order_by(Notification.timestamp.desc())
    #     .limit(5)
    # ).all()
    # for act in activities_raw:
    #     recent_executive_activities.append({
    #         'icon': 'bi-bell-fill', # Placeholder icon
    #         'badge_color': 'primary',
    #         'text': f"{act.content[:100]}..." if act.content else "Notification",
    #         'timestamp': act.timestamp,
    #         'url': act.link_url or "#"
    #     })
    # --- END ADDED/CORRECTED SECTION ---

    return render_template(
        "school_exec/dashboard.html",
        title="School Executive Dashboard",
        student_count=student_count,
        teacher_count=teacher_count,
        total_users=total_users,
        total_assets=total_assets,
        open_reports=open_reports,
        requests_inbox_count=requests_inbox_count,  # Now passed
        recent_executive_activities=recent_executive_activities,  # Now passed
    )


@app.route("/talent_club/dashboard")
@login_required
@tc_member_required
def talent_club_dashboard():
    """Talent Club specific dashboard."""
    # Unread counts in context processor

    # --- START OF FIX ---
    # Count active users who are TC Members (is_tc_member == True)
    member_count = (
        db.session.scalar(
            select(func.count(User.id)).where(
                User.is_tc_member == True, User.is_active == True
            )  # CORRECTED QUERY
        )
        or 0
    )
    # --- END OF FIX ---

    # Assets specifically designated for the Talent Club (assuming a category 'Talent Club Gear')
    talent_club_category = db.session.scalar(
        select(AssetCategory).filter_by(name="Talent Club Gear")
    )
    talent_club_assets = []
    if talent_club_category:
        talent_club_assets = db.session.scalars(
            select(Asset)
            .where(
                Asset.category == talent_club_category,
                Asset.status.in_(["Available", "Under Maintenance", "Needs Repair"]),
            )  # Show relevant statuses
            .order_by(Asset.name)
        ).all()

    return render_template(
        "talent_club/dashboard.html",
        title="Talent Club Dashboard",
        member_count=member_count,
        talent_club_assets=talent_club_assets,  # Pass assets
        # recent_notifications, unread_notifications_count are in context
    )


@app.route("/parent/dashboard")
@login_required
@role_required("parent")
def parent_dashboard():
    children_list = []
    recent_behavior_records_for_children = []

    # Assuming ParentStudent links Parent to student User, and User has parent_associations
    if current_user.parent_profile and current_user.parent_profile.student_associations:
        # Get verified children
        verified_associations = [
            assoc
            for assoc in current_user.parent_profile.student_associations
            if assoc.verification_status == "verified"
            and assoc.student  # Ensure student exists
        ]
        children_list = [assoc.student for assoc in verified_associations]

        if children_list:
            child_ids = [child.id for child in children_list]
            recent_behavior_records_for_children = db.session.scalars(
                select(BehaviorRecord)
                .where(BehaviorRecord.student_id.in_(child_ids))
                .options(
                    joinedload(BehaviorRecord.student)
                )  # Eager load student for display in record
                .order_by(BehaviorRecord.date.desc())
                .limit(5)  # Limit for dashboard snippet
            ).all()

    return render_template(
        "parent/dashboard.html",
        title="Parent Dashboard - Nexus",
        children=children_list,
        recent_behavior_records=recent_behavior_records_for_children,
    )


@app.route("/library")
@login_required
# Student can see their borrowed books. Librarian view redirects to list_checkouts.
@role_required("student", "librarian")
def view_library():
    if current_user.role.name.lower() == "student":
        # Ensure BorrowedAsset and its relationships (asset, asset.category) are loaded
        checkouts = db.session.scalars(
            select(
                BorrowedAsset
            )  # Using BorrowedAsset, as per student dashboard and models
            .where(
                BorrowedAsset.user_id == current_user.id,
                BorrowedAsset.returned == False,
            )
            .options(joinedload(BorrowedAsset.asset).joinedload(Asset.category))
            .order_by(BorrowedAsset.due_date.asc())
        ).all()
        # The template "student/library_view.html" needs to be created if not already.
        # For now, let's assume it's similar to a simplified list_checkouts or uses _book_checkout_item.
        # If "student/library_view.html" does not exist, you might need to create it or reuse parts of list_checkouts.
        # For simplicity, let's assume it expects 'checkouts' and can iterate them.
        # If student/library_view.html was intended to list BookCheckout model items,
        # then query BookCheckout instead of BorrowedAsset.
        # Given the backend definition used BorrowedAsset for student dashboard, let's stick to it.
        # If the student dashboard used BookCheckout then query BookCheckout here.
        # *** Assuming `student/library_view.html` will use `_book_checkout_item.html` for consistency. ***
        # This means we should pass BookCheckout objects, not BorrowedAsset.

        select(
            BookCheckout
        )  # QUERYING BookCheckout FOR CONSISTENCY WITH _book_checkout_item.html
        book_checkouts = db.session.scalars(
            select(BookCheckout)
            .where(
                BookCheckout.user_id == current_user.id, BookCheckout.returned == False
            )
            .options(
                joinedload(BookCheckout.asset).joinedload(Asset.category),
                joinedload(BookCheckout.user),
            )  # User is already current_user but good for partial
            .order_by(BookCheckout.due_date.asc())
        ).all()

        return render_template(
            "student/library_view.html",
            checkouts=book_checkouts,  # Pass BookCheckout objects
            title="My Borrowed Books - Nexus",
        )

    elif current_user.role.name.lower() == "librarian":
        return redirect(url_for("list_checkouts"))

    abort(403)  # Should not be reached


# --- PART 6 END ---

# --- PART 7 START: Teacher/Librarian Specific Features ---


# --- Teacher Specific Routes (Marks, Attendance, Lab) ---
# In app.py, add this new route, for example, after the 'enter_marks' function.

@app.route("/teacher/leaderboard/<grade>/<subject>")
@login_required
@role_required("teacher")
def view_leaderboard(grade, subject):
    """Displays a ranked leaderboard for a specific class."""
    # Verify the teacher is assigned to this class
    has_assignment = current_user.teacher_profiles.filter_by(grade=grade, subject=subject).first()
    if not has_assignment:
        flash("You are not assigned to teach this class.", "danger")
        abort(403)

    # Find all sections for this assignment to get all relevant students
    assigned_sections = [p.section for p in current_user.teacher_profiles.filter_by(grade=grade, subject=subject).all()]

    # Fetch all students in the assigned sections who have a mark record for this subject
    # and order them by rank.
    ranked_students_query = (
        select(Mark)
        .join(User) # Join Mark with User
        .where(
            Mark.subject == subject,
            User.grade == grade,
            User.section.in_(assigned_sections)
        )
        .options(joinedload(Mark.student)) # Eager load student details
        .order_by(Mark.rank.asc().nulls_last(), Mark.average.desc().nulls_last()) # Order by rank
    )
    ranked_marks = db.session.scalars(ranked_students_query).all()

    return render_template(
        "teacher/leaderboard.html",
        ranked_marks=ranked_marks,
        grade=grade,
        subject=subject,
        title=f"Leaderboard for {subject} - Grade {grade}"
    )

# ===================================================================
# 1. NEW AND IMPROVED HELPER FUNCTION TO CALCULATE RANKS
# Replace your old function with this one.
# ===================================================================
def update_ranks_for_subject(grade, subject_name):
    """
    Calculates and updates ranks using a more robust, ORM-based approach.
    This method is guaranteed to work with the most up-to-date data.
    """
    with app.app_context():
        try:
            # 1. Fetch all the marks for this grade and subject that we need to rank.
            #    We sort by average descending. Students with no score (NULL) go to the end.
            marks_to_rank = db.session.scalars(
                select(Mark)
                .join(User)
                .where(User.grade == grade, Mark.subject == subject_name)
                .order_by(Mark.average.desc().nullslast())
            ).all()

            if not marks_to_rank:
                app.logger.info(f"No marks found for Grade {grade}, Subject {subject_name} to rank.")
                return

            # 2. Rank the students in Python. This logic correctly handles ties.
            rank = 0
            last_score = -1  # A score that can't exist, to start the loop
            for index, mark_record in enumerate(marks_to_rank, 1):
                if mark_record.average is None:
                    # If there's no score, there's no rank.
                    mark_record.rank = None
                    continue
                
                # If the score is different from the previous one, the new rank is the current position in the list.
                if mark_record.average != last_score:
                    rank = index
                
                # Assign the rank. If it's a tie, this will assign the same rank as the previous student.
                mark_record.rank = rank
                last_score = mark_record.average
            
            # 3. Commit all the rank changes to the database.
            db.session.commit()
            app.logger.info(f"Successfully updated ranks for Grade {grade}, Subject {subject_name}.")

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"A critical error occurred while updating ranks for Grade {grade}, Subject '{subject_name}': {e}", 
                exc_info=True
            )


# ===================================================================
# 2. THE COMPLETE AND FINAL ROUTE FUNCTION
# Replace your existing enter_marks route with this.
# ===================================================================
@app.route("/teacher/marks/<grade>/<subject>", methods=["GET", "POST"])
@login_required
@role_required("teacher")
def enter_marks(grade, subject):
    teacher_profile = current_user.teacher_profiles.filter_by(grade=grade, subject=subject).first()
    if not teacher_profile:
        flash("You are not assigned to teach this class.", "danger")
        abort(403)

    assigned_sections = [p.section for p in current_user.teacher_profiles.filter_by(grade=grade, subject=subject).all()]
    students = db.session.scalars(
        select(User).join(Role).where(
            Role.name == "student",
            User.grade == grade,
            User.section.in_(assigned_sections),
            User.is_active == True,
        ).order_by(User.section, User.full_name)
    ).all()
    student_ids = [s.id for s in students]
    existing_marks_map = {mark.student_id: mark for mark in db.session.scalars(select(Mark).where(Mark.student_id.in_(student_ids), Mark.subject == subject))} if student_ids else {}

    form = CSRFProtectForm()

    if form.validate_on_submit():
        submitted_data = {}
        validation_errors = {}
        parsed_marks = {}

        def _parse_and_validate_score(score_str):
            if not score_str: return None, None
            try:
                score = float(score_str)
                if not (0 <= score <= 100):
                    return None, "Score must be between 0 and 100."
                return score, None
            except ValueError:
                return None, "Invalid number format."

        for student in students:
            student_id = student.id
            s1_str = request.form.get(f"semester_1_{student_id}", "").strip()
            s2_str = request.form.get(f"semester_2_{student_id}", "").strip()
            submitted_data[student_id] = {"semester_1": s1_str, "semester_2": s2_str}
            
            s1, s1_err = _parse_and_validate_score(s1_str)
            s2, s2_err = _parse_and_validate_score(s2_str)
            current_student_errors = []
            if s1_err: current_student_errors.append(f"Semester 1: {s1_err}")
            if s2_err: current_student_errors.append(f"Semester 2: {s2_err}")
            if current_student_errors:
                validation_errors[student_id] = current_student_errors
            else:
                parsed_marks[student_id] = {"s1": s1, "s2": s2}

        if validation_errors:
            for student_id, errors in validation_errors.items():
                student_name = next((s.full_name for s in students if s.id == student_id), f"ID {student_id}")
                flash(f"Error for {student_name}: {'. '.join(errors)}", "danger")
            
            return render_template("teacher/marks.html", students=students, subject_taught=subject, grade=grade, subject=subject, teacher_profile=teacher_profile, existing_marks_map=existing_marks_map, submitted_data=submitted_data, validation_errors=validation_errors, title=f"Enter Marks for {subject}", form=form)

        try:
            for student_id, marks in parsed_marks.items():
                record = existing_marks_map.get(student_id)
                s1, s2 = marks["s1"], marks["s2"]
                if record is None and (s1 is not None or s2 is not None):
                    record = Mark(student_id=student_id, subject=subject)
                    db.session.add(record)
                if record:
                    record.semester_1 = s1
                    record.semester_2 = s2
                    record.update_derived_fields()

            db.session.commit()

            update_ranks_for_subject(grade, subject)

            flash(f"Marks for {subject} updated successfully!", "success")
            return redirect(url_for('enter_marks', grade=grade, subject=subject))
            
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error saving marks for {subject} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while saving marks.", "danger")
            return render_template("teacher/marks.html", students=students, subject_taught=subject, grade=grade, subject=subject, teacher_profile=teacher_profile, existing_marks_map=existing_marks_map, submitted_data=submitted_data, validation_errors={}, title=f"Enter Marks for {subject}", form=form)

    return render_template(
        "teacher/marks.html",
        students=students,
        subject_taught=subject,
        grade=grade,
        subject=subject,
        teacher_profile=teacher_profile,
        existing_marks_map=existing_marks_map,
        submitted_data={},
        validation_errors={},
        title=f"Enter Marks for {subject}",
        form=form
    )

@app.route("/hr_ceo/lab_assignments")
@login_required
@role_required("hr_ceo", "system_admin")
def lab_assignment_index():
    """
    Displays subjects as categories to choose from for lab assignment.
    This boosts performance by not loading all teachers at once.
    """
    # Query for distinct subjects taught by active teachers
    subjects_query = (
        select(TeacherProfile.subject, func.count(func.distinct(TeacherProfile.user_id)).label('teacher_count'))
        .join(User)
        .where(User.role.has(name='teacher'), User.is_active == True, TeacherProfile.subject.isnot(None))
        .group_by(TeacherProfile.subject)
        .order_by(TeacherProfile.subject)
    )
    subjects = db.session.execute(subjects_query).all()

    return render_template(
        'hr_ceo/lab_assignment_index.html',
        subjects=subjects,
        title="Assign Labs to Teachers"
    )
# In app.py, find the assign_lab_to_teachers function

@app.route("/hr_ceo/lab_assignments/<subject>", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def assign_lab_to_teachers(subject):
    """
    Handles assigning labs to all teachers of a specific subject.
    """
    # ADD THIS LINE: Instantiate a form for CSRF protection.
    form = CSRFProtectForm()

    if request.method == 'POST':
        # No need to call form.validate_on_submit() here, as the global
        # CSRFProtect extension will check the token before the route runs.
        # Your existing POST logic can remain as is.
        try:
            # Loop through the form data submitted
            for teacher_id_str, lab_id_str in request.form.items():
                if teacher_id_str.startswith('teacher_'):
                    teacher_id = int(teacher_id_str.split('_')[1])
                    lab_id = int(lab_id_str) if lab_id_str.isdigit() and int(lab_id_str) != 0 else None

                    # Find the teacher and update their lab_id
                    teacher_user = db.session.get(User, teacher_id)
                    if teacher_user and teacher_user.role.name == 'teacher':
                        teacher_user.lab_id = lab_id
            
            db.session.commit()
            flash(f"Lab assignments for '{subject}' teachers have been updated successfully.", "success")
            app.logger.info(f"User {current_user.username} updated lab assignments for subject: {subject}")
            return redirect(url_for('lab_assignment_index'))
            
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error updating lab assignments for subject {subject}: {e}", exc_info=True)
            flash("An error occurred while saving lab assignments.", "danger")

    # --- GET Request Logic ---
    # ... (your existing GET logic remains here) ...
    teachers_query = (
        select(User)
        .join(User.teacher_profiles)
        .where(
            User.role.has(name='teacher'),
            User.is_active == True,
            TeacherProfile.subject == subject
        )
        .options(joinedload(User.lab)) 
        .distinct()
        .order_by(User.full_name)
    )
    teachers = db.session.scalars(teachers_query).all()
    labs = db.session.scalars(select(Lab).order_by(Lab.name)).all()

    return render_template(
        'hr_ceo/assign_lab_to_teachers.html',
        subject=subject,
        teachers=teachers,
        labs=labs,
        form=form,  # ADD THIS: Pass the form object to the template
        title=f"Assign Labs for {subject}"
    )

# ===================================================================
# CORRECTED ROUTE FOR ATTENDANCE GRID VIEW
# ===================================================================
@app.route("/teacher/attendance_grid/<grade>/<section>")
@login_required
@role_required("teacher")
def attendance_grid(grade, section):
    # --- 1. Authorization and Student Fetching ---
    has_assignment = current_user.teacher_profiles.filter_by(grade=grade, section=str(section)).first()
    if not has_assignment:
        flash("You are not assigned to teach this class.", "danger")
        abort(403)

    students = db.session.scalars(
        select(User).join(Role).where(
            Role.name == "student",
            User.grade == grade,
            User.section == str(section),
            User.is_active == True,
        ).order_by(User.full_name)
    ).all()

    if not students:
        flash(f"No active students found for Grade {grade}, Section {section}.", "warning")
        return redirect(url_for("teacher_dashboard"))

    # --- 2. Date and Month Calculation ---
    try:
        year = request.args.get('year', datetime.now().year, type=int)
        month = request.args.get('month', datetime.now().month, type=int)
        first_day_of_month = date(year, month, 1) # This line was causing the error
    except ValueError:
        flash("Invalid year or month provided. Showing current month.", "warning")
        today = datetime.now().date()
        year, month = today.year, today.month
        first_day_of_month = date(year, month, 1)

    _, num_days_in_month = monthrange(year, month)
    days_in_month = [date(year, month, day) for day in range(1, num_days_in_month + 1)]

    # --- 3. Fetch All Attendance Data for the Month ---
    student_ids = [s.id for s in students]
    start_date = date(year, month, 1)
    end_date = date(year, month, num_days_in_month)

    all_records_for_month = db.session.scalars(
        select(Attendance).where(
            Attendance.student_id.in_(student_ids),
            Attendance.date.between(start_date, end_date)
        )
    ).all()

    # --- 4. Structure Data for Easy Template Rendering ---
    attendance_data = defaultdict(dict)
    for record in all_records_for_month:
        attendance_data[record.student_id][record.date] = record.status

    # --- 5. Navigation Links for Previous/Next Month ---
    prev_month_date = first_day_of_month - timedelta(days=1)
    next_month_date = first_day_of_month + timedelta(days=num_days_in_month)

    nav_links = {
        'prev_month': {'year': prev_month_date.year, 'month': prev_month_date.month},
        'next_month': {'year': next_month_date.year, 'month': next_month_date.month},
        'current_month_display': first_day_of_month.strftime('%B %Y')
    }

    return render_template(
        'teacher/attendance_grid.html',
        students=students,
        days_in_month=days_in_month,
        attendance_data=attendance_data,
        nav_links=nav_links,
        grade=grade,
        section=section,
        title=f"Attendance Grid - G{grade} S{section}"
    )
# In app.py, find and REPLACE the mark_attendance route.

@app.route("/teacher/attendance/<grade>/<section>", methods=["GET", "POST"])
@login_required
@role_required("teacher")
def mark_attendance(grade, section):
    # This line correctly fetches the teacher's profile for this assignment.
    # We will pass this variable to the template.
    has_assignment = current_user.teacher_profiles.filter_by(grade=grade, section=str(section)).first()
    if not has_assignment:
        flash("You are not assigned to teach this class.", "danger")
        abort(403)

    students = db.session.scalars(
        select(User).join(Role).where(
            Role.name == "student",
            User.grade == grade,
            User.section == str(section),
            User.is_active == True,
        ).order_by(User.full_name)
    ).all()

    if not students:
        flash(f"No active students found for Grade {grade}, Section {section}.", "warning")
        return redirect(url_for("teacher_dashboard"))

    attendance_date_str = request.args.get("date", request.form.get("date", datetime.now(timezone.utc).strftime("%Y-%m-%d")))
    try:
        attendance_date_obj = datetime.strptime(attendance_date_str, "%Y-%m-%d").date()
        if attendance_date_obj > datetime.now(timezone.utc).date():
            flash("Cannot view/mark attendance for future dates.", "warning")
            attendance_date_obj = datetime.now(timezone.utc).date()
            attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d")
    except ValueError:
        flash("Invalid date format. Using today's date.", "warning")
        attendance_date_obj = datetime.now(timezone.utc).date()
        attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d")

    form = AttendanceForm(students=students)
    existing_records = db.session.scalars(select(Attendance).where(Attendance.student_id.in_([s.id for s in students]), Attendance.date == attendance_date_obj)).all()
    existing_attendance_map = {record.student_id: record for record in existing_records}

    if request.method == "POST":
        date_for_marking = attendance_date_obj
        try:
            for student in students:
                status = request.form.get(f"status_{student.id}")
                notes = request.form.get(f"notes_{student.id}", "").strip()
                existing_record = existing_attendance_map.get(student.id)
                if status:
                    if existing_record:
                        existing_record.status = status
                        existing_record.notes = notes
                    else:
                        new_record = Attendance(student_id=student.id, date=date_for_marking, status=status, notes=notes)
                        db.session.add(new_record)
            db.session.commit()
            flash(f"Attendance for {date_for_marking.strftime('%Y-%m-%d')} saved successfully.", "success")
            return redirect(url_for('mark_attendance', grade=grade, section=section, date=date_for_marking.strftime('%Y-%m-%d')))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error saving attendance: {e}", exc_info=True)
            flash("An error occurred while saving attendance.", "danger")

    # --- THIS IS THE FIX ---
    # We are adding `teacher_profile=has_assignment` to the list of variables
    # being passed to the template.
    return render_template(
        "teacher/attendance.html",
        form=form,
        students=students,
        grade=grade,
        section=section,
        attendance_date_str=attendance_date_str,
        attendance_date_obj=attendance_date_obj,
        existing_attendance_map=existing_attendance_map,
        teacher_profile=has_assignment, # <-- THIS LINE IS THE FIX
        title=f"Mark Attendance - G{grade} S{section}",
    )
    
@app.route("/teacher/lab_equipment")
@login_required
@role_required("teacher")
def teacher_lab_equipment():
    """Displays equipment assigned to the teacher's lab."""
    # Check if teacher is assigned to a lab via lab_id (column added in Part 2)
    if not current_user.lab_id:
        flash("You are not currently assigned to a lab.", "info")
        return redirect(url_for("teacher_dashboard"))

    # Fetch equipment belonging to the teacher's lab (Asset model filtering by lab_id)
    lab_equipment = db.session.scalars(
        select(Asset).where(Asset.lab_id == current_user.lab_id).order_by(Asset.name)
    ).all()

    # Fetch the Lab object to get the name easily
    lab = db.session.get(Lab, current_user.lab_id)
    lab_name = lab.name if lab else "Unknown Lab"

    app.logger.info(
        f"Teacher {current_user.username} (ID: {current_user.id}) accessed equipment for lab {lab_name} (ID: {current_user.lab_id}). Found {len(lab_equipment)} assets."
    )

    return render_template(
        "teacher/lab_equipment.html",
        lab_equipment=lab_equipment,
        lab_name=lab_name,
        title=f"Equipment in {lab_name}",
    )


# --- Librarian Specific Routes ---


@app.route(
    "/librarian/attendance/take/<string:grade>/<string:section>",
    methods=["GET", "POST"],
)  # Explicitly string type
@login_required
@role_required("librarian")
def take_attendance(grade, section):
    """Allows librarians to mark student attendance for a specific class."""
    # Get active students in this specific grade-section
    student_role = db.session.scalar(select(Role).where(Role.name == "student"))
    # Ensure student role exists and fetch students
    if not student_role:
        flash("Student role not found. Cannot take attendance.", "danger")
        return redirect(
            url_for("librarian_attendance")
        )  # Redirect back to attendance dashboard

    students = db.session.scalars(
        select(User)
        .where(
            User.grade == grade,
            User.section == section,
            User.is_active == True,  # Only active students
            User.role == student_role,  # Filter by role object or role_id
        )
        .order_by(User.full_name)  # Order students alphabetically
    ).all()

    # Handle invalid grade/section if no active students are found


# In app.py, add the new system_admin_dashboard and fix the others.


# FIX: Implemented the missing System Admin dashboard route.
@app.route("/system_admin/dashboard")
@login_required
@role_required("system_admin")
def system_admin_dashboard():
    # Fetching stats for the dashboard. These are examples and might need optimization.
    stats = {
        "total_active_users": db.session.scalar(
            select(func.count(User.id)).where(User.is_active == True)
        )
        or 0,
        "total_roles": db.session.scalar(select(func.count(Role.id))) or 0,
        "db_size": "N/A",  # DB size is complex to query, placeholder for now.
        "recent_log_count": 0,  # Would require a logging model or parsing log files.
    }
    # Placeholder for recent admin activities
    recent_admin_activities = []

    return render_template(
        "system_admin/dashboard.html",
        stats=stats,
        recent_admin_activities=recent_admin_activities,
        title="System Administration Dashboard",
    )


# FIX: Rewrote librarian attendance dashboard to provide the data the template expects.
# NOTE: This assumes a `LibraryLog` model exists as conceptualized in the analysis.
# If `LibraryLog` doesn't exist, this route will fail but shows the required logic.
# In app.py, find and REPLACE the LibraryLog model

# In app.py, add this with your other form definitions

class KioskAttendanceForm(FlaskForm):
    """Simple form for the librarian to enter a student's ID."""
    student_id = IntegerField(
        "Student ID", 
        validators=[DataRequired(message="Student ID is required.")],
        render_kw={"placeholder": "Enter Student ID...", "class": "form-control form-control-lg", "autofocus": True}
    )
    submit = SubmitField("Check In", render_kw={"class": "btn btn-primary btn-lg"})
# In app.py, ADD this new form class with your other WTForms definitions

class KioskAttendanceForm(FlaskForm):
    """Simple form for the librarian to enter a student's ID."""
    student_id = IntegerField(
        "Student ID", 
        validators=[DataRequired(message="Student ID is required.")],
        render_kw={"placeholder": "Enter Student ID...", "class": "form-control form-control-lg", "autofocus": True}
    )
    submit = SubmitField("Check In", render_kw={"class": "btn btn-primary btn-lg w-100"})
class LibraryLog(db.Model):
    __tablename__ = "library_log"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    
    # The exact time of check-in
    check_in_time = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    
    # The exact time of check-out (can be null if student is still present)
    check_out_time = db.Column(db.DateTime, nullable=True)
    
    # The date of the check-in for efficient daily filtering
    date = db.Column(db.Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False, index=True)
    
    # Calculated duration of the visit in minutes
    duration_minutes = db.Column(db.Integer, nullable=True)

    user = db.relationship("User")

    # A student can only check in once per day. This prevents duplicate entries.
    __table_args__ = (
        db.UniqueConstraint('user_id', 'date', name='_user_date_uc'),
    )

    def __repr__(self):
        return f"<LibraryLog User:{self.user_id} Date:{self.date} In:{self.check_in_time}>"
# In app.py, REPLACE the old librarian_attendance_dashboard and DELETE take_attendance.
# Then, ADD all of the following routes in that section of your file.

# --- NEW: Librarian Kiosk System ---

@app.route("/librarian/kiosk")
@login_required
@role_required("librarian") # Uses your existing decorator
def librarian_kiosk():
    """
    The main Kiosk interface for the librarian.
    Displays the check-in form, daily stats, and a live list of present students.
    """
    # Check for correct role_id
    if current_user.role_id != 6:
        abort(403)

    form = KioskAttendanceForm()
    today = datetime.now(timezone.utc).date()

    stats = {}
    stats['total_visits_today'] = db.session.scalar(
        select(func.count(LibraryLog.id)).where(LibraryLog.date == today)
    ) or 0
    stats['current_occupancy'] = db.session.scalar(
        select(func.count(LibraryLog.id)).where(LibraryLog.date == today, LibraryLog.check_out_time.is_(None))
    ) or 0
    
    present_students_log = db.session.scalars(
        select(LibraryLog)
        .options(joinedload(LibraryLog.user).joinedload(User.role))
        .where(LibraryLog.date == today, LibraryLog.check_out_time.is_(None))
        .order_by(LibraryLog.check_in_time.asc())
    ).all()

    return render_template(
        "librarian/kiosk.html",
        form=form,
        stats=stats,
        present_students_log=present_students_log,
        today_date=today,
        title="Library Kiosk"
    )

@app.route("/kiosk/check-in", methods=["POST"])
@login_required
@role_required("librarian")
def kiosk_check_in():
    """API endpoint to handle student check-in via ID."""
    if current_user.role_id != 6:
        return jsonify({"success": False, "error": "Unauthorized"}), 403

    form = KioskAttendanceForm()
    if form.validate_on_submit():
        student_id = form.student_id.data
        student = db.session.get(User, student_id)

        if not student or not student.role or student.role_id != 8: # Checks for student role_id = 8
            return jsonify({"success": False, "error": "Invalid Student ID."}), 404

        today = datetime.now(timezone.utc).date()
        already_checked_in = db.session.scalar(
            select(LibraryLog).where(LibraryLog.user_id == student.id, LibraryLog.date == today)
        )

        if already_checked_in:
            error_message = f"{student.full_name} is already checked in." if already_checked_in.check_out_time is None else f"{student.full_name} has already visited today."
            return jsonify({"success": False, "error": error_message}), 409

        try:
            new_log = LibraryLog(user_id=student.id, date=today)
            db.session.add(new_log)
            db.session.commit()

            present_students_log = db.session.scalars(
                select(LibraryLog).options(joinedload(LibraryLog.user).joinedload(User.role))
                .where(LibraryLog.date == today, LibraryLog.check_out_time.is_(None))
                .order_by(LibraryLog.check_in_time.asc())
            ).all()
            
            total_visits = db.session.scalar(select(func.count(LibraryLog.id)).where(LibraryLog.date == today)) or 0
            current_occupancy = len(present_students_log)
            rendered_html = render_template("partials/kiosk/_currently_present_list.html", present_students_log=present_students_log)

            return jsonify({
                "success": True, "message": f"Welcome, {student.full_name}!",
                "updated_html": rendered_html,
                "stats": {"total_visits_today": total_visits, "current_occupancy": current_occupancy}
            })
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Kiosk check-in error: {e}", exc_info=True)
            return jsonify({"success": False, "error": "A server error occurred."}), 500
    
    return jsonify({"success": False, "errors": form.errors}), 400

@app.route('/kiosk/check-out/<int:log_id>', methods=['POST'])
@login_required
@role_required("librarian")
def kiosk_check_out(log_id):
    """API endpoint to handle checking a student out of the library."""
    if current_user.role_id != 6:
        return jsonify({"success": False, "error": "Unauthorized"}), 403
        
    log_entry = db.get_or_404(LibraryLog, log_id)

    if log_entry.check_out_time is not None:
        return jsonify({"success": False, "error": "Student already checked out."}), 400

    try:
        log_entry.check_out_time = datetime.now(timezone.utc)
        duration = log_entry.check_out_time - log_entry.check_in_time
        log_entry.duration_minutes = int(duration.total_seconds() / 60)
        db.session.commit()

        today = datetime.now(timezone.utc).date()
        present_students_log = db.session.scalars(
            select(LibraryLog).options(joinedload(LibraryLog.user).joinedload(User.role))
            .where(LibraryLog.date == today, LibraryLog.check_out_time.is_(None))
            .order_by(LibraryLog.check_in_time.asc())
        ).all()

        current_occupancy = len(present_students_log)
        rendered_html = render_template("partials/kiosk/_currently_present_list.html", present_students_log=present_students_log)

        return jsonify({
            "success": True, "message": f"Goodbye, {log_entry.user.full_name}!",
            "updated_html": rendered_html, "stats": {"current_occupancy": current_occupancy}
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({"success": False, "error": "A server error occurred."}), 500

@app.route("/librarian/attendance/history")
@login_required
@role_required("librarian")
def library_attendance_history():
    if current_user.role_id != 6: abort(403)
        
    selected_date_str = request.args.get('date', datetime.now(timezone.utc).strftime('%Y-%m-%d'))
    selected_grade = request.args.get('grade', 'all')
    selected_section = request.args.get('section', 'all')
    
    try:
        selected_date = datetime.strptime(selected_date_str, '%Y-%m-%d').date()
    except ValueError:
        selected_date = datetime.now(timezone.utc).date()
        flash("Invalid date format. Showing today's records.", "warning")

    query = select(LibraryLog).join(User).where(LibraryLog.date == selected_date, User.role_id == 8)

    if selected_grade != 'all':
        query = query.where(User.grade == selected_grade)
    if selected_section != 'all':
        query = query.where(User.section == selected_section)
    
    attendance_records = db.session.scalars(
        query.options(joinedload(LibraryLog.user)).order_by(LibraryLog.check_in_time)
    ).all()

    distinct_grades = sorted([g[0] for g in db.session.query(User.grade.distinct()).where(User.role_id == 8, User.grade.isnot(None)).all()])
    distinct_sections = sorted([s[0] for s in db.session.query(User.section.distinct()).where(User.role_id == 8, User.section.isnot(None)).all()])
    
    return render_template(
        'librarian/attendance_history.html',
        records=attendance_records, selected_date=selected_date,
        selected_grade=selected_grade, selected_section=selected_section,
        distinct_grades=distinct_grades, distinct_sections=distinct_sections,
        title="Library Attendance History"
    )

@app.route("/librarian/overdue_books")
@login_required
@role_required("librarian")
def list_overdue_books():
    if current_user.role_id != 6: abort(403)
        
    today = datetime.now(timezone.utc).date()
    overdue_checkouts = db.session.scalars(
        select(BookCheckout)
        .options(joinedload(BookCheckout.user), joinedload(BookCheckout.asset))
        .where(BookCheckout.returned == False, BookCheckout.due_date < today)
        .order_by(BookCheckout.due_date.asc())
    ).all()
    return render_template('librarian/overdue_books.html', checkouts=overdue_checkouts, title="Overdue Books")

@app.route("/librarian/attendance/leaderboard")
@login_required
@role_required("librarian")
def library_attendance_leaderboard():
    if current_user.role_id != 6: abort(403)
        
    time_filter = request.args.get('filter', 'all_time')
    
    query = select(User.id, User.full_name, func.count(LibraryLog.id).label('visit_count'))\
            .join(LibraryLog, User.id == LibraryLog.user_id)\
            .where(User.role_id == 8)

    if time_filter == 'this_month':
        start_date = datetime.now(timezone.utc).date().replace(day=1)
        query = query.where(LibraryLog.date >= start_date)
    elif time_filter == 'this_year':
        start_date = datetime.now(timezone.utc).date().replace(day=1, month=1)
        query = query.where(LibraryLog.date >= start_date)

    leaderboard_data = db.session.execute(
        query.group_by(User.id).order_by(desc('visit_count')).limit(100)
    ).all()
    return render_template('librarian/leaderboard.html', leaderboard_data=leaderboard_data, time_filter=time_filter, title="Library Attendance Leaderboard")
# FIX: Updated government dashboard to provide missing data.
@app.route("/government/dashboard")
@login_required
@role_required("government")
def government_dashboard():
    total_students = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    total_teachers = (
        db.session.scalar(
            select(func.count(User.id))
            .join(Role)
            .where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )

    # ADDED: Fetch pending Tier 3 requests
    requests_inbox_count = (
        db.session.scalar(
            select(func.count(Request.id)).where(
                Request.current_handler_id == current_user.id,
                Request.tier == 3,
                Request.status == "Pending",
            )
        )
        or 0
    )

    # ADDED: Fetch recent submissions (example: last 5 requests handled by this user)
    recent_gov_submissions = db.session.scalars(
        select(Request)
        .where(Request.current_handler_id == current_user.id)
        .order_by(Request.last_updated_at.desc())
        .limit(5)
    ).all()

    return render_template(
        "government/dashboard.html",
        total_students=total_students,
        total_teachers=total_teachers,
        requests_inbox_count=requests_inbox_count,
        recent_gov_submissions=recent_gov_submissions,
        title="Government Oversight Dashboard",
    )


@app.route("/librarian/student/<int:user_id>")
@login_required
@role_required("librarian")
def librarian_student_profile(user_id):
    student = db.get_or_404(User, user_id, description="Student user not found.")
    if not student.role or student.role.name.lower() != "student":
        flash("The specified user is not a student.", "warning")
        abort(404)  # Or redirect

    # Current Book Checkouts for this student (using BookCheckout, not BorrowedAsset for consistency with form)
    current_checkouts = db.session.scalars(
        select(BookCheckout)  # Use BookCheckout
        .where(BookCheckout.user_id == student.id, BookCheckout.returned == False)
        .options(
            joinedload(BookCheckout.asset).joinedload(Asset.category)
        )  # Load asset info
        .order_by(BookCheckout.due_date.asc())
    ).all()

    # Other data the template might show (already fetched in your Part 7 for this route)
    # For simplicity, let's assume the template focuses on checkouts.
    # recent_attendance = db.session.scalars(...).all()
    # recent_behavior_records = db.session.scalars(...).all()
    # recent_marks = db.session.scalars(...).all()

    return render_template(
        "librarian/student_profile.html",
        student=student,
        current_checkouts=current_checkouts,  # Pass current checkouts
        # Pass other data if your template uses it:
        # recent_attendance=recent_attendance,
        # recent_behavior_records=recent_behavior_records,
        # recent_marks=recent_marks,
        title=f"Student Library Profile: {student.full_name or student.username} - Nexus",
    )


# Missing endpoint for returning a book from this profile view (can implement similar to /books/return)
# @app.route("/librarian/student/<int:user_id>/return_book/<int:checkout_id>", methods=["POST"])
# @login_required
# @role_required("librarian")
# def librarian_return_book_from_profile(user_id, checkout_id):
#      # Logic to find and mark the BorrowedAsset record as returned
#      # Update asset quantity
#      # Commit changes
#      # Redirect back to librarian_student_profile(user_id)
#      pass


# --- PART 7 END ---

# --- PART 8 START: HR/CEO & System Admin Management Features ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, TeacherProfile, Asset, AssetReport, AssetCategory, Lab, BehaviorRecord, Mark are defined.
# - Forms: AddAssetForm, ReportAssetForm, EditAssetForm, ResolveReportForm, AddCategoryForm, EditCategoryForm, BehaviorRecordForm, AssignLeaderForm are defined.
# - Helpers: get_user_assets_query, notify_hr_ceo_new_asset, notify_hr_ceo_new_report, notify_reporter_report_update, can_view_behavior_records, notify_student_and_parents, save_profile_photo, update_ranks_for_subject (used in teacher routes but defined earlier).
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, joinedload, etc.), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, os, uuid, secure_filename) are available.

# In app.py, replace the entire student_database_index function with this one

@app.route("/database/students")
@login_required
@role_required("hr_ceo", "system_admin", "teacher")
def student_database_index():
    """Renders the main student database index, grouping students by class."""
    
    # --- THIS IS THE FIX ---
    # The query is corrected to remove the invalid string comparisons (`!= ''`).
    # The `isnot(None)` check is the correct and sufficient way to ensure the columns have data.
    active_student_blocks_query = (
        select(User.grade, User.section)
        .join(User.role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade.isnot(None),    # This is correct and sufficient
            User.section.isnot(None)   # This is also correct and sufficient
        )
        .distinct()
        .order_by(User.grade.asc(), User.section.asc())
    )
    # --- END OF FIX ---

    try:
        grade_section_pairs = db.session.execute(active_student_blocks_query).all()
        
        grouped_blocks = defaultdict(list)
        if grade_section_pairs:
            for grade_val, section_val in grade_section_pairs:
                subjects_taught_in_block_query = (
                    select(TeacherProfile.subject)
                    .join(TeacherProfile.user)
                    .join(User.role)
                    .where(
                        Role.name == "teacher",
                        User.is_active == True,
                        TeacherProfile.grade == grade_val,
                        TeacherProfile.section == section_val, # Assuming TeacherProfile.section is Integer
                        TeacherProfile.subject.isnot(None),
                        TeacherProfile.subject != "",
                    )
                    .distinct()
                    .order_by(TeacherProfile.subject.asc())
                )
                subjects = db.session.scalars(subjects_taught_in_block_query).all()

                grouped_blocks[str(grade_val)].append({
                    "section": str(section_val),
                    "subjects": subjects if subjects else [],
                })

        ordered_grouped_blocks = {
            grade: sorted(sections, key=lambda s: s["section"])
            for grade, sections in sorted(grouped_blocks.items())
        }

        return render_template(
            "Database/students/index.html",
            ordered_grouped_blocks=ordered_grouped_blocks,
            title="Student Database Index - Nexus",
        )

    except Exception as e:
        # Catch the specific error and log it, then render an error page or redirect.
        # This handles the error gracefully for the user.
        app.logger.error(f"Database error in student_database_index: {e}", exc_info=True)
        flash("A database error occurred while trying to load the student directory. Please check your data or contact an administrator.", "danger")
        # Render the template with empty data to show the error message.
        return render_template(
            "Database/students/index.html",
            ordered_grouped_blocks={},
            title="Student Database Index - Nexus",
        )


@app.route(
    "/database/students/<string:grade>/<string:section>"
)  # Ensure grade/section are strings
@login_required
@role_required("hr_ceo", "system_admin", "teacher")
def student_database_block(grade, section):
    # Permission check for teachers: Can only view their assigned grade/section block(s)
    if current_user.role.name.lower() == "teacher":
        # Construct the subquery for existence check
        subquery = (
            select(TeacherProfile.id)
            .where(  # Select any single column
                TeacherProfile.user_id == current_user.id,
                TeacherProfile.grade == grade,
                TeacherProfile.section == section,
            )
            .limit(1)
        )  # Important: limit 1 for efficiency

        # Check if the subquery returns any rows
        can_view_block = db.session.execute(select(subquery.exists())).scalar_one()

        if not can_view_block:
            flash("You do not have permission to view this student block.", "danger")
            return redirect(url_for("student_database_index"))

    # Fetch active students in the specified grade and section
    students_in_block_query = (
        select(User)
        .join(User.role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade == grade,
            User.section == section,
        )
        .options(joinedload(User.role))  # Eager load role for student info
        .order_by(User.full_name.asc())
    )
    students = db.session.scalars(students_in_block_query).all()

    if not students:
        flash(
            f"No active students found for Grade {grade}, Section {section}. This block might be empty or incorrectly specified.",
            "info",
        )
        # Still render the page to show the message, or redirect
        # return redirect(url_for('student_database_index'))

    return render_template(
        "Database/students/student_block.html",  # Correct template path
        students=students,
        grade=grade,
        section=section,
        title=f"Students: Grade {grade} - Section {section} - Nexus",
    )


@app.route("/database/export_block/<string:grade>/<string:section>")
@login_required
@role_required("hr_ceo", "system_admin")
def export_block(grade, section):
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade == grade,
            User.section == section,
        )
        .order_by(User.username)
    ).all()

    if not students:
        flash(f"No students to export for Grade {grade}, Section {section}.", "warning")
        return redirect(
            request.referrer
            or url_for("student_database_block", grade=grade, section=section)
        )

    output = io.StringIO()
    writer = csv.writer(output)

    # CSV Header (Matches User model attributes and template output)
    writer.writerow(
        [
            "ID",
            "USERNAME",
            "FULL_NAME",
            "FIRST_NAME",
            "LAST_NAME",
            "EMAIL",
            "GRADE",
            "SECTION",
            "DATE_OF_BIRTH",
            "GENDER",
            "PHONE",
            "ADDRESS",
            "IS_ACTIVE",
            "CREATED_AT",
            "LAST_LOGIN",
            "IS_LEADER",
            "IS_TC_MEMBER",  # Added these relevant flags
        ]
    )

    for student in students:
        writer.writerow(
            [
                student.id,
                student.username or "",
                student.full_name or "",
                student.first_name or "",
                student.last_name or "",
                student.email or "",
                student.grade or "",
                student.section or "",
                (
                    student.date_of_birth.strftime("%Y-%m-%d")
                    if student.date_of_birth
                    else ""
                ),
                student.gender
                or "",  # This was student.gender in your User model from app.py
                student.phone or "",
                student.address or "",
                "True" if student.is_active else "False",
                (
                    student.created_at.strftime("%Y-%m-%d %H:%M:%S")
                    if student.created_at
                    else ""
                ),
                (
                    student.last_login.strftime("%Y-%m-%d %H:%M:%S")
                    if student.last_login
                    else ""
                ),
                "True" if student.is_leader else "False",
                "True" if student.is_tc_member else "False",
            ]
        )

    csv_data = output.getvalue()
    response = make_response(csv_data)
    export_filename = f"students_{grade}_{section}_export_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.csv"
    response.headers["Content-Disposition"] = f"attachment; filename={export_filename}"
    response.headers["Content-Type"] = "text/csv"

    app.logger.info(
        f"User {current_user.username} exported student data for Grade {grade}, Section {section}."
    )
    return response


# --- Behavior Record Management (HR/CEO, System Admin, School Executive) ---
# manage_student_behavior and view_student_behavior routes are defined in Part 6/7

# In Part 7, replace the entire `view_student_behavior_records` route and its subsequent behavior record routes with the following:

# --- Student Behavior Records (Universal View, Refined Recording/Editing/Deletion) ---


@app.route("/student/<int:user_id>/behavior_records")
@login_required
# No role_required here; the internal can_view_behavior_records helper
# will handle granular access based on the 'all can view' rule.
def view_student_behavior_records(user_id):
    """
    Allows authorized users to view a student's behavior records.
    Permissions handled by the `can_view_behavior_records` helper.
    """
    student = db.session.get(User, user_id)
    if (
        not student
        or not student.is_active
        or (student.role and student.role.name.lower() != "student")
    ):
        abort(404, description="Student not found or is inactive.")

    # Check permission using the helper function (all authenticated users can view)
    if not can_view_behavior_records(current_user, student):
        flash("You do not have permission to view these behavior records.", "danger")
        app.logger.warning(
            f"Unauthorized view of behavior records for student {user_id} by user {current_user.id}."
        )
        return redirect(url_for("role_redirect"))

    # Fetch behavior records for the student, newest first
    records = db.session.scalars(
        select(BehaviorRecord)
        .where(BehaviorRecord.student_id == user_id)
        .options(joinedload(BehaviorRecord.recorded_by))  # Eager load who recorded it
        .order_by(BehaviorRecord.date.desc(), BehaviorRecord.id.desc())
    ).all()

    # Determine if the current user can add a record for this student
    can_add_record = (
        current_user.is_authenticated
        and current_user.role
        and current_user.role.name.lower()
        in [
            "teacher",
            "librarian",
            "talent_club",
            "hr_ceo",
            "system_admin",
            "school_executive",
            "government",
            "parent",
        ]
    )

    # These flags will be used in the template to conditionally show/hide buttons for each record
    # based on the fine-grained permissions.
    # Note: `can_edit_any_record` and `can_delete_any_record` are global role permissions for the current user.
    # `can_edit_this_record` and `can_delete_this_record` will be per-record in the template.
    can_edit_any_record = current_user.role and current_user.role.name.lower() in [
        "hr_ceo",
        "system_admin",
        "school_executive",
    ]
    can_delete_any_record = current_user.role and current_user.role.name.lower() in [
        "hr_ceo",
        "system_admin",
        "school_executive",
    ]

    return render_template(
        "behavior/view_student_records.html",
        student=student,
        records=records,
        can_add_record=can_add_record,
        can_edit_any_record=can_edit_any_record,  # For UI logic for top-level roles
        can_delete_any_record=can_delete_any_record,  # For UI logic for top-level roles
        title=f"{student.full_name}'s Behavior Records",
    )


@app.route("/student/<int:student_id>/behavior_records/add", methods=["GET", "POST"])
@login_required
# Ensure all roles that can record behavior are listed. Parent was added.
@role_required(
    "teacher",
    "librarian",
    "talent_club",
    "hr_ceo",
    "system_admin",
    "school_executive",
    "government",
    "parent",
)
def add_behavior_record(student_id):
    student = db.get_or_404(User, student_id, description="Student not found.")
    if not student.role or student.role.name.lower() != "student":
        flash("Cannot add behavior record: Target user is not a student.", "warning")
        return redirect(
            request.referrer or url_for("student_database_index")
        )  # Or appropriate redirect

    form = BehaviorRecordForm()  # Your BehaviorRecordForm

    if form.validate_on_submit():
        try:
            new_record = BehaviorRecord(
                student_id=student.id,
                recorded_by_id=current_user.id,  # The logged-in user is the recorder
                date=datetime.now(timezone.utc),  # Or allow form to set date if needed
                behavior_type=form.behavior_type.data,
                description=form.description.data.strip(),
                severity=form.severity.data,
                resolution=(
                    form.resolution.data.strip() if form.resolution.data else None
                ),
                is_resolved=form.is_resolved.data,
            )
            db.session.add(new_record)
            db.session.commit()

            # notify_student_and_parents helper (from app.py Part 3) should be called
            notify_student_and_parents(student, new_record)

            flash(
                f"Behavior record for {student.full_name or student.username} added successfully.",
                "success",
            )
            app.logger.info(
                f"User {current_user.username} added behavior record ID {new_record.id} for student {student.id}."
            )
            return redirect(
                url_for("view_student_behavior_records", user_id=student.id)
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error adding behavior record for student {student.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while adding the record. Please try again.",
                "danger",
            )

    return render_template(
        "behavior/add_edit_record.html",  # Your template for adding/editing
        form=form,
        student=student,
        is_edit=False,  # Flag for template to know it's "Add" mode
        title=f"Add Behavior Record for {student.full_name or student.username} - Nexus",
    )


@app.route("/behavior_records/edit/<int:record_id>", methods=["GET", "POST"])
@login_required
# Roles that can potentially edit (permission check inside)
@role_required(
    "teacher",
    "librarian",
    "talent_club",
    "hr_ceo",
    "system_admin",
    "school_executive",
    "government",
    "parent",
)
def edit_behavior_record(record_id):
    record = db.get_or_404(
        BehaviorRecord, record_id, description="Behavior record not found."
    )
    student = record.student  # Get student for context and redirection

    # --- Permission Check ---
    admin_editor_roles = [
        "hr_ceo",
        "system_admin",
        "school_executive",
    ]  # Roles that can edit ANY record
    is_global_admin_editor = (
        current_user.role and current_user.role.name.lower() in admin_editor_roles
    )
    is_original_recorder = record.recorded_by_id == current_user.id

    if not (is_global_admin_editor or is_original_recorder):
        flash("You do not have permission to edit this behavior record.", "danger")
        app.logger.warning(
            f"Unauthorized edit attempt on behavior record {record_id} by user {current_user.username}."
        )
        return redirect(url_for("view_student_behavior_records", user_id=student.id))

    form = BehaviorRecordForm(obj=record)  # Populate form with existing data

    if form.validate_on_submit():
        try:
            record.behavior_type = form.behavior_type.data
            record.description = form.description.data.strip()
            record.severity = form.severity.data
            record.resolution = (
                form.resolution.data.strip() if form.resolution.data else None
            )
            record.is_resolved = form.is_resolved.data
            # record.date could be made editable too if needed, or keep original record date
            # record.updated_at = datetime.now(timezone.utc) # If you track updates

            db.session.commit()
            flash(f"Behavior record ID {record.id} updated successfully.", "success")
            app.logger.info(
                f"User {current_user.username} edited behavior record ID {record.id} for student {student.id}."
            )
            return redirect(
                url_for("view_student_behavior_records", user_id=student.id)
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error editing behavior record ID {record.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash("An unexpected error occurred. Please try again.", "danger")

    return render_template(
        "behavior/add_edit_record.html",
        form=form,
        student=student,
        record=record,  # Pass record for context if template needs its ID etc.
        is_edit=True,  # Flag for template
        title=f"Edit Behavior Record for {student.full_name or student.username} - Nexus",
    )


@app.route(
    "/behavior_records/delete/<int:record_id>", methods=["POST"]
)  # Should strictly be POST
@login_required
@role_required(
    "teacher",
    "librarian",
    "talent_club",
    "hr_ceo",
    "system_admin",
    "school_executive",
    "government",
    "parent",
)
def delete_behavior_record(record_id):
    record = db.get_or_404(
        BehaviorRecord, record_id, description="Behavior record not found."
    )
    student_id_for_redirect = record.student_id  # Store before potential deletion

    # --- Permission Check ---
    admin_deleter_roles = ["hr_ceo", "system_admin", "school_executive"]
    is_global_admin_deleter = (
        current_user.role and current_user.role.name.lower() in admin_deleter_roles
    )
    is_original_recorder = record.recorded_by_id == current_user.id

    if not (is_global_admin_deleter or is_original_recorder):
        flash("You do not have permission to delete this behavior record.", "danger")
        app.logger.warning(
            f"Unauthorized delete attempt on behavior record {record_id} by user {current_user.username}."
        )
        return redirect(
            url_for("view_student_behavior_records", user_id=student_id_for_redirect)
        )

    try:
        db.session.delete(record)
        db.session.commit()
        flash(f"Behavior record ID {record_id} deleted successfully.", "success")
        app.logger.info(
            f"User {current_user.username} deleted behavior record ID {record_id} for student {student_id_for_redirect}."
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error deleting behavior record ID {record_id} by {current_user.username}: {e}",
            exc_info=True,
        )
        flash(
            "An error occurred while deleting the record. Please try again.", "danger"
        )

    return redirect(
        url_for("view_student_behavior_records", user_id=student_id_for_redirect)
    )


# In PART 8 START: HR/CEO & System Admin Management Features


# Add a new asset
# Locate this existing route in PART 8
@app.route("/assets/add", methods=["GET", "POST"])
@login_required
# The role_required decorator handles the base roles.
# Specific leader checks are done inside the route.
@role_required(
    "hr_ceo", "system_admin", "teacher", "librarian", "student", "talent_club"
)
def add_asset():
    form = AddAssetForm()  # Your AddAssetForm definition
    current_user_role_name = current_user.role.name.lower()

    # --- Permission check for student/talent_club roles needing leader status ---
    if current_user_role_name == "student" and not current_user.is_leader:
        flash("Only student leaders can add assets.", "danger")
        abort(403)
    if (
        current_user_role_name == "talent_club" and not current_user.is_tc_leader
    ):  # Assuming system-wide TC Leader
        flash("Only Talent Club leaders can add assets.", "danger")
        abort(403)

    if form.validate_on_submit():
        final_category_id = None
        final_lab_id = None
        location_desc_to_save = (
            form.location_description.data.strip()
            if form.location_description.data
            else None
        )

        try:
            # --- Role-based Auto-Assignment Logic ---
            # (This logic was detailed in your original app.py Part 8. Ensure it's correctly adapted here)
            if current_user_role_name == "student" and current_user.is_leader:
                if not current_user.grade or not current_user.section:
                    flash(
                        "Your student profile (grade/section) is incomplete. Cannot determine classroom for asset.",
                        "danger",
                    )
                    return render_template(
                        "assets/add_asset.html",
                        form=form,
                        title="Add New Asset - Nexus",
                    )

                classroom_name = f"Grade {current_user.grade} Section {current_user.section} Classroom"
                classroom_lab = db.session.scalar(
                    select(Lab).filter_by(name=classroom_name)
                )
                if not classroom_lab:  # Create if not exists
                    classroom_lab = Lab(name=classroom_name)
                    db.session.add(classroom_lab)
                    db.session.flush()  # Get ID
                final_lab_id = classroom_lab.id

                classroom_category = db.session.scalar(
                    select(AssetCategory).filter_by(name="Classroom Assets")
                )
                if not classroom_category:  # Create if not exists
                    classroom_category = AssetCategory(
                        name="Classroom Assets",
                        description="Assets primarily used in classrooms.",
                    )
                    db.session.add(classroom_category)
                    db.session.flush()  # Get ID
                final_category_id = classroom_category.id
                location_desc_to_save = (
                    classroom_name  # Override user input for student leader
                )

            elif current_user_role_name == "teacher":
                final_lab_id = current_user.lab_id  # Teacher's assigned lab by default
                if form.suggested_lab_id.data and form.suggested_lab_id.data != 0:
                    final_lab_id = form.suggested_lab_id.data

                if (
                    form.suggested_category_id.data
                    and form.suggested_category_id.data != 0
                ):
                    final_category_id = form.suggested_category_id.data
                else:  # Default for teachers if not specified
                    lab_eq_cat = db.session.scalar(
                        select(AssetCategory).filter_by(name="Lab Equipment")
                    )
                    if lab_eq_cat:
                        final_category_id = lab_eq_cat.id
                    else:  # Fallback or error
                        flash(
                            "Default 'Lab Equipment' category not found. Please select a category or contact admin.",
                            "warning",
                        )
                        # return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus") # Optionally halt

            elif current_user_role_name == "librarian":
                library_lab = db.session.scalar(
                    select(Lab).filter_by(name="Main Library")
                )
                if not library_lab:  # Create if not exists
                    library_lab = Lab(name="Main Library")
                    db.session.add(library_lab)
                    db.session.flush()
                final_lab_id = library_lab.id
                location_desc_to_save = "Main Library"

                if (
                    form.suggested_category_id.data
                    and form.suggested_category_id.data != 0
                ):
                    final_category_id = form.suggested_category_id.data
                else:  # Default for librarians
                    books_cat = db.session.scalar(
                        select(AssetCategory).filter_by(name="Books")
                    )
                    if books_cat:
                        final_category_id = books_cat.id
                    else:
                        flash("Default 'Books' category not found.", "warning")

            elif current_user_role_name == "talent_club" and current_user.is_tc_leader:
                tc_hq_lab = db.session.scalar(
                    select(Lab).filter_by(name="Talent Club HQ")
                )
                if not tc_hq_lab:  # Create if not exists
                    tc_hq_lab = Lab(name="Talent Club HQ")
                    db.session.add(tc_hq_lab)
                    db.session.flush()
                final_lab_id = tc_hq_lab.id
                location_desc_to_save = "Talent Club HQ"

                if (
                    form.suggested_category_id.data
                    and form.suggested_category_id.data != 0
                ):
                    final_category_id = form.suggested_category_id.data
                else:  # Default for TC Leaders
                    tc_gear_cat = db.session.scalar(
                        select(AssetCategory).filter_by(name="Talent Club Gear")
                    )
                    if tc_gear_cat:
                        final_category_id = tc_gear_cat.id
                    else:
                        flash(
                            "Default 'Talent Club Gear' category not found.", "warning"
                        )

            elif current_user_role_name in ["hr_ceo", "system_admin"]:
                # HR/Admin use the form's direct suggestion if provided, otherwise it can be None
                if (
                    form.suggested_category_id.data
                    and form.suggested_category_id.data != 0
                ):
                    final_category_id = form.suggested_category_id.data
                if form.suggested_lab_id.data and form.suggested_lab_id.data != 0:
                    final_lab_id = form.suggested_lab_id.data
            else:  # Should not happen due to @role_required and leader checks
                flash("Unauthorized asset addition attempt.", "danger")
                abort(403)

            # --- Create Asset ---
            new_asset = Asset(
                name=form.name.data.strip(),
                description=(
                    form.description.data.strip() if form.description.data else None
                ),
                quantity=form.quantity.data,
                purchase_cost=(
                    form.purchase_cost.data
                    if form.purchase_cost.data is not None
                    else None
                ),
                condition=form.condition.data,
                is_consumable=form.is_consumable.data,
                expiry_date=(
                    form.expiry_date.data
                    if form.is_consumable.data and form.expiry_date.data
                    else None
                ),
                last_maintenance_date=form.last_maintenance_date.data,
                added_by_user_id=current_user.id,
                category_id=final_category_id,  # Can be None if not determined/selected
                lab_id=final_lab_id,  # Can be None
                location_description=location_desc_to_save,
                status="Pending Review",  # All new assets start as pending
            )
            db.session.add(new_asset)
            db.session.commit()

            notify_hr_ceo_new_asset(
                new_asset
            )  # Ensure this helper is correctly implemented

            flash(
                f"Asset '{new_asset.name}' added successfully and is now pending review.",
                "success",
            )
            app.logger.info(
                f"User {current_user.username} added asset '{new_asset.name}' (ID: {new_asset.id})."
            )
            return redirect(url_for("my_assets"))

        except IntegrityError as e:  # E.g. if asset name had a unique constraint
            db.session.rollback()
            app.logger.error(
                f"IntegrityError adding asset by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "Error: An asset with similar identifying information might already exist.",
                "danger",
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error adding asset by {current_user.username}: {e}", exc_info=True
            )
            flash(
                "An unexpected error occurred while adding the asset. Please try again.",
                "danger",
            )

    return render_template(
        "assets/add_asset.html", form=form, title="Add New Asset - Nexus"
    )


# Add this new route in PART 8, near other asset management routes
@app.route("/assets/<int:asset_id>/delete", methods=["POST"])
@login_required
# Only HR/CEO, System Admin, and relevant leaders can delete assets
@role_required("hr_ceo", "system_admin", "student", "talent_club")
def delete_asset(asset_id):
    """Deletes an asset from the system."""
    asset = db.get_or_404(Asset, asset_id)

    current_user_role_name = current_user.role.name.lower()

    # --- Fine-grained permission check for deletion ---
    # HR/CEO and System Admin can delete any asset.
    is_global_admin = current_user_role_name in ["hr_ceo", "system_admin"]

    # Student leaders can only delete assets they added AND are in their designated classroom lab/category
    is_student_leader_authorized = (
        current_user_role_name == "student"
        and current_user.is_leader
        and asset.added_by_user_id == current_user.id  # Must be the one who added it
        and asset.lab
        and current_user.grade
        and current_user.section  # Check if they have a lab and grade/section
        and asset.lab.name
        == f"Grade {current_user.grade} Section {current_user.section} Classroom"  # Must be in their classroom lab
    )

    # Talent Club leaders can only delete assets they added AND are in the Talent Club HQ lab/category
    is_tc_leader_authorized = (
        current_user_role_name == "talent_club"
        and current_user.is_tc_leader
        and asset.added_by_user_id == current_user.id  # Must be the one who added it
        and asset.lab
        and asset.lab.name == "Talent Club HQ"  # Must be in the Talent Club HQ lab
    )

    # Teachers and Librarians are NOT granted deletion permission here.
    # This aligns with the "only leaders can add/delete" for student/TC,
    # while teachers/librarians can add but not delete (HR/CEO handles deletion for them).

    if not (is_global_admin or is_student_leader_authorized or is_tc_leader_authorized):
        flash("You do not have permission to delete this asset.", "danger")
        app.logger.warning(
            f"Unauthorized delete attempt: User {current_user.username} (ID: {current_user.id}, Role: {current_user_role_name}, Leader: {current_user.is_leader}, TC Leader: {current_user.is_tc_leader}) "
            f"tried to delete asset ID {asset.id} (Added by: {asset.added_by_user_id}, Lab: {asset.lab.name if asset.lab else 'N/A'})."
        )
        abort(403)

    try:
        db.session.delete(asset)
        db.session.commit()
        flash(f"Asset '{asset.name}' deleted successfully.", "success")
        app.logger.info(
            f"User {current_user.username} (ID: {current_user.id}) deleted asset '{asset.name}' (ID: {asset.id})."
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error deleting asset ID {asset.id} by {current_user.username} (ID: {current_user.id}): {e}",
            exc_info=True,
        )
        flash("An error occurred while deleting the asset. Please try again.", "danger")

    # Redirect to appropriate asset list
    return redirect(url_for("my_assets"))  # Or list_all_assets


# Add this new route, potentially in PART 8 or a new "Asset Views" section
@app.route("/assets/all")
@login_required  # All authenticated users can view this
def list_all_assets():
    """Displays a list of all assets visible to the current user, with basic filtering."""
    # Query for all active assets
    # We can add filters based on query parameters (e.g., category, status, lab)
    # For universal view, let's include assets that are "available", "pending review", "under maintenance"
    # but exclude "retired", "lost". HR/CEO can see all.

    # Fetch basic filter parameters from the request query string
    category_filter = request.args.get("category", "all").strip()
    status_filter = request.args.get(
        "status", "available_active"
    ).strip()  # New status filter options
    lab_filter = request.args.get("lab", "all").strip()
    search_query = request.args.get("search", "").strip()
    page = request.args.get("page", 1, type=int)
    per_page = 20  # Number of assets per page

    assets_query = select(Asset).options(
        joinedload(Asset.category),  # Eager load category
        joinedload(Asset.lab),  # Eager load lab
        joinedload(Asset.added_by_user),  # Eager load who added it
    )

    # Apply role-based visibility to the query (HR/CEO sees everything)
    if current_user.role.name.lower() not in ["hr_ceo", "system_admin"]:
        # Non-HR/CEO/System Admin users might only see 'Available', 'Under Maintenance', 'Needs Repair' etc.
        # but not 'Pending Review' (unless they added it) or 'Retired', 'Lost' unless they have specific permission.
        # For simplicity, let's define what IS generally visible.
        assets_query = assets_query.where(
            Asset.status.in_(
                ["Available", "Under Maintenance", "Needs Repair", "CheckedOut"]
            )
            # Optionally: only show assets they have a direct connection to, e.g. for student leaders, only assets in their classroom
            # For this route, the requirement is "every one can view".
            # The `my_assets` route (if you implement it specifically for different roles) would be for personalized views.
        )
    else:  # HR/CEO, System Admin
        # They see all assets, including 'Pending Review', 'Retired', 'Lost'
        pass

    # Apply Category Filter
    if category_filter != "all":
        category_obj = db.session.scalar(
            select(AssetCategory).filter_by(name=category_filter)
        )
        if category_obj:
            assets_query = assets_query.where(Asset.category_id == category_obj.id)
        else:
            flash(f"Invalid category filter: {category_filter}", "warning")
            category_filter = "all"  # Reset to all

    # Apply Status Filter
    if status_filter == "available_active":
        # Assets that are available for use or actively in use/maintenance
        assets_query = assets_query.where(
            Asset.status.in_(
                ["Available", "CheckedOut", "Under Maintenance", "Needs Repair"]
            )
        )
    elif status_filter == "pending_review":
        assets_query = assets_query.where(Asset.status == "Pending Review")
    elif status_filter == "retired_lost":
        assets_query = assets_query.where(Asset.status.in_(["Retired", "Lost"]))
    # 'all' status filter is covered by the base query (or hr_ceo/system_admin above)

    # Apply Lab Filter
    if lab_filter != "all":
        lab_obj = db.session.scalar(select(Lab).filter_by(name=lab_filter))
        if lab_obj:
            assets_query = assets_query.where(Asset.lab_id == lab_obj.id)
        else:
            flash(f"Invalid lab filter: {lab_filter}", "warning")
            lab_filter = "all"  # Reset to all

    # Apply Search Query
    if search_query:
        assets_query = assets_query.where(
            or_(
                Asset.name.ilike(f"%{search_query}%"),
                Asset.description.ilike(f"%{search_query}%"),
                Asset.location_description.ilike(f"%{search_query}%"),
            )
        )

    # Order assets for display
    assets_query = assets_query.order_by(Asset.name.asc())

    # Paginate the results
    paginated_assets = db.paginate(
        assets_query, page=page, per_page=per_page, error_out=False
    )

    # Get all categories and labs for filter dropdowns
    all_categories = db.session.scalars(
        select(AssetCategory).order_by(AssetCategory.name)
    ).all()
    all_labs = db.session.scalars(select(Lab).order_by(Lab.name)).all()

    return render_template(
        "assets/all_assets.html",
        paginated_assets=paginated_assets,
        all_categories=all_categories,
        all_labs=all_labs,
        category_filter=category_filter,
        status_filter=status_filter,
        lab_filter=lab_filter,
        search_query=search_query,
        title="All School Assets",
    )


# Example my_assets (if you have one, modify it like this)
@app.route("/my_assets")
@login_required
def my_assets():
    """Displays assets added by the current user."""
    user_added_assets = db.session.scalars(
        select(Asset)
        .where(Asset.added_by_user_id == current_user.id)
        .order_by(Asset.name.asc())
    ).all()
    # You might also want to show books checked out, etc., here depending on role.
    return render_template(
        "assets/my_assets.html", assets=user_added_assets, title="My Added Assets"
    )


# Route for reporting an issue for a specific asset (clicking  next to a listed asset)
@app.route("/asset/<int:asset_id>/report", methods=["GET", "POST"])
@login_required
# Roles who can report on a specific asset (assuming they can view it)
@role_required(
    "hr_ceo", "system_admin", "teacher", "librarian", "talent_club", "student"
)
def report_asset_specific(asset_id):
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")
    form = ReportAssetForm()  # Your ReportAssetForm definition

    if form.validate_on_submit():
        try:
            new_report = AssetReport(
                asset_id=asset.id,  # Link to the specific asset
                reported_by_id=current_user.id,
                damage_description=form.damage_description.data.strip(),
                date_of_damage=form.date_of_damage.data,  # WTForms converts to date object or None
                quantity_damaged=form.quantity_damaged.data,
                status="Pending",  # New reports default to Pending
                report_date=datetime.now(timezone.utc),
            )
            db.session.add(new_report)
            db.session.commit()  # Commit to get report ID for notification

            notify_hr_ceo_new_report(
                new_report
            )  # Ensure this helper is correctly implemented

            flash(
                f"Issue reported successfully for asset '{asset.name}'. An administrator will review it.",
                "success",
            )
            app.logger.info(
                f"User {current_user.username} reported issue for asset ID {asset.id} (Report ID: {new_report.id})."
            )

            # Redirect back to where they came from, or a sensible default
            # If they came from all_assets or my_assets, request.referrer would be good.
            # If direct link, maybe redirect to asset detail or user's dashboard.
            return redirect(request.referrer or url_for("list_all_assets"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error submitting specific asset report for asset ID {asset.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while submitting the report. Please try again.",
                "danger",
            )
            # Re-render the form with errors, form data is preserved by WTForms

    # For GET request or if form validation failed on POST
    return render_template(
        "assets/report_asset_specific.html",
        form=form,
        asset=asset,
        title=f"Report Issue for: {asset.name} - Nexus",
    )


# Route for a general asset report (clicking  next to 'Add Assets')
# This route handles reports that are not initially linked to a specific asset ID.
@app.route("/report/general", methods=["GET", "POST"])
@login_required
# Roles who can submit a general report
@role_required(
    "hr_ceo", "system_admin", "teacher", "librarian", "talent_club", "student"
)
def report_asset_general():
    form = ReportAssetForm()  # Your ReportAssetForm definition

    if form.validate_on_submit():
        try:
            # Get the user-provided asset description if they filled it in the template
            user_provided_asset_name_desc = request.form.get(
                "asset_name_description", ""
            ).strip()

            full_damage_description = form.damage_description.data.strip()
            if user_provided_asset_name_desc:
                # Prepend it to the main damage description for context
                full_damage_description = f"Reported Item (User Described): {user_provided_asset_name_desc}\n\nIssue Details:\n{full_damage_description}"

            new_report = AssetReport(
                asset_id=None,  # General report, not linked to a specific asset initially
                reported_by_id=current_user.id,
                damage_description=full_damage_description,  # Save combined description
                date_of_damage=form.date_of_damage.data,
                quantity_damaged=form.quantity_damaged.data,
                status="Pending",
                report_date=datetime.now(timezone.utc),
            )
            db.session.add(new_report)
            db.session.commit()

            notify_hr_ceo_new_report(
                new_report
            )  # Ensure this helper is correctly implemented

            flash(
                "General issue report submitted successfully. An administrator will review it.",
                "success",
            )
            app.logger.info(
                f"User {current_user.username} submitted a general asset report (Report ID: {new_report.id})."
            )

            # Redirect to a relevant page, e.g., user's dashboard or a "my reports" page if it exists
            return redirect(url_for(f"{current_user.role.name.lower()}_dashboard"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error submitting general asset report by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while submitting the general report. Please try again.",
                "danger",
            )
            # Re-render form with errors

    # For GET request or if form validation failed on POST
    return render_template(
        "assets/report_asset_general.html",
        form=form,
        title="Report General Asset Issue - Nexus",
    )


# --- HR/CEO Specific Asset Management Routes ---
# In app.py, find and modify the list_pending_assets route

@app.route("/hr_ceo/assets/pending")
@login_required
@role_required("hr_ceo", "system_admin")
def list_pending_assets():
    pending_assets = db.session.scalars(
        select(Asset)
        .options(
            joinedload(Asset.added_by_user).joinedload(User.role),
            joinedload(Asset.category),
            joinedload(Asset.lab),
        )
        .where(Asset.status == "Pending Review")
        .order_by(Asset.created_at.asc())
    ).all()

    # ADD THIS LINE: Instantiate a form for CSRF protection on the page.
    csrf_form = CSRFOnlyForm()

    return render_template(
        "hr_ceo/pending_assets.html",
        pending_assets=pending_assets,
        csrf_form=csrf_form,  # ADD THIS: Pass the form to the template.
        title="Assets Pending Review - Nexus",
    )


# Edit/Review a specific asset (for HR/CEO & System Admin)
@app.route(
    "/assets/<int:asset_id>/edit", methods=["GET", "POST"]
)  # Ensure path is correct
@login_required
@role_required("hr_ceo", "system_admin")  # Only these roles can edit full asset details
def edit_asset(asset_id):
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")
    # EditAssetForm is defined in your app.py or forms.py
    form = EditAssetForm(obj=asset)  # Pre-populate form with existing asset data on GET

    if form.validate_on_submit():
        try:
            old_status = asset.status  # Store old status for notification logic

            # Update asset fields from form data
            asset.name = form.name.data.strip()
            asset.description = (
                form.description.data.strip() if form.description.data else None
            )
            asset.quantity = form.quantity.data
            asset.purchase_cost = (
                form.purchase_cost.data if form.purchase_cost.data is not None else None
            )

            # Ensure category_id is handled correctly (it's required in the form)
            if (
                form.category_id.data and form.category_id.data != 0
            ):  # Assuming 0 might be a "no selection" placeholder if form allows
                asset.category_id = form.category_id.data
            else:  # This case should ideally be caught by form.category_id.validators=[DataRequired()]
                flash("Asset category is required.", "danger")
                return render_template(
                    "assets/edit_asset.html",
                    form=form,
                    asset=asset,
                    title=f"Edit Asset: {asset.name} - Nexus",
                )

            asset.status = form.status.data
            asset.condition = form.condition.data
            asset.is_consumable = form.is_consumable.data

            if asset.is_consumable and form.expiry_date.data:
                asset.expiry_date = form.expiry_date.data
            elif not asset.is_consumable:
                asset.expiry_date = None  # Clear expiry if not consumable

            asset.last_maintenance_date = form.last_maintenance_date.data

            asset.lab_id = (
                form.lab_id.data if form.lab_id.data and form.lab_id.data != 0 else None
            )
            asset.location_description = (
                form.location_description.data.strip()
                if form.location_description.data
                else None
            )

            # Asset.updated_at should be handled by onupdate in the model if defined,
            # otherwise, set it manually:
            # asset.last_updated_at = datetime.now(timezone.utc)

            db.session.commit()

            # Notification logic: Notify original adder if status changed from "Pending Review"
            if (
                old_status == "Pending Review"
                and asset.status != "Pending Review"
                and asset.added_by_user
            ):
                if asset.added_by_user.is_active:
                    try:
                        message_content = f"Your submitted asset '{asset.name}' (ID: {asset.id}) has been reviewed. New status: '{asset.status}'."
                        # Link to a viewable page for the user, not necessarily the edit page
                        link_url = url_for(
                            "my_assets", _external=True
                        )  # Or a specific asset view if available for them

                        # Ensure is_notification_allowed is checked
                        if is_notification_allowed(current_user, asset.added_by_user):
                            notification = Notification(
                                sender_id=current_user.id,
                                receiver_id=asset.added_by_user_id,
                                content=message_content,
                                link_url=link_url,
                                timestamp=datetime.now(timezone.utc),
                                notification_type="asset_status_change",  # Add a specific type
                            )
                            db.session.add(notification)
                            db.session.commit()  # Commit notification separately
                            app.logger.info(
                                f"Notified user {asset.added_by_user_id} about asset {asset.id} status change to '{asset.status}'."
                            )
                    except Exception as notify_e:
                        db.session.rollback()  # Rollback only notification part
                        app.logger.error(
                            f"Error sending asset status change notification to {asset.added_by_user_id}: {notify_e}",
                            exc_info=True,
                        )

            flash(
                f"Asset '{asset.name}' updated successfully. Status is now '{asset.status}'.",
                "success",
            )
            app.logger.info(f"User {current_user.username} edited asset ID {asset.id}.")

            if asset.status == "Pending Review":
                return redirect(url_for("list_pending_assets"))
            else:
                return redirect(
                    url_for("list_all_assets")
                )  # Or back to where they came from

        except IntegrityError:
            db.session.rollback()
            flash(
                "Error: Could not update asset. A similar asset might already exist or there was a data conflict.",
                "danger",
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error editing asset ID {asset.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while updating the asset. Please try again.",
                "danger",
            )

    return render_template(
        "assets/edit_asset.html",
        form=form,
        asset=asset,
        title=f"Edit Asset: {asset.name} - Nexus",
    )


# List all asset reports (for HR/CEO & System Admin)
@app.route("/hr_ceo/reports")
@login_required
@role_required("hr_ceo", "system_admin")
def list_asset_reports():
    # Add pagination and filtering later if needed
    reports_query = (
        select(AssetReport)
        .options(
            joinedload(AssetReport.asset).joinedload(
                Asset.category
            ),  # Load asset and its category
            joinedload(AssetReport.reporter).joinedload(
                User.role
            ),  # Load reporter and their role
            joinedload(AssetReport.resolver).joinedload(
                User.role
            ),  # Load resolver and their role
        )
        .order_by(
            # Custom order for status: Pending, In Progress, then others, then Resolved/Rejected
            case(
                (AssetReport.status == "Pending", 1),
                (AssetReport.status == "In Progress", 2),
                (AssetReport.status == "Resolved", 4),
                (AssetReport.status == "Rejected", 5),
                else_=3,
            ).asc(),
            AssetReport.report_date.desc(),
        )
    )
    reports = db.session.scalars(reports_query).all()

    return render_template(
        "hr_ceo/list_reports.html", reports=reports, title="All Asset Reports - Nexus"
    )


@app.route("/hr_ceo/report/<int:report_id>/resolve", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def resolve_asset_report(report_id):
    report = db.get_or_404(
        AssetReport, report_id, description="Asset report not found."
    )
    # Ensure related asset, reporter, resolver are loaded for display in template if needed
    # The query in list_asset_reports already does this, but direct access might not.
    # For simplicity, assume they are accessible via report.asset, report.reporter etc.
    # Or load them explicitly:
    # report = db.session.query(AssetReport).options(joinedload...)...get()

    form = ResolveReportForm(obj=report)  # Pre-populate with existing data

    # Logic for potentially linking a general report to an asset (if form.link_to_asset_id exists)
    # This was commented out in the template; if implementing, handle it here.
    # if not report.asset_id and hasattr(form, 'link_to_asset_id'):
    #     # Populate choices for form.link_to_asset_id
    #     form.link_to_asset_id.choices = [(0, '--- Select Asset to Link (Optional) ---')] + \
    #                                     [(a.id, f"{a.name} (ID: {a.id})") for a in db.session.scalars(select(Asset).order_by(Asset.name)).all()]

    if form.validate_on_submit():
        try:
            old_status = report.status

            report.status = form.status.data
            report.resolution_notes = (
                form.resolution_notes.data.strip()
                if form.resolution_notes.data
                else None
            )

            # Handle asset linking for general reports if implemented
            # if not report.asset_id and hasattr(form, 'link_to_asset_id') and form.link_to_asset_id.data and form.link_to_asset_id.data != 0:
            #    report.asset_id = form.link_to_asset_id.data

            if report.status in ["Resolved", "Rejected"] and old_status not in [
                "Resolved",
                "Rejected",
            ]:
                report.resolved_by_id = current_user.id
                report.resolved_date = datetime.now(timezone.utc)
            elif report.status not in ["Resolved", "Rejected"] and old_status in [
                "Resolved",
                "Rejected",
            ]:
                report.resolved_by_id = None
                report.resolved_date = None

            # Update related asset's status/condition if report is "Resolved"
            if (
                report.asset
                and report.status == "Resolved"
                and old_status != "Resolved"
            ):
                asset_to_update = report.asset
                if asset_to_update.status in [
                    "Needs Repair",
                    "Under Maintenance",
                    "Lost",
                ]:  # Or other problematic statuses
                    asset_to_update.status = "Available"
                    # Optionally, update condition if relevant
                    if asset_to_update.condition in ["Poor", "Needs Repair", "Broken"]:
                        asset_to_update.condition = "Good"  # Or "Fair"
                app.logger.info(
                    f"Asset ID {asset_to_update.id} status/condition updated due to resolved report {report.id}."
                )

            db.session.commit()

            notify_reporter_report_update(
                report
            )  # Ensure this helper is correctly implemented

            flash(
                f"Report ID {report.id} status updated to '{report.status}'.", "success"
            )
            app.logger.info(
                f"User {current_user.username} updated report ID {report.id} to status '{report.status}'."
            )
            return redirect(url_for("list_asset_reports"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error resolving report ID {report.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while updating the report. Please try again.",
                "danger",
            )

    # For GET, pass the report (and its asset) and form to the template
    return render_template(
        "hr_ceo/resolve_report.html",
        form=form,
        report=report,
        asset=report.asset,  # Pass asset explicitly if needed by template beyond report.asset
        title=f"Resolve Report ID: {report.id} - Nexus",
    )


# Route for HR/CEO to manage asset categories (list, add form)
@app.route("/hr_ceo/asset_categories")
@login_required
@role_required("hr_ceo", "system_admin")
def manage_asset_categories():
    # Fetch all asset categories, ordered by name
    # Eager load assets count if your model has a direct count or efficient way
    # For simplicity, template uses category.assets.count() which might do N+1 if not careful.
    # Consider adding a count property or subquery if performance becomes an issue for many categories.
    categories = db.session.scalars(
        select(AssetCategory).order_by(AssetCategory.name.asc())
        # .options(selectinload(AssetCategory.assets)) # If you want to iterate assets in template for count, but .count() is usually better
    ).all()

    add_form = AddCategoryForm()  # Your AddCategoryForm definition

    return render_template(
        "hr_ceo/manage_categories.html",
        categories=categories,
        add_form=add_form,  # Pass the form for adding new categories
        title="Manage Asset Categories - Nexus",
    )


# Add new category (POST only)
@app.route("/hr_ceo/asset_categories/add", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def add_asset_category():
    # This route now primarily handles the POST from the manage_asset_categories page's form
    add_form = AddCategoryForm()  # Instantiate the form to validate against

    if add_form.validate_on_submit():
        try:
            new_category_name = add_form.name.data.strip()
            # Check for existing category with the same name (case-insensitive)
            existing_category = db.session.scalar(
                select(AssetCategory).filter(
                    func.lower(AssetCategory.name) == func.lower(new_category_name)
                )
            )
            if existing_category:
                flash(f"Asset category '{new_category_name}' already exists.", "danger")
            else:
                new_category = AssetCategory(
                    name=new_category_name,
                    description=(
                        add_form.description.data.strip()
                        if add_form.description.data
                        else None
                    ),
                )
                db.session.add(new_category)
                db.session.commit()
                flash(
                    f"Asset category '{new_category.name}' added successfully.",
                    "success",
                )
                app.logger.info(
                    f"User {current_user.username} added asset category '{new_category.name}'."
                )
        except (
            IntegrityError
        ):  # Should be caught by the name check above, but as a fallback
            db.session.rollback()
            flash(
                "Asset category with this name already exists or another database error occurred.",
                "danger",
            )
            app.logger.warning(
                f"IntegrityError while adding asset category: {add_form.name.data} by {current_user.username}."
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error adding asset category by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while adding the category. Please try again.",
                "danger",
            )
    else:
        # If form validation fails (e.g., name is empty)
        for field, errors in add_form.errors.items():
            for error in errors:
                flash(
                    f"Error in {getattr(add_form, field).label.text}: {error}", "danger"
                )

    return redirect(url_for("manage_asset_categories"))  # Always redirect back


# Edit category (GET and POST)
@app.route("/hr_ceo/asset_category/<int:category_id>/edit", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def edit_asset_category(category_id):
    category = db.get_or_404(
        AssetCategory, category_id, description="Asset category not found."
    )
    # EditCategoryForm is defined in your app.py or forms.py
    form = EditCategoryForm(obj=category)  # Pre-populate with existing data on GET

    if form.validate_on_submit():
        try:
            new_name = form.name.data.strip()
            # Check if new name conflicts with another existing category (case-insensitive)
            existing_category_with_new_name = db.session.scalar(
                select(AssetCategory).filter(
                    AssetCategory.id
                    != category.id,  # Exclude the current category being edited
                    func.lower(AssetCategory.name) == func.lower(new_name),
                )
            )
            if existing_category_with_new_name:
                flash(
                    f"Another asset category named '{new_name}' already exists.",
                    "danger",
                )
            else:
                category.name = new_name
                category.description = (
                    form.description.data.strip() if form.description.data else None
                )
                # category.updated_at = datetime.now(timezone.utc) # If you have an updated_at field
                db.session.commit()
                flash(
                    f"Asset category '{category.name}' updated successfully.", "success"
                )
                app.logger.info(
                    f"User {current_user.username} edited asset category ID {category.id} to '{category.name}'."
                )
                return redirect(url_for("manage_asset_categories"))
        except IntegrityError:  # Fallback, should be caught by name check
            db.session.rollback()
            flash(
                f"Update failed. A category named '{form.name.data.strip()}' might already exist.",
                "danger",
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error editing asset category ID {category_id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while updating the category. Please try again.",
                "danger",
            )

    # For GET request or if form validation failed on POST
    return render_template(
        "hr_ceo/edit_category.html",
        form=form,
        category=category,
        title=f"Edit Category: {category.name} - Nexus",
    )


# Delete category (POST only, with safety checks)
@app.route("/hr_ceo/asset_category/<int:category_id>/delete", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def delete_asset_category(category_id):
    category = db.get_or_404(
        AssetCategory, category_id, description="Asset category not found."
    )

    # Check dependencies: assets and channels
    # Assuming 'assets' and 'channels' are the correct relationship names on AssetCategory model
    asset_count = (
        category.assets.count()
        if hasattr(category, "assets")
        else db.session.scalar(
            select(func.count(Asset.id)).where(Asset.category_id == category.id)
        )
        or 0
    )

    # The original SocialCategory model (and its relationship to Channel) was used for channels
    # If AssetCategory is also used by Channel (which it was in some of your model snippets), check that too.
    # Based on frontend, AssetCategory does not link to Channel, but SocialCategory does.
    # Let's assume AssetCategory ONLY links to Asset for this check.
    # If Channel can also link to AssetCategory, this check needs to be updated:
    # channel_count = category.channels.count() if hasattr(category, 'channels') else \
    #                 db.session.scalar(select(func.count(Channel.id)).where(Channel.category_id == category.id)) or 0
    # For now, assuming channels use SocialCategory, not AssetCategory.

    if asset_count > 0:
        flash(
            f"Cannot delete category '{category.name}' because {asset_count} asset(s) are still assigned to it. Please reassign them first.",
            "danger",
        )
        app.logger.warning(
            f"Attempted to delete asset category ID {category_id} ('{category.name}') with {asset_count} linked assets."
        )
    # elif channel_count > 0: # If channels could use AssetCategory
    #     flash(f"Cannot delete category '{category.name}' because {channel_count} social channel(s) are still using it.", "danger")
    else:
        try:
            db.session.delete(category)
            db.session.commit()
            flash(f"Asset category '{category.name}' deleted successfully.", "success")
            app.logger.info(
                f"User {current_user.username} deleted asset category ID {category.id} ('{category.name}')."
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error deleting asset category ID {category_id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while deleting the category. Please try again.",
                "danger",
            )

    return redirect(url_for("manage_asset_categories"))


# --- HR Student Leader Management ---
@app.route("/hr_ceo/manage_student_leaders", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")  # Allow System Admin
def manage_student_leaders():
    """Displays student leaders and allows assigning students to leaders or toggling leader status."""

    # This part handles the POST request for assigning students to a leader.
    # We instantiate the form here for both GET/POST, ensuring it's available for re-rendering on POST failure.
    # The current_leaders argument will be populated for the GET request logic later.
    form = AssignLeaderForm()

    if (
        form.validate_on_submit()
    ):  # If the 'Assign Students' form was submitted and valid
        selected_leader_id = form.leader.data
        selected_leader = db.session.get(User, selected_leader_id)

        # Basic validation for the selected leader from the dropdown
        if (
            not selected_leader
            or not selected_leader.is_leader  # Must be marked as a leader to be assigned followers
            or selected_leader.role.name.lower() != "student"
            or not selected_leader.is_active
        ):
            flash(
                "Invalid leader selected for assignment. Please select an active student leader.",
                "danger",
            )
        # Ensure the selected leader has a grade and section, which is crucial for section leadership
        elif not selected_leader.grade or not selected_leader.section:
            flash(
                f"The selected leader ({selected_leader.full_name or selected_leader.username}) does not have a grade or section assigned and cannot be used to lead a section.",
                "danger",
            )
        else:
            # Get the list of student IDs from the checkboxes submitted in the template
            # Assumes checkbox names are "students_to_assign" and values are student.id
            selected_student_ids_str = request.form.getlist("students_to_assign")
            selected_student_ids = [
                int(sid) for sid in selected_student_ids_str if sid.isdigit()
            ]

            if not selected_student_ids:
                flash("No students selected to assign to the leader.", "warning")
            else:
                assigned_count = 0
                skipped_count = 0
                try:
                    # Fetch the students who were selected to be assigned, ensuring they are active students
                    students_to_update_stmt = (
                        select(User)
                        .join(Role)
                        .where(
                            User.id.in_(selected_student_ids),
                            Role.name == "student",
                            User.is_active == True,
                        )
                    )
                    students_to_update = db.session.scalars(
                        students_to_update_stmt
                    ).all()

                    for student in students_to_update:
                        # Crucial check: Only assign students if they are in the *same* grade and section as the leader
                        if (
                            student.id
                            != selected_leader.id  # Cannot assign the leader to follow themselves
                            and student.grade == selected_leader.grade
                            and student.section == selected_leader.section
                        ):
                            student.leader_id = (
                                selected_leader.id
                            )  # Update the student's leader_id
                            assigned_count += 1
                        else:
                            skipped_count += 1
                            if student.id == selected_leader.id:
                                flash(
                                    f"Skipped {student.full_name or student.username}: Cannot assign a leader to follow themselves.",
                                    "warning",
                                )
                            elif (
                                student.grade != selected_leader.grade
                                or student.section != selected_leader.section
                            ):
                                flash(
                                    f"Skipped {student.full_name or student.username}: Student is in a different grade/section ({student.grade}-{student.section}) than the selected leader ({selected_leader.grade}-{selected_leader.section}).",
                                    "warning",
                                )

                    if assigned_count > 0:
                        db.session.commit()  # Commit the updates
                        flash(
                            f"{assigned_count} student(s) successfully assigned to leader {selected_leader.full_name or selected_leader.username}.",
                            "success",
                        )
                        app.logger.info(
                            f"{assigned_count} students assigned to leader {selected_leader.username} by {current_user.username}"
                        )
                    if skipped_count > 0:
                        # Only show this general message if specific ones were shown above
                        flash(
                            f"{skipped_count} student(s) were skipped (check messages above for reasons).",
                            "info",
                        )

                    # Redirect back to the manage leaders page to see updated assignments
                    return redirect(url_for("manage_student_leaders"))
                except Exception as e:
                    db.session.rollback()  # Rollback if any database operation failed
                    app.logger.error(
                        f"Error assigning students to leader {selected_leader.username}: {e}",
                        exc_info=True,
                    )
                    flash(
                        "An unexpected error occurred while assigning students. Please try again.",
                        "danger",
                    )

    # --- Handle GET request or failed POST (if POST failed, form will retain data) ---
    # Fetch all active students with their grade/section, ordered for display
    # Eager load their leader if available (the User object pointed to by leader_id)
    all_students_stmt = (
        select(User)
        .join(Role)
        .where(Role.name == "student", User.is_active == True)
        .options(
            joinedload(User.leader)
        )  # Eager load the leader object for each student
        .order_by(User.grade, User.section, User.full_name)  # Sort for logical grouping
    )
    all_students = db.session.scalars(all_students_stmt).all()

    # Students currently marked as leaders (is_leader=True) and have grade/section defined
    current_leaders = [s for s in all_students if s.is_leader and s.grade and s.section]

    # Re-instantiate form here to ensure choices are fresh for GET request, or on POST re-render.
    # This must be done *after* `current_leaders` is determined.
    form = AssignLeaderForm(
        current_leaders=current_leaders
    )  # Populate dropdown for leader assignment

    # Group students by grade and section for easier display in the template
    # `defaultdict` is perfect for this, default value is a dictionary with three lists/slots
    students_by_grade_section = defaultdict(
        lambda: {"leader": None, "unassigned_students": [], "followers": []}
    )

    for s in all_students:
        # Create a tuple key for grade and section, handling cases where they might be None
        key = (s.grade or "N/A_Grade", s.section or "N/A_Section")

        if s.is_leader:
            # This student is a designated leader for their section
            students_by_grade_section[key]["leader"] = s
            # A leader's own leader_id should logically be None. If not, it's a data anomaly.
            if s.leader_id is not None:
                app.logger.warning(
                    f"Leader {s.username} (G:{s.grade}, S:{s.section}) has a non-None leader_id ({s.leader_id}). This should be cleared for data consistency, but the system continues."
                )
        else:
            # This student is not a leader themselves
            # Check if their `leader_id` points to the designated leader for their section
            current_section_leader = students_by_grade_section[key][
                "leader"
            ]  # Already populated if leader was processed

            if current_section_leader and s.leader_id == current_section_leader.id:
                # Student is correctly assigned to the leader of their section
                students_by_grade_section[key]["followers"].append(s)
            else:
                # Student is not a leader, and is either unassigned or assigned to an incorrect/non-existent leader
                students_by_grade_section[key]["unassigned_students"].append(s)

    # Sort the top-level keys (grade-section tuples)
    sorted_grade_section_keys = sorted(students_by_grade_section.keys())

    # Create a new ordered dictionary to store the sorted data, with inner lists also sorted
    sorted_students_by_grade_section = {}
    for key in sorted_grade_section_keys:
        block_data = students_by_grade_section[key]
        # Sort unassigned students alphabetically by full name
        block_data["unassigned_students"] = sorted(
            block_data["unassigned_students"],
            key=lambda stu: stu.full_name or stu.username,
        )
        # Sort followers alphabetically by full name
        block_data["followers"] = sorted(
            block_data["followers"], key=lambda stu: stu.full_name or stu.username
        )
        sorted_students_by_grade_section[key] = block_data

    return render_template(
        "hr_ceo/student_leaders.html",
        form=form,  # Pass the AssignLeader form (used for the leader dropdown and its POST validation)
        students_by_grade_section=sorted_students_by_grade_section,  # Grouped students for display and checkboxes
        current_leaders=current_leaders,  # Still useful for a quick list of leaders (e.g., in a sidebar)
        title="Manage Student Leaders & Assignments",
    )


# Route to toggle the is_leader status of a single student (POST only)
@app.route("/hr_ceo/toggle_leader_status/<int:student_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")  # Allow System Admin
def toggle_student_leader_status(student_id):
    """Toggles the 'is_leader' status for a specific student, enforcing one leader per grade-section."""
    student = db.session.get(User, student_id)

    # Validate that the user exists, is a student, and is active
    if not student or student.role.name.lower() != "student" or not student.is_active:
        flash("User not found, is not a student, or is inactive.", "danger")
        return redirect(request.referrer or url_for("manage_student_leaders"))

    # Ensure the student has a grade and section assigned
    if not student.grade or not student.section:
        flash(
            f"Student {student.full_name or student.username} must have a grade and section assigned before being promoted/demoted as a section leader.",
            "danger",
        )
        return redirect(request.referrer or url_for("manage_student_leaders"))

    try:
        action_message = ""
        if student.is_leader:
            # --- Demoting a leader ---
            student.is_leader = False
            # Also, unset the `leader_id` for any students who were following this demoted leader
            # This ensures orphaned leader_ids are cleared.
            db.session.query(User).filter(User.leader_id == student.id).update(
                {User.leader_id: None}, synchronize_session=False
            )

            action_message = f"{student.full_name or student.username} is no longer the leader for Grade {student.grade}, Section {student.section}."
            app.logger.info(
                f"HR/CEO {current_user.username} (ID: {current_user.id}) demoted student {student.username} (ID: {student.id}) from leader status for G:{student.grade} S:{student.section}."
            )
        else:
            # --- Promoting a leader ---
            # Check if there's already a leader for this student's grade and section
            existing_leader = db.session.scalar(
                select(User)
                .where(
                    User.grade == student.grade,
                    User.section == student.section,
                    User.is_leader == True,  # Look for an existing leader flag
                    User.id
                    != student.id,  # Exclude the current student in case of self-promotion scenario
                    User.is_active == True,  # Only active leaders
                )
                .join(Role)
                .filter(Role.name == "student")  # Ensure it's a student leader
            )

            if existing_leader:
                flash(
                    f"A leader ({existing_leader.full_name or existing_leader.username}) already exists for Grade {student.grade}, Section {student.section}. Please demote them first.",
                    "danger",
                )
                return redirect(request.referrer or url_for("manage_student_leaders"))

            # No existing leader found for this section, proceed with promotion
            student.is_leader = True
            student.leader_id = None  # A leader does not follow anyone

            action_message = f"{student.full_name or student.username} is now the leader for Grade {student.grade}, Section {student.section}."
            app.logger.info(
                f"HR/CEO {current_user.username} (ID: {current_user.id}) promoted student {student.username} (ID: {student.id}) to leader status for G:{student.grade} S:{student.section}."
            )

            # Assign this new leader to ALL other active students in the same grade and section
            # Exclude the new leader themselves.
            db.session.query(User).filter(
                User.grade == student.grade,
                User.section == student.section,
                User.id != student.id,  # Exclude the new leader
                User.is_active == True,
                User.role_id == student.role_id,  # Ensure they are students
            ).update({User.leader_id: student.id}, synchronize_session=False)

        db.session.commit()  # Commit the change to the student's is_leader status and potentially followers' leader_id
        flash(action_message, "success")

    except Exception as e:
        db.session.rollback()  # Rollback on error
        app.logger.error(
            f"Error toggling leader status for student {student_id} ({student.username}) by {current_user.username}: {e}",
            exc_info=True,
        )
        flash(
            "An error occurred while updating leader status. Please try again.",
            "danger",
        )

    # Redirect back to the manage leaders page
    return redirect(request.referrer or url_for("manage_student_leaders"))


# --- PART 8 END: HR/CEO & System Admin Management Features ---

# --- PART 9 START: Book Checkout & Management ---


# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Asset, AssetCategory, BookCheckout, BorrowedAsset are defined.
# - Forms: BookCheckoutForm is defined.
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, joinedload, etc.), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify, paginate), and other Python imports (datetime, timezone, date) are available.
@app.route("/books/checkout", methods=["GET", "POST"])
@login_required
@role_required("librarian", "student")
def checkout_book():
    is_librarian = current_user.role.name.lower() == "librarian"
    form = BookCheckoutForm()
    if request.method == "GET" and is_librarian:
        user_id_to_prefill = request.args.get("user_id_prefill", type=int)
        if user_id_to_prefill and hasattr(form, "user_id"):
            if form.user_id.choices and any(
                user_id_to_prefill == choice[0] for choice in form.user_id.choices
            ):
                form.user_id.data = user_id_to_prefill
    if form.validate_on_submit():
        asset_id_to_checkout = form.asset_id.data
        due_date_from_form = form.due_date.data
        user_to_checkout_for_id = current_user.id
        if is_librarian:
            if form.user_id.data and form.user_id.data != 0:
                user_to_checkout_for_id = form.user_id.data
            else:
                flash(
                    "Librarians must select a user to checkout the book for.", "danger"
                )
                return render_template(
                    "books/checkout_book.html",
                    form=form,
                    is_librarian=is_librarian,
                    title="Checkout Book - Nexus",
                )
        asset = db.session.get(Asset, asset_id_to_checkout)
        user_for_checkout = db.session.get(User, user_to_checkout_for_id)
        if not asset or not user_for_checkout or not user_for_checkout.is_active:
            flash("Invalid book or user selected, or user is inactive.", "danger")
        elif asset.quantity < 1:
            flash(f"Book '{asset.name}' is currently out of stock.", "danger")
        elif asset.status != "Available":
            flash(
                f"Book '{asset.name}' is not currently available for checkout (Status: {asset.status}).",
                "warning",
            )
        else:
            existing_checkout = db.session.scalar(
                select(BookCheckout).where(
                    BookCheckout.user_id == user_for_checkout.id,
                    BookCheckout.asset_id == asset.id,
                    BookCheckout.returned == False,
                )
            )
            if existing_checkout:
                flash(
                    f"{user_for_checkout.full_name or user_for_checkout.username} already has '{asset.name}' checked out.",
                    "warning",
                )
            else:
                try:
                    new_checkout = BookCheckout(
                        user_id=user_for_checkout.id,
                        asset_id=asset.id,
                        checkout_date=datetime.now(timezone.utc).date(),
                        due_date=due_date_from_form,
                        returned=False,
                    )
                    asset.quantity -= 1
                    if asset.quantity == 0 and asset.status == "Available":
                        asset.status = "CheckedOut"
                    db.session.add(new_checkout)
                    db.session.commit()
                    flash(
                        f"Book '{asset.name}' checked out successfully to {user_for_checkout.full_name or user_for_checkout.username}. Due: {due_date_from_form.strftime('%Y-%m-%d')}.",
                        "success",
                    )
                    app.logger.info(
                        f"Book ID {asset.id} checked out to user ID {user_for_checkout.id} by {current_user.username}. Due: {due_date_from_form}."
                    )
                    if is_librarian:
                        return redirect(url_for("list_checkouts"))
                    else:
                        return redirect(url_for("view_library"))
                except Exception as e:
                    db.session.rollback()
                    flash(f"Error checking out book: {str(e)}", "danger")
                    app.logger.error(
                        f"Checkout failed for book ID {asset.id} by user ID {user_for_checkout.id}: {str(e)}"
                    )
    return render_template(
        "books/checkout_book.html",
        form=form,
        is_librarian=is_librarian,
        title="Checkout Book/Asset - Nexus",
    )


@app.route("/books/return/<int:checkout_id>", methods=["POST"])
@login_required
@role_required(
    "librarian"
)  # Only librarians can mark books as returned via this direct route
def return_book(checkout_id):
    checkout_record = db.get_or_404(
        BookCheckout, checkout_id, description="Checkout record not found."
    )

    if checkout_record.returned:
        flash(
            f"Book '{checkout_record.asset.name if checkout_record.asset else 'Unknown Book'}' was already marked as returned on {checkout_record.return_date.strftime('%Y-%m-%d') if checkout_record.return_date else 'N/A'}.",
            "info",
        )
    else:
        try:
            checkout_record.returned = True
            checkout_record.return_date = datetime.now(timezone.utc).date()

            asset = checkout_record.asset
            if asset:  # Ensure asset exists
                asset.quantity += 1
                # If asset was 'CheckedOut' (meaning it was likely out of stock due to this checkout)
                # and now has quantity, set it back to 'Available'.
                # Don't change if it was 'Under Maintenance', 'Lost', etc.
                if asset.status == "CheckedOut" and asset.quantity > 0:
                    asset.status = "Available"
                elif (
                    asset.status is None and asset.quantity > 0
                ):  # If status was never set
                    asset.status = "Available"

            db.session.commit()
            flash(
                f"Book '{asset.name if asset else 'Unknown Book'}' marked as returned successfully.",
                "success",
            )
            app.logger.info(
                f"Book checkout ID {checkout_id} (Asset: {asset.id if asset else 'N/A'}) marked returned by {current_user.username}."
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error returning book for checkout ID {checkout_id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while marking the book as returned. Please try again.",
                "danger",
            )

    # Redirect back to where the librarian was, or a default list
    return redirect(request.referrer or url_for("list_checkouts"))


@app.route("/books/checkouts")
@login_required
@role_required("librarian")
def list_checkouts():
    page = request.args.get("page", 1, type=int)
    per_page = 15
    status_filter = request.args.get("status", "active", type=str).lower()
    search_query = request.args.get("search", "", type=str).strip()
    today_date = datetime.now(timezone.utc).date()

    query = select(BookCheckout).options(
        joinedload(BookCheckout.asset).joinedload(
            Asset.category
        ),  # Load asset and its category
        joinedload(BookCheckout.user).joinedload(User.role),  # Load user and their role
    )

    if status_filter == "active":
        query = query.where(BookCheckout.returned == False)
        query = query.order_by(BookCheckout.due_date.asc())  # Overdue first
    elif status_filter == "overdue":
        query = query.where(
            BookCheckout.returned == False, BookCheckout.due_date < today_date
        )
        query = query.order_by(BookCheckout.due_date.asc())
    elif status_filter == "returned":
        query = query.where(BookCheckout.returned == True)
        query = query.order_by(BookCheckout.return_date.desc())  # Newest returns first
    else:  # 'all'
        query = query.order_by(
            BookCheckout.returned.asc(), BookCheckout.checkout_date.desc()
        )  # Active first, then newest checkouts

    if search_query:
        search_term = f"%{search_query}%"
        # Ensure you join User and Asset if they are not default joined by the relationships
        # The options(joinedload(...)) above should make them available for filtering.
        query = (
            query.join(BookCheckout.user)
            .join(BookCheckout.asset)
            .where(
                or_(
                    User.full_name.ilike(search_term),
                    User.username.ilike(search_term),
                    Asset.name.ilike(search_term),
                )
            )
        )

    # Important: Re-apply order_by if search joins changed the primary table in query construction
    # For simplicity, the initial order_by might still work, but complex joins can affect it.
    # If ordering is lost after search, re-apply a default order or the status-specific order.

    checkouts_paginated = db.paginate(
        query, page=page, per_page=per_page, error_out=False
    )

    return render_template(
        "librarian/list_checkouts.html",
        checkouts_paginated=checkouts_paginated,
        status_filter=status_filter,
        search_query=search_query,
        title="Manage Book Checkouts - Nexus",
    )


# --- PART 9 END: Book Checkout & Management ---

# --- PART 10 START: Chat and Contacts ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Message are defined.
# - Helpers: is_chat_allowed (defined in Part 3), get_allowed_roles (defined in Part 3), get_unread_message_count (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: CHAT_PERMISSIONS, VALID_ROLES dictionaries (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_), Flask imports (abort, flash, redirect, url_for, request, render_template, jsonify).
# - Other Python imports (datetime, timezone).

# get_chat_messages helper is defined here, as it's specific to chat routes

# --- (Place with other API/AJAX routes, or in a new section for Chat # In app.py
# --- (Previous app code) ---
#


# =================================================================
# GEMINI 3 PRO: PHASE 1.1a - API for Club Request Handling
# =================================================================
# =================================================================
# GEMINI 3 PRO: PHASE 1.1c/d - API for Comments & Likes
# =================================================================

# =================================================================
# GEMINI 3 PRO: PHASE 1.3 - Flask-Assets Configuration
# =================================================================
from flask_assets import Environment, Bundle

assets = Environment(app)

# Define the JavaScript bundle.
# 'module' type is critical for using import/export syntax.
js_bundle = Bundle(
    "js/app.js",  # Our main entrypoint
    # Add other vendor scripts here if needed, e.g., 'vendor/chart.js'
    filters="jsmin",  # Minify in production
    output="gen/app.%(version)s.js",
    extra={"type": "module"},  # CRITICAL for modern JS
)

# Register the bundle with a name.
assets.register("app_js", js_bundle)


def get_comment_form():
    return CommentForm()


@app.context_processor
def inject_utility_processor():
    return dict(get_comment_form=get_comment_form)


# =================================================================
# GEMINI 3 PRO: PHASE 2.2 - Broadcasting Backend Events
# =================================================================


@app.route("/api/post/<int:post_id>/comment", methods=["POST"])
@login_required
def submit_comment_api(post_id):
    """AUGMENTED: Submits a comment and broadcasts the event."""
    post = Post.query.get_or_404(post_id)
    form = CommentForm()

    if form.validate_on_submit():
        comment = Comment(
            content=form.content.data, author_id=current_user.id, post_id=post.id
        )
        db.session.add(comment)
        if post.author_id != current_user.id:
            db.session.add(
                Notification(
                    user_id=post.author_id,
                    message=f"{current_user.first_name} commented on your post.",
                )
            )
        db.session.commit()

        rendered_comment_html = render_template(
            "social/partials/_social_comment_item.html", comment=comment
        )

        # --- BROADCAST LOGIC ---
        # We emit an event to a "room" specific to this post.
        # Any client viewing this post will be in this room.
        socketio.emit(
            "new_comment",
            {
                "post_id": post_id,
                "comment_html": rendered_comment_html,
                "new_comment_count": post.comments.count(),
            },
            room=f"post-{post_id}",
        )

        # The original AJAX request still gets its direct response.
        return jsonify(
            {
                "success": True,
                "comment_html": rendered_comment_html,
                "new_comment_count": post.comments.count(),
            }
        )
    else:
        return jsonify({"success": False, "errors": form.errors}), 400


# --- NEW SOCKETIO EVENT HANDLERS ---
# In app.py, add these event handlers.


@socketio.on("connect")
def handle_user_connect():
    """
    Handles a new client connection and joins them to a user-specific room.
    This allows the server to send targeted real-time events to that user.
    """
    if current_user.is_authenticated:
        # Create a unique room for this user, e.g., 'user_room_123'
        user_room = f"user_room_{current_user.id}"
        join_room(user_room)
        app.logger.info(
            f"Socket.IO Client {request.sid} connected and joined room: {user_room}"
        )
    else:
        app.logger.info(f"Socket.IO Client {request.sid} connected (Unauthenticated).")


@socketio.on("disconnect")
def handle_user_disconnect():
    """Handles a client disconnection."""
    if current_user.is_authenticated:
        user_room = f"user_room_{current_user.id}"
        leave_room(user_room)
        app.logger.info(
            f"Socket.IO Client {request.sid} disconnected and left room: {user_room}"
        )


@socketio.on("connect")
def handle_connect():
    """Handles a new client connection."""
    print(f"Client connected: {request.sid}")


@socketio.on("connect")
def handle_global_connect():  # Renamed to avoid conflict if other 'connect' handlers exist
    # This can be a generic connect handler or specific to a namespace if you use them.
    # request.sid is the unique session ID for the client.
    app.logger.info(f"Socket.IO Client connected: {request.sid}")
    # No need to emit anything back by default unless you have specific connection ACK logic.


@socketio.on("disconnect")
def handle_global_disconnect():  # Renamed for clarity
    app.logger.info(f"Socket.IO Client disconnected: {request.sid}")
    # Any cleanup related to this specific SID leaving rooms can be done here,
    # though Flask-SocketIO often handles room cleanup automatically on disconnect.


@socketio.on("join_post_room")  # Matches client emit event name
def handle_join_global_post_room(data):  # data is the dict { 'post_id': postId }
    post_id = data.get("post_id")
    if post_id:
        room_name = f"global_post-{post_id}"
        join_room(room_name)
        app.logger.info(f"Client {request.sid} joined room: {room_name}")
        # Optionally, you could emit a confirmation back to the joining client
        # emit('joined_room_ack', {'room': room_name}, room=request.sid)
    else:
        app.logger.warning(
            f"Client {request.sid} tried to join_post_room without post_id."
        )


@socketio.on("leave_post_room")  # Matches client emit event name
def handle_leave_global_post_room(data):
    post_id = data.get("post_id")
    if post_id:
        room_name = f"global_post-{post_id}"
        leave_room(room_name)
        app.logger.info(f"Client {request.sid} left room: {room_name}")
        # Optionally, emit confirmation
        # emit('left_room_ack', {'room': room_name}, room=request.sid)
    else:
        app.logger.warning(
            f"Client {request.sid} tried to leave_post_room without post_id."
        )


# --- END SOCKETIO EVENT HANDLERS ---


@socketio.on("join_post_room")
def handle_join_post_room(data):
    """Client requests to join a room to receive updates for a specific post."""
    post_id = data.get("post_id")
    if post_id:
        join_room(f"post-{post_id}")
        print(f"Client {request.sid} joined room post-{post_id}")


@socketio.on("leave_post_room")
def handle_leave_post_room(data):
    """Client leaves a room (e.g., navigates away from the page)."""
    post_id = data.get("post_id")
    if post_id:
        leave_room(f"post-{post_id}")
        print(f"Client {request.sid} left room post-{post_id}")


@app.route("/api/post/<int:post_id>/like", methods=["POST"])
@login_required
def toggle_like_api(post_id):
    """
    Toggles a like on a post asynchronously.
    """
    post = Post.query.get_or_404(post_id)
    existing_like = Like.query.filter_by(
        user_id=current_user.id, post_id=post.id
    ).first()

    if existing_like:
        # User has liked it, so unlike it.
        db.session.delete(existing_like)
        user_liked = False
    else:
        # User has not liked it, so like it.
        new_like = Like(user_id=current_user.id, post_id=post.id)
        db.session.add(new_like)
        user_liked = True

    db.session.commit()

    return jsonify(
        {
            "success": True,
            "new_like_count": post.likes.count(),
            "user_liked": user_liked,
        }
    )


@app.route("/club/request/<int:request_id>/handle", methods=["POST"])
@login_required
def handle_club_request(request_id):
    """
    Handles approving or declining a 'JOIN_CLUB' request.
    This is an API endpoint designed to be called via Fetch from the frontend.
    """
    join_request = Request.query.get_or_404(request_id)
    action = request.form.get("action")

    if join_request.request_type != "JOIN_CLUB":
        return jsonify({"success": False, "error": "Invalid request type."}), 400

    club = join_request.talent_club
    # --- Permission Check: Only the club leader can handle requests. ---
    if not club.is_leader(current_user):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to perform this action.",
                }
            ),
            403,
        )

    if action == "approve":
        join_request.status = "APPROVED"
        # Create a new membership for the requesting user.
        new_membership = TalentClubMembership(
            user_id=join_request.sender_id, club_id=club.id, role="Member"
        )
        db.session.add(new_membership)

        # Create a notification for the user who was accepted.
        approval_notification = Notification(
            user_id=join_request.sender_id,
            message=f"Your request to join '{club.name}' has been approved!",
        )
        db.session.add(approval_notification)
        flash(
            f"{join_request.sender.first_name} has been added to the club.", "success"
        )

    elif action == "decline":
        join_request.status = "DECLINED"
        # Create a notification for the user who was declined.
        rejection_notification = Notification(
            user_id=join_request.sender_id,
            message=f"Your request to join '{club.name}' has been declined.",
        )
        db.session.add(rejection_notification)
        flash(f"{join_request.sender.first_name}'s request has been declined.", "info")
    else:
        return jsonify({"success": False, "error": "Invalid action."}), 400

    db.session.commit()
    return redirect(url_for("inbox"))


# --- PART X START: Talent Club Features ---
#
# Find and replace this API search route. It is now corrected to specifically query
# based on the `is_tc_member` flag, which is what you wanted.
# This endpoint is what your JavaScript user picker (e.g., TomSelect) should be calling.
# In app.py, REPLACE the entire api_search_tc_members function.

@app.route("/talent_club/api/members/search")
@login_required
@tc_member_required  # Ensures the person doing the searching is a TC member
def api_search_tc_members():
    """
    AJAX endpoint to search for students who are also active Talent Club members,
    for the purpose of mentioning them in proposals.
    """
    search_query = request.args.get("q", "").strip()
    if not search_query or len(search_query) < 2:
        return jsonify([])

    try:
        # --- THIS IS THE FIX ---
        # The query now JOINS with the Role table and explicitly checks
        # that the user's role is 'student' AND is_tc_member is True.
        results_query = (
            select(User)
            .join(User.role)  # Join to the Role table
            .where(
                User.is_tc_member == True,
                Role.name == 'student',  # CRITICAL: Ensure the user is a student
                User.is_active == True,
                User.id != current_user.id,  # Don't let user mention themselves
                or_(  # Search by username or full name
                    User.username.ilike(f"%{search_query}%"),
                    User.full_name.ilike(f"%{search_query}%"),
                ),
            )
            .options(joinedload(User.role))
            .order_by(User.full_name)
            .limit(15)
        )
        # --- END OF FIX ---

        results = db.session.scalars(results_query).all()
        
        # Format for the JavaScript user picker (e.g., TomSelect)
        # The text now more clearly indicates the user's status.
        return jsonify(
            [
                {
                    "id": u.id,
                    "text": f"{u.full_name or u.username} (Student TC Member)",
                }
                for u in results
            ]
        )
    except Exception as e:
        app.logger.error(f"Error searching TC members for mention: {e}", exc_info=True)
        return jsonify([]), 500
# In app.py, find and replace your CreateTalentClubProposalForm class

# In app.py, find and replace your create_talent_club_proposal route

@app.route("/talent_club/configuration/new_club_proposal", methods=["GET", "POST"])
@login_required
@tc_member_required
def create_talent_club_proposal():
    form = CreateTalentClubProposalForm()

    if form.validate_on_submit():
        # --- THIS IS THE FIX ---
        # Get the comma-separated string of IDs from the validated form data,
        # which is the standard and secure way with WTForms.
        mentioned_member_ids_str = form.mentioned_member_ids.data
        # --- END OF FIX ---

        mentioned_member_ids = [
            int(uid) for uid in mentioned_member_ids_str.split(",") if uid.isdigit()
        ]

        valid_mentioned_users = []
        if mentioned_member_ids:
            valid_mentioned_users_query = (
                select(User)
                .join(User.role)
                .where(
                    User.id.in_(mentioned_member_ids),
                    User.id != current_user.id,
                    User.is_active == True,
                    User.is_tc_member == True,
                    Role.name == 'student'
                )
            )
            valid_mentioned_users = db.session.scalars(valid_mentioned_users_query).all()

        MIN_MENTIONED_MEMBERS = 5
        if len(valid_mentioned_users) < MIN_MENTIONED_MEMBERS:
            flash(
                f"You must successfully mention at least {MIN_MENTIONED_MEMBERS} other active Student TC members. The system found {len(valid_mentioned_users)} valid members in your selection.",
                "danger",
            )
            all_tc_students = db.session.scalars(select(User).join(Role).where(User.is_tc_member == True, Role.name == 'student', User.is_active == True, User.id != current_user.id)).all()
            return render_template(
                "talent_club/config_new_proposal.html",
                form=form,
                all_tc_members=all_tc_students,
                title="Propose New Talent Club - Nexus TC",
            )

        try:
            new_proposal = TalentClubProposal(
                creator_id=current_user.id,
                name=form.name.data.strip(),
                description=form.description.data.strip(),
                social_category_id=form.social_category_id.data,
                proposal_file_id=None, # File logic can be re-added
                status="pending_leader_review",
            )
            db.session.add(new_proposal)
            db.session.flush()

            mention_entries_for_notification = []
            for user_to_mention in valid_mentioned_users:
                mention = TalentClubMention(proposal_id=new_proposal.id, user_id=user_to_mention.id, status="pending")
                db.session.add(mention)
                mention_entries_for_notification.append(mention)

            db.session.commit()
            app.logger.info(f"User {current_user.username} submitted TC Proposal ID {new_proposal.id} mentioning {len(valid_mentioned_users)} users.")
            
            notification_content_mention = f"You've been mentioned in a new Talent Club proposal for '{new_proposal.name}'..."
            for mention_record in mention_entries_for_notification:
                link_url_mention = url_for("view_tc_proposal_mention", mention_id=mention_record.id, _external=True)
                notify_tc_member(receiver_user=mention_record.user, sender_user=current_user, content=notification_content_mention, notification_type="tc_proposal_mention_invite", related_object_id=mention_record.id, link_url=link_url_mention)
            
            flash(f"Your proposal for '{new_proposal.name}' has been submitted and mentioned members notified!", "success")
            return redirect(url_for("my_talent_club_proposals"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating proposal for user {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")

    # This part runs for GET requests or if the POST validation fails.
    all_tc_students = db.session.scalars(select(User).join(Role).where(User.is_tc_member == True, Role.name == 'student', User.is_active == True, User.id != current_user.id)).all()
    return render_template(
        "talent_club/config_new_proposal.html",
        form=form,
        all_tc_members=all_tc_students,
        title="Propose New Talent Club - Nexus TC",
    )
@app.route("/chat/api/messages/<int:other_user_id>/new")
@login_required
def ajax_get_new_chat_messages(other_user_id):
    if other_user_id == current_user.id:
        return (
            jsonify(
                {
                    "messages": [],
                    "latest_timestamp": int(
                        datetime.now(timezone.utc).timestamp() * 1000
                    ),
                }
            ),
            200,
        )

    since_ms_str = request.args.get("since")
    if not since_ms_str:
        return jsonify({"error": "Missing 'since' timestamp."}), 400

    try:
        since_ms = int(since_ms_str)
        # Add a small buffer (e.g., 1 second) to avoid re-fetching the exact last message due to millisecond precision
        since_time = datetime.fromtimestamp(
            (since_ms / 1000.0) + 0.001, tz=timezone.utc
        )
    except (ValueError, TypeError):
        app.logger.warning(
            f"AJAX Chat: Invalid 'since' timestamp '{since_ms_str}' for user {current_user.username} polling {other_user_id}."
        )
        return jsonify({"error": "Invalid timestamp format."}), 400

    # Fetch new messages FROM other_user_id TO current_user_id
    # AND messages FROM current_user_id TO other_user_id (if sent from another client/tab)
    new_messages_query = (
        select(Message)
        .where(
            Message.timestamp > since_time,  # Key condition
            or_(
                (Message.sender_id == current_user.id)
                & (Message.receiver_id == other_user_id),
                (Message.sender_id == other_user_id)
                & (Message.receiver_id == current_user.id),
            ),
        )
        .options(
            joinedload(Message.sender).joinedload(User.role)
        )  # Eager load sender for client-side rendering
        .order_by(Message.timestamp.asc())  # Send in chronological order
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data = []
    latest_ts_in_batch = since_ms

    # Mark newly fetched messages FROM other_user_id as read
    unread_ids_to_mark_on_poll = []

    for msg in new_messages_list:
        messages_data.append(
            {
                "id": msg.id,
                "sender_id": msg.sender_id,
                "sender": {  # Essential for JS to render the message correctly
                    "full_name": msg.sender.full_name if msg.sender else "Unknown",
                    "username": msg.sender.username if msg.sender else "unknown",
                    "profile_photo_url": (
                        msg.sender.profile_photo_url if msg.sender else None
                    ),
                },
                "receiver_id": msg.receiver_id,
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat() + "Z",  # ISO format for JS
                "is_read": msg.is_read,  # Reflect current read status
            }
        )

        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms

        # If message is from the other user and current user is receiver, mark it read
        if (
            msg.sender_id == other_user_id
            and msg.receiver_id == current_user.id
            and not msg.is_read
        ):
            unread_ids_to_mark_on_poll.append(msg.id)

    if unread_ids_to_mark_on_poll:
        try:
            db.session.query(Message).filter(
                Message.id.in_(unread_ids_to_mark_on_poll)
            ).update({Message.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(
                f"AJAX Chat: Marked {len(unread_ids_to_mark_on_poll)} polled messages as read for user {current_user.username} from {other_user_id}."
            )
            # Update is_read status in the data being sent to client
            for msg_data in messages_data:
                if msg_data["id"] in unread_ids_to_mark_on_poll:
                    msg_data["is_read"] = True
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"AJAX Chat: Error marking polled messages read for user {current_user.id} from {other_user_id}: {e}",
                exc_info=True,
            )

    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(
        latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0
    )

    return (
        jsonify(
            {
                "messages": messages_data,
                "latest_timestamp": final_latest_timestamp,  # Crucial for client's next poll 'since'
            }
        ),
        200,
    )


def get_chat_messages(user1_id, user2_id, limit=50):
    """Fetches chat messages between two users, ordered by timestamp."""
    # Ensure app context for DB access if called outside a request context
    with app.app_context():
        # Use `or_` to filter messages where either user is the sender or receiver
        # and the other user is the corresponding receiver or sender.
        return db.session.scalars(
            select(Message)
            .where(
                ((Message.sender_id == user1_id) & (Message.receiver_id == user2_id))
                | ((Message.sender_id == user2_id) & (Message.receiver_id == user1_id))
            )
            .order_by(Message.timestamp.asc())  # Show oldest first for chat flow
            .limit(
                limit
            )  # Limit messages to prevent overload, implement pagination later if needed
        ).all()
# In app.py

# Ensure this form class is defined somewhere in your file, likely with other forms.
# If it's not there, add it.
from flask_wtf import FlaskForm
class CSRFOnlyForm(FlaskForm):
    """A form that only contains the CSRF token for protection."""
    pass
# In app.py, replace your entire existing universal_chat function.

@app.route("/chat/user/<int:target_user_id>", methods=["GET", "POST"])
@login_required
def universal_chat(target_user_id):
    if target_user_id == current_user.id:
        flash("You cannot chat with yourself.", "warning")
        return redirect(url_for("contacts_list"))

    target_user = db.get_or_404(User, target_user_id, description="The user you are trying to chat with does not exist.")
    if not target_user.is_active or not target_user.role:
        abort(
            404,
            description="The user you are trying to chat with is inactive or has no role.",
        )

    if not is_chat_allowed(current_user, target_user):
        flash(
            f"You do not have permission to chat with {target_user.full_name or target_user.username}.",
            "danger",
        )
        return redirect(url_for("contacts_list"))

    # FIX: Instantiate a form object to pass to the template for CSRF protection.
    form = CSRFOnlyForm()

    if request.method == "POST":
        # CSRF is automatically validated by Flask-WTF on POST requests.
        content = request.form.get("message", "").strip()
        dm_file_storage = request.files.get("dm_file")

        if not content and not (dm_file_storage and dm_file_storage.filename):
            return jsonify({"success": False, "error": "Cannot send an empty message or file."}), 400

        if content and len(content) > 2000:
            return jsonify({"success": False, "error": "Message is too long (max 2000 characters)."}), 400

        saved_file_db_object = None
        try:
            if dm_file_storage and dm_file_storage.filename:
                saved_file_db_object = save_uploaded_file(dm_file_storage)
                if not saved_file_db_object:
                    return jsonify({"success": False, "error": "File upload processing failed."}), 400
                db.session.add(saved_file_db_object)

            msg = Message(
                sender_id=current_user.id,
                receiver_id=target_user.id,
                sender_role=current_user.role.name,
                receiver_role=target_user.role.name,
                content=content if content else None,
                file_id=saved_file_db_object.id if saved_file_db_object else None,
            )
            db.session.add(msg)
            db.session.commit()

            app.logger.info(f"Message ID {msg.id} (File ID: {msg.file_id}) sent from {current_user.username} to {target_user.username}.")

            file_details_for_response = None
            if msg.file:
                file_details_for_response = {
                    "id": msg.file.id, "original_filename": msg.file.original_filename,
                    "mimetype": msg.file.mimetype, "size": msg.file.size,
                    "download_url": msg.file.get_download_url(),
                }

            message_data_for_client = {
                "id": msg.id, "sender_id": msg.sender_id,
                "sender": { "full_name": current_user.full_name, "username": current_user.username, "profile_photo_url": current_user.profile_photo_url },
                "receiver_id": msg.receiver_id, "content": msg.content,
                "timestamp": msg.timestamp.isoformat() + "Z", "is_read": msg.is_read,
                "file_details": file_details_for_response,
            }

            socketio.emit("new_direct_message", message_data_for_client, room=f"user_room_{target_user.id}")
            
            return jsonify({ "success": True, "message": "Message sent!", "message_data": message_data_for_client }), 201
        except Exception as e:
            db.session.rollback()
            if saved_file_db_object and saved_file_db_object.filepath:
                try:
                    disk_filename = os.path.basename(saved_file_db_object.filepath)
                    full_path = os.path.join(app.config['UPLOAD_FOLDER'], disk_filename)
                    if os.path.exists(full_path):
                        os.remove(full_path)
                except Exception as cleanup_e:
                    app.logger.error(f"Error cleaning up DM file on error: {cleanup_e}")
            app.logger.error(f"Error sending message from {current_user.id} to {target_user.id}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Server error sending message."}), 500

    # This part handles the GET request.
    initial_messages_query = (
        db.select(Message)
        .where(
            or_(
                (Message.sender_id == current_user.id)
                & (Message.receiver_id == target_user.id),
                (Message.sender_id == target_user.id)
                & (Message.receiver_id == current_user.id),
            )
        )
        .options(
            joinedload(Message.sender).joinedload(User.role),
            joinedload(Message.file),
        )
        .order_by(Message.timestamp.asc())
        .limit(50)
    )
    messages = db.session.scalars(initial_messages_query).all()

    unread_ids_in_batch_to_mark = [
        m.id for m in messages if m.sender_id == target_user.id and not m.is_read
    ]
    if unread_ids_in_batch_to_mark:
        try:
            db.session.query(Message).filter(
                Message.id.in_(unread_ids_in_batch_to_mark)
            ).update({Message.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(
                f"Marked {len(unread_ids_in_batch_to_mark)} messages as read from user {target_user.username} upon opening chat with {current_user.username}."
            )
            for m in messages:
                if m.id in unread_ids_in_batch_to_mark:
                    m.is_read = True
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error marking messages read in chat between {current_user.id} and {target_user.id}: {e}",
                exc_info=True,
            )

    # FIX: Pass the 'form' object to the template.
    return render_template(
        "chat/universal_chat.html",
        target_user=target_user,
        messages=messages,
        form=form,  # This line is crucial for the template
        title=f"Chat with {target_user.full_name or target_user.username} - Nexus",
    )

@app.route("/contacts/section/<grade>/<section>")
@login_required
def contacts_by_section(grade, section):
    """
    Displays the list of students for a specific grade and section.
    Accepts a 'tc_only' flag to filter for Talent Club members.
    """
    allowed_role_names = get_allowed_chat_roles("send_to", current_user)
    if "student" not in allowed_role_names:
        flash("You do not have permission to view student contacts.", "danger")
        abort(403)

    # Check the flag from the URL to determine which group to show
    show_tc_only = request.args.get("tc_only") == "true"

    # Base query for students in this specific section
    students_query = (
        select(User)
        .join(Role)
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name == "student",
            User.grade == grade,
            User.section == section,
        )
    )

    # Apply the TC member filter based on the flag
    if show_tc_only:
        students_query = students_query.where(User.is_tc_member == True)
        title = f"TC Members: Grade {grade} - Section {section}"
    else:
        students_query = students_query.where(User.is_tc_member == False)
        title = f"Other Students: Grade {grade} - Section {section}"

    students_in_section = db.session.scalars(
        students_query.order_by(User.full_name.asc())
    ).all()

    # Get unread counts specifically for the displayed students
    contact_unread_counts = {}
    if students_in_section:
        student_ids = [s.id for s in students_in_section]
        unread_counts_raw = db.session.execute(
            select(Message.sender_id, func.count(Message.id))
            .where(
                Message.receiver_id == current_user.id,
                Message.is_read == False,
                Message.sender_id.in_(student_ids),
            )
            .group_by(Message.sender_id)
        ).all()
        contact_unread_counts = dict(unread_counts_raw)

    return render_template(
        "chat/contacts_section.html",
        students=students_in_section,
        contact_unread_counts=contact_unread_counts,
        title=title,
    )
# In app.py, find and replace the entire contacts_list function with this corrected version.
# In app.py, REPLACE the entire manage_tc_members_leader function with this one.

@app.route("/talent_club/leader/member_management")
@login_required
@tc_leader_required  # Custom decorator for system-wide TC Leader
def manage_tc_members_leader():
    """
    Renders the page for the TC Leader to view and manage all active Talent Club members.
    This corrected version uses .unique() to handle the eager loading of collections.
    """
    # Query for all active TC members.
    # We eagerly load their primary role and their specific club memberships
    # to display all necessary information in a single database trip.
    active_tc_members_query = (
        select(User)
        .where(User.is_tc_member == True, User.is_active == True)
        .options(
            joinedload(User.role),
            joinedload(User.tc_memberships).joinedload(TalentClubMembership.club),
        )
        .order_by(User.full_name.asc())
    )

    # --- THIS IS THE FIX ---
    # The .unique() method is added here to correctly de-duplicate the results
    # from the one-to-many join created by `joinedload(User.tc_memberships)`.
    tc_members = db.session.scalars(active_tc_members_query).unique().all()
    # --- END OF FIX ---

    # Create a dictionary to hold the ban/mute status for each member.
    # This is more efficient than checking the status for each member inside the template loop.
    member_ban_status = {}
    if tc_members:
        member_ids = [m.id for m in tc_members]
        
        # Find any active bans or mutes for the members being displayed.
        active_bans_query = select(TalentClubBan).where(
            TalentClubBan.user_id.in_(member_ids),
            or_(
                TalentClubBan.expires_at.is_(None), # Permanent ban/mute
                TalentClubBan.expires_at > datetime.now(timezone.utc), # Temporary ban/mute that hasn't expired
            ),
        )
        active_bans = db.session.scalars(active_bans_query).all()
        
        # Map the ban object to the user's ID for quick lookup in the template.
        for ban in active_bans:
            member_ban_status[ban.user_id] = ban

    # Render the management page, passing the list of members and their ban statuses.
    return render_template(
        "talent_club/leader/member_management.html",
        tc_members=tc_members,
        member_ban_status=member_ban_status,
        title="Manage TC Members - TC Leader Admin"
    )
    
@app.route("/contacts")
@login_required
def contacts_list():
    """
    Displays an organized contacts list based on user role and permissions.
    - Non-student/teacher roles are listed first.
    - Teachers are grouped by the grade/section they teach.
    - Students are grouped into "TC Members" and "Other Students" blocks.
    - All visibility is controlled by the current user's chat permissions.
    """
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for("role_redirect"))

    # The permission helper is the single source of truth for what can be displayed.
    allowed_role_names = get_allowed_chat_roles("send_to", current_user)

    # Initialize data structures to pass to the template
    other_contacts_by_role = defaultdict(list)
    teachers_by_grade_section = defaultdict(list)
    tc_student_blocks = []
    non_tc_student_blocks = []
    contact_unread_counts = {}

    # 1. Fetch Staff Contacts (Non-Teacher, Non-Student)
    other_role_names = [r for r in allowed_role_names if r not in ["student", "teacher"]]
    if other_role_names:
        other_contacts_query = (
            select(User)
            .join(Role)
            .where(
                User.id != current_user.id,
                User.is_active == True,
                Role.name.in_(other_role_names),
            )
            .options(joinedload(User.role))
            .order_by(Role.name, User.full_name)
        )
        other_contacts_results = db.session.scalars(other_contacts_query).all()
        for contact in other_contacts_results:
            other_contacts_by_role[contact.role.name.replace("_", " ").title()].append(contact)

    # 2. Fetch and Classify Teachers by Grade/Section
    if "teacher" in allowed_role_names:
        teacher_query = select(User).where(User.role.has(name="teacher"), User.is_active == True)
        all_teachers = db.session.scalars(teacher_query).all()
        added_teachers = defaultdict(set)
        for teacher in all_teachers:
            # Using the dynamic relationship to fetch profiles for this specific teacher
            for profile in teacher.teacher_profiles:
                if profile.grade and profile.section:
                    key = (profile.grade, profile.section)
                    if teacher.id not in added_teachers[key]:
                        teachers_by_grade_section[key].append(teacher)
                        added_teachers[key].add(teacher.id)

    # 3. Fetch Student Blocks (TC and Non-TC)
    if "student" in allowed_role_names:
        # --- THIS IS THE FIX ---
        # Removed the incorrect `User.grade != ""` and `User.section != ""` checks.
        # The `isnot(None)` check is the correct way to ensure the columns have a value.
        base_student_query = (
            select(User.grade, User.section, func.count(User.id).label("student_count"))
            .join(Role)
            .where(
                Role.name == "student",
                User.is_active == True,
                User.id != current_user.id,
                User.grade.isnot(None),    # Correctly checks for a non-null grade
                User.section.isnot(None),  # Correctly checks for a non-null section
            )
        )
        # --- END OF FIX ---

        tc_query = base_student_query.where(User.is_tc_member == True).group_by(User.grade, User.section).order_by(User.grade, User.section)
        tc_student_blocks = db.session.execute(tc_query).all()

        non_tc_query = base_student_query.where(User.is_tc_member == False).group_by(User.grade, User.section).order_by(User.grade, User.section)
        non_tc_student_blocks = db.session.execute(non_tc_query).all()
    
    # 4. Get Unread Counts for individually displayed contacts
    all_individual_contacts = [c for role_list in other_contacts_by_role.values() for c in role_list]
    all_individual_contacts.extend([t for t_list in teachers_by_grade_section.values() for t in t_list])
    if all_individual_contacts:
        contact_ids = list(set([c.id for c in all_individual_contacts]))
        unread_counts_raw = db.session.execute(
            select(Message.sender_id, func.count(Message.id))
            .where(Message.receiver_id == current_user.id, Message.is_read == False, Message.sender_id.in_(contact_ids))
            .group_by(Message.sender_id)
        ).all()
        contact_unread_counts = dict(unread_counts_raw)

    sorted_teacher_blocks = sorted(teachers_by_grade_section.items())

    return render_template(
        "chat/contacts_list.html",
        other_contacts_by_role=other_contacts_by_role,
        sorted_teacher_blocks=sorted_teacher_blocks,
        tc_student_blocks=tc_student_blocks,
        non_tc_student_blocks=non_tc_student_blocks,
        contact_unread_counts=contact_unread_counts,
        allowed_role_names=allowed_role_names,
        title="My Chat Contacts",
    )

@app.route("/contacts_by_role/<string:display_role_filter>")
@login_required
def contacts_by_role_filter(display_role_filter):
    if not current_user.role:
        flash(
            "Your user role is not properly configured. Cannot determine contacts.",
            "danger",
        )
        return redirect(url_for("role_redirect"))

    allowed_chat_send_to_roles = get_allowed_chat_roles("send_to", current_user)
    display_role_filter_lower = display_role_filter.lower()
    valid_role_names_lower = [
        r[0].lower() for r in current_app.config.get("VALID_ROLES", [])
    ]

    if (
        display_role_filter_lower != "all"
        and display_role_filter_lower not in valid_role_names_lower
    ):
        flash(f"Invalid role filter: {display_role_filter}", "warning")
        return redirect(url_for("contacts_list"))

    contacts_query = (
        select(User)
        .join(User.role)
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name.in_(allowed_chat_send_to_roles),
        )
    )

    if display_role_filter_lower != "all":
        if display_role_filter_lower in allowed_chat_send_to_roles:
            contacts_query = contacts_query.where(
                func.lower(Role.name) == display_role_filter_lower
            )
        else:  # User requested a role they aren't allowed to chat with based on their 'send_to'
            flash(
                f"You do not have permission to initiate chats with users in the '{display_role_filter}' role.",
                "warning",
            )
            contacts = []  # Override query to return empty
            # To prevent further processing if contacts is empty:
            contact_unread_counts = {}
            all_roles_for_filter = current_app.config.get("VALID_ROLES", [])
            return render_template(
                "chat/contacts_list.html",
                contacts=contacts,
                contact_unread_counts=contact_unread_counts,
                all_roles=all_roles_for_filter,
                title=f"{display_role_filter.replace('_', ' ').title()} Contacts - Nexus",
                selected_role_filter=display_role_filter,
            )

    contacts = db.session.scalars(contacts_query.order_by(User.full_name.asc())).all()

    contact_unread_counts = {}
    if contacts:
        for contact in contacts:
            count = db.session.scalar(
                select(func.count(Message.id)).where(
                    Message.sender_id == contact.id,
                    Message.receiver_id == current_user.id,
                    Message.is_read == False,
                )
            )
            if count and count > 0:
                contact_unread_counts[contact.id] = count

    all_roles_for_filter = current_app.config.get("VALID_ROLES", [])

    return render_template(
        "chat/contacts_list.html",
        contacts=contacts,
        contact_unread_counts=contact_unread_counts,
        all_roles=all_roles_for_filter,
        title=f"{display_role_filter.replace('_', ' ').title()} Contacts - Nexus",
        selected_role_filter=display_role_filter,
    )


# --- PART 10 END: Chat and Contacts ---
# --- PART 11 START: Notifications ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Notification are defined.
# - Forms: NotificationForm is defined (in Part 4).
# - Helpers: get_unread_notifications_count (defined in Part 3), get_allowed_roles (defined in Part 3), can_send (defined in Part 3), can_receive (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: NOTIFICATION_PERMISSIONS dictionary (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_, literal, case), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, uuid, secure_filename, os).
# In app.py, near your other form definitions
# --- PART 11 START: Notifications ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Notification are defined.
# - Forms: NotificationForm is defined (in Part 4).
# - Helpers: get_unread_notifications_count (defined in Part 3), get_allowed_roles (defined in Part 3), can_send (defined in Part 3), can_receive (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: NOTIFICATION_PERMISSIONS dictionary (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_, literal, case), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, uuid, secure_filename, os).

# In app.py, near your other form definitions

# ADD THIS NEW, SIMPLIFIED FORM CLASS
class CSRFOnlyForm(FlaskForm):
    """A form that only contains the CSRF token for protection."""
    pass

# ADD THIS NEW ROUTE
@app.route("/notifications")
@login_required
def view_notifications():
    """Displays a paginated list of all notifications for the current user."""
    page = request.args.get("page", 1, type=int)
    per_page = 20

    notifications_query = (
        select(Notification)
        .where(Notification.receiver_id == current_user.id)
        .options(joinedload(Notification.sender))
        .order_by(Notification.is_read.asc(), Notification.timestamp.desc()) # Show unread first, then newest
    )

    pagination = db.paginate(notifications_query, page=page, per_page=per_page, error_out=False)
    
    csrf_form = CSRFOnlyForm()

    # This route assumes a template at 'notifications/view.html' exists to display the list.
    return render_template(
        "notifications/view.html",
        notifications=pagination.items,
        pagination=pagination,
        csrf_form=csrf_form,
        title="My Notifications"
    )

# FIND and REPLACE the select_recipients and compose_notification routes with these versions.

@app.route("/notifications/select_recipients")
@login_required
def select_recipients():
    """
    Step 1: Displays the interactive, searchable list of all potential recipients.
    This page's form POSTs to /compose_notification.
    """
    # Use the new, simpler form just for CSRF protection.
    form = CSRFOnlyForm() 
    
    allowed_roles = get_allowed_notification_roles("send_to", current_user)
    
    query = (
        select(User)
        .where(User.is_active == True, User.id != current_user.id)
        .options(joinedload(User.role))
        .order_by(User.full_name)
    )
    all_possible_recipients = db.session.scalars(query).all()

    grouped_recipients = defaultdict(lambda: defaultdict(list))
    for user in all_possible_recipients:
        role_name = user.role.name
        if role_name not in allowed_roles:
            continue

        if role_name == 'student':
            if user.grade and user.section:
                grouped_recipients["Students by Class"][f"Grade {user.grade} - Section {user.section}"].append(user)
        elif role_name == 'teacher':
            subjects = {p.subject for p in user.teacher_profiles if p.subject}
            if subjects:
                for subject in subjects:
                    grouped_recipients["Teachers by Subject"][subject].append(user)
            else:
                grouped_recipients["Teachers by Subject"]["Uncategorized"].append(user)
        else:
            grouped_recipients["Staff Roles"][role_name.replace('_', ' ').title()].append(user)
    
    return render_template(
        "notifications/select_recipients.html",
        form=form, # Pass the new form object
        grouped_recipients=grouped_recipients,
        title="Send Notification: Select Recipients"
    )


@app.route("/notifications/compose", methods=["POST"])
@login_required
def compose_notification():
    """
    Step 2: Receives the list of IDs from the selection page and renders
    the final composition form.
    """
    # Use the simple form to validate the CSRF token.
    form = CSRFOnlyForm()
    
    # This will now ONLY validate that the CSRF token is present and correct.
    if form.validate_on_submit():
        # Manually get the recipient list from the request form, not from the WTForms object.
        recipient_id_list_str = request.form.get("recipient_id_list", "")
        recipient_ids = [int(id) for id in recipient_id_list_str.split(',') if id.isdigit()]
        
        if not recipient_ids:
            flash("No recipients were selected.", "warning")
            return redirect(url_for("select_recipients"))

        recipients = db.session.scalars(
            select(User).where(User.id.in_(recipient_ids)).order_by(User.full_name)
        ).all()
        
        compose_form = NotificationForm() 
        
        return render_template(
            "notifications/compose_notification.html",
            form=compose_form,
            recipients=recipients,
            recipient_id_list=recipient_id_list_str,
            title=f"Compose for {len(recipients)} Recipients"
        )
    
    # If we get here, it means form.validate_on_submit() returned False,
    # which in this case means the CSRF token failed validation.
    flash("There was a security issue with your request. Please try again.", "danger")
    return redirect(url_for('select_recipients'))
@app.route("/notifications/send", methods=["POST"])
@login_required
def send_final_notification():
    """
    Step 3: Receives the final composed message and the list of recipient IDs,
    then sends the notifications.
    """
    # This form validates the content and its own CSRF token.
    form = NotificationForm() 
    
    if form.validate_on_submit():
        # Get the recipient list passed from the previous step.
        recipient_id_list_str = request.form.get("recipient_id_list", "")
        recipient_ids = [int(id) for id in recipient_id_list_str.split(',') if id.isdigit()]

        if not recipient_ids:
            flash("Recipient list was lost. Please select recipients again.", "danger")
            return redirect(url_for('select_recipients'))
            
        recipients = db.session.scalars(select(User).where(User.id.in_(recipient_ids))).all()
        
        try:
            notifications_to_send = []
            for recipient in recipients:
                if is_notification_allowed(current_user, recipient):
                    notifications_to_send.append(Notification(
                        sender_id=current_user.id, receiver_id=recipient.id,
                        content=form.content.data.strip(),
                        link_url=form.link_url.data.strip() if form.link_url.data else None
                    ))
            
            if notifications_to_send:
                db.session.add_all(notifications_to_send)
                db.session.commit()
                flash(f"Notification sent to {len(notifications_to_send)} recipients.", "success")
            else:
                flash("No valid recipients found based on permissions.", "warning")
                
            return redirect(url_for('view_notifications'))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error sending bulk notification: {e}", exc_info=True)
            flash("An error occurred while sending the notification.", "danger")
            return redirect(url_for('select_recipients'))
    
    # This is reached if the compose form (NotificationForm) fails validation.
    flash("There was an error with your message. Please try again.", "danger")
    # Redirecting to start is safest if the form data is invalid.
    return redirect(url_for('select_recipients'))
# --- (Place with other API/AJAX routes, or in a new section for Notification API) ---


@app.route("/notifications/mark-all-read", methods=["POST"])
@login_required
def ajax_mark_all_notifications_read():
    try:
        updated_count_result = db.session.execute(
            db.update(Notification)
            .where(
                Notification.receiver_id == current_user.id,
                Notification.is_read == False,
            )
            .values(is_read=True)
        )
        db.session.commit()
        updated_count = updated_count_result.rowcount

        app.logger.info(
            f"AJAX: Marked {updated_count} notifications as read for user {current_user.username}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"{updated_count} notification(s) marked as read.",
                    "updated_count": updated_count,  # JS can use this to update UI if needed
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"AJAX: Error marking all notifications read for user {current_user.id}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error marking notifications."}),
            500,
        )


@app.route("/notifications/mark-read/<int:notification_id>", methods=["POST"])
@login_required
def ajax_mark_notification_read(notification_id):
    try:
        notification = db.session.get(Notification, notification_id)
        if not notification:
            return jsonify({"success": False, "error": "Notification not found."}), 404
        if notification.receiver_id != current_user.id:
            return jsonify({"success": False, "error": "Unauthorized."}), 403

        if not notification.is_read:
            notification.is_read = True
            db.session.commit()
            app.logger.info(
                f"AJAX: Marked notification {notification_id} as read for user {current_user.username}."
            )

        # Get current total unread count to send back
        current_total_unread = get_unread_notifications_count(current_user.id)

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Notification marked as read.",
                    "notification_id": notification_id,
                    "total_unread_count": current_total_unread,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"AJAX: Error marking notification {notification_id} read for user {current_user.id}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/notifications/check-new")
@login_required
def ajax_check_new_notifications():
    since_ms_str = request.args.get("since")
    if not since_ms_str:
        # If no 'since', return current total unread and current server time, no new messages
        current_total_unread = get_unread_notifications_count(current_user.id)
        return (
            jsonify(
                {
                    "newNotificationsHTML": [],  # HTML snippets for new notifications
                    "new_notification_data": [],  # Raw data for new notifications
                    "count": 0,
                    "latestTimestamp": int(
                        datetime.now(timezone.utc).timestamp() * 1000
                    ),
                    "totalUnreadCount": current_total_unread,
                }
            ),
            200,
        )

    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp(since_ms / 1000.0, tz=timezone.utc)
    except (ValueError, TypeError):
        app.logger.warning(
            f"AJAX: Invalid 'since' timestamp '{since_ms_str}' for user {current_user.username}."
        )
        return jsonify({"success": False, "error": "Invalid timestamp format."}), 400

    new_notifications_query = (
        select(Notification)
        .where(
            Notification.receiver_id == current_user.id,
            Notification.timestamp > since_time,
        )
        .options(joinedload(Notification.sender))  # Eager load sender for template
        .order_by(Notification.timestamp.desc())  # Newest first
    )
    new_notifications_list = db.session.scalars(new_notifications_query).all()

    rendered_html_snippets = []
    new_notification_data_list = []  # For potential non-HTML updates

    latest_ts_in_batch = since_ms  # Start with the 'since' timestamp

    for n in new_notifications_list:
        # Render each new notification item using the partial
        # Ensure `humanize_time_diff` is available to templates
        html_snippet = render_template(
            "partials/_notification_item.html", notification=n
        )
        rendered_html_snippets.append(html_snippet)

        # Also prepare raw data if JS needs it for more complex updates
        new_notification_data_list.append(
            {
                "id": n.id,
                "content": n.content,
                "link_url": n.link_url,
                "timestamp_iso": n.timestamp.isoformat(),
                "sender_name": (
                    n.sender.full_name or n.sender.username if n.sender else "System"
                ),
                "is_read": n.is_read,  # Should be false for new ones
                "notification_type": n.notification_type,
            }
        )

        # Update latest timestamp from this batch
        notification_ts_ms = int(n.timestamp.timestamp() * 1000)
        if notification_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = notification_ts_ms

    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(
        latest_ts_in_batch,
        current_server_timestamp_ms if not new_notifications_list else 0,
    )

    # Get current total unread count to send back for accurate badge update
    current_total_unread = get_unread_notifications_count(current_user.id)

    return (
        jsonify(
            {
                "newNotificationsHTML": rendered_html_snippets,  # Pass rendered HTML
                "new_notification_data": new_notification_data_list,  # Pass raw data
                "count": len(new_notifications_list),
                "latestTimestamp": final_latest_timestamp,  # Crucial for next poll
                "totalUnreadCount": current_total_unread,  # For accurate badge update
            }
        ),
        200,
    )


@app.route("/notifications/mark-all-read", methods=["POST"])
@login_required  # User must be logged in
def mark_all_notifications_read():
    """Mark all unread notifications as read for the current user (AJAX endpoint)."""
    try:
        # Use a bulk update for efficiency to mark all unread notifications for the current user as read
        updated_count = (
            db.session.query(Notification)
            .filter(
                Notification.receiver_id
                == current_user.id,  # Only affect current user's notifications
                Notification.is_read
                == False,  # Only update those that are currently unread
            )
            .update(
                {Notification.is_read: True},  # Set is_read to True
                synchronize_session=False,  # Required for bulk updates outside standard ORM session sync
            )
        )
        db.session.commit()  # Commit the bulk update

        app.logger.info(
            f"Marked {updated_count} notifications as read for user {current_user.username} (ID: {current_user.id}) via mark-all-read endpoint."
        )

        # Return a JSON response indicating success and the number of notifications updated
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Marked {updated_count} notifications as read",
                    "updated_count": updated_count,
                }
            ),
            200,
        )  # 200 OK success status code

    except Exception as e:
        db.session.rollback()  # Rollback the transaction on error
        app.logger.error(
            f"Error marking all notifications as read for user {current_user.id}: {e}",
            exc_info=True,
        )
        # Return a JSON response indicating failure
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Failed to mark notifications as read due to a server error.",
                }
            ),
            500,
        )  # 500 Internal Server Error status code


@app.route("/notifications/mark-read/<int:notification_id>", methods=["POST"])
@login_required  # User must be logged in
def mark_notification_read(notification_id):
    """Mark a specific notification as read (AJAX endpoint)."""
    try:
        # Fetch the specific notification by ID
        notification = db.session.get(Notification, notification_id)

        # Check if notification exists and belongs to the current user
        if not notification:
            app.logger.warning(
                f"Mark read attempt failed for non-existent notification ID {notification_id} by user {current_user.id}."
            )
            return (
                jsonify({"success": False, "error": "Notification not found"}),
                404,
            )  # 404 Not Found

        # Security check: Ensure the notification belongs to the currently logged-in user
        if notification.receiver_id != current_user.id:
            app.logger.warning(
                f"Unauthorized mark read attempt: User {current_user.id} tried to mark notification {notification_id} belonging to user {notification.receiver_id}."
            )
            return (
                jsonify(
                    {"success": False, "error": "Unauthorized access to notification"}
                ),
                403,
            )  # 403 Forbidden

        # Only update the notification if it's currently unread
        if not notification.is_read:
            notification.is_read = True  # Mark as read
            db.session.commit()  # Commit the change
            app.logger.info(
                f"Marked notification {notification_id} as read for user {current_user.username} (ID: {current_user.id})."
            )
            # Return success JSON response
            return (
                jsonify(
                    {
                        "success": True,
                        "message": "Notification marked as read",
                        "notification_id": notification_id,
                    }
                ),
                200,
            )  # 200 OK
        else:
            # Notification was already read, return success but indicate no change was needed
            app.logger.debug(
                f"Notification {notification_id} was already read for user {current_user.id}."
            )
            return (
                jsonify(
                    {
                        "success": True,
                        "message": "Notification was already read",
                        "notification_id": notification_id,
                    }
                ),
                200,
            )

    except Exception as e:
        db.session.rollback()  # Rollback on error
        app.logger.error(
            f"Error marking notification {notification_id} as read for user {current_user.id}: {e}",
            exc_info=True,
        )
        # Return JSON response indicating failure
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Failed to mark notification as read due to a server error.",
                }
            ),
            500,
        )  # 500 Internal Server Error


@app.route("/notifications/check-new")
@login_required  # User must be logged in to check for new notifications
def check_new_notifications():
    """
    Checks for new notifications received by the current user since a given timestamp (AJAX endpoint for polling).
    Expected query parameter: `since` (timestamp in milliseconds since epoch).
    """
    try:
        # Get the 'since' timestamp from query arguments
        since_ms = request.args.get("since", type=int)

        # Validate the input timestamp
        if since_ms is None or since_ms < 0:
            app.logger.warning(
                f"Invalid or missing 'since' timestamp ({since_ms}) from user {current_user.id}. Returning empty new notifications."
            )
            # Return current time and an empty list
            return (
                jsonify(
                    {
                        "newNotifications": [],
                        "count": 0,
                        "latestTimestamp": int(
                            datetime.now(timezone.utc).timestamp() * 1000
                        ),
                    }
                ),
                200,
            )  # 200 OK

        # Convert milliseconds timestamp to datetime object (UTC)
        # Handle potential errors during conversion (e.g., excessively large timestamp)
        try:
            since_time = datetime.fromtimestamp(since_ms / 1000.0, tz=timezone.utc)
        except (ValueError, OverflowError):
            app.logger.warning(
                f"Invalid 'since' timestamp value {since_ms} from user {current_user.id}. Conversion error. Returning empty new notifications."
            )
            # Return current time and an empty list
            return (
                jsonify(
                    {
                        "newNotifications": [],
                        "count": 0,
                        "latestTimestamp": int(
                            datetime.now(timezone.utc).timestamp() * 1000
                        ),
                    }
                ),
                200,
            )

        # Query for new notifications received by the current user since the provided timestamp
        # Order by timestamp descending (newest first)
        new_notifications = db.session.scalars(
            Notification.query.filter(
                Notification.receiver_id == current_user.id,  # For the current user
                Notification.timestamp
                > since_time,  # Notifications created AFTER the 'since' timestamp
            ).order_by(Notification.timestamp.desc())
        ).all()

        # Prepare HTML snippets for the new notifications for display on the client side
        html_snippets = []
        for n in new_notifications:
            try:
                # Render a small HTML snippet for each new notification using a partial template
                # Assume a template file like `partials/notification_item.html` exists for rendering a single notification
                html_snippets.append(
                    render_template("partials/notification_item.html", notification=n)
                )
            except Exception as render_e:
                app.logger.error(
                    f"Error rendering notification item {n.id} for user {current_user.id}: {render_e}",
                    exc_info=True,
                )
                # Optionally include a placeholder error message in the snippet list

        # Get the current server timestamp (in milliseconds) to send back to the client
        # The client will use this for the 'since' parameter in the next polling request.
        current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)

        # Return a JSON response containing the new notifications' HTML, count, and the latest server timestamp
        return (
            jsonify(
                {
                    "newNotifications": html_snippets,  # List of rendered HTML strings
                    "count": len(
                        new_notifications
                    ),  # Number of new notifications fetched
                    "latestTimestamp": current_server_timestamp_ms,  # Server timestamp for next poll
                }
            ),
            200,
        )  # 200 OK success status code

    except Exception as e:
        # Log any unexpected errors during the check
        app.logger.error(
            f"Error checking new notifications for user {current_user.id}: {e}",
            exc_info=True,
        )
        # Return a JSON response indicating failure
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Failed to fetch new notifications due to a server error.",
                }
            ),
            500,
        )  # 500 Internal Server Error status code


# Notification settings route - needs implementation based on user model fields (e.g., email_notifications, push_notifications)
# This route is likely part of the universal settings page (Part 13) or a dedicated notifications settings page.
@app.route("/notifications/settings", methods=["GET", "POST"])
@login_required  # User must be logged in to change settings
def notification_settings():
    """Allows the current user to manage their notification preferences."""
    # This route is typically accessed as a GET to display the current settings
    # and a POST to save updated settings.

    # This requires notification preference columns on the User model (added in Part 2's User model update).
    # Example: email_notifications, push_notifications, notification_sound, etc.

    # A dedicated form for notification settings (`NotificationSettingsForm`) could be defined in Part 4,
    # or these settings could be integrated into the `UniversalSettingsForm` (Part 13).
    # If using a dedicated form:
    # form = NotificationSettingsForm(obj=current_user) # Populate form fields from current_user object

    if request.method == "POST":
        # Handle saving the notification settings from the submitted data.
        # The data might come from a standard form POST or an AJAX JSON request.

        # --- Option 1: Handle data directly from request.form (if using a standard form) ---
        # Assuming form fields like 'email_notifications', 'push_notifications' exist in request.form
        # try:
        #     # Update user attributes based on form data (checkboxes submit 'on' or are missing)
        #     current_user.email_notifications = 'email_notifications' in request.form
        #     current_user.push_notifications = 'push_notifications' in request.form # If column exists
        #     current_user.notification_sound = 'notification_sound' in request.form # If column exists
        #     # Add updates for other notification settings...

        #     db.session.commit() # Save changes
        #     flash("Notification settings saved successfully!", "success")
        #     app.logger.info(f"Notification settings updated for user {current_user.id} via POST.")
        #     # Redirect back to the settings page (GET method)
        #     return redirect(url_for('notification_settings'))

        # except Exception as e:
        #     db.session.rollback()
        #     app.logger.error(f"Error updating notification settings for user {current_user.id} via POST: {e}", exc_info=True)
        #     flash("Failed to save notification settings due to a server error.", "danger")
        #     # Re-render the page with error message - might need to fetch current settings again if not using a form object
        #     # If using a form: return render_template("notifications/settings.html", form=form, title="Notification Settings")
        #     # If not using a form: render the page directly and flash message is shown
        #     return render_template("notifications/settings.html", title="Notification Settings")

        # --- Option 2: Handle data from JSON request (if using AJAX save) ---
        if request.is_json:
            try:
                data = request.get_json()  # Get JSON data from the request body

                # Update user attributes based on JSON data keys
                # Accessing data using .get() with a default handles missing keys gracefully
                # Assuming keys like 'email_notifications', 'push_notifications', 'notification_sound' etc.
                # Values expected: boolean (True/False)
                if "email_notifications" in data:  # Check if the key exists in the JSON
                    current_user.email_notifications = bool(
                        data["email_notifications"]
                    )  # Ensure boolean type
                # Add updates for other notification settings if they exist on the User model:
                # if 'push_notifications' in data:
                #      current_user.push_notifications = bool(data['push_notifications'])
                # if 'notification_sound' in data:
                #      current_user.notification_sound = bool(data['notification_sound'])
                # ... etc. for other notification settings columns ...

                db.session.commit()  # Save changes to the database

                app.logger.info(
                    f"Notification settings updated for user {current_user.id} via AJAX."
                )
                # Return a JSON response indicating success
                return (
                    jsonify(
                        {"success": True, "message": "Notification settings saved."}
                    ),
                    200,
                )  # 200 OK

            except Exception as e:
                db.session.rollback()  # Rollback on error
                app.logger.error(
                    f"Error updating notification settings for user {current_user.id} via AJAX: {e}",
                    exc_info=True,
                )
                # Return a JSON response indicating failure
                return (
                    jsonify(
                        {
                            "success": False,
                            "message": "Failed to save notification settings.",
                        }
                    ),
                    500,
                )  # 500 Internal Server Error

        else:  # Handle cases where POST is not JSON (and not a standard form, if Option 1 is commented out)
            flash("Invalid request format for saving notification settings.", "danger")
            # Redirect back or re-render the page
            return redirect(url_for("notification_settings"))  # Redirect back on error

    # --- Handle GET request (displaying the notification settings page) ---
    # Render the settings page template.
    # If using a dedicated form, pass it: return render_template("notifications/settings.html", form=form, title="Notification Settings")
    # If reading settings directly from the current_user object in the template:
    return render_template("notifications/settings.html", title="Notification Settings")


# --- PART 11 END: Notifications ---


# In app.py -> social media routes section

@app.route("/social/groups")
@login_required
def social_group_list():
    # --- THIS LOGIC IS NEW ---
    # Fetch groups current user owns
    my_owned_groups_query = (
        select(SocialGroup)
        .where(
            SocialGroup.owner_id == current_user.id,
            SocialGroup.is_active == True,
        )
        .order_by(SocialGroup.name.asc())
    )
    my_owned_groups = db.session.scalars(my_owned_groups_query).all()

    # Fetch groups current user is a member of (but does not own)
    my_joined_groups_query = (
        select(SocialGroupMember)
        .join(SocialGroup)
        .where(
            SocialGroupMember.user_id == current_user.id,
            SocialGroup.owner_id != current_user.id, # Exclude owned groups
            SocialGroup.is_active == True,
        )
        .options(
            joinedload(SocialGroupMember.group).joinedload(SocialGroup.owner)
        )
        .order_by(SocialGroup.name.asc())
    )
    my_joined_groups = db.session.scalars(my_joined_groups_query).all()
    # --- END OF NEW LOGIC ---

    return render_template(
        "social/groups/list.html", 
        my_owned_groups=my_owned_groups, 
        my_joined_groups=my_joined_groups, # Pass both lists to the template
        title="My Social Groups - Nexus"
    )
# Route to discover groups (optional - similar to channels, but groups are often private)
# This would typically list public groups or groups where membership is open/requestable.
# @app.route("/social/groups/discovery")
# @login_required
# def social_group_discovery():
#      # Query for public groups or groups user can join
@app.route("/social/channels/<int:channel_id>")
@login_required
def view_social_channel(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    if not channel.is_active:
        flash(f"Channel '{channel.name}' is currently not active.", "warning")
        return redirect(url_for("social_channel_list"))

    # Permission checks
    user_channel_role = current_user.get_channel_role(channel)
    is_owner = channel.owner_id == current_user.id
    is_admin = user_channel_role == "admin"
    is_subscribed = user_channel_role is not None

    if channel.type == "private" and not is_subscribed:
        flash(f"'{channel.name}' is a private channel. You must be a subscriber to view its content.", "warning")
        return redirect(url_for("social_channel_discover"))

    # The problematic eager loads for 'comments' and 'reactions' have been removed.
    posts_query = (
        select(ChannelPost)
        .where(ChannelPost.channel_id == channel.id)
        .options(
            joinedload(ChannelPost.author).joinedload(User.role),
            joinedload(ChannelPost.file),
        )
        .order_by(ChannelPost.timestamp.desc())
    )

    page = request.args.get("page", 1, type=int)
    per_page_posts = 10
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts = pagination.items

    # Form for creating new posts
    post_form = PostContentForm()

    # Determine if the current user can post
    can_post_in_channel = is_owner or is_admin

    # FIX: The form object is now passed with the key 'form' which the template expects.
    return render_template(
        "social/channels/view_channel.html",
        channel=channel,
        posts=posts,
        pagination=pagination,
        form=post_form,  # Changed 'post_form' to 'form' to match the template partial
        is_owner=is_owner,
        is_admin=is_admin,
        is_subscribed=is_subscribed,
        can_post_in_channel=can_post_in_channel,
        title=f"{channel.name} - Channel - Nexus",
    )
@app.route(
    "/social/groups/<int:group_id>"
)  # Add methods=['GET'] if it only handles GET for now (POST is separate)
@login_required
def view_social_group(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    if not group.is_active:
        flash(f"Group '{group.name}' is currently not active.", "warning")
        return redirect(url_for("social_group_list"))

    user_group_role = current_user.get_group_role(group)  # Helper from User model
    if not user_group_role:  # Not a member
        # For groups, usually only members can view. Adjust if public groups are a feature.
        flash(f"You must be a member of '{group.name}' to view its content.", "warning")
        return redirect(url_for("social_group_list"))  # Or a group discovery page

    # Fetch initial messages (e.g., paginated)
    # Assuming column-reverse, so fetch oldest first if prepending via JS later, or newest if initial load shows latest
    messages_query = (
        select(GroupMessage)
        .where(GroupMessage.group_id == group.id)
        .options(
            joinedload(GroupMessage.author).joinedload(User.role),
            joinedload(GroupMessage.file),
        )
        .order_by(
            GroupMessage.timestamp.asc()
        )  # Oldest first for typical chat display append
        .limit(50)  # Initial batch
    )
    messages = db.session.scalars(messages_query).all()

    # Form for creating new messages in this group
    post_form = PostContentForm()  # Your PostContentForm for message input

    # FIX: The form object is now passed with the key 'form' which the template expects.
    return render_template(
        "social/groups/view_group.html",
        group=group,
        messages=messages,
        # pagination=pagination, # If messages are paginated
        form=post_form, # Changed 'post_form' to 'form' to match the template partial
        user_group_role=user_group_role,  # e.g., 'owner', 'admin', 'member'
        title=f"{group.name} - Group Chat - Nexus",
    )

# Route to redirect for viewing a specific message (e.g., from a notification link)
@app.route("/social/messages/<int:message_id>/view")
@login_required
def view_social_group_message_redirect(message_id):
    """Redirects to the group page containing a specific message."""
    message = db.get_or_404(GroupMessage, message_id)

    # Before redirecting, check if the user has permission to view the group where this message is located
    if not current_user.is_group_member(message.group):  # Uses User model helper
        flash("You do not have permission to view this message.", "danger")
        return redirect(
            url_for("social_group_list")
        )  # Redirect to group list or similar safe page

    # Redirect to the group page. Use an anchor if the frontend chat UI supports it.
    # The anchor helps the page scroll to the specific message if the template is set up for it.
    return redirect(
        url_for(
            "view_social_group",
            group_id=message.group_id,
            _anchor=f"message-{message.id}",
        )
    )


@app.route("/social/groups/<int:group_id>/create_message", methods=["POST"])
@login_required
def create_group_message(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    if not group.is_active:
        return jsonify({"success": False, "error": "This group is not active."}), 403

    user_group_role = current_user.get_group_role(group)
    if not user_group_role:  # Must be a member to post
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You must be a member to send messages in this group.",
                }
            ),
            403,
        )

    # Assume PostContentForm for validation consistency
    form = PostContentForm(request.form)
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Message content or a file must be provided.",
                }
            ),
            400,
        )
    if form.content.data and not form.content.validate(form):
        return (
            jsonify(
                {
                    "success": False,
                    "error": (
                        form.content.errors[0]
                        if form.content.errors
                        else "Invalid content."
                    ),
                }
            ),
            400,
        )

    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage)  # Reusing helper
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed."}), 400
        except Exception as e:
            app.logger.error(
                f"Error processing file for group message by {current_user.username}: {e}",
                exc_info=True,
            )
            return jsonify({"success": False, "error": "Error processing file."}), 500

    try:
        new_message = GroupMessage(  # Ensure GroupMessage model is imported
            group_id=group.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc),
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_message)
        db.session.commit()

        app.logger.info(
            f"User {current_user.username} sent message ID {new_message.id} in group {group.id}."
        )

        # Prepare message data for client-side rendering using _chat_message_item.html
        # The _chat_message_item.html expects a 'message' object with 'sender', 'content', 'timestamp'
        message_data_for_client = {
            "id": new_message.id,
            "sender_id": new_message.author_id,  # Correct field
            "sender": {
                "full_name": current_user.full_name,
                "username": current_user.username,
                "profile_photo_url": current_user.profile_photo_url,
            },
            "content": new_message.content,
            "timestamp": new_message.timestamp.isoformat() + "Z",
            # Include file info if any, for the _chat_message_item to render (if it handles files)
            "file": (
                {
                    "id": uploaded_file_obj.id,
                    "original_filename": uploaded_file_obj.original_filename,
                    "mimetype": uploaded_file_obj.mimetype,
                    "size": uploaded_file_obj.size,
                    "download_url": url_for(
                        "download_social_file", file_id=uploaded_file_obj.id
                    ),  # Assuming this route exists
                }
                if uploaded_file_obj
                else None
            ),
        }
        # OR render HTML on server
        # message_for_render = db.session.query(GroupMessage).options(...).get(new_message.id)
        # post_html = render_template("partials/_chat_message_item.html", message=message_for_render, current_user_id=current_user.id)

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Message sent!",
                    # "post_html": post_html, # If rendering HTML snippet on server
                    "post_data": message_data_for_client,  # If rendering on client
                }
            ),
            201,
        )

    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath:  # Cleanup
            try:
                os.remove(
                    os.path.join(current_app.static_folder, uploaded_file_obj.filepath)
                )
            except:
                pass
        app.logger.error(
            f"Error creating group message in group {group.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error sending message."}),
            500,
        )


# --- Channel and Group Creation/Management Routes ---
@app.route("/social/api/groups/<int:group_id>/messages/new")
@login_required
def ajax_get_new_group_messages(group_id):
    group = db.get_or_404(SocialGroup, group_id)
    if not current_user.is_group_member(group):  # User.is_group_member helper
        return jsonify({"error": "Access denied."}), 403

    since_ms_str = request.args.get("since")
    if not since_ms_str:
        return jsonify({"error": "Missing 'since' timestamp."}), 400

    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp(
            (since_ms / 1000.0) + 0.001, tz=timezone.utc
        )
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid timestamp format."}), 400

    new_messages_query = (
        select(GroupMessage)
        .where(GroupMessage.group_id == group_id, GroupMessage.timestamp > since_time)
        .options(
            joinedload(GroupMessage.author).joinedload(User.role),
            joinedload(GroupMessage.file),
        )
        .order_by(GroupMessage.timestamp.asc())
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data_for_client = []
    latest_ts_in_batch = since_ms
    for msg in new_messages_list:
        # Prepare data similarly to create_group_message response
        messages_data_for_client.append(
            {
                "id": msg.id,
                "sender_id": msg.author_id,
                "sender": {
                    "full_name": msg.author.full_name if msg.author else "Unknown",
                    "username": msg.author.username if msg.author else "unknown",
                    "profile_photo_url": (
                        msg.author.profile_photo_url if msg.author else None
                    ),
                },
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat() + "Z",
                "file": (
                    {
                        "id": msg.file.id,
                        "original_filename": msg.file.original_filename,
                        "mimetype": msg.file.mimetype,
                        "size": msg.file.size,
                        "download_url": url_for(
                            "download_social_file", file_id=msg.file.id
                        ),
                    }
                    if msg.file
                    else None
                ),
            }
        )
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms

    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(
        latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0
    )

    return (
        jsonify(
            {
                "messages": messages_data_for_client,  # Send structured data
                "latest_timestamp": final_latest_timestamp,
            }
        ),
        200,
    )


# Note: create_social_channel and create_social_group routes were already generated in Part 8 accidentally.
# I will regenerate them here for completeness of Part 12, assuming they were not included in previous parts.
# If they WERE included in Part 8, you should remove the duplicates.

# Helper function to save profile photos (separate from general file uploads)
# Assuming this helper was intended for Part 12 and is defined here.
# --- (Place with other helper functions, ensure secure_filename, os, uuid are imported) ---
# from werkzeug.utils import secure_filename
# import os
# import uuid
# from flask import current_app, flash # Ensure current_app and flash are available

# Define UPLOAD_PHOTO_FOLDER at the top level of your app.py, after app initialization
# if not already defined in a more central config place.
# UPLOAD_PHOTO_FOLDER = os.path.join(app.root_path, 'static', 'uploads', 'profile_photos')
# app.config['UPLOAD_PHOTO_FOLDER'] = UPLOAD_PHOTO_FOLDER
# It's better if app.config['UPLOAD_PHOTO_FOLDER'] is set during app configuration.


def save_profile_photo(file_storage):
    """Saves an uploaded profile photo securely and returns its relative path for DB storage."""
    if not file_storage or not file_storage.filename:
        # This case should ideally be caught by FileField validators if field is required
        return None

    # Ensure the target upload folder exists
    # It's better to ensure this once at app startup or use app.config
    upload_folder = current_app.config.get(
        "UPLOAD_PHOTO_FOLDER",
        os.path.join(current_app.root_path, "static", "uploads", "profile_photos"),
    )
    os.makedirs(upload_folder, exist_ok=True)

    # Allowed extensions for photos
    ALLOWED_PHOTO_EXTENSIONS = {"png", "jpg", "jpeg", "gif", "webp"}
    filename = secure_filename(file_storage.filename)

    file_ext = filename.rsplit(".", 1)[1].lower() if "." in filename else ""
    if file_ext not in ALLOWED_PHOTO_EXTENSIONS:
        flash(
            f"Invalid file type for profile photo: '{file_ext}'. Allowed: {', '.join(ALLOWED_PHOTO_EXTENSIONS)}.",
            "danger",
        )
        app.logger.warning(
            f"Profile photo upload rejected for user {current_user.id if current_user.is_authenticated else 'Unknown'}: Invalid extension '{file_ext}'."
        )
        return None  # Indicate failure

    # Check file size (example: 2MB limit)
    # FilePond might handle this client-side, but server-side check is crucial.
    MAX_PHOTO_SIZE = (
        current_app.config.get("MAX_PROFILE_PHOTO_SIZE_MB", 2) * 1024 * 1024
    )  # e.g., 2MB
    file_storage.seek(0, os.SEEK_END)
    file_length = file_storage.tell()
    file_storage.seek(0)  # Reset cursor
    if file_length > MAX_PHOTO_SIZE:
        flash(
            f"Profile photo exceeds maximum size of {MAX_PHOTO_SIZE / (1024*1024):.0f}MB.",
            "danger",
        )
        app.logger.warning(
            f"Profile photo upload rejected for user {current_user.id if current_user.is_authenticated else 'Unknown'}: File too large ({file_length} bytes)."
        )
        return None  # Indicate failure

    # Generate a unique filename using UUID to prevent collisions and obscure original name
    unique_filename = str(uuid.uuid4()) + "." + file_ext
    save_path_full = os.path.join(upload_folder, unique_filename)

    try:
        file_storage.save(save_path_full)
        app.logger.info(
            f"Profile photo '{unique_filename}' saved to '{save_path_full}' for user {current_user.id if current_user.is_authenticated else 'Unknown'}."
        )
        # Return the path relative to the 'static' folder for use in url_for()
        # e.g., uploads/profile_photos/unique_filename.jpg
        # This assumes your UPLOAD_PHOTO_FOLDER is under 'static'.
        # Adjust if your static file serving or UPLOAD_PHOTO_FOLDER structure is different.
        # The path stored in User.profile_photo_url should be relative from 'static'.
        # Example: if app.root_path is /srv/app, and upload_folder is /srv/app/static/uploads/profile_photos
        # then relative_path should be uploads/profile_photos/unique_filename.jpg

        # Construct the relative path from the 'static' folder correctly
        static_folder_path = os.path.join(current_app.root_path, "static")
        relative_path = os.path.relpath(save_path_full, static_folder_path)
        # On Windows, relpath might use backslashes; convert to forward slashes for URLs
        return relative_path.replace(os.sep, "/")

    except Exception as e:
        app.logger.error(
            f"Error saving profile photo '{unique_filename}': {e}", exc_info=True
        )
        flash(
            "An error occurred while saving the profile photo. Please try again.",
            "danger",
        )
        # Optionally, attempt to clean up if file was partially saved
        if os.path.exists(save_path_full):
            try:
                os.remove(save_path_full)
            except Exception as cleanup_e:
                app.logger.error(
                    f"Failed to cleanup partially saved photo {save_path_full}: {cleanup_e}"
                )
        return None  # Indicate failure


# START MODIFICATION (create_social_channel route)
@app.route("/social/create_channel", methods=["GET", "POST"])
@login_required
# Define who can create channels (e.g., teachers, hr_ceo, system_admin)


def create_social_channel():
    form = CreateChannelForm()  # CreateChannelForm from app.py Part 4
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        profile_photo_relative_path = None
        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                # save_profile_photo helper should be suitable for channel photos too,
                # or create a save_channel_photo variant if paths/sizes differ.
                profile_photo_relative_path = save_profile_photo(
                    form.profile_photo.data
                )
                if not profile_photo_relative_path:
                    # Error flashed by helper
                    return render_template(
                        "social/channels/create_channel.html",
                        form=form,
                        title="Create New Channel - Nexus",
                    )
            except Exception as e:
                app.logger.error(
                    f"Error saving channel profile photo for user {current_user.id}: {e}",
                    exc_info=True,
                )
                flash(
                    "An unexpected error occurred while uploading the profile photo.",
                    "danger",
                )
                return render_template(
                    "social/channels/create_channel.html",
                    form=form,
                    title="Create New Channel - Nexus",
                )

        try:
            # Check for existing channel name (case-insensitive)
            existing_channel = db.session.scalar(
                select(Channel).filter(
                    func.lower(Channel.name) == func.lower(form.name.data.strip())
                )
            )
            if existing_channel:
                form.name.errors.append("A channel with this name already exists.")
                # Cleanup uploaded photo if name conflict
                if profile_photo_relative_path:
                    try:
                        os.remove(
                            os.path.join(
                                current_app.static_folder, profile_photo_relative_path
                            )
                        )
                    except:
                        pass
                return render_template(
                    "social/channels/create_channel.html",
                    form=form,
                    title="Create New Channel - Nexus",
                )

            new_channel = Channel(
                name=form.name.data.strip(),
                bio=form.bio.data.strip() if form.bio.data else None,
                profile_photo_url=profile_photo_relative_path,
                owner_id=current_user.id,
                social_category_id=form.social_category_id.data,
                type=form.channel_type.data,  # 'public' or 'private'
                allow_comments=form.allow_comments.data,
                allow_reactions=form.allow_reactions.data,
                created_at=datetime.now(timezone.utc),
                is_active=True,  # New channels are active
            )
            db.session.add(new_channel)
            db.session.commit()  # Commit to get new_channel.id

            # Automatically subscribe the owner
            owner_subscription = ChannelSubscriber(
                channel_id=new_channel.id,
                user_id=current_user.id,
                role="owner",  # Owner role in the channel
                subscribed_at=datetime.now(timezone.utc),
            )
            db.session.add(owner_subscription)
            db.session.commit()

            flash(f"Channel '{new_channel.name}' created successfully!", "success")
            app.logger.info(
                f"User {current_user.username} created channel '{new_channel.name}' (ID: {new_channel.id})."
            )
            return redirect(url_for("view_social_channel", channel_id=new_channel.id))

        except IntegrityError:  # Should be caught by name check, but as fallback
            db.session.rollback()
            if profile_photo_relative_path:  # Cleanup photo if DB error
                try:
                    os.remove(
                        os.path.join(
                            current_app.static_folder, profile_photo_relative_path
                        )
                    )
                except:
                    pass
            flash(
                "A channel with this name already exists or another database error occurred.",
                "danger",
            )
        except Exception as e:
            db.session.rollback()
            if profile_photo_relative_path:  # Cleanup photo
                try:
                    os.remove(
                        os.path.join(
                            current_app.static_folder, profile_photo_relative_path
                        )
                    )
                except:
                    pass
            app.logger.error(
                f"Error creating channel by {current_user.username}: {e}", exc_info=True
            )
            flash("An unexpected error occurred. Please try again.", "danger")

    return render_template(
        "social/channels/create_channel.html",
        form=form,
        title="Create New Channel - Nexus",
    )


@app.route("/social/channels/<int:channel_id>/posts")  # GET request
@login_required
def get_channel_posts_paginated(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    # Permission check (same as view_social_channel)
    user_channel_role = current_user.get_channel_role(channel)
    if channel.type == "private" and not user_channel_role:
        return (
            jsonify({"success": False, "error": "Access denied to private channel."}),
            403,
        )

    page = request.args.get("page", 1, type=int)
    per_page_posts = 10  # Should match the initial load in view_social_channel

    posts_query = (
        select(ChannelPost)
        .where(ChannelPost.channel_id == channel.id)
        .options(
            joinedload(ChannelPost.author).joinedload(User.role),
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments).joinedload(ChannelComment.author),
            joinedload(ChannelPost.reactions),
        )
        .order_by(ChannelPost.timestamp.desc())
    )
    pagination = db.paginate(
        posts_query, page=page, per_page=per_page_posts, error_out=False
    )
    posts_on_page = pagination.items

    posts_html = ""
    if posts_on_page:
        # Create a temporary list of rendered post items
        rendered_posts_list = []
        for post_item in posts_on_page:
            rendered_posts_list.append(
                render_template(
                    "partials/_social_post_item.html",
                    post=post_item,
                    current_user=current_user,
                )
            )
        posts_html = "".join(rendered_posts_list)  # Join all rendered HTML strings

    return jsonify(
        {
            "success": True,
            "posts_html": posts_html,  # The rendered HTML for the posts
            "has_next_page": pagination.has_next,
            "next_page_num": pagination.next_num if pagination.has_next else None,
            "current_page": pagination.page,
        }
    )


@app.route("/social/channels/<int:channel_id>/subscribe", methods=["POST"])
@login_required
def ajax_subscribe_channel(channel_id):  # Renamed to indicate AJAX
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    if current_user.is_channel_member(channel):
        return (
            jsonify(
                {"success": False, "error": "You are already a member/subscriber."}
            ),
            400,
        )

    if channel.type != "public":  # For now, only direct subscribe to public
        return (
            jsonify(
                {
                    "success": False,
                    "error": "This is a private channel. Subscription by invite/approval only.",
                }
            ),
            403,
        )

    try:
        new_subscriber = ChannelSubscriber(
            channel_id=channel.id,
            user_id=current_user.id,
            role="subscriber",
            subscribed_at=datetime.now(timezone.utc),
        )
        db.session.add(new_subscriber)
        db.session.commit()

        new_subscriber_count = channel.subscribers.count()  # Recalculate count
        app.logger.info(
            f"User {current_user.username} AJAX subscribed to channel {channel.id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Successfully subscribed to '{channel.name}'.",
                    "new_subscriber_count": new_subscriber_count,
                }
            ),
            200,
        )
    except IntegrityError:  # Should be caught by first check, but safety
        db.session.rollback()
        return (
            jsonify({"success": False, "error": "Already subscribed (Integrity)."}),
            400,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error AJAX subscribing user {current_user.id} to channel {channel.id}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error during subscription."}),
            500,
        )


@app.route("/social/channels/<int:channel_id>/unsubscribe", methods=["POST"])
@login_required
def ajax_unsubscribe_channel(channel_id):  # Renamed for AJAX
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    subscriber_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(
            channel_id=channel.id, user_id=current_user.id
        )
    )

    if not subscriber_entry:
        return (
            jsonify(
                {"success": False, "error": "You are not subscribed to this channel."}
            ),
            400,
        )

    if subscriber_entry.role == "owner":
        owner_count = (
            db.session.scalar(
                select(func.count(ChannelSubscriber.user_id)).where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.role == "owner",
                )
            )
            or 0
        )
        if owner_count <= 1:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "You are the only owner. Transfer ownership before leaving.",
                    }
                ),
                403,
            )

    try:
        db.session.delete(subscriber_entry)
        db.session.commit()
        new_subscriber_count = channel.subscribers.count()
        app.logger.info(
            f"User {current_user.username} AJAX unsubscribed from channel {channel.id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Successfully unsubscribed from '{channel.name}'.",
                    "new_subscriber_count": new_subscriber_count,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error AJAX unsubscribing user {current_user.id} from channel {channel.id}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error during unsubscription."}),
            500,
        )


@app.route("/social/channels/posts/<int:post_id>/react", methods=["POST"])
@login_required
def react_channel_post(post_id):
    post = db.get_or_404(ChannelPost, post_id, description="Post not found.")
    channel = post.channel

    if not channel.is_active or (
        not channel.allow_reactions
        and not current_user.get_channel_role(channel) in ["owner", "admin"]
    ):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Reactions are disabled for this post or channel.",
                }
            ),
            403,
        )

    if not current_user.is_channel_member(channel):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You must be a channel subscriber to react.",
                }
            ),
            403,
        )

    data = request.get_json()
    emoji = data.get("emoji", "").strip()

    if not emoji:  # Basic validation, can be more specific
        return jsonify({"success": False, "error": "Emoji is required."}), 400

    # For simplicity, allowing only a few known emojis. Expand as needed.
    ALLOWED_REACTION_EMOJIS = ["", "", "", "", "", ""]
    if emoji not in ALLOWED_REACTION_EMOJIS:
        return jsonify({"success": False, "error": "Invalid reaction emoji."}), 400

    try:
        existing_reaction = db.session.scalar(
            select(ChannelReaction).where(
                ChannelReaction.post_id == post.id,
                ChannelReaction.user_id == current_user.id,
                ChannelReaction.emoji
                == emoji,  # Check if user already reacted with this specific emoji
            )
        )

        user_reacted_with_this_emoji = False
        if existing_reaction:
            db.session.delete(existing_reaction)
            action_message = "Reaction removed."
            user_reacted_with_this_emoji = False
        else:
            # Optional: If user has another reaction, remove it before adding new one (single reaction per user per post)
            # current_user_any_reaction = db.session.scalar(
            #     select(ChannelReaction).where(ChannelReaction.post_id == post.id, ChannelReaction.user_id == current_user.id)
            # )
            # if current_user_any_reaction:
            #     db.session.delete(current_user_any_reaction)

            new_reaction = ChannelReaction(
                post_id=post.id,
                user_id=current_user.id,
                emoji=emoji,
                created_at=datetime.now(timezone.utc),
            )
            db.session.add(new_reaction)
            action_message = "Reaction added."
            user_reacted_with_this_emoji = True

        db.session.commit()

        # Get updated count for this specific emoji
        new_count_for_emoji = (
            db.session.scalar(
                select(func.count(ChannelReaction.id)).where(
                    ChannelReaction.post_id == post.id, ChannelReaction.emoji == emoji
                )
            )
            or 0
        )

        app.logger.info(
            f"User {current_user.username} {action_message.lower()} emoji '{emoji}' on channel post {post.id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": action_message,
                    "emoji": emoji,  # Send back the emoji for UI update
                    "new_count": new_count_for_emoji,
                    "user_reacted": user_reacted_with_this_emoji,  # True if added, False if removed
                }
            ),
            200,
        )

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error reacting to channel post {post.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error processing reaction."}),
            500,
        )


@app.route("/social/channels/posts/<int:post_id>/comment", methods=["POST"])
@login_required
def add_channel_post_comment(post_id):
    post = db.get_or_404(ChannelPost, post_id, description="Post not found.")
    channel = post.channel  # Get the channel from the post

    if not channel.is_active or (
        not channel.allow_comments
        and not current_user.get_channel_role(channel) in ["owner", "admin"]
    ):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Comments are disabled for this post or channel.",
                }
            ),
            403,
        )

    # Permission to comment (basic: any subscriber if channel allows comments)
    if not current_user.is_channel_member(
        channel
    ):  # Assumes User.is_channel_member helper
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You must be a channel subscriber to comment.",
                }
            ),
            403,
        )

    data = request.get_json()
    content = data.get("content", "").strip()

    if not content:
        return (
            jsonify({"success": False, "error": "Comment content cannot be empty."}),
            400,
        )
    if len(content) > 500:  # Max comment length
        return (
            jsonify(
                {"success": False, "error": "Comment is too long (max 500 characters)."}
            ),
            400,
        )

    try:
        new_comment = ChannelComment(
            post_id=post.id,
            author_id=current_user.id,
            content=content,
            timestamp=datetime.now(timezone.utc),
        )
        db.session.add(new_comment)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} added comment ID {new_comment.id} to channel post {post.id}."
        )

        # Eager load author for rendering the partial
        comment_for_render = (
            db.session.query(ChannelComment)
            .options(joinedload(ChannelComment.author).joinedload(User.role))
            .get(new_comment.id)
        )

        comment_html = render_template(
            "partials/_social_comment_item.html",
            comment=comment_for_render,
            current_user=current_user,
            post=post,
        )  # Pass post if partial needs it for context

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Comment posted!",
                    "comment_html": comment_html,
                }
            ),
            201,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error adding comment to channel post {post.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error posting comment."}),
            500,
        )


@app.route(
    "/social/channels/posts/<int:post_id>/comments/<int:comment_id>/delete",
    methods=["POST"],
)
@login_required
def delete_channel_post_comment(post_id, comment_id):
    comment = db.get_or_404(
        ChannelComment, comment_id, description="Comment not found."
    )
    post = comment.post  # Assumes comment.post relationship
    if not post or post.id != post_id:
        return (
            jsonify(
                {"success": False, "error": "Comment does not belong to this post."}
            ),
            400,
        )

    channel = post.channel

    # Permission to delete comment: comment author OR channel owner/admin OR post author
    is_comment_author = comment.author_id == current_user.id
    is_post_author = post.author_id == current_user.id
    user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner_or_admin = user_channel_role in ["owner", "admin"]

    if not (is_comment_author or is_post_author or is_channel_owner_or_admin):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to delete this comment.",
                }
            ),
            403,
        )

    try:
        db.session.delete(comment)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} deleted comment ID {comment.id} from channel post {post.id}."
        )
        return (
            jsonify({"success": True, "message": "Comment deleted successfully."}),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error deleting comment {comment.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error deleting comment."}),
            500,
        )


@app.route("/social/channels/<int:channel_id>/create_post", methods=["POST"])
@login_required
def create_channel_post(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    if not channel.is_active:
        return jsonify({"success": False, "error": "This channel is not active."}), 403

    # Permission to post (owner, admin, or if channel allows all subscribers - basic for now)
    user_channel_role = current_user.get_channel_role(channel)  # Helper from User model
    is_owner = channel.owner_id == current_user.id
    is_admin_in_channel = user_channel_role == "admin"

    # Basic permission: Owner or Admin of the channel can post.
    # Future: Add channel.allow_all_subscribers_to_post setting check
    can_post = is_owner or is_admin_in_channel
    if not can_post:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to post in this channel.",
                }
            ),
            403,
        )

    # Use PostContentForm for validation (text OR file)
    # The form fields are 'content' and 'attached_file'
    form = PostContentForm(request.form)  # Pass request.form for text fields
    # File data is in request.files, not request.form for WTForms FileField
    # Manually assign file data to form field if needed for form validation,
    # or handle file separately after text validation.

    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)  # Get by field name

    # Validate: content OR file is required
    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return (
            jsonify(
                {"success": False, "error": "Post content or a file must be provided."}
            ),
            400,
        )

    # Validate text content length if present
    if form.content.data and not form.content.validate(
        form
    ):  # Trigger validation for content
        return (
            jsonify(
                {
                    "success": False,
                    "error": (
                        form.content.errors[0]
                        if form.content.errors
                        else "Invalid content."
                    ),
                }
            ),
            400,
        )

    # Handle file upload if present
    if file_storage and file_storage.filename:
        try:
            # save_uploaded_file should return a File DB object (uncommitted) or None
            uploaded_file_obj = save_uploaded_file(
                file_storage
            )  # Your helper from app.py Part 3/12
            if not uploaded_file_obj:
                # Error (e.g. file type/size) should be flashed by helper, or return specific error here
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "File upload failed. Check file type or size.",
                        }
                    ),
                    400,
                )
        except Exception as e:
            app.logger.error(
                f"Error processing uploaded file for channel post by {current_user.username}: {e}",
                exc_info=True,
            )
            return (
                jsonify({"success": False, "error": "Error processing uploaded file."}),
                500,
            )

    try:
        new_post = ChannelPost(
            channel_id=channel.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc),
        )
        if uploaded_file_obj:  # If file was uploaded, add it to session with post
            db.session.add(uploaded_file_obj)

        db.session.add(new_post)
        db.session.commit()  # Commits post and file object if new

        app.logger.info(
            f"User {current_user.username} created post ID {new_post.id} in channel {channel.id}."
        )

        # Eagerly load necessary relationships for rendering the partial
        # This ensures that when render_template is called, all data is available
        post_for_render = (
            db.session.query(ChannelPost)
            .options(
                joinedload(ChannelPost.author).joinedload(User.role),
                joinedload(ChannelPost.file),
                joinedload(ChannelPost.comments),  # For count
                joinedload(ChannelPost.reactions),  # For count
            )
            .get(new_post.id)
        )

        # Render the HTML for the new post item
        post_html = render_template(
            "partials/_social_post_item.html",
            post=post_for_render,
            current_user=current_user,
        )  # Pass current_user if partial needs it

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Post created successfully!",
                    "post_html": post_html,
                    # Optionally send structured post_data if client-side rendering is preferred sometimes
                    # "post_data": { ... serialized post data ... }
                }
            ),
            201,
        )  # 201 Created

    except Exception as e:
        db.session.rollback()
        # If a file was uploaded but DB commit failed, it's good practice to delete the orphaned file
        if uploaded_file_obj and uploaded_file_obj.filepath:
            try:
                full_file_path = os.path.join(
                    current_app.static_folder, uploaded_file_obj.filepath
                )
                if os.path.exists(full_file_path):
                    os.remove(full_file_path)
                    app.logger.info(
                        f"Cleaned up orphaned file: {uploaded_file_obj.filepath}"
                    )
            except Exception as cleanup_e:
                app.logger.error(
                    f"Error cleaning up orphaned file {uploaded_file_obj.filepath}: {cleanup_e}"
                )

        app.logger.error(
            f"Error creating channel post in channel {channel.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error creating post."}), 500



@app.route("/social/channels")
@login_required
def social_channel_list():
    # Fetch channels current user owns
    my_owned_channels_query = (
        select(Channel)
        .where(Channel.owner_id == current_user.id, Channel.is_active == True)
        .options(
            joinedload(Channel.social_category), joinedload(Channel.owner)
        )  # Eager load for card
        .order_by(Channel.name.asc())
    )
    my_owned_channels = db.session.scalars(my_owned_channels_query).all()

    # Fetch channels current user is subscribed to (but does not own)
    my_subscribed_channels_query = (
        select(ChannelSubscriber)
        .join(Channel)  # Join to Channel table
        .where(
            ChannelSubscriber.user_id == current_user.id,
            Channel.owner_id
            != current_user.id,  # Exclude owned channels from this list
            Channel.is_active == True,
        )
        .options(
            joinedload(ChannelSubscriber.channel).joinedload(Channel.social_category),
            joinedload(ChannelSubscriber.channel).joinedload(Channel.owner),
        )  # Eager load for card
        .order_by(Channel.name.asc())
    )
    my_subscribed_channels = db.session.scalars(my_subscribed_channels_query).all()

    return render_template(
        "social/channels/list.html",
        my_owned_channels=my_owned_channels,
        my_subscribed_channels=my_subscribed_channels,
        title="My Channels - Nexus",
    )


# END MODIFICATION (create_social_channel route)
@app.route("/social/create_group", methods=["GET", "POST"])
@login_required
def create_social_group():
    form = CreateGroupForm()  # Your CreateGroupForm from app.py Part 4

    if form.validate_on_submit():
        profile_photo_relative_path = None
        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                profile_photo_relative_path = save_profile_photo(
                    form.profile_photo.data
                )  # Reusing helper
                if not profile_photo_relative_path:
                    return render_template(
                        "social/groups/create_group.html",
                        form=form,
                        title="Create New Group - Nexus",
                    )
            except Exception as e:
                app.logger.error(
                    f"Error saving group profile photo for group by user {current_user.id}: {e}",
                    exc_info=True,
                )
                flash(
                    "An unexpected error occurred while uploading the profile photo.",
                    "danger",
                )
                return render_template(
                    "social/groups/create_group.html",
                    form=form,
                    title="Create New Group - Nexus",
                )

        try:
            # Check for existing group name (case-insensitive)
            existing_group = db.session.scalar(
                select(SocialGroup).filter(
                    func.lower(SocialGroup.name) == func.lower(form.name.data.strip())
                )
            )
            if existing_group:
                form.name.errors.append("A group with this name already exists.")
                if profile_photo_relative_path:  # Cleanup
                    try:
                        os.remove(
                            os.path.join(
                                current_app.static_folder, profile_photo_relative_path
                            )
                        )
                    except:
                        pass
                return render_template(
                    "social/groups/create_group.html",
                    form=form,
                    title="Create New Group - Nexus",
                )

            new_group = SocialGroup(
                name=form.name.data.strip(),
                description=(
                    form.bio.data.strip() if form.bio.data else None
                ),  # Form uses 'bio'
                profile_photo_url=profile_photo_relative_path,
                owner_id=current_user.id,
                is_active=True,
                # Group type (public/private) if added to model and form
            )
            db.session.add(new_group)
            db.session.commit()  # Commit to get new_group.id

            # Automatically make the owner a member
            owner_membership = SocialGroupMember(
                group_id=new_group.id,
                user_id=current_user.id,
                role="owner",
                joined_at=datetime.now(timezone.utc),
            )
            db.session.add(owner_membership)
            db.session.commit()

            flash(f"Group '{new_group.name}' created successfully!", "success")
            app.logger.info(
                f"User {current_user.username} created group '{new_group.name}' (ID: {new_group.id})."
            )
            return redirect(url_for("view_social_group", group_id=new_group.id))

        except IntegrityError:  # Fallback
            db.session.rollback()
            if profile_photo_relative_path:  # Cleanup
                try:
                    os.remove(
                        os.path.join(
                            current_app.static_folder, profile_photo_relative_path
                        )
                    )
                except:
                    pass
            flash(
                "A group with this name already exists or another database error occurred.",
                "danger",
            )
        except Exception as e:
            db.session.rollback()
            if profile_photo_relative_path:  # Cleanup
                try:
                    os.remove(
                        os.path.join(
                            current_app.static_folder, profile_photo_relative_path
                        )
                    )
                except:
                    pass
            app.logger.error(
                f"Error creating group by {current_user.username}: {e}", exc_info=True
            )
            flash("An unexpected error occurred. Please try again.", "danger")

    return render_template(
        "social/groups/create_group.html",
        form=form,
        title="Create New Social Group - Nexus",
    )


# START MODIFICATION (edit_social_channel route)
@app.route("/social/channels/<int:channel_id>/edit", methods=["GET", "POST"])
@login_required
def edit_social_channel(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    # Authorization: Owner, channel admin, or system-level admin (hr_ceo, system_admin)
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]
    if not (
        channel.owner_id == current_user.id
        or user_channel_role == "admin"
        or is_global_admin
    ):
        flash("You do not have permission to edit this channel.", "danger")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    form = EditChannelForm(obj=channel)  # Pre-populate with channel data on GET
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        old_profile_photo_relative_path = channel.profile_photo_url
        new_profile_photo_relative_path = None

        if (
            form.profile_photo.data and form.profile_photo.data.filename
        ):  # Check if new photo uploaded
            try:
                saved_relative_path = save_profile_photo(form.profile_photo.data)
                if saved_relative_path:
                    new_profile_photo_relative_path = saved_relative_path
                else:  # Error flashed by save_profile_photo
                    return render_template(
                        "social/channels/edit_channel.html",
                        form=form,
                        channel=channel,
                        title=f"Edit Channel: {channel.name} - Nexus",
                    )
            except Exception as e:
                app.logger.error(
                    f"Error processing channel photo upload for channel {channel_id}: {e}",
                    exc_info=True,
                )
                flash("An error occurred with the photo upload.", "danger")
                return render_template(
                    "social/channels/edit_channel.html",
                    form=form,
                    channel=channel,
                    title=f"Edit Channel: {channel.name} - Nexus",
                )

        try:
            # Check for name conflict if name changed
            new_name = form.name.data.strip()
            if new_name.lower() != channel.name.lower():
                existing_channel_with_new_name = db.session.scalar(
                    select(Channel).filter(
                        Channel.id != channel.id,
                        func.lower(Channel.name) == func.lower(new_name),
                    )
                )
                if existing_channel_with_new_name:
                    form.name.errors.append(
                        "Another channel with this name already exists."
                    )
                    # Cleanup newly uploaded photo if name conflict
                    if (
                        new_profile_photo_relative_path
                        and old_profile_photo_relative_path
                        != new_profile_photo_relative_path
                    ):
                        try:
                            os.remove(
                                os.path.join(
                                    current_app.static_folder,
                                    new_profile_photo_relative_path,
                                )
                            )
                        except:
                            pass
                    return render_template(
                        "social/channels/edit_channel.html",
                        form=form,
                        channel=channel,
                        title=f"Edit Channel: {channel.name} - Nexus",
                    )

            channel.name = new_name
            channel.bio = form.bio.data.strip() if form.bio.data else None
            channel.social_category_id = form.social_category_id.data
            channel.allow_comments = form.allow_comments.data
            channel.allow_reactions = form.allow_reactions.data
            # channel.type is not typically editable after creation, but if it is:
            # channel.type = form.channel_type.data # Assuming channel_type is on EditChannelForm

            if new_profile_photo_relative_path:
                channel.profile_photo_url = new_profile_photo_relative_path

            # channel.updated_at = datetime.now(timezone.utc) # If you have an updated_at field

            db.session.commit()

            # Delete old photo if new one was successfully saved and different
            if (
                new_profile_photo_relative_path
                and old_profile_photo_relative_path
                and old_profile_photo_relative_path != new_profile_photo_relative_path
                and not old_profile_photo_relative_path.startswith("img/placeholders/")
            ):
                old_photo_full_path = os.path.join(
                    current_app.static_folder, old_profile_photo_relative_path
                )
                if os.path.exists(old_photo_full_path):
                    try:
                        os.remove(old_photo_full_path)
                        app.logger.info(
                            f"Deleted old channel photo: {old_profile_photo_relative_path} for channel {channel.id}"
                        )
                    except Exception as e:
                        app.logger.error(
                            f"Error deleting old channel photo {old_profile_photo_relative_path}: {e}"
                        )

            flash(f"Channel '{channel.name}' updated successfully!", "success")
            app.logger.info(
                f"User {current_user.username} edited channel ID {channel.id}."
            )
            return redirect(url_for("view_social_channel", channel_id=channel.id))

        except IntegrityError:  # Fallback if name check fails due to race condition
            db.session.rollback()
            flash(
                "Update failed. A channel with the new name might already exist.",
                "danger",
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error editing channel {channel.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash("An unexpected error occurred while updating the channel.", "danger")

    return render_template(
        "social/channels/edit_channel.html",
        form=form,
        channel=channel,
        title=f"Edit Channel: {channel.name} - Nexus",
    )


@app.route("/social/groups/<int:group_id>/edit", methods=["GET", "POST"])
@login_required
def edit_social_group(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")

    # --- Authorization Check ---
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    if not (
        group.owner_id == current_user.id
        or user_group_role == "admin"
        or is_global_admin
    ):
        flash("You do not have permission to edit this group.", "danger")
        return redirect(url_for("view_social_group", group_id=group.id))

    # Pass the group's original name to the form for validation purposes.
    form = EditGroupForm(obj=group, original_group_name=group.name)

    if form.validate_on_submit():
        old_profile_photo_path = group.profile_photo_url
        new_profile_photo_path = None

        # --- Handle File Upload ---
        if form.profile_photo.data:
            try:
                saved_path = save_profile_photo(form.profile_photo.data)
                if saved_path:
                    new_profile_photo_path = saved_path
                else:  # save_profile_photo helper flashes its own error
                    return render_template(
                        "social/groups/edit_group.html",
                        form=form,
                        group=group,
                        title=f"Edit Group: {group.name}",
                    )
            except Exception as e:
                app.logger.error(
                    f"Error processing photo upload for group {group_id}: {e}",
                    exc_info=True,
                )
                flash("An error occurred with the photo upload.", "danger")

        try:
            # --- Update Group Fields ---
            group.name = form.name.data.strip()
            group.description = form.description.data.strip()
            # FIX: Save the new is_active status from the form.
            group.is_active = form.is_active.data

            if new_profile_photo_path:
                group.profile_photo_url = new_profile_photo_path

            db.session.commit()

            # --- Cleanup Old Photo ---
            if (
                new_profile_photo_path
                and old_profile_photo_path
                and not old_profile_photo_path.startswith("img/placeholders/")
            ):
                try:
                    full_old_path = os.path.join(
                        current_app.static_folder, old_profile_photo_path
                    )
                    if os.path.exists(full_old_path):
                        os.remove(full_old_path)
                        app.logger.info(
                            f"Deleted old group photo: {old_profile_photo_path}"
                        )
                except Exception as e:
                    app.logger.error(
                        f"Error deleting old group photo {old_profile_photo_path}: {e}"
                    )

            flash(f"Group '{group.name}' updated successfully!", "success")
            return redirect(url_for("view_social_group", group_id=group.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error editing group {group.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash("An unexpected error occurred while updating the group.", "danger")

    # For GET request or if form validation failed
    return render_template(
        "social/groups/edit_group.html",
        form=form,
        group=group,
        title=f"Edit Group: {group.name}",
    )


@app.route(
    "/social/channels/<int:channel_id>/subscribers/<int:subscriber_user_id>/update_role",
    methods=["POST"],
)
@login_required
def ajax_update_channel_subscriber_role(channel_id, subscriber_user_id):
    channel = db.get_or_404(Channel, channel_id)
    subscriber_to_update = db.get_or_404(
        User, subscriber_user_id, description="Subscriber user not found."
    )

    subscription_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(
            channel_id=channel.id, user_id=subscriber_user_id
        )
    )
    if not subscription_entry:
        return (
            jsonify(
                {"success": False, "error": "User is not subscribed to this channel."}
            ),
            404,
        )

    # Authorization: Current user must be channel owner, or channel admin (and not targeting owner), or
    current_user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner = channel.owner_id == current_user.id
    is_current_user_channel_admin = current_user_channel_role == "admin"
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    can_manage = False
    if is_global_admin or is_channel_owner:
        can_manage = True
    elif (
        is_current_user_channel_admin and subscription_entry.role != "owner"
    ):  # Admin cannot change owner's role
        can_manage = True

    if not can_manage:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to change this subscriber's role.",
                }
            ),
            403,
        )

    if (
        subscriber_user_id == current_user.id
    ):  # Prevent user from changing their own role via this AJAX
        return (
            jsonify(
                {"success": False, "error": "You cannot change your own role here."}
            ),
            403,
        )
    if (
        channel.owner_id == subscriber_user_id and not is_channel_owner
    ):  # Only owner can change owner role (though usually done via transfer)
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Only the channel owner can modify the owner role.",
                }
            ),
            403,
        )

    data = request.get_json()
    new_role = data.get("role", "").strip().lower()
    valid_roles = [
        "admin",
        "subscriber",
    ]  # Owner role typically set on creation or via "transfer ownership"

    if new_role not in valid_roles:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"Invalid role '{new_role}'. Valid roles are 'admin', 'subscriber'.",
                }
            ),
            400,
        )

    old_role = subscription_entry.role
    if old_role == new_role:
        return (
            jsonify({"success": True, "message": "Role is already set to this value."}),
            200,
        )

    try:
        subscription_entry.role = new_role
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} updated role of user {subscriber_user_id} in channel {channel_id} to '{new_role}'."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Role for {subscriber_to_update.full_name or subscriber_to_update.username} updated to {new_role.title()}.",
                    "user_id": subscriber_user_id,
                    "new_role": new_role,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating channel subscriber role for user {subscriber_user_id} in channel {channel_id}: {e}",
            exc_info=True,
        )
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Server error updating role.",
                    "previous_role": old_role,
                }
            ),
            500,
        )


@app.route(
    "/social/channels/<int:channel_id>/subscribers/<int:subscriber_user_id>/remove",
    methods=["POST"],
)
@login_required
def ajax_remove_channel_subscriber(channel_id, subscriber_user_id):
    channel = db.get_or_404(Channel, channel_id)
    # subscriber_user_to_remove = db.get_or_404(User, subscriber_user_id) # Not needed if we just delete the entry

    subscription_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(
            channel_id=channel.id, user_id=subscriber_user_id
        )
    )
    if not subscription_entry:
        return (
            jsonify(
                {
                    "success": True,
                    "message": "User was not subscribed or already removed.",
                }
            ),
            200,
        )  # Idempotent

    # Authorization (similar to update_role but with different nuances for removal)
    current_user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner = channel.owner_id == current_user.id
    is_current_user_channel_admin = current_user_channel_role == "admin"
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    if subscriber_user_id == channel.owner_id:  # Cannot remove the owner directly
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Channel owner cannot be removed. Transfer ownership first.",
                }
            ),
            403,
        )
    if (
        subscriber_user_id == current_user.id
    ):  # User should use "Unsubscribe" action, not be removed by self here
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Use the 'Unsubscribe' option to leave the channel.",
                }
            ),
            403,
        )

    can_remove = False
    if is_global_admin or is_channel_owner:
        can_remove = True
    elif (
        is_current_user_channel_admin and subscription_entry.role == "subscriber"
    ):  # Admin can remove subscribers
        can_remove = True

    if not can_remove:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to remove this subscriber.",
                }
            ),
            403,
        )

    try:
        subscriber_name_for_log = (
            subscription_entry.user.full_name or subscription_entry.user.username
        )
        db.session.delete(subscription_entry)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} removed subscriber {subscriber_user_id} ({subscriber_name_for_log}) from channel {channel.id}."
        )

        # Get updated subscriber count for UI update
        new_subscriber_count = channel.subscribers.count()

        return (
            jsonify(
                {
                    "success": True,
                    "message": f"{subscriber_name_for_log} removed from channel.",
                    "user_id": subscriber_user_id,
                    "new_subscriber_count": new_subscriber_count,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error removing subscriber {subscriber_user_id} from channel {channel_id}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Server error removing subscriber."}),
            500,
        )


# Route to view and manage channel subscribers
@app.route("/social/channels/<int:channel_id>/manage_subscribers")
@login_required
def manage_channel_subscribers(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    # Authorization: Owner, channel admin, or system-level admin
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]
    if not (
        channel.owner_id == current_user.id
        or user_channel_role == "admin"
        or is_global_admin
    ):
        flash(
            "You do not have permission to manage subscribers for this channel.",
            "danger",
        )
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    subscribers_query = (
        select(ChannelSubscriber)
        .where(ChannelSubscriber.channel_id == channel.id)
        .join(
            ChannelSubscriber.user
        )  # Explicit join to User for ordering by User.full_name
        .options(
            joinedload(ChannelSubscriber.user).joinedload(
                User.role
            )  # Load user and their global role
        )
        .order_by(
            case(  # Custom order for channel roles
                (ChannelSubscriber.role == "owner", 1),
                (ChannelSubscriber.role == "admin", 2),
                (ChannelSubscriber.role == "subscriber", 3),
                else_=4,
            ).asc(),
            User.full_name.asc(),
        )
    )
    subscribers = db.session.scalars(subscribers_query).all()

    return render_template(
        "social/channels/manage_subscribers.html",
        channel=channel,
        subscribers=subscribers,
        user_channel_role=user_channel_role,  # Current user's role in this channel
        title=f"Manage Subscribers - {channel.name} - Nexus",
    )


# Endpoint to change a subscriber's role (AJAX or POST)
@app.route(
    "/social/channels/<int:channel_id>/subscribers/<int:subscriber_id>/update_role",
    methods=["POST"],
)
@login_required
def update_channel_subscriber_role(channel_id, subscriber_id):
    """Updates the role of a channel subscriber (Owner/Admin/SysAdmin/HR only)."""
    channel = db.get_or_404(Channel, channel_id)
    subscriber_entry = db.session.get(
        ChannelSubscriber, (channel_id, subscriber_id)
    )  # Get the specific association object

    if not subscriber_entry:
        return (
            jsonify(
                {"success": False, "error": "Subscriber not found in this channel"}
            ),
            404,
        )

    # Check authorization: User must be owner, admin in the channel, or SysAdmin/HR/CEO
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    is_authorized = (user_channel_role in ["owner", "admin"]) or is_global_admin

    if not is_authorized:
        app.logger.warning(
            f"Unauthorized attempt to change subscriber role in channel {channel_id}: User {current_user.id} (Role: {user_channel_role})"
        )
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to change roles",
                }
            ),
            403,
        )

    # Get the new role from the request (assuming JSON body with key 'role')
    if not request.is_json:
        return jsonify({"success": False, "error": "Invalid request format"}), 400

    data = request.get_json()
    new_role = data.get("role", "").strip().lower()

    # Validate the requested new role
    valid_roles = ["owner", "admin", "subscriber"]
    if new_role not in valid_roles:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"Invalid role '{new_role}' provided. Valid roles are: {', '.join(valid_roles)}",
                }
            ),
            400,
        )

    # Additional authorization checks:
    # - Owner can set/unset any role (including other admins, but maybe not demote self?)
    # - Admin can set/unset 'subscriber' and 'admin', but NOT 'owner'.
    # -  can do anything (handled by initial is_authorized)

    if not is_global_admin:  # Apply specific channel role restrictions
        if user_channel_role != "owner" and new_role == "owner":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only the owner can assign the 'owner' role",
                    }
                ),
                403,
            )
        if user_channel_role != "owner" and subscriber_entry.role == "owner":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only the owner can demote the current owner",
                    }
                ),
                403,
            )
        if user_channel_role == "admin" and new_role == "owner":
            return (
                jsonify(
                    {"success": False, "error": "Admins cannot assign the 'owner' role"}
                ),
                403,
            )
        # Prevent demoting self if you are the *last* owner? Or just prevent demoting self at all?
        # Let's prevent changing your own role here for safety.
        if subscriber_entry.user_id == current_user.id:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "You cannot change your own role via this endpoint",
                    }
                ),
                403,
            )  # Needs a separate 'leave channel' / 'transfer ownership' flow

    # Prevent setting the same role again (optional optimization)
    if subscriber_entry.role.lower() == new_role:
        return (
            jsonify({"success": True, "message": f"Role is already '{new_role}'"}),
            200,
        )

    try:
        # Update the subscriber's role
        subscriber_entry.role = new_role
        db.session.commit()
        app.logger.info(
            f"Channel {channel_id}: User {current_user.username} (ID: {current_user.id}) changed role of user {subscriber_id} to '{new_role}'."
        )

        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Role updated to '{new_role}'",
                    "user_id": subscriber_id,
                    "new_role": new_role,
                }
            ),
            200,
        )  # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating subscriber role in channel {channel_id} for user {subscriber_id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Failed to update role"}), 500


# Endpoint to remove a subscriber (AJAX or POST)
@app.route(
    "/social/channels/<int:channel_id>/subscribers/<int:subscriber_id>/remove",
    methods=["POST"],
)
@login_required
def remove_channel_subscriber(channel_id, subscriber_id):
    """Removes a subscriber from a channel (Owner/Admin/SysAdmin/HR only)."""
    channel = db.get_or_404(Channel, channel_id)
    subscriber_entry = db.session.get(
        ChannelSubscriber, (channel_id, subscriber_id)
    )  # Get the specific association object

    if not subscriber_entry:
        return (
            jsonify(
                {
                    "success": True,
                    "message": "User is not a subscriber (already removed?)",
                }
            ),
            200,
        )  # Already gone

    # Check authorization: User must be owner, admin in the channel, or SysAdmin/HR/CEO
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    is_authorized = (user_channel_role in ["owner", "admin"]) or is_global_admin

    if not is_authorized:
        app.logger.warning(
            f"Unauthorized attempt to remove subscriber {subscriber_id} from channel {channel_id}: User {current_user.id} (Role: {user_channel_role})"
        )
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to remove subscribers",
                }
            ),
            403,
        )

    # Additional authorization checks:
    # - Owner can remove anyone except perhaps themselves (needs separate leave flow)
    # - Admin can remove 'subscriber' role, but NOT 'admin' or 'owner' roles.
    # -  can remove anyone.

    if not is_global_admin:
        if subscriber_entry.user_id == current_user.id:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "You cannot remove yourself via this endpoint (use leave channel)",
                    }
                ),
                403,
            )  # Needs separate leave flow
        if user_channel_role == "admin" and subscriber_entry.role in ["owner", "admin"]:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Admins cannot remove other admins or owners",
                    }
                ),
                403,
            )

    # Prevent removing the last owner? This requires more complex logic.
    # For V1, allow removing owner, but the channel might become unmanageable without a new owner.
    # A better flow would be 'transfer ownership' before the owner leaves/is removed.

    try:
        db.session.delete(subscriber_entry)  # Delete the association object
        db.session.commit()
        app.logger.info(
            f"Channel {channel_id}: User {current_user.username} (ID: {current_user.id}) removed user {subscriber_id} (was role: {subscriber_entry.role})."
        )

        return (
            jsonify(
                {
                    "success": True,
                    "message": "User removed from channel",
                    "user_id": subscriber_id,
                }
            ),
            200,
        )  # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error removing subscriber {subscriber_id} from channel {channel_id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Failed to remove user from channel"}),
            500,
        )


# Endpoint for a user to subscribe to a channel (if public or open)
# This would require a mechanism for public channels or join requests for private ones.
# For V1, let's assume only public channels are joinable via this route, or only owners can add members.
# If membership is invite-only or public-joinable, this route needs to check that.
@app.route("/social/channels/<int:channel_id>/subscribe", methods=["POST"])
@login_required
def subscribe_channel(channel_id):
    """Allows a user to subscribe to a channel (if public or allowed)."""
    channel = db.get_or_404(Channel, channel_id)

    # Check if user is already a member/subscriber
    if current_user.is_channel_member(channel):
        flash("You are already a member of this channel.", "info")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    # Check if channel is public or requires an invite/request
    # For V1, let's assume only public channels are open for self-subscription via this route.
    # Private channels require an owner/admin to add the member (handled in manage_subscribers or separate invite flow).
    if channel.type != "public":
        flash("This is a private channel. You cannot subscribe directly.", "warning")
        # Redirect to discovery or back to channel view
        return redirect(url_for("social_channel_discovery"))  # Or view_social_channel

    try:
        # Create a new subscriber entry with default 'subscriber' role
        new_subscriber = ChannelSubscriber(
            channel_id=channel.id,
            user_id=current_user.id,
            role="subscriber",  # Default role for self-subscription
            subscribed_at=datetime.now(timezone.utc),
        )
        db.session.add(new_subscriber)
        db.session.commit()

        flash(f"Successfully subscribed to channel '{channel.name}'.", "success")
        app.logger.info(
            f"User {current_user.username} subscribed to channel {channel.id}."
        )
        # Redirect to the channel view page
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    except IntegrityError:
        db.session.rollback()
        # Should be caught by the initial check, but good safety net
        flash("You are already a member of this channel.", "info")
        return redirect(url_for("view_social_channel", channel_id=channel.id))
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error subscribing user {current_user.id} to channel {channel.id}: {e}",
            exc_info=True,
        )
        flash(
            "An error occurred while subscribing to the channel. Please try again.",
            "danger",
        )
        return redirect(url_for("social_channel_discovery"))


# Endpoint for a user to unsubscribe from a channel (if not the last owner)
@app.route("/social/channels/<int:channel_id>/unsubscribe", methods=["POST"])
@login_required
def unsubscribe_channel(channel_id):
    """Allows a user to unsubscribe from a channel."""
    channel = db.get_or_404(Channel, channel_id)

    # Fetch the subscriber entry for the current user in this channel
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, current_user.id))

    if not subscriber_entry:
        flash("You are not a member of this channel.", "warning")
        return redirect(url_for("social_channel_discovery"))  # Redirect to discovery

    # Prevent the *last* owner from unsubscribing (unless ownership is transferred)
    if subscriber_entry.role == "owner":
        # Check if this is the only owner left
        owner_count = (
            db.session.scalar(
                select(func.count(ChannelSubscriber.user_id)).where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.role == "owner",
                )
            )
            or 0
        )  # Use scalar and default 0

        if owner_count <= 1:  # If this user is the only owner or one of the last owners
            flash(
                "You are the only owner of this channel. Transfer ownership before leaving.",
                "danger",
            )
            # Redirect back to channel management page (or view page)
            return redirect(
                url_for("view_social_channel", channel_id=channel.id)
            )  # Or manage_channel_subscribers

    try:
        db.session.delete(subscriber_entry)  # Delete the association object
        db.session.commit()

        flash(f"Successfully unsubscribed from channel '{channel.name}'.", "success")
        app.logger.info(
            f"User {current_user.username} unsubscribed from channel {channel.id}."
        )
        # Redirect to channel discovery or user's dashboard
        return redirect(url_for("social_channel_discovery"))

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error unsubscribing user {current_user.id} from channel {channel.id}: {e}",
            exc_info=True,
        )
        flash(
            "An error occurred while unsubscribing from the channel. Please try again.",
            "danger",
        )
        # Redirect back to the channel view page on error
        return redirect(url_for("view_social_channel", channel_id=channel.id))


@app.route("/social/channels/discover")
@login_required
def social_channel_discover():
    page = request.args.get("page", 1, type=int)
    per_page = 12  # Number of channels per page for card view
    search_query_param = request.args.get(
        "search_query", "", type=str
    ).strip()  # Renamed to avoid conflict
    category_id_filter = request.args.get(
        "category_id", "", type=str
    )  # String from form, convert to int if not empty

    query = (
        select(Channel)
        .where(
            Channel.type == "public", Channel.is_active == True
        )  # Only public and active
        .options(
            joinedload(Channel.social_category),
            joinedload(Channel.owner),
            # REMOVED: joinedload(Channel.subscribers) # This was causing the error
        )
    )

    if search_query_param:  # Use the renamed variable
        search_term = f"%{search_query_param}%"
        query = query.where(
            or_(Channel.name.ilike(search_term), Channel.bio.ilike(search_term))
        )

    selected_category_id_int = None
    if category_id_filter and category_id_filter.isdigit():
        selected_category_id_int = int(category_id_filter)
        query = query.where(Channel.social_category_id == selected_category_id_int)

    query = query.order_by(Channel.name.asc())
    # Line 9794 from the traceback
    pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
    discoverable_channels = pagination.items

    all_social_categories = db.session.scalars(
        select(SocialCategory).order_by(SocialCategory.name)
    ).all()

    # Determine subscription status for displayed channels
    channel_statuses = {}
    if discoverable_channels:
        channel_ids = [c.id for c in discoverable_channels]
        # Fetch subscriptions for the current user for these specific channels
        subscriptions = db.session.scalars(
            select(ChannelSubscriber).where(
                ChannelSubscriber.user_id == current_user.id,
                ChannelSubscriber.channel_id.in_(channel_ids),
            )
        ).all()
        subscribed_channel_ids = {s.channel_id for s in subscriptions}

        for ch in discoverable_channels:
            channel_statuses[ch.id] = {
                "is_subscribed": ch.id in subscribed_channel_ids,
                "is_owner": ch.owner_id == current_user.id,
            }

    return render_template(
        "social/channels/discover.html",
        discoverable_channels=discoverable_channels,
        all_social_categories=all_social_categories,
        pagination=pagination,
        search_query=search_query_param,  # Pass renamed variable
        selected_category_id=selected_category_id_int,
        channel_statuses=channel_statuses,
        title="Discover Channels - Nexus",
    )


# Route to view and manage group members (Owner/Admin)
@app.route("/social/groups/<int:group_id>/manage_members")
@login_required
def manage_group_members(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")

    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]
    if not (
        group.owner_id == current_user.id
        or user_group_role == "admin"
        or is_global_admin
    ):
        flash("You do not have permission to manage members for this group.", "danger")
        return redirect(url_for("view_social_group", group_id=group.id))

    members_query = (
        select(SocialGroupMember)
        .where(SocialGroupMember.group_id == group.id)
        .join(SocialGroupMember.user)
        .options(joinedload(SocialGroupMember.user).joinedload(User.role))
        .order_by(
            case(
                (SocialGroupMember.role == "owner", 1),
                (SocialGroupMember.role == "admin", 2),
                (SocialGroupMember.role == "member", 3),
                else_=4,
            ).asc(),
            User.full_name.asc(),
        )
    )
    members = db.session.scalars(members_query).all()

    return render_template(
        "social/groups/manage_members.html",
        group=group,
        members=members,
        user_group_role=user_group_role,  # Current user's role in this group
        title=f"Manage Members - {group.name} - Nexus",
    )


@app.route(
    "/social/groups/<int:group_id>/members/<int:member_user_id>/update_role",
    methods=["POST"],
)
@login_required
def ajax_update_group_member_role(group_id, member_user_id):
    group = db.get_or_404(SocialGroup, group_id)
    member_to_update = db.get_or_404(
        User, member_user_id, description="Member user not found."
    )
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=member_user_id)
    )
    if not membership_entry:
        return (
            jsonify({"success": False, "error": "User is not a member of this group."}),
            404,
        )

    # Authorization (similar to channel role update)
    current_user_group_role = current_user.get_group_role(group)
    is_group_owner = group.owner_id == current_user.id
    is_current_user_group_admin = current_user_group_role == "admin"
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    can_manage = False
    if is_global_admin or is_group_owner:
        can_manage = True
    elif is_current_user_group_admin and membership_entry.role != "owner":
        can_manage = True

    if not can_manage:
        return (
            jsonify({"success": False, "error": "Permission denied to change role."}),
            403,
        )
    if member_user_id == current_user.id:
        return jsonify({"success": False, "error": "Cannot change your own role."}), 403
    if group.owner_id == member_user_id and not is_group_owner:
        return (
            jsonify(
                {"success": False, "error": "Only group owner can modify owner role."}
            ),
            403,
        )

    data = request.get_json()
    new_role = data.get("role", "").strip().lower()
    valid_roles = ["admin", "member"]  # Owner usually by transfer
    if new_role not in valid_roles:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"Invalid role. Valid: {', '.join(valid_roles)}.",
                }
            ),
            400,
        )

    old_role = membership_entry.role
    if old_role == new_role:
        return jsonify({"success": True, "message": "Role is already set."}), 200

    try:
        membership_entry.role = new_role
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} updated role of user {member_user_id} in group {group_id} to '{new_role}'."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Role for {member_to_update.full_name or member_to_update.username} updated to {new_role.title()}.",
                    "user_id": member_user_id,
                    "new_role": new_role,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating group member role for {member_user_id} in group {group_id}: {e}",
            exc_info=True,
        )
        return (
            jsonify(
                {"success": False, "error": "Server error.", "previous_role": old_role}
            ),
            500,
        )


@app.route(
    "/social/groups/<int:group_id>/members/<int:member_user_id>/remove",
    methods=["POST"],
)
@login_required
def ajax_remove_group_member(group_id, member_user_id):
    group = db.get_or_404(SocialGroup, group_id)
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=member_user_id)
    )
    if not membership_entry:
        return (
            jsonify(
                {"success": True, "message": "User not a member or already removed."}
            ),
            200,
        )

    # Authorization (similar to channel member removal)
    current_user_group_role = current_user.get_group_role(group)
    is_group_owner = group.owner_id == current_user.id
    is_current_user_group_admin = current_user_group_role == "admin"
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    if member_user_id == group.owner_id:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Group owner cannot be removed. Transfer ownership first.",
                }
            ),
            403,
        )
    if member_user_id == current_user.id:
        return jsonify({"success": False, "error": "Use 'Leave Group' option."}), 403

    can_remove = False
    if is_global_admin or is_group_owner:
        can_remove = True
    elif is_current_user_group_admin and membership_entry.role == "member":
        can_remove = True

    if not can_remove:
        return (
            jsonify({"success": False, "error": "Permission denied to remove member."}),
            403,
        )

    try:
        member_name_for_log = (
            membership_entry.user.full_name or membership_entry.user.username
        )
        db.session.delete(membership_entry)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} removed member {member_user_id} ({member_name_for_log}) from group {group.id}."
        )
        new_member_count = group.members.count()
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"{member_name_for_log} removed from group.",
                    "user_id": member_user_id,
                    "new_member_count": new_member_count,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error removing member {member_user_id} from group {group_id}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/social/groups/<int:group_id>/leave", methods=["POST"])
@login_required
def ajax_leave_social_group(group_id):  # Renamed for AJAX
    group = db.get_or_404(SocialGroup, group_id)
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=current_user.id)
    )
    if not membership_entry:
        return (
            jsonify({"success": False, "error": "You are not a member of this group."}),
            400,
        )

    if membership_entry.role == "owner":
        owner_count = (
            db.session.scalar(
                select(func.count(SocialGroupMember.user_id)).where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.role == "owner",
                )
            )
            or 0
        )
        if owner_count <= 1:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "You are the only owner. Transfer ownership before leaving.",
                    }
                ),
                403,
            )

    try:
        db.session.delete(membership_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} left group {group.id}.")
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Successfully left group '{group.name}'.",
                    "redirect_url": url_for(
                        ""
                    ),  # Client-side can use this
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} leaving group {group.id}: {e}", exc_info=True
        )
        return jsonify({"success": False, "error": "Server error leaving group."}), 500


@app.route(
    "/social/groups/<int:group_id>/members/<int:member_id>/update_role",
    methods=["POST"],
)
@login_required
def update_group_member_role(group_id, member_id):
    """Updates the role of a group member (Owner/Admin/SysAdmin/HR only)."""
    group = db.get_or_404(SocialGroup, group_id)
    member_entry = db.session.get(
        SocialGroupMember, (group_id, member_id)
    )  # Get the specific association object

    if not member_entry:
        return (
            jsonify({"success": False, "error": "Member not found in this group"}),
            404,
        )

    # Check authorization: User must be owner, admin in the group, or SysAdmin/HR/CEO
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    is_authorized = (user_group_role in ["owner", "admin"]) or is_global_admin

    if not is_authorized:
        app.logger.warning(
            f"Unauthorized attempt to change member role in group {group_id}: User {current_user.id} (Role: {user_group_role})"
        )
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to change roles",
                }
            ),
            403,
        )

    # Get the new role from the request (assuming JSON body with key 'role')
    if not request.is_json:
        return jsonify({"success": False, "error": "Invalid request format"}), 400

    data = request.get_json()
    new_role = data.get("role", "").strip().lower()

    # Validate the requested new role
    valid_roles = ["owner", "admin", "member"]
    if new_role not in valid_roles:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"Invalid role '{new_role}' provided. Valid roles are: {', '.join(valid_roles)}",
                }
            ),
            400,
        )

    # Additional authorization checks:
    # - Owner can set/unset any role
    # - Admin can set/unset 'member' and 'admin', but NOT 'owner'.
    # -  can do anything.

    if not is_global_admin:  # Apply specific group role restrictions
        if user_group_role != "owner" and new_role == "owner":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only the owner can assign the 'owner' role",
                    }
                ),
                403,
            )
        if user_group_role != "owner" and member_entry.role == "owner":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only the owner can demote the current owner",
                    }
                ),
                403,
            )
        if user_group_role == "admin" and new_role == "owner":
            return (
                jsonify(
                    {"success": False, "error": "Admins cannot assign the 'owner' role"}
                ),
                403,
            )
        # Prevent changing your own role via this endpoint.
        if member_entry.user_id == current_user.id:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "You cannot change your own role via this endpoint",
                    }
                ),
                403,
            )  # Needs a separate 'leave group' / 'transfer ownership' flow

    # Prevent setting the same role again (optional optimization)
    if member_entry.role.lower() == new_role:
        return (
            jsonify({"success": True, "message": f"Role is already '{new_role}'"}),
            200,
        )

    try:
        # Update the member's role
        member_entry.role = new_role
        db.session.commit()
        app.logger.info(
            f"Group {group_id}: User {current_user.username} (ID: {current_user.id}) changed role of user {member_id} to '{new_role}'."
        )

        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Role updated to '{new_role}'",
                    "user_id": member_id,
                    "new_role": new_role,
                }
            ),
            200,
        )  # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating member role in group {group_id} for user {member_id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Failed to update role"}), 500


# Endpoint to remove a member (AJAX or POST)
@app.route(
    "/social/groups/<int:group_id>/members/<int:member_id>/remove", methods=["POST"]
)
@login_required
def remove_group_member(group_id, member_id):
    """Removes a member from a group (Owner/Admin/SysAdmin/HR only)."""
    group = db.get_or_404(SocialGroup, group_id)
    member_entry = db.session.get(
        SocialGroupMember, (group_id, member_id)
    )  # Get the specific association object

    if not member_entry:
        return (
            jsonify(
                {"success": True, "message": "User is not a member (already removed?)"}
            ),
            200,
        )  # Already gone

    # Check authorization: User must be owner, admin in the group, or SysAdmin/HR/CEO
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    is_authorized = (user_group_role in ["owner", "admin"]) or is_global_admin

    if not is_authorized:
        app.logger.warning(
            f"Unauthorized attempt to remove member {member_id} from group {group_id}: User {current_user.id} (Role: {user_group_role})"
        )
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to remove members",
                }
            ),
            403,
        )

    # Additional authorization checks:
    # - Owner can remove anyone except perhaps themselves (needs separate leave flow)
    # - Admin can remove 'member' role, but NOT 'admin' or 'owner' roles.
    # -  can remove anyone.

    if not is_global_admin:
        if member_entry.user_id == current_user.id:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "You cannot remove yourself via this endpoint (use leave group)",
                    }
                ),
                403,
            )  # Needs separate leave flow
        if user_group_role == "admin" and member_entry.role in ["owner", "admin"]:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Admins cannot remove other admins or owners",
                    }
                ),
                403,
            )

    # Prevent removing the last owner? This requires more complex logic.
    # For V1, allow removing owner, but the group might become unmanageable without a new owner.
    # A better flow would be 'transfer ownership' before the owner leaves/is removed.

    try:
        db.session.delete(member_entry)  # Delete the association object
        db.session.commit()
        app.logger.info(
            f"Group {group_id}: User {current_user.username} (ID: {current_user.id}) removed user {member_id} (was role: {member_entry.role})."
        )

        return (
            jsonify(
                {
                    "success": True,
                    "message": "User removed from group",
                    "user_id": member_id,
                }
            ),
            200,
        )  # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error removing member {member_id} from group {group_id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return (
            jsonify({"success": False, "error": "Failed to remove user from group"}),
            500,
        )


# --- ADD THESE API ROUTES (e.g., towards the end of app.py, before error handlers or main execution block) ---
# --- API v1: Global Engagement Core ---


# Helper function for API error responses (optional, but good practice)
def api_error_response(status_code, message):
    response = jsonify({"error": message, "success": False})
    response.status_code = status_code
    return response

@app.route("/api/v1/global_posts", methods=["GET"])
@login_required  # All authenticated users can view public posts
def get_global_posts():
    """
    Retrieves a paginated list of global posts.
    Initial version: Fetches all 'public' posts.
    """
    page = request.args.get("page", 1, type=int)
    per_page = request.args.get("per_page", 10, type=int)  # Default 10 posts per page
    author_id_filter = request.args.get("author_id", type=int)

    if per_page > 50:  # Max per_page limit
        per_page = 50

    query = db.select(GlobalPost).where(
        GlobalPost.visibility == "public"
    )  # Only public for now

    if author_id_filter:
        query = query.where(GlobalPost.author_id == author_id_filter)

    query = query.options(
        joinedload(GlobalPost.author).options(
            joinedload(User.role)
        ),  # Eager load author and their role
        joinedload(GlobalPost.attached_file),  # Eager load attached file details
        # Comments and Likes counts will be added dynamically or via subquery for performance
    ).order_by(GlobalPost.timestamp.desc())

    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        posts_list = pagination.items

        result_posts = []
        for post in posts_list:
            # Efficiently get comment and like counts for each post
            comment_count = (
                db.session.scalar(
                    db.select(func.count(GlobalComment.id)).where(
                        GlobalComment.post_id == post.id
                    )
                )
                or 0
            )
            like_count = (
                db.session.scalar(
                    db.select(func.count(GlobalLike.id)).where(
                        GlobalLike.post_id == post.id
                    )
                )
                or 0
            )

            # Check if current user liked this post
            current_user_liked = False
            if current_user.is_authenticated:
                current_user_liked = db.session.query(
                    db.exists().where(
                        GlobalLike.post_id == post.id,
                        GlobalLike.user_id == current_user.id,
                    )
                ).scalar()

            post_data = {
                "id": post.id,
                "author_id": post.author_id,
                "content": post.content,
                "timestamp": post.timestamp.isoformat() + "Z",
                "is_edited": post.is_edited,
                "visibility": post.visibility,
                "allow_comments": post.allow_comments,
                "allow_likes": post.allow_likes,
                "comment_count": comment_count,
                "like_count": like_count,
                "current_user_liked": current_user_liked,
                "author": {
                    "id": post.author.id,
                    "username": post.author.username,
                    "full_name": post.author.full_name,
                    "profile_photo_url": post.author.profile_photo_url,
                    "role": post.author.role.name if post.author.role else None,
                },
                "file": (
                    {
                        "id": post.attached_file.id,
                        "filename": post.attached_file.filename,  # Server-side filename
                        "original_filename": post.attached_file.original_filename,
                        "mimetype": post.attached_file.mimetype,
                        "size": post.attached_file.size,
                        "download_url": post.attached_file.get_download_url(),
                    }
                    if post.attached_file
                    else None
                ),
                "share_url": post.get_share_url(),
            }
            result_posts.append(post_data)

        return (
            jsonify(
                {
                    "success": True,
                    "posts": result_posts,
                    "pagination": {
                        "page": pagination.page,
                        "per_page": pagination.per_page,
                        "total_pages": pagination.pages,
                        "total_items": pagination.total,
                        "has_next": pagination.has_next,
                        "has_prev": pagination.has_prev,
                    },
                }
            ),
            200,
        )

    except Exception as e:
        app.logger.error(f"Error retrieving GlobalPosts: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving posts.")
        
@app.route("/api/v1/global_posts/<int:post_id>/comments", methods=["POST"])
@login_required
def create_global_comment(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    if not post.allow_comments:
        return api_error_response(403, "Comments are disabled for this post.")

    if request.is_json:
        data = request.get_json()
        content = data.get("content", "").strip()
    else:
        content = request.form.get("content", "").strip()

    parent_comment_id = request.values.get("parent_comment_id")

    if not content:
        return api_error_response(400, "Comment content cannot be empty.")
    if len(content) > 2000:
        return api_error_response(400, "Comment is too long.")

    parent_comment = None
    if parent_comment_id:
        try:
            parent_id_int = int(parent_comment_id)
            parent_comment = db.session.get(GlobalComment, parent_id_int)
            if not parent_comment or parent_comment.post_id != post.id:
                return api_error_response(400, "Invalid parent comment ID.")
        except (ValueError, TypeError):
            return api_error_response(400, "Invalid parent_comment_id format.")

    try:
        new_comment = GlobalComment(
            post_id=post.id,
            author_id=current_user.id,
            content=content,
            parent_comment_id=parent_comment.id if parent_comment else None,
            timestamp=datetime.now(timezone.utc),
        )
        db.session.add(new_comment)
        db.session.commit()

        app.logger.info(
            f"User {current_user.username} created GlobalComment ID {new_comment.id} on GlobalPost ID {post.id}."
        )
        
        comment_for_render = db.session.get(GlobalComment, new_comment.id)
        
        # --- THIS IS THE FIX ---
        # The template path was incorrect. It should be "partials/_comment_item.html"
        # as the partials directory is at the root of the templates folder.
        rendered_comment_html = render_template(
            "partials/_comment_item.html", # Corrected path
            comment=comment_for_render,
            current_user=current_user,
            post_type='global',
            parent_post_author_id=post.author_id,
            can_current_user_manage_parent_content=False
        )

        new_total_comment_count = db.session.scalar(
            db.select(func.count(GlobalComment.id)).where(GlobalComment.post_id == post.id)
        ) or 0

        socketio.emit(
            "new_comment",
            {
                "post_id": post.id,
                "comment_html": rendered_comment_html,
                "new_comment_count": new_total_comment_count,
            },
            room=f"global_post-{post.id}",
        )
        app.logger.info(f"SocketIO 'new_comment' emitted for GlobalPost ID {post.id}.")

        comment_data_for_ajax_response = {
            "id": new_comment.id,
            "post_id": new_comment.post_id,
            "author_id": new_comment.author_id,
            "content": new_comment.content,
            "timestamp": new_comment.timestamp.isoformat() + "Z",
            "author": {
                "id": current_user.id,
                "username": current_user.username,
                "full_name": current_user.full_name,
                "profile_photo_url": current_user.profile_photo_url,
            },
        }

        return jsonify({
            "success": True,
            "comment": comment_data_for_ajax_response,
            "post_comment_count": new_total_comment_count,
        }), 201

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error creating GlobalComment for user {current_user.id} on post {post.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error creating comment.")

# --- END: CORRECTED FUNCTION ---
@app.route("/api/v1/global_posts/<int:post_id>/like", methods=["POST"])
@login_required
def toggle_global_post_like(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    if not post.allow_likes:
        return api_error_response(403, "Likes are disabled for this post.")

    try:
        existing_like = db.session.scalar(
            db.select(GlobalLike).where(
                GlobalLike.post_id == post.id, GlobalLike.user_id == current_user.id
            )
        )

        user_liked_action = False
        if existing_like:
            db.session.delete(existing_like)
            app.logger.info(
                f"User {current_user.username} unliked GlobalPost ID {post.id}."
            )
            user_liked_action = False
        else:
            new_like = GlobalLike(
                post_id=post.id,
                user_id=current_user.id,
                timestamp=datetime.now(timezone.utc),
            )
            db.session.add(new_like)
            app.logger.info(
                f"User {current_user.username} liked GlobalPost ID {post.id}."
            )
            user_liked_action = True

        db.session.commit()

        new_like_count = (
            db.session.scalar(
                db.select(func.count(GlobalLike.id)).where(
                    GlobalLike.post_id == post.id
                )
            )
            or 0
        )

        # --- SOCKETIO EMIT ---
        socketio.emit(
            "like_update",
            {
                "post_id": post.id,
                "new_like_count": new_like_count,
                # Client-side handles 'user_liked' state based on AJAX response, not socket for this one.
                # Socket is for broad count update to all viewers.
            },
            room=f"global_post-{post.id}",
        )
        app.logger.info(f"SocketIO 'like_update' emitted for GlobalPost ID {post.id}.")
        # --- END SOCKETIO EMIT ---

        return (
            jsonify(
                {
                    "success": True,
                    "liked": user_liked_action,  # For the user who initiated the action
                    "like_count": new_like_count,
                }
            ),
            200,
        )

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error toggling like for user {current_user.id} on post {post.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error processing like.")


# --- END API v1: Global Engagement Core --


# === Global Post Endpoints (Continued) ===


@app.route("/api/v1/global_posts/<int:post_id>", methods=["GET"])
@login_required
def get_global_post_detail(post_id):
    """Retrieves a single global post with details."""
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    if post.visibility != "public":
        # Basic check: if not public, only author or admin can view directly.
        # More complex visibility (e.g., connections_only) would require further checks.
        if not (
            current_user.is_authenticated
            and (
                post.author_id == current_user.id
                or current_user.role.name in ["system_admin", "hr_ceo"]
            )
        ):
            return api_error_response(
                403, "You do not have permission to view this post."
            )

    try:
        comment_count = (
            db.session.scalar(
                db.select(func.count(GlobalComment.id)).where(
                    GlobalComment.post_id == post.id
                )
            )
            or 0
        )
        like_count = (
            db.session.scalar(
                db.select(func.count(GlobalLike.id)).where(
                    GlobalLike.post_id == post.id
                )
            )
            or 0
        )
        current_user_liked = (
            db.session.query(
                db.exists().where(
                    GlobalLike.post_id == post.id, GlobalLike.user_id == current_user.id
                )
            ).scalar()
            if current_user.is_authenticated
            else False
        )

        post_data = {
            "id": post.id,
            "author_id": post.author_id,
            "content": post.content,
            "timestamp": post.timestamp.isoformat() + "Z",
            "is_edited": post.is_edited,
            "visibility": post.visibility,
            "allow_comments": post.allow_comments,
            "allow_likes": post.allow_likes,
            "comment_count": comment_count,
            "like_count": like_count,
            "current_user_liked": current_user_liked,
            "author": {
                "id": post.author.id,
                "username": post.author.username,
                "full_name": post.author.full_name,
                "profile_photo_url": post.author.profile_photo_url,
                "role": post.author.role.name if post.author.role else None,
            },
            "file": (
                {
                    "id": post.attached_file.id,
                    "original_filename": post.attached_file.original_filename,
                    "mimetype": post.attached_file.mimetype,
                    "size": post.attached_file.size,
                    "download_url": post.attached_file.get_download_url(),
                }
                if post.attached_file
                else None
            ),
            "share_url": post.get_share_url(),
        }
        return jsonify({"success": True, "post": post_data}), 200
    except Exception as e:
        app.logger.error(
            f"Error retrieving GlobalPost ID {post_id}: {e}", exc_info=True
        )
        return api_error_response(500, "Server error retrieving post details.")


@app.route("/api/v1/global_posts/<int:post_id>", methods=["PUT"])
@login_required
def update_global_post(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")

    # Authorization: Only author or admin can edit
    if not (
        post.author_id == current_user.id
        or current_user.role.name in ["system_admin", "hr_ceo"]
    ):
        return api_error_response(403, "You do not have permission to edit this post.")

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")

    data = request.get_json()
    content = data.get("content", "").strip()
    # file_id cannot be updated here; file attachment is on creation or via separate endpoint if needed.
    visibility = (
        data.get("visibility", post.visibility).strip().lower()
    )  # Keep current if not provided
    allow_comments = data.get("allow_comments", post.allow_comments)
    allow_likes = data.get("allow_likes", post.allow_likes)

    if (
        not content and not post.file_id
    ):  # If no file was ever attached, content is required
        return api_error_response(
            400, "Post content cannot be empty if no file is attached."
        )
    if len(content) > 10000:
        return api_error_response(400, "Post content is too long.")
    if visibility not in ["public"]:  # Expand when other visibilities are supported
        return api_error_response(400, "Invalid visibility setting.")

    try:
        post.content = (
            content if content else post.content
        )  # Allow clearing content if file exists
        post.visibility = visibility
        post.allow_comments = bool(allow_comments)
        post.allow_likes = bool(allow_likes)
        post.is_edited = True
        # post.timestamp = datetime.now(timezone.utc) # Optionally update timestamp on edit

        db.session.commit()
        app.logger.info(
            f"User {current_user.username} updated GlobalPost ID {post.id}."
        )
        # Return updated post data (similar to get_global_post_detail)
        # For brevity, returning a simple success message. Consider returning full updated object.
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Post updated successfully.",
                    "post_id": post.id,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating GlobalPost ID {post.id} by user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error updating post.")


@app.route("/api/v1/global_posts/<int:post_id>", methods=["DELETE"])
@login_required
def delete_global_post(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")

    # Authorization: Only author or admin can delete
    if not (
        post.author_id == current_user.id
        or current_user.role.name in ["system_admin", "hr_ceo"]
    ):
        return api_error_response(
            403, "You do not have permission to delete this post."
        )

    try:
        # Cascading delete should handle comments and likes.
        # The file linked via file_id is set to NULL due to ondelete='SET NULL', so it's not deleted from File table.
        # Actual file system cleanup for orphaned files would be a separate process or handled by File model logic.
        file_to_potentially_delete = (
            post.attached_file
        )  # Get File object before deleting post

        db.session.delete(post)
        db.session.commit()

        # If the File was uniquely attached to this GlobalPost and should be deleted:
        if file_to_potentially_delete:
            # Check if this file is ONLY referenced by the deleted GlobalPost
            # (This requires checking other relationships on the File model)
            # For now, let's assume if a GlobalPost had a file, its File record should be deleted.
            # This is a simplification; a robust system might check if the File is used elsewhere.
            try:
                other_references = False
                if (
                    file_to_potentially_delete.channel_post
                    or file_to_potentially_delete.group_message
                    or file_to_potentially_delete.talent_club_feed_post
                    or file_to_potentially_delete.talent_club_community_message
                    or file_to_potentially_delete.talent_club_proposal_file
                ):  # Add other file usages
                    other_references = True

                if not other_references:
                    app.logger.info(
                        f"Preparing to delete File record ID {file_to_potentially_delete.id} as it was only linked to deleted GlobalPost {post_id}."
                    )
                    # First, delete the physical file
                    if file_to_potentially_delete.filepath:
                        full_file_path = os.path.join(
                            current_app.static_folder,
                            file_to_potentially_delete.filepath,
                        )  # Assuming path relative to static
                        if os.path.exists(full_file_path):
                            os.remove(full_file_path)
                            app.logger.info(f"Deleted physical file: {full_file_path}")
                    # Then, delete the File DB record
                    db.session.delete(file_to_potentially_delete)
                    db.session.commit()
                    app.logger.info(
                        f"Deleted File DB record ID {file_to_potentially_delete.id}."
                    )
                else:
                    app.logger.info(
                        f"File ID {file_to_potentially_delete.id} is referenced elsewhere, not deleting File record or physical file."
                    )

            except Exception as file_delete_exc:
                db.session.rollback()  # Rollback file deletion part if it fails
                app.logger.error(
                    f"Error during associated file deletion for GlobalPost {post_id}: {file_delete_exc}",
                    exc_info=True,
                )
                # Post is already deleted, so this is a secondary error.

        app.logger.info(
            f"User {current_user.username} deleted GlobalPost ID {post_id}."
        )
        # TODO: Emit SocketIO event for global_post_deleted (Phase 4.3 enhancement or here)
        # socketio.emit('global_post_deleted', {'post_id': post_id}, room=f'global_post-{post_id}')
        # socketio.emit('global_post_deleted_from_feed', {'post_id': post_id}, room='global_feed') # If general feed room exists

        return jsonify({"success": True, "message": "Post deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error deleting GlobalPost ID {post_id} by user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error deleting post.")


# === Global Comment Endpoints (Continued) ===


@app.route("/api/v1/global_posts/<int:post_id>/comments", methods=["GET"])
@login_required
def get_global_post_comments(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    # Add visibility check for post if necessary before showing comments

    page = request.args.get("page", 1, type=int)
    per_page = request.args.get("per_page", 10, type=int)
    if per_page > 50:
        per_page = 50

    # Query for top-level comments (parent_comment_id is None)
    # Threaded replies would be fetched client-side or via a separate endpoint per comment.
    query = (
        db.select(GlobalComment)
        .where(
            GlobalComment.post_id == post.id, GlobalComment.parent_comment_id.is_(None)
        )
        .options(
            joinedload(GlobalComment.author).joinedload(User.role),
            joinedload(
                GlobalComment.replies
            ).options(  # Eager load replies and their authors
                joinedload(GlobalComment.author).joinedload(User.role)
            ),
        )
        .order_by(
            GlobalComment.timestamp.asc()
        )  # Oldest first for chronological display
    )

    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        comments_list = pagination.items

        result_comments = []
        for comment in comments_list:
            # Recursively format replies (basic example, can be optimized)
            def format_replies(comment_obj):
                replies_data = []
                # Access loaded replies directly if lazy='dynamic' is not used or if loaded via options
                # If replies is lazy='dynamic', use .all() or further query.
                # Assuming replies are loaded via joinedload as above.
                for (
                    reply
                ) in (
                    comment_obj.replies
                ):  # This should iterate over loaded replies if joinedload was effective
                    replies_data.append(
                        {
                            "id": reply.id,
                            "post_id": reply.post_id,
                            "author_id": reply.author_id,
                            "parent_comment_id": reply.parent_comment_id,
                            "content": reply.content,
                            "timestamp": reply.timestamp.isoformat() + "Z",
                            "is_edited": reply.is_edited,
                            "author": {
                                "id": reply.author.id,
                                "username": reply.author.username,
                                "full_name": reply.author.full_name,
                                "profile_photo_url": reply.author.profile_photo_url,
                            },
                            "replies": format_replies(
                                reply
                            ),  # Recursive call for nested replies
                        }
                    )
                return replies_data

            comment_data = {
                "id": comment.id,
                "post_id": comment.post_id,
                "author_id": comment.author_id,
                "parent_comment_id": comment.parent_comment_id,
                "content": comment.content,
                "timestamp": comment.timestamp.isoformat() + "Z",
                "is_edited": comment.is_edited,
                "author": {
                    "id": comment.author.id,
                    "username": comment.author.username,
                    "full_name": comment.author.full_name,
                    "profile_photo_url": comment.author.profile_photo_url,
                    "role": comment.author.role.name if comment.author.role else None,
                },
                "replies": format_replies(comment),  # Add formatted replies
                # "reply_count": db.session.scalar(db.select(func.count(GlobalComment.id)).where(GlobalComment.parent_comment_id == comment.id)) or 0
            }
            result_comments.append(comment_data)

        return (
            jsonify(
                {
                    "success": True,
                    "comments": result_comments,
                    "pagination": {
                        "page": pagination.page,
                        "per_page": pagination.per_page,
                        "total_pages": pagination.pages,
                        "total_items": pagination.total,
                        "has_next": pagination.has_next,
                        "has_prev": pagination.has_prev,
                    },
                }
            ),
            200,
        )
    except Exception as e:
        app.logger.error(
            f"Error retrieving comments for GlobalPost ID {post_id}: {e}", exc_info=True
        )
        return api_error_response(500, "Server error retrieving comments.")


@app.route("/api/v1/global_comments/<int:comment_id>", methods=["PUT"])
@login_required
def update_global_comment(comment_id):
    comment = db.session.get(GlobalComment, comment_id)
    if not comment:
        return api_error_response(404, "Comment not found.")

    # Authorization: Only author or admin can edit
    if not (
        comment.author_id == current_user.id
        or current_user.role.name in ["system_admin", "hr_ceo"]
    ):
        return api_error_response(
            403, "You do not have permission to edit this comment."
        )

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")

    data = request.get_json()
    content = data.get("content", "").strip()

    if not content:
        return api_error_response(400, "Comment content cannot be empty.")
    if len(content) > 2000:
        return api_error_response(400, "Comment is too long.")

    try:
        comment.content = content
        comment.is_edited = True
        # comment.timestamp = datetime.now(timezone.utc) # Optionally update timestamp
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} updated GlobalComment ID {comment.id}."
        )
        # TODO: Emit SocketIO event for comment_updated
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Comment updated successfully.",
                    "comment_id": comment.id,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating GlobalComment ID {comment.id} by user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error updating comment.")


@app.route("/api/v1/global_comments/<int:comment_id>", methods=["DELETE"])
@login_required
def delete_global_comment(comment_id):
    comment = db.session.get(GlobalComment, comment_id)
    if not comment:
        return api_error_response(404, "Comment not found.")

    post = comment.post  # Get the parent post for authorization checks

    # Authorization: Comment author, Post author, or Admin
    can_delete = (
        comment.author_id == current_user.id
        or (post and post.author_id == current_user.id)
        or current_user.role.name in ["system_admin", "hr_ceo"]
    )
    if not can_delete:
        return api_error_response(
            403, "You do not have permission to delete this comment."
        )

    try:
        post_id_for_socket = comment.post_id  # Get before deleting comment
        db.session.delete(comment)  # Cascade delete should handle replies
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} deleted GlobalComment ID {comment.id}."
        )

        # Get new total comment count for the post
        new_total_comment_count = (
            db.session.scalar(
                db.select(func.count(GlobalComment.id)).where(
                    GlobalComment.post_id == post_id_for_socket
                )
            )
            or 0
        )

        # TODO: Emit SocketIO event for comment_deleted
        # socketio.emit('global_comment_deleted', {'post_id': post_id_for_socket, 'comment_id': comment_id, 'post_comment_count': new_total_comment_count}, room=f'global_post-{post_id_for_socket}')

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Comment deleted successfully.",
                    "post_comment_count": new_total_comment_count,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error deleting GlobalComment ID {comment.id} by user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error deleting comment.")


# === Global Like Endpoints (Continued) ===


@app.route("/api/v1/global_posts/<int:post_id>/likes", methods=["GET"])
@login_required
def get_global_post_likers(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    # Add visibility check for post if necessary

    page = request.args.get("page", 1, type=int)
    per_page = request.args.get("per_page", 20, type=int)  # More likers might be shown
    if per_page > 100:
        per_page = 100

    query = (
        db.select(User)
        .join(GlobalLike, GlobalLike.user_id == User.id)
        .where(GlobalLike.post_id == post.id)
        .options(joinedload(User.role))
        .order_by(GlobalLike.timestamp.desc())  # Newest likes first
    )

    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        likers_list = pagination.items

        result_likers = [
            {
                "id": user.id,
                "username": user.username,
                "full_name": user.full_name,
                "profile_photo_url": user.profile_photo_url,
                "role": user.role.name if user.role else None,
            }
            for user in likers_list
        ]

        return (
            jsonify(
                {
                    "success": True,
                    "likers": result_likers,
                    "pagination": {
                        "page": pagination.page,
                        "per_page": pagination.per_page,
                        "total_pages": pagination.pages,
                        "total_items": pagination.total,
                        "has_next": pagination.has_next,
                        "has_prev": pagination.has_prev,
                    },
                }
            ),
            200,
        )
    except Exception as e:
        app.logger.error(
            f"Error retrieving likers for GlobalPost ID {post_id}: {e}", exc_info=True
        )
        return api_error_response(500, "Server error retrieving likers.")


# === Placeholder for Global Post Share URL Redirect ===
@app.route("/global_posts/<int:post_id>/view")
# No login_required here if posts can be shared publicly, but content access will be checked
def view_global_post_redirect(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        abort(404, description="Shared post not found.")

    # Check post visibility before redirecting to a frontend view
    if post.visibility != "public":
        if not current_user.is_authenticated:
            flash("Please log in to view this content.", "warning")
            return redirect(url_for("login", next=request.url))
        # Further checks if not public (e.g., author, admin, connections for future)
        if not (
            post.author_id == current_user.id
            or current_user.role.name in ["system_admin", "hr_ceo"]
        ):
            flash("You do not have permission to view this post.", "warning")
            abort(403)

    # Redirect to a frontend route that displays this post.
    # This frontend route would then use the API /api/v1/global_posts/{post_id} to fetch details.
    # Example: frontend_url = f"/app/feed?post={post.id}" # Or similar client-side routing
    # For now, a simple placeholder redirect that might not work without a frontend page.
    # A better solution is for the frontend to handle /app/feed?post=ID directly.
    # This backend route is just for sharing a link that gets processed.
    flash(
        (
            f"Viewing shared post: {post.content[:50]}..."
            if post.content
            else f"Viewing shared media post ID {post.id}"
        ),
        "info",
    )
    # This would typically redirect to a frontend page that loads the post details via API.
    # For now, let's assume there's a generic 'feed' page on the frontend that can handle a post_id query param.
    return redirect(
        url_for("social_feed_placeholder", highlight_post_id=post.id)
    )  # Assuming a general feed page
# In app.py, replace your existing social_feed_placeholder function with this one.

@app.route("/feed", methods=["GET", "POST"])
@login_required
def social_feed_placeholder():
    """
    Renders the main global feed page ("Nexus Pulse") and handles the
    creation of new posts via POST requests from the same page.
    """
    # This form is used for both rendering the page (GET) and validating the submission (POST).
    form = PostContentForm()

    # This block executes only on a valid POST submission from the form.
    if form.validate_on_submit():
        content = form.content.data.strip()
        file_storage = form.attached_file.data # This is a FileStorage object

        linked_file = None
        if file_storage and file_storage.filename:
            # The save_uploaded_file helper handles security, saving, and DB object creation.
            linked_file = save_uploaded_file(file_storage)
            if not linked_file:
                # The helper should flash an error, and we return a JSON error for the AJAX call.
                return api_error_response(400, "File upload failed. Please check file type and size.")

        try:
            # Create the new post record in the database.
            new_post = GlobalPost(
                author_id=current_user.id,
                content=content if content else None,
                file_id=linked_file.id if linked_file else None,
                visibility="public", # Default visibility
                timestamp=datetime.now(timezone.utc),
            )

            if linked_file:
                db.session.add(linked_file)

            db.session.add(new_post)
            db.session.commit()

            app.logger.info(f"User {current_user.username} created GlobalPost ID {new_post.id} via /feed endpoint.")

            # Fetch the newly created post with all necessary data for rendering.
            post_for_render = db.session.get(GlobalPost, new_post.id)
            
            # Render the HTML for just the new post item.
            post_html = render_template(
                "partials/_global_post_item.html",
                post=post_for_render,
                current_user=current_user
            )

            # Return a JSON response to the JavaScript, which will then inject the HTML into the page.
            return jsonify({
                "success": True,
                "message": "Post created successfully!",
                "post_html": post_html,
            }), 201

        except Exception as e:
            db.session.rollback()
            # If the database commit failed, clean up any file that was saved to the disk.
            if linked_file and hasattr(linked_file, 'filepath') and linked_file.filepath:
                 try:
                    full_path = os.path.join(app.config['UPLOAD_FOLDER'], os.path.basename(linked_file.filepath))
                    if os.path.exists(full_path):
                        os.remove(full_path)
                 except Exception as cleanup_e:
                    app.logger.error(f"Error cleaning up orphaned file on post create fail: {cleanup_e}")
            app.logger.error(f"Error creating GlobalPost for user {current_user.id}: {e}", exc_info=True)
            return api_error_response(500, "Server error creating post.")

    # This part runs for GET requests or if the POST request's form validation failed.
    if request.method == "POST" and form.errors:
        # If an AJAX POST fails validation, return errors as JSON.
        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
            return jsonify({"success": False, "errors": form.errors}), 400
        # For a standard non-AJAX POST, WTForms flashes errors and we just re-render the page below.

    # Logic for a standard GET request to display the feed page.
    highlight_post_id = request.args.get("highlight_post_id")
    return render_template(
        "social/global/feed.html",
        title="Nexus Pulse - Community Feed",
        global_post_create_form=form, # Pass the form object to the template
        highlight_post_id=highlight_post_id,
    )
# ... (your existing code in app.py) ...

@app.route("/talent_club/community/messages", methods=["POST"])
@login_required
@tc_member_required # Assumed decorator for member check
def send_tc_community_message():
    """
    Handles the submission of new community messages for a talent club.
    Expects JSON data with 'content' and 'club_id'.
    """
    if not request.is_json:
        flash("Request must be JSON.", "danger")
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.get_json()
    message_content = data.get("content", "").strip()
    club_id = data.get("club_id") # Changed from community_group_id for clarity with TalentClub model

    if not message_content:
        flash("Message content cannot be empty.", "warning")
        return jsonify({"error": "Message content cannot be empty"}), 400

    if not club_id:
        flash("Club ID is missing.", "danger")
        return jsonify({"error": "Club ID is missing"}), 400

    try:
        # Verify if the club exists and if the current user is authorized (tc_member_required should handle this)
        # You might want an explicit check here if tc_member_required isn't enough for the specific club_id
        talent_club = TalentClub.query.get(club_id)
        if not talent_club:
            flash("Talent Club not found.", "danger")
            return jsonify({"error": "Talent Club not found"}), 404

        # Create a new message instance
        new_message = Message(
            club_id=club_id,
            user_id=current_user.id, # Assumes current_user is available from Flask-Login
            content=message_content,
            timestamp=datetime.now(timezone.utc) # Use timezone-aware datetime for production
        )

        # Add to session and commit to database
        db.session.add(new_message)
        db.session.commit()

        flash("Message sent successfully!", "success")
        return jsonify({"success": True, "message": "Message sent successfully!"}), 201

    except Exception as e:
        db.session.rollback() # Rollback changes in case of an error
        current_app.logger.error(f"Error sending community message for club {club_id}: {e}", exc_info=True)
        flash("An error occurred while sending your message. Please try again.", "danger")
        return jsonify({"error": "Internal server error"}), 500

# ... (rest of your app.py code) ...    
    
# --- END API v1: Global Engagement Core ---
# In app.py, find and REPLACE this entire function.

@app.route("/notifications/mark-selected-read", methods=["POST"])
@login_required
def ajax_mark_selected_notifications_read():
    """
    Marks a list of provided notification IDs as read.
    This is now robust and handles both standard form data and JSON requests.
    """
    notification_ids = [] ### MODIFIED: Initialize an empty list first.
    
    # --- THIS IS THE FIX ---
    # We now check if the incoming request is JSON. If it is, we parse it
    # as JSON. If not, we fall back to the original form-data logic.
    if request.is_json:
        # Handle a JSON request, e.g., from a fetch call with a JSON body.
        data = request.get_json()
        # The key in JSON is typically 'notification_ids', not 'notification_ids[]'.
        notification_ids = data.get("notification_ids", [])
    else:
        # Fallback to handle a standard form submission.
        notification_ids_str = request.form.getlist("notification_ids[]")
        if notification_ids_str:
             notification_ids = notification_ids_str
    # --- END OF FIX ---

    if not notification_ids:
        return jsonify({"success": False, "error": "No notification IDs provided."}), 400

    try:
        # Ensure all IDs are integers. This works for both lists.
        ids_to_update = [int(id_val) for id_val in notification_ids]
    except (ValueError, TypeError):
        return jsonify({"success": False, "error": "Invalid notification ID format."}), 400

    if not ids_to_update:
        return jsonify({"success": True, "message": "No notifications to update.", "updated_count": 0}), 200

    try:
        # Perform a bulk update for efficiency.
        # CRITICAL: The WHERE clause includes `receiver_id == current_user.id` to ensure
        # a user can only mark their OWN notifications as read.
        result = db.session.execute(
            db.update(Notification)
            .where(
                Notification.id.in_(ids_to_update),
                Notification.receiver_id == current_user.id
            )
            .values(is_read=True)
            .execution_options(synchronize_session=False) # Recommended for bulk updates
        )
        db.session.commit()
        
        updated_count = result.rowcount
        app.logger.info(f"User {current_user.id} marked {updated_count} notifications as read.")

        # Recalculate total unread count to send back to the client.
        total_unread_count = get_unread_notifications_count(current_user.id)

        return jsonify({
            "success": True,
            "message": f"{updated_count} notification(s) marked as read.",
            "updated_count": updated_count,
            "total_unread_count": total_unread_count
        }), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error marking selected notifications read for user {current_user.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "A server error occurred."}), 500
# app.py
# Add this route, typically near other API endpoints


@app.route("/api/analytics/log", methods=["POST"])
@login_required  # Or remove if anonymous analytics are also desired
def log_analytics_event():
    if not request.is_json:
        app.logger.warning(
            f"Analytics: Received non-JSON request from IP: {request.remote_addr}"
        )
        return (
            jsonify(
                {"success": False, "error": "Invalid request format, JSON expected."}
            ),
            400,
        )

    data = request.get_json()
    events = data.get("events", [])
    client_batch_timestamp = data.get("client_timestamp")
    page_url = data.get("url")
    user_id_for_log = current_user.id if current_user.is_authenticated else "anonymous"
    ip_address = request.remote_addr

    if not events or not isinstance(events, list):
        app.logger.warning(
            f"Analytics: Received empty or invalid events array from User: {user_id_for_log}, IP: {ip_address}, URL: {page_url}"
        )
        return (
            jsonify(
                {
                    "success": False,
                    "error": "No events provided or events in wrong format.",
                }
            ),
            400,
        )

    for event in events:
        event_name = event.get("name", "unknown_event")
        event_data = event.get("data", {})
        event_timestamp = event.get("timestamp", "N/A")

        app.logger.info(
            f"[ANALYTICS_EVENT] User: {user_id_for_log}, IP: {ip_address}, URL: {page_url}, "
            f'EventName: "{event_name}", Data: {event_data}, EventTS: {event_timestamp}, ClientBatchTS: {client_batch_timestamp}'
        )
        # In a real scenario, you would insert this into an analytics database table or send to a service.
        # Example:
        # new_analytic_entry = AnalyticsEntry(user_id=user_id_for_log, event_name=event_name, event_data=event_data, ...)
        # db.session.add(new_analytic_entry)

    # db.session.commit() # If saving to DB

    return jsonify({"success": True, "message": f"{len(events)} event(s) logged."}), 200


# --- ADD TO API v1 section in app.py (or new API section) ---


@app.route("/api/v1/me/channels/view", methods=["GET"])
@login_required
def get_my_channels_view_api():
    filter_type = request.args.get(
        "filter_type", "active"
    ).lower()  # 'all', 'pinned', 'active', 'archived'
    user_category_id_filter_str = request.args.get("category_id")
    page = request.args.get("page", 1, type=int)
    per_page = request.args.get("per_page", 20, type=int)
    if per_page > 50:
        per_page = 50

    # Base query: Channels user is subscribed to or owns
    base_query = (
        db.select(Channel)
        .outerjoin(
            UserChannelPreference,
            and_(
                UserChannelPreference.channel_id == Channel.id,
                UserChannelPreference.user_id == current_user.id,
            ),
        )
        .join(
            ChannelSubscriber,
            and_(
                ChannelSubscriber.channel_id == Channel.id,
                ChannelSubscriber.user_id == current_user.id,
            ),
        )  # Ensures user is subscribed
        .where(Channel.is_active == True)  # Only active channels
        .options(
            joinedload(Channel.social_category),
            joinedload(Channel.owner),
            # Load the specific preference for *this* user directly with the channel
            # This subqueryload approach is often more efficient for one-to-one or one-to-many (filtered to one)
            selectinload(
                Channel.user_preferences.and_(
                    UserChannelPreference.user_id == current_user.id
                )
            ),
        )
    )

    # Apply filters based on UserChannelPreference
    if filter_type == "pinned":
        base_query = base_query.where(UserChannelPreference.is_pinned == True).order_by(
            UserChannelPreference.pinned_order.asc().nulls_last(), Channel.name.asc()
        )
    elif filter_type == "archived":
        base_query = base_query.where(
            UserChannelPreference.is_archived == True
        ).order_by(
            UserChannelPreference.last_accessed_at.desc().nulls_last(),
            Channel.name.asc(),
        )
    elif (
        filter_type == "active"
    ):  # Default: not archived, not hidden (if hidden is a separate flag)
        base_query = base_query.where(
            or_(
                UserChannelPreference.is_archived.is_(None),
                UserChannelPreference.is_archived == False,
            ),
            or_(
                UserChannelPreference.is_hidden.is_(None),
                UserChannelPreference.is_hidden == False,
            ),  # if is_hidden implemented
        ).order_by(
            UserChannelPreference.is_pinned.desc(),
            UserChannelPreference.pinned_order.asc().nulls_last(),
            Channel.name.asc(),
        )  # Pinned first
    else:  # 'all' (includes archived, hidden, etc. - maybe for a management view)
        base_query = base_query.order_by(Channel.name.asc())

    # Filter by user's custom category
    unlocked_category_ids = session.get("unlocked_channel_category_ids", set())
    selected_user_category = None
    if user_category_id_filter_str:
        try:
            user_category_id_filter = int(user_category_id_filter_str)
            selected_user_category = db.session.get(
                UserChannelCategory, user_category_id_filter
            )
            if (
                not selected_user_category
                or selected_user_category.user_id != current_user.id
            ):
                return api_error_response(
                    404, "Custom category not found or not yours."
                )

            # If category is locked and not in session's unlocked list, deny access to its content
            if (
                selected_user_category.security_type
                and selected_user_category.security_type != "none"
                and selected_user_category.id not in unlocked_category_ids
            ):
                return (
                    jsonify(
                        {
                            "success": True,
                            "channels": [],
                            "pagination": {
                                "page": 1,
                                "per_page": per_page,
                                "total_pages": 0,
                                "total_items": 0,
                            },
                            "category_locked": True,
                            "category_id": selected_user_category.id,
                            "category_name": selected_user_category.name,
                        }
                    ),
                    200,
                )  # Return success but indicate category is locked

            base_query = base_query.where(
                UserChannelPreference.user_category_id == user_category_id_filter
            )
        except ValueError:
            return api_error_response(400, "Invalid category_id format.")

    try:
        pagination = db.paginate(
            base_query, page=page, per_page=per_page, error_out=False
        )
        channels_list = pagination.items

        results = []
        for ch in channels_list:
            # User preferences for this channel (should be loaded by selectinload or available via ch.user_preferences.first())
            pref = next(
                (p for p in ch.user_preferences if p.user_id == current_user.id), None
            )  # Get specific pref

            # Subscriber count (can be expensive if not careful, consider denormalization or approximate count)
            # For now, direct count from relationship if ChannelSubscriber is loaded for channel.
            # subscriber_count = ch.subscribers.count() # If 'subscribers' is a dynamic relationship
            # For performance, a subquery in the main query or a separate count query might be better for list views.
            # This can be simplified if `ch.subscribers` is configured to be a scalar count.

            results.append(
                {
                    "id": ch.id,
                    "name": ch.name,
                    "bio": ch.bio,
                    "profile_photo_url": ch.profile_photo_url,
                    "type": ch.type,
                    "owner_id": ch.owner_id,
                    "owner_name": (
                        ch.owner.full_name or ch.owner.username if ch.owner else "N/A"
                    ),
                    "social_category_name": (
                        ch.social_category.name
                        if ch.social_category
                        else "Uncategorized"
                    ),
                    "allow_comments": ch.allow_comments,
                    "allow_reactions": ch.allow_reactions,
                    # "subscriber_count": subscriber_count, # Add if efficiently obtainable
                    "user_preference": {
                        "is_pinned": pref.is_pinned if pref else False,
                        "pinned_order": (
                            pref.pinned_order if pref and pref.is_pinned else None
                        ),
                        "is_archived": pref.is_archived if pref else False,
                        "is_hidden": pref.is_hidden if pref else False,  # If using
                        "user_category_id": pref.user_category_id if pref else None,
                        "last_accessed_at": (
                            pref.last_accessed_at.isoformat() + "Z"
                            if pref and pref.last_accessed_at
                            else None
                        ),
                    },
                }
            )

        return (
            jsonify(
                {
                    "success": True,
                    "channels": results,
                    "pagination": {
                        "page": pagination.page,
                        "per_page": pagination.per_page,
                        "total_pages": pagination.pages,
                        "total_items": pagination.total,
                        "has_next": pagination.has_next,
                        "has_prev": pagination.has_prev,
                    },
                    "category_locked": False,  # Default if not specifically filtering by a locked category
                }
            ),
            200,
        )

    except Exception as e:
        app.logger.error(
            f"Error retrieving personalized channel list for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error retrieving channel list.")


# --- END Channel Command & Control API Endpoints ---
# --- Channel Command & Control API Endpoints ---


# Helper to get or create UserChannelPreference
def get_or_create_channel_preference(user_id, channel_id):
    preference = db.session.get(UserChannelPreference, (user_id, channel_id))
    if not preference:
        # Ensure channel exists before creating preference
        channel = db.session.get(Channel, channel_id)
        if not channel:
            return None  # Or raise an error
        # User must be subscribed or own the channel to have preferences for it
        # This check assumes ChannelSubscriber link exists and user.is_channel_member or owner check
        # For simplicity here, we assume if they are trying to set a pref, they have some relation.
        # Robust check: if not (current_user.id == channel.owner_id or current_user.is_channel_member(channel)): return None

        preference = UserChannelPreference(user_id=user_id, channel_id=channel_id)
        db.session.add(preference)
    return preference


# === Channel Preference API Endpoints ===


@app.route(
    "/api/v1/users/me/channel_preferences/<int:channel_id>/pin", methods=["POST"]
)
@login_required
def pin_channel_api(channel_id):
    preference = get_or_create_channel_preference(current_user.id, channel_id)
    if not preference:
        return api_error_response(
            404, "Channel not found or preference cannot be created."
        )

    data = request.get_json() if request.is_json else {}
    new_order = data.get("order")  # Optional: for explicit ordering by user

    try:
        preference.is_pinned = True
        if new_order is not None:
            try:
                preference.pinned_order = int(new_order)
            except ValueError:
                return api_error_response(400, "Invalid 'order' value for pinning.")
        # If order not provided, could auto-assign to end or handle in frontend

        # Simple re-ordering logic if new_order is provided (can be more complex)
        # If setting a pinned_order, ensure other pinned items are adjusted if needed.
        # For now, assume client handles visual order and backend stores user's explicit intent.

        db.session.commit()
        app.logger.info(f"User {current_user.username} pinned Channel ID {channel_id}.")
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Channel pinned.",
                    "channel_id": channel_id,
                    "is_pinned": True,
                    "pinned_order": preference.pinned_order,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error pinning channel {channel_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error pinning channel.")


@app.route(
    "/api/v1/users/me/channel_preferences/<int:channel_id>/pin", methods=["DELETE"]
)
@login_required
def unpin_channel_api(channel_id):
    preference = db.session.get(UserChannelPreference, (current_user.id, channel_id))
    if not preference or not preference.is_pinned:
        return api_error_response(404, "Channel not pinned or preference not found.")
    try:
        preference.is_pinned = False
        preference.pinned_order = None  # Clear order when unpinned
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} unpinned Channel ID {channel_id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Channel unpinned.",
                    "channel_id": channel_id,
                    "is_pinned": False,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error unpinning channel {channel_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error unpinning channel.")


@app.route(
    "/api/v1/users/me/channel_preferences/<int:channel_id>/archive", methods=["POST"]
)
@login_required
def archive_channel_api(channel_id):
    preference = get_or_create_channel_preference(current_user.id, channel_id)
    if not preference:
        return api_error_response(
            404, "Channel not found or preference cannot be created."
        )
    try:
        preference.is_archived = True
        preference.is_hidden = False  # Archiving might override simple hiding
        preference.is_pinned = False  # Cannot be pinned and archived
        preference.pinned_order = None
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} archived Channel ID {channel_id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Channel archived.",
                    "channel_id": channel_id,
                    "is_archived": True,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error archiving channel {channel_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error archiving channel.")


@app.route(
    "/api/v1/users/me/channel_preferences/<int:channel_id>/archive", methods=["DELETE"]
)
@login_required
def unarchive_channel_api(channel_id):
    preference = db.session.get(UserChannelPreference, (current_user.id, channel_id))
    if not preference or not preference.is_archived:
        return api_error_response(404, "Channel not archived or preference not found.")
    try:
        preference.is_archived = False
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} unarchived Channel ID {channel_id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Channel unarchived.",
                    "channel_id": channel_id,
                    "is_archived": False,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error unarchiving channel {channel_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error unarchiving channel.")

# In app.py, add this to the Talent Club Features section

@app.route("/talent_club/leader/dashboard")
@login_required
@tc_leader_required
def talent_club_leader_dashboard():
    """
    Renders the main administrative dashboard for the system-wide Talent Club Leader.
    This page provides high-level stats and navigation to management tools.
    """
    # --- Fetch Key Statistics for the Dashboard ---
    
    # Count of proposals awaiting the leader's review
    pending_proposals_count = db.session.scalar(
        select(func.count(TalentClubProposal.id))
        .where(TalentClubProposal.status == 'pending_leader_review')
    ) or 0
    
    # Total number of active Talent Clubs
    active_clubs_count = db.session.scalar(
        select(func.count(TalentClub.id))
        .where(TalentClub.is_active == True)
    ) or 0
    
    # Total number of active TC members
    active_members_count = db.session.scalar(
        select(func.count(User.id))
        .where(User.is_tc_member == True, User.is_active == True)
    ) or 0
    
    # Total number of active system-wide bans or mutes
    active_restrictions_count = db.session.scalar(
        select(func.count(TalentClubBan.id))
        .where(or_(
            TalentClubBan.expires_at.is_(None),
            TalentClubBan.expires_at > datetime.now(timezone.utc)
        ))
    ) or 0

    # Fetch recent activities for the leader (e.g., new proposals, high-level warnings)
    # This is a conceptual example; you can tailor the notification types.
    leader_activity_types = ['tc_proposal_for_review', 'tc_club_high_warning']
    recent_activities = db.session.scalars(
        select(Notification)
        .where(
            Notification.receiver_id == current_user.id,
            Notification.notification_type.in_(leader_activity_types)
        )
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()

    return render_template(
        'talent_club/leader/dashboard.html',
        title="TC Leader Dashboard",
        pending_proposals_count=pending_proposals_count,
        active_clubs_count=active_clubs_count,
        active_members_count=active_members_count,
        active_restrictions_count=active_restrictions_count,
        recent_activities=recent_activities
    )
# Implement /hide and /unhide similarly if their behavior is distinct from archive.
# For now, assuming archive is the primary "remove from active list" mechanism.


@app.route(
    "/api/v1/users/me/channel_preferences/<int:channel_id>/assign_category",
    methods=["PUT"],
)
@login_required
def assign_channel_to_category_api(channel_id):
    preference = get_or_create_channel_preference(current_user.id, channel_id)
    if not preference:
        return api_error_response(
            404, "Channel not found or preference cannot be created."
        )

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")
    data = request.get_json()
    user_category_id = data.get("user_category_id")  # Can be null to unassign

    try:
        if user_category_id is not None:
            try:
                user_category_id = int(user_category_id)
                # Verify category exists and belongs to current user
                category = db.session.get(UserChannelCategory, user_category_id)
                if not category or category.user_id != current_user.id:
                    return api_error_response(
                        404, "Custom category not found or does not belong to you."
                    )
                preference.user_category_id = category.id
            except ValueError:
                return api_error_response(400, "Invalid user_category_id format.")
        else:  # Unassign
            preference.user_category_id = None

        db.session.commit()
        app.logger.info(
            f"User {current_user.username} assigned Channel ID {channel_id} to Category ID {preference.user_category_id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Channel category assignment updated.",
                    "channel_id": channel_id,
                    "user_category_id": preference.user_category_id,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error assigning channel {channel_id} to category for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error assigning category.")


# === User-Defined Channel Category API Endpoints ===


@app.route("/api/v1/users/me/channel_categories", methods=["POST"])
@login_required
def create_user_channel_category_api():
    if not request.is_json:
        return api_error_response(400, "JSON expected.")
    data = request.get_json()
    name = data.get("name", "").strip()
    order = data.get("order", 0)
    security_type = data.get("security_type", "none").strip().lower()
    security_payload = data.get("security_payload")  # Plain PIN or pattern string

    if not name:
        return api_error_response(400, "Category name is required.")
    if len(name) > 100:
        return api_error_response(400, "Category name is too long.")

    valid_security_types = [
        "none",
        "pin_code",
        "pattern",
    ]  # 'pattern' is conceptual for now
    if security_type not in valid_security_types:
        return api_error_response(
            400, f"Invalid security_type. Allowed: {', '.join(valid_security_types)}"
        )
    if security_type != "none" and not security_payload:
        return api_error_response(
            400, "security_payload is required for secured categories."
        )

    try:
        new_category = UserChannelCategory(
            user_id=current_user.id,
            name=name,
            order=int(order),
            security_type=security_type if security_type != "none" else None,
        )
        if new_category.security_type:
            new_category.set_security_payload(security_payload)  # Hashes the payload

        db.session.add(new_category)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} created Channel Category '{name}' (ID: {new_category.id})."
        )

        category_data = {
            "id": new_category.id,
            "name": new_category.name,
            "order": new_category.order,
            "security_type": new_category.security_type,
            "channel_count": 0,  # Initial count
        }
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Category created.",
                    "category": category_data,
                }
            ),
            201,
        )
    except IntegrityError:
        db.session.rollback()
        return api_error_response(409, f"A category named '{name}' already exists.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error creating channel category for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error creating category.")


@app.route("/api/v1/users/me/channel_categories", methods=["GET"])
@login_required
def get_user_channel_categories_api():
    categories_query = (
        db.select(UserChannelCategory)
        .where(UserChannelCategory.user_id == current_user.id)
        .order_by(UserChannelCategory.order.asc(), UserChannelCategory.name.asc())
    )
    categories = db.session.scalars(categories_query).all()

    results = []
    for cat in categories:
        # Efficiently count channels in this category for this user
        channel_count = (
            db.session.scalar(
                db.select(func.count(UserChannelPreference.channel_id)).where(
                    UserChannelPreference.user_category_id == cat.id,
                    UserChannelPreference.user_id == current_user.id,
                )  # Ensure it's for this user's preferences
            )
            or 0
        )
        results.append(
            {
                "id": cat.id,
                "name": cat.name,
                "order": cat.order,
                "security_type": cat.security_type,  # DO NOT return security_payload_hash
                "is_locked": bool(
                    cat.security_type and cat.security_type != "none"
                ),  # Simple locked status
                "channel_count": channel_count,
                "_metadata": cat._metadata,
            }
        )
    return jsonify({"success": True, "categories": results}), 200


# PUT and DELETE for categories, and POST for /unlock would follow similar patterns.
# The /unlock endpoint needs careful session management for the "unlocked" state.


@app.route("/api/v1/users/me/channel_categories/<int:category_id>", methods=["PUT"])
@login_required
def update_user_channel_category_api(category_id):
    category = db.session.get(UserChannelCategory, category_id)
    if not category or category.user_id != current_user.id:
        return api_error_response(404, "Category not found or not yours.")

    if not request.is_json:
        return api_error_response(400, "JSON expected.")
    data = request.get_json()

    try:
        if "name" in data:
            name = data["name"].strip()
            if not name:
                return api_error_response(400, "Category name cannot be empty.")
            if len(name) > 100:
                return api_error_response(400, "Category name is too long.")
            # Check for name conflict if changed
            if name.lower() != category.name.lower():
                existing = db.session.scalar(
                    db.select(UserChannelCategory).where(
                        UserChannelCategory.user_id == current_user.id,
                        func.lower(UserChannelCategory.name) == name.lower(),
                        UserChannelCategory.id != category.id,
                    )
                )
                if existing:
                    return api_error_response(
                        409, f"A category named '{name}' already exists."
                    )
            category.name = name

        if "order" in data:
            category.order = int(data["order"])

        if "security_type" in data:
            security_type = (
                data["security_type"].strip().lower()
                if data["security_type"]
                else "none"
            )
            security_payload = data.get("security_payload")  # New PIN/Pattern

            valid_security_types = ["none", "pin_code", "pattern"]
            if security_type not in valid_security_types:
                return api_error_response(400, "Invalid security_type.")

            if security_type != "none" and not security_payload:
                # If changing to a secure type, payload is required
                if (
                    category.security_type is None or category.security_type == "none"
                ):  # Only if was not secure before or changing type
                    return api_error_response(
                        400,
                        "security_payload is required to set a new secured category type.",
                    )
                # If just updating name/order of an already secured category, payload is not required to change

            category.security_type = security_type if security_type != "none" else None
            if security_payload:  # If a new payload is provided, hash and set it
                category.set_security_payload(security_payload)
            elif security_type == "none":  # If changing to 'none', clear hash
                category.security_payload_hash = None

        if "_metadata" in data:
            category._metadata = data["_metadata"]  # Allow updating metadata

        db.session.commit()
        app.logger.info(
            f"User {current_user.username} updated Channel Category ID {category.id}."
        )
        # Return updated category data
        updated_category_data = {
            "id": category.id,
            "name": category.name,
            "order": category.order,
            "security_type": category.security_type,
            "is_locked": bool(category.security_type),
            "channel_count": category.channel_assignments.count(),
            "_metadata": category._metadata,
        }
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Category updated.",
                    "category": updated_category_data,
                }
            ),
            200,
        )
    except ValueError:
        return api_error_response(400, "Invalid data format (e.g., for order).")
    except IntegrityError:  # Name conflict
        db.session.rollback()
        return api_error_response(409, "Category name already exists.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating channel category {category_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error updating category.")


@app.route("/api/v1/users/me/channel_categories/<int:category_id>", methods=["DELETE"])
@login_required
def delete_user_channel_category_api(category_id):
    category = db.session.get(UserChannelCategory, category_id)
    if not category or category.user_id != current_user.id:
        return api_error_response(404, "Category not found or not yours.")
    try:
        # Unassign channels from this category before deleting category
        UserChannelPreference.query.filter_by(
            user_category_id=category.id, user_id=current_user.id
        ).update({"user_category_id": None})

        db.session.delete(category)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} deleted Channel Category ID {category.id} ('{category.name}')."
        )
        return jsonify({"success": True, "message": "Category deleted."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error deleting channel category {category_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error deleting category.")


@app.route(
    "/api/v1/users/me/channel_categories/<int:category_id>/unlock", methods=["POST"]
)
@login_required
def unlock_user_channel_category_api(category_id):
    category = db.session.get(UserChannelCategory, category_id)
    if not category or category.user_id != current_user.id:
        return api_error_response(404, "Category not found or not yours.")
    if not category.security_type or category.security_type == "none":
        return (
            jsonify({"success": True, "message": "Category is not locked."}),
            200,
        )  # Not an error

    if not request.is_json:
        return api_error_response(400, "JSON expected.")
    data = request.get_json()
    security_payload_attempt = data.get("security_payload")

    if not security_payload_attempt:
        return api_error_response(
            400, "Security payload (PIN/pattern data) is required to unlock."
        )

    if category.check_security_payload(security_payload_attempt):
        # Set session variable to mark category as unlocked for a limited time
        unlocked_cats = session.get("unlocked_channel_category_ids", set())
        unlocked_cats.add(category.id)
        session["unlocked_channel_category_ids"] = unlocked_cats
        # Set an expiration for this "unlocked" status if desired, e.g., by also storing a timestamp
        # session['unlocked_channel_category_expiry'] = datetime.now(timezone.utc) + timedelta(minutes=15)
        app.logger.info(
            f"User {current_user.username} unlocked Channel Category ID {category.id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Category unlocked.",
                    "category_id": category.id,
                }
            ),
            200,
        )
    else:
        # Optional: Implement attempt counter and temporary lockout for security
        app.logger.warning(
            f"User {current_user.username} failed to unlock Channel Category ID {category.id}."
        )
        return api_error_response(401, "Incorrect PIN or pattern.")


# --- END Channel Command & Control API Endpoints ---


def can_user_view_item(user, item_type, item_id):
    """
    Checks if the given user has permission to view the specified item.
    This is a simplified placeholder and needs to be fully implemented
    based on your application's specific visibility and permission rules for each item_type.
    """
    if (
        not user or not user.is_authenticated
    ):  # Should be caught by @login_required but good check
        return False

    # Fetch the item first
    item = None
    if item_type == "GlobalPost":
        item = db.session.get(GlobalPost, item_id)
        if item:
            return item.visibility == "public" or item.author_id == user.id  # or admin
    elif item_type == "ChannelPost":
        item = db.session.get(ChannelPost, item_id)
        if item and item.channel:
            return user.is_channel_member(item.channel)  # Example permission
    elif item_type == "GroupMessage":
        item = db.session.get(GroupMessage, item_id)
        if item and item.group:
            return user.is_group_member(item.group)  # Example permission
    elif item_type == "DirectMessage":  # Assuming 'Message' model for DMs
        item = db.session.get(Message, item_id)
        if item:
            return item.sender_id == user.id or item.receiver_id == user.id
    elif item_type == "TalentClubFeedPost":
        item = db.session.get(TalentClubFeedPost, item_id)
        if item and item.feed and item.feed.talent_club:
            # TC members can view active club feeds. More granular checks might be needed.
            return item.feed.talent_club.is_active and user.is_tc_member
    elif item_type == "TalentClubCommunityMessage":
        item = db.session.get(TalentClubCommunityMessage, item_id)
        if item:
            return user.is_tc_member  # TC Community is for all TC members
    # ... Add checks for other item_types ...

    if not item:
        app.logger.warning(
            f"Permission check: Item {item_type} ID {item_id} not found for user {user.id}."
        )
        return False  # Item doesn't exist

    app.logger.debug(
        f"Permission check for user {user.id} on {item_type} ID {item_id}: Granted (basic check)."
    )
    return True  # Default to true if item exists but no specific check implemented yet, needs refinement.


# Helper for API to get item details for hydrated saved list (expand with all supported item_types)
def get_item_summary_for_saved_list(item_type, item_id, requesting_user):
    """
    Fetches a summary of an item for the saved items list.
    Includes permission check before returning details.
    """
    details = {
        "type": item_type,
        "id": item_id,
        "title": "Item not found or access denied",
        "snippet": "",
        "url": None,
        "author_name": None,
        "author_id": None,
        "timestamp": None,
        "thumbnail_url": None,
        "item_exists": False,
    }

    if not can_user_view_item(requesting_user, item_type, item_id):
        return details  # Return default "access denied" structure

    details["item_exists"] = True  # Item exists and user can view it

    # --- GlobalPost ---
    if item_type == "GlobalPost":
        post = db.session.get(GlobalPost, item_id)
        if post:
            details["title"] = (
                post.content[:70] + "..."
                if post.content and len(post.content) > 70
                else post.content
            ) or (
                f"Media Post by {post.author.full_name or post.author.username}"
                if post.author
                else "Media Post"
            )
            details["snippet"] = (
                post.content[:150] + "..."
                if post.content and len(post.content) > 150
                else post.content
            ) or (
                f"File: {post.attached_file.original_filename}"
                if post.attached_file
                else "Global Post"
            )
            details["url"] = post.get_share_url()
            if post.author:
                details["author_name"] = post.author.full_name or post.author.username
                details["author_id"] = post.author.id
            details["timestamp"] = (
                post.timestamp.isoformat() + "Z" if post.timestamp else None
            )
            if (
                post.attached_file
                and post.attached_file.mimetype
                and post.attached_file.mimetype.startswith("image/")
            ):
                details["thumbnail_url"] = url_for(
                    "static", filename=post.attached_file.filepath
                )  # Assuming filepath is relative to static

    # --- ChannelPost ---
    elif item_type == "ChannelPost":
        post = db.session.get(ChannelPost, item_id)
        if post:
            details["title"] = (
                f"Post in '{post.channel.name}': "
                + (
                    post.content[:50] + "..."
                    if post.content and len(post.content) > 50
                    else post.content
                )
            ) or f"Media Post in '{post.channel.name}'"
            details["snippet"] = (
                post.content[:150] + "..."
                if post.content and len(post.content) > 150
                else post.content
            ) or (
                f"File: {post.file.original_filename}" if post.file else "Channel Post"
            )
            details["url"] = post.get_share_url()
            if post.author:
                details["author_name"] = post.author.full_name or post.author.username
                details["author_id"] = post.author.id
            details["timestamp"] = (
                post.timestamp.isoformat() + "Z" if post.timestamp else None
            )
            if (
                post.file
                and post.file.mimetype
                and post.file.mimetype.startswith("image/")
            ):
                details["thumbnail_url"] = url_for(
                    "static", filename=post.file.filepath
                )

    # --- GroupMessage ---
    elif item_type == "GroupMessage":
        msg = db.session.get(GroupMessage, item_id)
        if msg:
            details["title"] = (
                f"Message in '{msg.group.name}': "
                + (
                    msg.content[:50] + "..."
                    if msg.content and len(msg.content) > 50
                    else msg.content
                )
            ) or f"Media Message in '{msg.group.name}'"
            details["snippet"] = (
                msg.content[:150] + "..."
                if msg.content and len(msg.content) > 150
                else msg.content
            ) or (
                f"File: {msg.file.original_filename}" if msg.file else "Group Message"
            )
            details["url"] = msg.get_share_url()
            if msg.author:
                details["author_name"] = msg.author.full_name or msg.author.username
                details["author_id"] = msg.author.id
            details["timestamp"] = (
                msg.timestamp.isoformat() + "Z" if msg.timestamp else None
            )
            if (
                msg.file
                and msg.file.mimetype
                and msg.file.mimetype.startswith("image/")
            ):
                details["thumbnail_url"] = url_for("static", filename=msg.file.filepath)

    # --- DirectMessage (Message model) ---
    elif item_type == "DirectMessage":
        msg = db.session.get(Message, item_id)  # Assuming Message is your DM model
        if msg:
            other_user = (
                msg.sender if msg.receiver_id == requesting_user.id else msg.receiver
            )
            details["title"] = (
                f"DM with {other_user.full_name or other_user.username}: "
                + (
                    msg.content[:50] + "..."
                    if msg.content and len(msg.content) > 50
                    else msg.content
                )
            )
            details["snippet"] = (
                msg.content[:150] + "..."
                if msg.content and len(msg.content) > 150
                else msg.content
            )
            # URL for DMs might point to the chat interface with that user
            details["url"] = url_for("universal_chat", target_user_id=other_user.id)
            if msg.sender:  # The actual sender of this specific message
                details["author_name"] = msg.sender.full_name or msg.sender.username
                details["author_id"] = msg.sender.id
            details["timestamp"] = (
                msg.timestamp.isoformat() + "Z" if msg.timestamp else None
            )

    # --- TalentClubFeedPost ---
    elif item_type == "TalentClubFeedPost":
        post = db.session.get(TalentClubFeedPost, item_id)
        if post and post.feed and post.feed.talent_club:
            club_name = post.feed.talent_club.name
            details["title"] = (
                f"Post in TC '{club_name}': "
                + (
                    post.content[:50] + "..."
                    if post.content and len(post.content) > 50
                    else post.content
                )
            ) or f"Media Post in TC '{club_name}'"
            details["snippet"] = (
                post.content[:150] + "..."
                if post.content and len(post.content) > 150
                else post.content
            ) or (
                f"File: {post.file.original_filename}" if post.file else "TC Feed Post"
            )
            details["url"] = url_for(
                "view_talent_club_feed",
                club_id=post.feed.talent_club_id,
                _anchor=f"tc_feed_post-{post.id}",
            )
            if post.author:
                details["author_name"] = post.author.full_name or post.author.username
                details["author_id"] = post.author.id
            details["timestamp"] = (
                post.timestamp.isoformat() + "Z" if post.timestamp else None
            )
            if (
                post.file
                and post.file.mimetype
                and post.file.mimetype.startswith("image/")
            ):
                details["thumbnail_url"] = url_for(
                    "static", filename=post.file.filepath
                )

    # --- TalentClubCommunityMessage ---
    elif item_type == "TalentClubCommunityMessage":
        msg = db.session.get(TalentClubCommunityMessage, item_id)
        if msg and msg.community:
            details["title"] = (
                f"Message in '{msg.community.name}': "
                + (
                    msg.content[:50] + "..."
                    if msg.content and len(msg.content) > 50
                    else msg.content
                )
            ) or f"Media Message in '{msg.community.name}'"
            details["snippet"] = (
                msg.content[:150] + "..."
                if msg.content and len(msg.content) > 150
                else msg.content
            ) or (
                f"File: {msg.file.original_filename}"
                if msg.file
                else "TC Community Message"
            )
            details["url"] = url_for(
                "view_tc_community_messages", _anchor=f"tcc_message-{msg.id}"
            )
            if msg.author:
                details["author_name"] = msg.author.full_name or msg.author.username
                details["author_id"] = msg.author.id
            details["timestamp"] = (
                msg.timestamp.isoformat() + "Z" if msg.timestamp else None
            )
            if (
                msg.file
                and msg.file.mimetype
                and msg.file.mimetype.startswith("image/")
            ):
                details["thumbnail_url"] = url_for("static", filename=msg.file.filepath)

    # Add more elif blocks for other item_types as they become saveable

    return details
# File: app.py
# In app.py, replace your entire existing save_item_api function with this one.

@app.route("/api/v1/saved_items", methods=["POST"])
@login_required
def save_item_api():
    data = None
    # --- THIS IS THE FIX ---
    # We now check if the request is JSON. If not, we fall back to checking standard form data.
    # This makes the endpoint more robust to different types of AJAX requests.
    if request.is_json:
        data = request.get_json()
    else:
        # If not JSON, it's likely form-data. Create a dictionary from the form fields.
        data = request.form.to_dict()

    if not data:
        return api_error_response(400, "Request body is empty or data is missing.")
    # --- END OF FIX ---

    item_type = data.get("item_type")
    item_id_from_req = data.get("item_id")
    notes = data.get("notes")

    if not item_type or item_id_from_req is None:
        return api_error_response(400, "item_type and item_id are required.")

    allowed_item_types = [
        "GlobalPost", "ChannelPost", "GroupMessage", "DirectMessage",
        "TalentClubFeedPost", "TalentClubCommunityMessage",
    ]
    if item_type not in allowed_item_types:
        return api_error_response(
            400, f"Invalid item_type. Allowed types: {', '.join(allowed_item_types)}"
        )

    try:
        item_id = int(item_id_from_req)
    except (ValueError, TypeError):
        return api_error_response(400, "Invalid item_id format: Must be an integer.")

    if not can_user_view_item(current_user, item_type, item_id):
        app.logger.warning(
            f"User {current_user.id} attempt to save unviewable item: {item_type} ID {item_id}."
        )
        return api_error_response(
            404,
            "Item not found or you do not have permission to view it, so it cannot be saved.",
        )

    try:
        new_saved_item = UserSavedItem(
            user_id=current_user.id,
            item_type=item_type,
            item_id=item_id,
            notes=notes.strip() if notes else None,
            saved_at=datetime.now(timezone.utc),
        )
        db.session.add(new_saved_item)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} saved item: Type '{item_type}', ID {item_id}."
        )

        saved_item_data = {
            "id": new_saved_item.id,
            "item_type": new_saved_item.item_type,
            "item_id": new_saved_item.item_id,
            "notes": new_saved_item.notes,
            "saved_at": new_saved_item.saved_at.isoformat() + "Z",
        }
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Item saved successfully.",
                    "saved_item": saved_item_data,
                }
            ),
            201,
        )
    except IntegrityError:
        db.session.rollback()
        app.logger.info(
            f"User {current_user.username} attempt to save already saved item: Type '{item_type}', ID {item_id}."
        )
        return api_error_response(409, "This item is already in your saved list.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error saving item (Type '{item_type}', ID {item_id}) for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error occurred while saving the item.")

@app.route(
    "/api/v1/saved_items", methods=["GET"]
)  # Using query params for item identification
@login_required
def get_saved_items_api():  # Renamed
    page = request.args.get("page", 1, type=int)
    per_page = request.args.get("per_page", 15, type=int)
    if per_page > 50:
        per_page = 50  # Max limit

    item_type_filter_req = request.args.get("item_type_filter")
    sort_by_req = request.args.get("sort_by", "saved_at_desc")  # Default sort

    query = db.select(UserSavedItem).where(UserSavedItem.user_id == current_user.id)

    if item_type_filter_req:
        query = query.where(UserSavedItem.item_type == item_type_filter_req)

    if sort_by_req == "saved_at_desc":
        query = query.order_by(UserSavedItem.saved_at.desc())
    elif sort_by_req == "saved_at_asc":
        query = query.order_by(UserSavedItem.saved_at.asc())
    elif sort_by_req == "item_type_asc":
        query = query.order_by(
            UserSavedItem.item_type.asc(), UserSavedItem.saved_at.desc()
        )
    else:  # Default if invalid sort_by
        query = query.order_by(UserSavedItem.saved_at.desc())

    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        saved_items_raw_list = pagination.items

        hydrated_results = []
        for si_raw_item in saved_items_raw_list:
            # Use the refined helper that includes permission check
            item_content_details = get_item_summary_for_saved_list(
                si_raw_item.item_type, si_raw_item.item_id, current_user
            )

            hydrated_results.append(
                {
                    "saved_item_id": si_raw_item.id,  # ID of the UserSavedItem record itself
                    "item_type": si_raw_item.item_type,
                    "item_id": si_raw_item.item_id,  # ID of the actual content (GlobalPost, Message, etc.)
                    "saved_at": si_raw_item.saved_at.isoformat() + "Z",
                    "notes": si_raw_item.notes,
                    "content_details": item_content_details,  # This is the hydrated part from the helper
                }
            )

        return (
            jsonify(
                {
                    "success": True,
                    "saved_items": hydrated_results,
                    "pagination": {
                        "page": pagination.page,
                        "per_page": pagination.per_page,
                        "total_pages": pagination.pages,
                        "total_items": pagination.total,
                        "has_next": pagination.has_next,
                        "has_prev": pagination.has_prev,
                    },
                }
            ),
            200,
        )
    except Exception as e:
        app.logger.error(
            f"Error retrieving saved items for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error retrieving saved items.")

@app.route(
    "/api/v1/saved_items", methods=["DELETE"]
)  # Using query params for item identification
@login_required
def unsave_item_api():  # Renamed
    item_type = request.args.get("item_type")
    item_id_str = request.args.get("item_id")

    if not item_type or not item_id_str:
        return api_error_response(
            400, "item_type and item_id query parameters are required."
        )
    try:
        item_id = int(item_id_str)
    except ValueError:
        return api_error_response(400, "Invalid item_id format: Must be an integer.")

    try:
        saved_item_to_delete = db.session.scalar(
            db.select(UserSavedItem).where(
                UserSavedItem.user_id == current_user.id,
                UserSavedItem.item_type == item_type,
                UserSavedItem.item_id == item_id,
            )
        )
        if not saved_item_to_delete:
            return api_error_response(
                404, "This item is not in your saved list or was already unsaved."
            )

        saved_item_id_for_response = (
            saved_item_to_delete.id
        )  # Get UserSavedItem.id for response consistency
        db.session.delete(saved_item_to_delete)
        db.session.commit()
        app.logger.info(
            f"User {current_user.username} unsaved item: Type '{item_type}', ID {item_id} (UserSavedItem ID: {saved_item_id_for_response})."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Item removed from your saved list.",
                    "unsaved_item_details": {  # Send back identifiers for client to update UI
                        "saved_item_id": saved_item_id_for_response,  # The ID of the UserSavedItem row
                        "item_type": item_type,
                        "item_id": item_id,
                    },
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error unsaving item (Type '{item_type}', ID {item_id}) for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error occurred while unsaving the item.")


@app.route("/api/v1/saved_items/<int:saved_item_id>", methods=["PUT"])
@login_required
def update_saved_item_notes_api(saved_item_id):  # Renamed
    saved_item = db.session.get(UserSavedItem, saved_item_id)
    if not saved_item or saved_item.user_id != current_user.id:
        return api_error_response(
            404, "Saved item not found or you do not have permission to edit it."
        )

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")

    data = request.get_json()
    notes = data.get("notes")  # Allow empty string to clear notes, or null
    # custom_tags = data.get("custom_tags") # For future tag editing

    if notes is not None and len(notes.strip()) > 1000:  # Max length for notes
        return api_error_response(400, "Notes are too long (max 1000 characters).")

    try:
        saved_item.notes = notes.strip() if notes is not None else None
        # if custom_tags is not None: saved_item.custom_tags = custom_tags # For future

        db.session.commit()
        app.logger.info(
            f"User {current_user.username} updated notes for UserSavedItem ID {saved_item_id}."
        )

        updated_item_data = {
            "id": saved_item.id,
            "item_type": saved_item.item_type,
            "item_id": saved_item.item_id,
            "notes": saved_item.notes,
            "saved_at": saved_item.saved_at.isoformat() + "Z",
            "custom_tags": saved_item.custom_tags,
        }
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Saved item updated.",
                    "saved_item": updated_item_data,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error updating UserSavedItem ID {saved_item_id} for user {current_user.id}: {e}",
            exc_info=True,
        )
        return api_error_response(500, "Server error updating saved item.")


# --- END Content Curation API Endpoints ---


# Endpoint for a user to leave a group (if not the last owner)
@app.route("/social/groups/<int:group_id>/leave", methods=["POST"])
@login_required
def leave_social_group(group_id):
    """Allows a user to leave a group."""
    group = db.get_or_404(SocialGroup, group_id)

    # Fetch the member entry for the current user in this group
    member_entry = db.session.get(SocialGroupMember, (group_id, current_user.id))

    if not member_entry:
        flash("You are not a member of this group.", "warning")
        return redirect(url_for("social_group_list"))  # Redirect to group list

    # Prevent the *last* owner from leaving (unless ownership is transferred)
    if member_entry.role == "owner":
        # Check if this is the only owner left
        owner_count = (
            db.session.scalar(
                select(func.count(SocialGroupMember.user_id)).where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.role == "owner",
                )
            )
            or 0
        )

        if owner_count <= 1:  # If this user is the only owner or one of the last owners
            flash(
                "You are the only owner of this group. Transfer ownership before leaving.",
                "danger",
            )
            # Redirect back to group management page (or view page)
            return redirect(
                url_for("view_social_group", group_id=group.id)
            )  # Or manage_group_members

    try:
        db.session.delete(member_entry)  # Delete the association object
        db.session.commit()

        flash(f"Successfully left group '{group.name}'.", "success")
        app.logger.info(f"User {current_user.username} left group {group.id}.")
        # Redirect to group list
        return redirect(url_for("social_group_list"))

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error leaving group {group.id} by {current_user.id}: {e}", exc_info=True
        )
        flash("An error occurred while leaving the group. Please try again.", "danger")
        # Redirect back to the group view page on error
        return redirect(url_for("view_social_group", group_id=group.id))


# --- PART 12 END: Social Media Features ---

# --- PART 13 START: Settings ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User are defined with settings columns (e.g., age, sex, profile_photo_url, etc.).
# - Forms: UniversalSettingsForm is defined.
# - Decorators: login_required, role_required are defined.
# - Helpers: save_profile_photo (defined in Part 12) is used for profile photo uploads.
# - SQLAlchemy imports (select, func), Flask imports (abort, flash, redirect, url_for, request, render_template, jsonify), and other Python imports (datetime, timezone, os).


# Universal Settings Page
@app.route("/settings", methods=["GET", "POST"])
@login_required
def settings():
    # UniversalSettingsForm should be defined in your app.py or imported.
    # It should include fields like: full_name, username, email, age, sex,
    # and critically for this step: profile_photo (as FileField)
    # The 'profile_photo_url' field in the form (StringField) from previous phases can be removed
    # if direct file upload is now the primary method via 'profile_photo' FileField.

    # Ensure UniversalSettingsForm in your app.py has:
    # profile_photo = FileField("Update Profile Photo",
    # validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!')])

    form = UniversalSettingsForm(
        obj=current_user,  # Pre-populate with current user's data
        original_username=current_user.username,  # For unique username validation
        original_email=current_user.email,  # For unique email validation
    )

    # Manually set the display-only TC member status for the form, if the field exists
    if hasattr(form, "is_tc_member_display"):
        form.is_tc_member_display.data = current_user.is_tc_member

    if form.validate_on_submit():
        old_profile_photo_relative_path = current_user.profile_photo_url
        new_profile_photo_relative_path = None

        # --- Handle Profile Photo Upload ---
        # Check if the 'profile_photo' FileField in the form has data
        if form.profile_photo.data and form.profile_photo.data.filename:
            file_storage = form.profile_photo.data  # This is a FileStorage object
            try:
                # Call your save_profile_photo helper
                saved_relative_path = save_profile_photo(file_storage)
                if saved_relative_path:
                    new_profile_photo_relative_path = saved_relative_path
                    app.logger.info(
                        f"New profile photo uploaded for user {current_user.username}: {new_profile_photo_relative_path}"
                    )
                else:
                    # save_profile_photo should flash its own error, but we can add a general one
                    # If photo save failed, we might not want to proceed with other updates,
                    # or save other updates but not the photo. For now, we'll proceed with other updates.
                    flash(
                        "Profile photo update failed, but other settings might be saved.",
                        "warning",
                    )
            except Exception as e:
                app.logger.error(
                    f"Critical error processing profile photo for user {current_user.id}: {e}",
                    exc_info=True,
                )
                flash(
                    "A critical error occurred with the photo upload. Other settings were not saved.",
                    "danger",
                )
                return render_template(
                    "settings.html", form=form, title="My Settings - Nexus"
                )

        # --- Update User Object ---
        try:
            current_user.full_name = form.full_name.data.strip()
            # Update first_name and last_name based on full_name
            name_parts = current_user.full_name.split(" ", 1)
            current_user.first_name = name_parts[0]
            current_user.last_name = name_parts[1] if len(name_parts) > 1 else None

            # Username and Email uniqueness is handled by form validators
            current_user.username = form.username.data.strip()
            current_user.email = form.email.data.strip() if form.email.data else None

            current_user.age = form.age.data
            current_user.sex = (
                form.sex.data if form.sex.data else None
            )  # Handle empty select

            if new_profile_photo_relative_path:
                current_user.profile_photo_url = new_profile_photo_relative_path
            # If no new photo was uploaded, current_user.profile_photo_url remains unchanged.

            # Example for other settings if they were on UniversalSettingsForm:
            # if hasattr(form, 'theme') and hasattr(current_user, 'theme'):
            #     current_user.theme = form.theme.data
            # if hasattr(form, 'email_notifications') and hasattr(current_user, 'email_notifications'):
            #     current_user.email_notifications = form.email_notifications.data

            db.session.commit()

            # If a new photo was successfully saved and DB committed, delete the old one (if different)
            if (
                new_profile_photo_relative_path
                and old_profile_photo_relative_path
                and old_profile_photo_relative_path != new_profile_photo_relative_path
                and not old_profile_photo_relative_path.startswith("img/placeholders/")
            ):  # Don't delete default placeholders

                old_photo_full_path = os.path.join(
                    current_app.static_folder, old_profile_photo_relative_path
                )
                if os.path.exists(old_photo_full_path):
                    try:
                        os.remove(old_photo_full_path)
                        app.logger.info(
                            f"Deleted old profile photo: {old_profile_photo_relative_path} for user {current_user.username}"
                        )
                    except Exception as e:
                        app.logger.error(
                            f"Error deleting old profile photo {old_profile_photo_relative_path}: {e}"
                        )

            flash("Your settings have been updated successfully!", "success")
            app.logger.info(
                f"User {current_user.username} (ID: {current_user.id}) updated their settings."
            )
            return redirect(
                url_for("settings")
            )  # Redirect to refresh the page with new data

        except IntegrityError:  # Should be caught by form validators ideally
            db.session.rollback()
            app.logger.warning(
                f"Settings update for user {current_user.username} failed: IntegrityError (username/email)."
            )
            # Form validators (validate_username, validate_email in UniversalSettingsForm) should add errors to form.
            # If they are not present on the form, add a generic flash message.
            if not form.username.errors and not form.email.errors:
                flash(
                    "Update failed. The username or email may already be in use.",
                    "danger",
                )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error updating settings for user {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while saving your settings. Please try again.",
                "danger",
            )

    # For GET request or if form validation failed on POST
    # The form object (with data and errors) is passed to the template.
    return render_template("settings.html", form=form, title="My Settings - Nexus")

# In app.py, replace the entire create_task function

@app.route("/tasks/create", methods=["GET", "POST"])
@login_required
@role_required(*TASK_CREATOR_ROLES)
def create_task():
    form = CreateTaskForm()

    if form.validate_on_submit():
        assignees_data_str = form.assignees_data.data
        if not assignees_data_str:
            flash("Please assign the task to at least one user, role, or group.", "danger")
            return render_template("tasks/create.html", form=form, title="Create New Task")

        individual_user_ids = []
        selected_roles = []
        selected_grade_sections = []
        selected_subjects = []

        # Parse the "type:id,type:id,..." string from the hidden input
        for item in assignees_data_str.split(","):
            try:
                item_type, item_id = item.split(":", 1)
                if item_type == "user":
                    individual_user_ids.append(int(item_id))
                elif item_type == "role":
                    selected_roles.append(item_id)
                elif item_type == "grade_section":
                    selected_grade_sections.append(item_id)
                elif item_type == "subject":
                    selected_subjects.append(item_id)
            except (ValueError, IndexError):
                app.logger.warning(f"Could not parse assignee item: '{item}'")
                continue

        try:
            new_task = Task(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                due_date=form.due_date.data,
                urgency=form.urgency.data,
                created_by=current_user,
            )
            db.session.add(new_task)
            
            # This is a placeholder for a more robust assignment helper.
            # We'll collect all user IDs first, then assign.
            final_user_ids_to_assign = set(individual_user_ids)

            # Get user IDs for each selected role
            if selected_roles:
                role_users = db.session.scalars(select(User.id).where(User.role.has(Role.name.in_(selected_roles)))).all()
                final_user_ids_to_assign.update(role_users)

            # Get user IDs for each selected class
            for gs_string in selected_grade_sections:
                grade, section = gs_string.split('-', 1)
                class_users = db.session.scalars(select(User.id).where(User.grade == grade, User.section == section)).all()
                final_user_ids_to_assign.update(class_users)

            # Get user IDs for each selected subject
            if selected_subjects:
                subject_teachers = db.session.scalars(select(TeacherProfile.user_id).where(TeacherProfile.subject.in_(selected_subjects))).all()
                final_user_ids_to_assign.update(subject_teachers)

            # Now, assign the task to the unique set of users
            assigned_count = assign_task_to_users(new_task, list(final_user_ids_to_assign), current_user)

            if assigned_count > 0:
                # The helper function now handles the commit
                flash(f"Task '{new_task.title}' created and assigned to {assigned_count} user(s) successfully!", "success")
                return redirect(url_for("my_assigned_tasks"))
            else:
                db.session.rollback()
                flash("No valid assignees were found for the selection. Task not created.", "warning")

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating task: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")

    return render_template("tasks/create.html", form=form, title="Create New Task")

@app.route("/tasks/api/assignees/search")
@login_required
def api_search_assignees():
    """
    Powerful AJAX endpoint to search for all types of assignees for a task:
    - Individual Users
    - Roles (e.g., 'teacher', 'librarian')
    - Grade/Sections (e.g., 'Grade 9 - Section A')
    - Subjects (e.g., 'All Science Teachers')
    """
    search_query = request.args.get("q", "").strip()
    if not search_query or len(search_query) < 2:
        return jsonify([])  # Return empty list if query is too short

    results = []
    
    # --- 1. Search for Individual Users ---
    # Only search users who can actually be assigned tasks
    assignable_user_roles = [r[0] for r in VALID_ROLES if r[0] not in ['system_admin', 'government']]
    user_query = (
        select(User)
        .where(
            User.is_active == True,
            User.role.has(Role.name.in_(assignable_user_roles)),
            or_(
                User.username.ilike(f"%{search_query}%"),
                User.full_name.ilike(f"%{search_query}%"),
            ),
        )
        .options(joinedload(User.role))
        .order_by(User.full_name)
        .limit(10)
    )
    found_users = db.session.scalars(user_query).all()
    for user in found_users:
        results.append({
            "group": "Users",
            "type": "user",
            "id": user.id,
            "text": f"{user.full_name} ({user.role.name.replace('_',' ').title()})",
            "subtext": f"@{user.username}",
        })

    # --- 2. Search for Roles ---
    assignable_roles = get_assignable_roles()
    matching_roles = [r for r in assignable_roles if search_query.lower() in r.lower()]
    for role_name in matching_roles:
        results.append({
            "group": "Roles",
            "type": "role",
            "id": role_name,
            "text": f"All {role_name.replace('_',' ').title()}s",
            "subtext": "Assign to entire role",
        })

    # --- 3. Search for Grade/Sections ---
    assignable_sections = get_assignable_grade_sections()
    matching_sections = [(g, s) for g, s in assignable_sections if search_query.lower() in str(g).lower() or search_query.lower() in str(s).lower()]
    for grade, section in matching_sections:
        composite_id = f"{grade}-{section}"
        results.append({
            "group": "Classes",
            "type": "grade_section",
            "id": composite_id,
            "text": f"Grade {grade}, Section {section}",
            "subtext": "Assign to all students in this class",
        })
        
    # --- 4. Search for Subjects ---
    all_subjects = db.session.scalars(select(TeacherProfile.subject).distinct()).all()
    matching_subjects = [s for s in all_subjects if s and search_query.lower() in s.lower()]
    for subject in matching_subjects:
        results.append({
            "group": "Subjects",
            "type": "subject",
            "id": subject,
            "text": f"All {subject} Teachers",
            "subtext": "Assign to all teachers of this subject"
        })

    return jsonify(results)
@app.route("/tasks/api/users/search")  # AJAX Endpoint for User Search Picker
@login_required  # User must be logged in
def api_search_users():
    """Provides a list of assignable users based on a search query (for JS picker)."""
    search_query = request.args.get("q", "").strip()
    if not search_query or len(search_query) < 2:  # Require minimum 2 characters
        return jsonify([])  # Return empty list if query too short

    try:
        # Get users who are eligible to be assigned tasks (reuse helper logic)
        # The helper already excludes System Admins by default
        assignable_users_query = select(User).where(
            User.is_active == True
        )  # Start with active users
        # Exclude Task Creator roles from being assigned? Or just System Admin?
        # Let's exclude System Admins based on the helper
        system_admin_role = db.session.scalar(
            select(Role).filter_by(name="system_admin")
        )
        if system_admin_role:
            assignable_users_query = assignable_users_query.where(
                User.role != system_admin_role
            )

        # Filter by search query (case-insensitive on username or full_name)
        assignable_users_query = assignable_users_query.where(
            or_(
                User.username.ilike(f"%{search_query}%"),
                User.full_name.ilike(f"%{search_query}%"),
            )
        )

        # Order results and limit
        results = db.session.scalars(
            assignable_users_query.order_by(User.full_name).limit(20)
        ).all()  # Limit results

        # Format results for JSON response
        formatted_results = [
            {
                "id": user.id,
                "text": f"{user.full_name} ({user.username})",  # Format for display in picker
                "role": user.role.name if user.role else "N/A",
            }
            for user in results
        ]

        return jsonify(formatted_results)

    except Exception as e:
        app.logger.error(
            f"Error searching users for task assignment picker by user {current_user.id}: {e}",
            exc_info=True,
        )
        return jsonify({"error": "Failed to search users"}), 500


# Around line 10540 in your app.py
@app.route("/tasks/my_tasks")
@login_required
def my_tasks():
    """Lists tasks assigned to the current user."""
    # Fetch UserTask entries assigned *to* the current user
    my_tasks_list = db.session.scalars(
        select(UserTask)
        .join(UserTask.task)  # <<< --- ADD THIS JOIN
        .where(UserTask.user_id == current_user.id)
        # Eager load the Task and the creator of the Task (keep this)
        .options(joinedload(UserTask.task).joinedload(Task.created_by))
        # Order by status (Open first), then urgency (High first), then assigned_at (oldest first)
        .order_by(
            # Custom order for statuses: Open, In Progress, Delayed, Rejected, Completed, Accepted, Review Rejected
            case(
                {
                    "Open": 1,
                    "In Progress": 2,
                    "Delayed (Pending Review)": 3,
                    "Rejected (Pending Review)": 4,
                    "Completed (Pending Review)": 5,
                    "Review Rejected": 6,  # Tasks rejected by reviewer need action again
                    "Accepted": 7,  # Final state
                },
                value=UserTask.status,  # Order by this mapping
            ),
            Task.urgency.desc(),  # <<< --- CHANGE THIS LINE TO REFER TO THE Task MODEL
            UserTask.assigned_at.asc(),  # Order by assignment date ascending
        )
    ).all()

    # Filter tasks that are still 'Open', 'In Progress', 'Delayed', 'Rejected', 'Review Rejected' for the "My Tasks" list
    # 'Completed (Pending Review)' should also be listed under My Tasks until reviewed.
    # 'Accepted' tasks are considered done for the user and might be filtered out of the primary "My Tasks" view.
    # 'Review Rejected' tasks are effectively sent back, so they should remain in the "My Tasks" view.

    actionable_statuses = [
        "Open",
        "In Progress",
        "Completed (Pending Review)",
        "Delayed (Pending Review)",
        "Rejected (Pending Review)",
        "Review Rejected",
    ]
    my_actionable_tasks = [
        ut for ut in my_tasks_list if ut.status in actionable_statuses
    ]
    # You might want a separate list for 'Accepted' tasks or view them via history.

    return render_template(
        "tasks/my_tasks.html", my_tasks=my_actionable_tasks, title="My Tasks"
    )


# In app.py, replace or ensure the view_user_task route is correct.


@app.route("/tasks/user_task/<int:user_task_id>/view")
@login_required
def view_user_task(user_task_id):
    """
    Displays the detailed view of a single user's task assignment.
    This provides the necessary context for the corrected `user_task_detail.html` template.
    """
    user_task = db.get_or_404(
        UserTask, user_task_id, description="Task assignment not found."
    )
    task = user_task.task  # Get the parent task

    # Authorization checks
    is_assigned_user = user_task.user_id == current_user.id
    is_task_creator = task.created_by_id == current_user.id
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    if not (is_assigned_user or is_task_creator or is_global_admin):
        flash("You do not have permission to view this task assignment.", "danger")
        abort(403)

    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc())
    ).all()

    # Determine who can do what
    can_update_status = is_assigned_user and user_task.status in [
        "Open",
        "In Progress",
        "Review Rejected",
    ]
    can_review_status = (is_task_creator or is_global_admin) and user_task.status in [
        "Completed (Pending Review)",
        "Delayed (Pending Review)",
        "Rejected (Pending Review)",
    ]

    # Instantiate forms only if the user can perform the action
    update_form = (
        UpdateUserTaskStatusForm(prefix="update") if can_update_status else None
    )
    review_form = ReviewUserTaskForm(prefix="review") if can_review_status else None

    # Pre-populate forms with existing data on GET request
    if request.method == "GET":
        if update_form and user_task.completion_notes:
            update_form.completion_notes.data = user_task.completion_notes
        if review_form and user_task.reviewer_notes:
            review_form.reviewer_notes.data = user_task.reviewer_notes

    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=task,
        history_records=history_records,
        is_assigned_user=is_assigned_user,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=update_form,
        review_form=review_form,
        title=f"Task: {task.title}",
    )


# In app.py


@app.route("/tasks/user_task/<int:user_task_id>/update_status", methods=["POST"])
@login_required
def update_user_task_status(user_task_id):
    """Handles status updates submitted by the assigned user, supporting both AJAX and standard POST."""
    user_task = db.get_or_404(
        UserTask, user_task_id, description="Task assignment not found."
    )

    # --- Authorization Check ---
    if user_task.user_id != current_user.id:
        app.logger.warning(
            f"Unauthorized status update attempt on UserTask {user_task.id} by user {current_user.id}."
        )
        abort(403)

    # --- State Machine Check ---
    if user_task.status not in ["Open", "In Progress", "Review Rejected"]:
        flash(
            f"Cannot update status from '{user_task.status}'. The task is either completed or awaiting review.",
            "warning",
        )
        return redirect(url_for("view_user_task", user_task_id=user_task.id))

    form = UpdateUserTaskStatusForm()
    if form.validate_on_submit():
        try:
            old_status = user_task.status
            user_task.status = form.status.data
            user_task.completion_notes = (
                form.completion_notes.data.strip()
                if form.completion_notes.data
                else None
            )
            user_task.last_status_update_at = datetime.now(timezone.utc)
            # Clear previous review details when user resubmits
            user_task.reviewed_by_id = None
            user_task.reviewer_notes = None

            log_user_task_history(
                user_task,
                current_user,
                old_status,
                user_task.status,
                "Status Update",
                user_task.completion_notes,
            )
            db.session.commit()
            notify_user_task_status_update(user_task)  # Notify creator of the update

            flash(
                "Task status updated successfully and is now pending review!", "success"
            )

            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return jsonify(
                    {
                        "success": True,
                        "redirect_url": url_for(
                            "view_user_task", user_task_id=user_task.id
                        ),
                    }
                )
            return redirect(url_for("view_user_task", user_task_id=user_task.id))
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error updating status for UserTask {user_task_id}: {e}", exc_info=True
            )
            flash("An unexpected error occurred while updating task status.", "danger")
            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return (
                    jsonify({"success": False, "error": "A server error occurred."}),
                    500,
                )
            return redirect(url_for("view_user_task", user_task_id=user_task.id))

    # Handle form validation failure
    if request.headers.get("X-Requested-With") == "XMLHttpRequest":
        return jsonify({"success": False, "errors": form.errors}), 400

    # Flash errors for standard form submission
    flash("Failed to update status. Please check for errors below.", "danger")
    for field, errors in form.errors.items():
        for error in errors:
            flash(f"{getattr(form, field).label.text}: {error}", "danger")
    return redirect(url_for("view_user_task", user_task_id=user_task.id))


# In app.py


@app.route("/tasks/user_task/<int:user_task_id>/review", methods=["POST"])
@login_required
def review_user_task(user_task_id):
    """Handles review of a user's task status update by the creator, supporting AJAX and standard POST."""
    user_task = db.get_or_404(
        UserTask, user_task_id, description="Task assignment not found."
    )

    # --- Authorization Check ---
    is_task_creator = user_task.task.created_by_id == current_user.id
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    if not (is_task_creator or is_global_admin):
        app.logger.warning(
            f"Unauthorized review attempt on UserTask {user_task.id} by user {current_user.id}."
        )
        abort(403)

    # --- State Machine Check ---
    if user_task.status not in [
        "Completed (Pending Review)",
        "Delayed (Pending Review)",
        "Rejected (Pending Review)",
    ]:
        flash(
            f"This task's status ('{user_task.status}') is not pending review.",
            "warning",
        )
        return redirect(url_for("view_user_task", user_task_id=user_task.id))

    form = ReviewUserTaskForm()
    if form.validate_on_submit():
        try:
            old_status = user_task.status
            review_outcome = form.review_outcome.data

            user_task.reviewer_notes = (
                form.reviewer_notes.data.strip() if form.reviewer_notes.data else None
            )
            user_task.reviewed_by = current_user
            user_task.reviewed_at = datetime.now(timezone.utc)

            action = (
                "Review Accepted" if review_outcome == "Accepted" else "Review Rejected"
            )
            user_task.status = (
                "Accepted" if review_outcome == "Accepted" else "Open"
            )  # Reset to 'Open' if rejected

            log_user_task_history(
                user_task,
                current_user,
                old_status,
                user_task.status,
                action,
                user_task.reviewer_notes,
            )
            db.session.commit()
            notify_user_task_review_result(user_task)  # Notify assignee of the result

            flash(
                f"Review submitted. Task status is now '{user_task.status}'.", "success"
            )

            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return jsonify(
                    {
                        "success": True,
                        "redirect_url": url_for(
                            "view_user_task", user_task_id=user_task.id
                        ),
                    }
                )
            return redirect(
                url_for("view_assigned_task_detail", task_id=user_task.task_id)
            )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error reviewing UserTask {user_task.id}: {e}", exc_info=True
            )
            flash("An unexpected error occurred while processing the review.", "danger")
            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return (
                    jsonify({"success": False, "error": "A server error occurred."}),
                    500,
                )
            return redirect(url_for("view_user_task", user_task_id=user_task.id))

    # Handle form validation failure
    if request.headers.get("X-Requested-With") == "XMLHttpRequest":
        return jsonify({"success": False, "errors": form.errors}), 400

    flash("Failed to submit review. Please check for errors below.", "danger")
    for field, errors in form.errors.items():
        for error in errors:
            flash(f"{getattr(form, field).label.text}: {error}", "danger")
    return redirect(url_for("view_user_task", user_task_id=user_task.id))


@app.route("/tasks/my_assigned_tasks")
@login_required
def my_assigned_tasks():
    """Lists tasks created by the current user for their review/management."""
    # Check if current user's role is in the list of roles allowed to create tasks
    if current_user.role.name.lower() not in TASK_CREATOR_ROLES:
        flash("You do not have permission to view tasks you assigned.", "danger")
        app.logger.warning(
            f"Unauthorized view of assigned tasks list by user {current_user.username} (Role: {current_user.role.name})."
        )
        abort(403)

    # Fetch tasks created by the current user
    my_created_tasks = db.session.scalars(
        select(Task)
        .where(Task.created_by_id == current_user.id)
        .order_by(Task.created_at.desc())  # Newest first
    ).all()

    # For each task, get counts of UserTask assignments by status
    task_status_counts = {}
    for task in my_created_tasks:
        status_counts = db.session.execute(
            select(UserTask.status, func.count(UserTask.id))
            .where(UserTask.task_id == task.id)
            .group_by(UserTask.status)
        ).all()
        task_status_counts[task.id] = dict(
            status_counts
        )  # Store as a dictionary per task

    return render_template(
        "tasks/my_assigned_tasks.html",
        my_created_tasks=my_created_tasks,
        task_status_counts=task_status_counts,  # Pass the counts
        title="Tasks I Assigned",
    )


@app.route("/tasks/my_assigned_tasks/<int:task_id>")
@login_required
def view_assigned_task_detail(task_id):
    """Displays details and all user assignments for a task created by the current user."""
    task = db.get_or_404(Task, task_id)

    # Check authorization: Must be the task creator or a
    is_task_creator = task.created_by_id == current_user.id
    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin",
        "hr_ceo",
    ]

    if not is_task_creator and not is_global_admin:
        flash("You do not have permission to view details for this task.", "danger")
        app.logger.warning(
            f"Unauthorized view of assigned task detail {task_id} by user {current_user.id}. Creator: {task.created_by_id}."
        )
        abort(403)

    # Fetch all UserTask assignments for this task
    user_assignments = db.session.scalars(
        select(UserTask).where(UserTask.task_id == task.id)
        # Eager load the assigned user and their role
        .options(joinedload(UserTask.user).joinedload(User.role))
        # Order assignments by status (pending review first), then assigned user name
        .order_by(
            case(
                {
                    "Completed (Pending Review)": 1,
                    "Delayed (Pending Review)": 2,
                    "Rejected (Pending Review)": 3,
                },
                value=UserTask.status,
                else_=4,  # All other statuses after pending review
            ),
            User.full_name.asc(),
        )
    ).all()

    # Determine counts of assignments by status for a summary
    status_counts = defaultdict(int)
    for assignment in user_assignments:
        status_counts[assignment.status] += 1

    return render_template(
        "tasks/my_assigned_tasks_detail.html",
        task=task,
        user_assignments=user_assignments,
        status_counts=dict(status_counts),  # Convert back to dict for template
        title=f"Assigned Task: {task.title}",
    )


# @app.route("/tasks/all") # Optional Admin View (Placeholder)
# @login_required
# @role_required("system_admin", "hr_ceo")
# def list_all_tasks_admin():
#     """Admin view to list all tasks in the system."""
#     # Implement query for all Task objects, possibly with pagination and filtering
#     all_tasks = db.session.scalars(
#          select(Task)
#          .options(joinedload(Task.created_by))
#          .order_by(Task.created_at.desc())
#     ).all()
#     # Render template...
#     pass

# @app.route("/tasks/user_task/<int:user_task_id>/history") # Optional history detail
# @login_required
# def view_user_task_history(user_task_id):
#     """Displays the history of a specific user's task assignment."""
#     user_task = db.get_or_404(UserTask, user_task_id)
#     # Check permissions (assigned user, creator, or admin)
#     is_assigned_user = (user_task.user_id == current_user.id)
#     is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False
#     is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
#
#     if not is_assigned_user and not is_task_creator and not is_global_admin:
#          flash("You do not have permission to view this task assignment history.", "danger")
#          abort(403)
#
#     history_records = db.session.scalars(
#         select(TaskHistory)
#         .where(TaskHistory.user_task_id == user_task.id)
#         .options(joinedload(TaskHistory.changed_by))
#         .order_by(TaskHistory.timestamp.asc())
#     ).all()
#
#     # Render template...
#     pass

# --- PART Y END: Task System Features ---

# --- PART 14 START: Analytics (Placeholder/Basic) ---

# --- (Place with other Analytics or API routes) ---


@app.route("/analytics/attendance")
@login_required
@role_required(
    "hr_ceo", "system_admin", "school_executive"
)  # Roles that can access this data
def analytics_attendance_data():
    try:
        today = datetime.now(timezone.utc).date()

        # Counts of attendance statuses for today
        # Ensure Attendance model and func are imported
        attendance_summary_raw = db.session.execute(
            select(Attendance.status, func.count(Attendance.id).label("count"))
            .where(Attendance.date == today)
            .group_by(Attendance.status)
        ).all()  # List of Row objects [(status, count), ...]

        summary_dict = {row.status: row.count for row in attendance_summary_raw}

        # Calculate 'Absent (No Entry)' if needed, based on total eligible students
        total_eligible_students = (
            db.session.scalar(
                select(func.count(User.id))
                .join(Role)
                .where(Role.name == "student", User.is_active == True)
            )
            or 0
        )

        students_with_entry_today = sum(summary_dict.values())
        absent_no_entry_count = total_eligible_students - students_with_entry_today

        # Prepare labels and data for Chart.js
        labels = []
        data_values = []

        # Order for consistency, e.g., Present, Late, Excused, Absent (from DB), Absent (No Entry)
        status_order = ["Present", "Late", "Excused", "Absent"]
        for status_key in status_order:
            if status_key in summary_dict:
                labels.append(status_key)
                data_values.append(summary_dict[status_key])

        if absent_no_entry_count > 0:
            labels.append("Absent (No Entry)")
            data_values.append(absent_no_entry_count)

        # If no data at all, provide empty arrays but success
        if not labels and not data_values and total_eligible_students == 0:
            labels = ["No Student Data"]
            data_values = [0]
        elif (
            not labels and not data_values and total_eligible_students > 0
        ):  # No attendance marked today
            labels = ["Attendance Not Marked"]
            data_values = [total_eligible_students]

        return (
            jsonify(
                {
                    "success": True,  # Indicate successful data fetch
                    "labels": labels,
                    "data": data_values,
                    "chart_type": "doughnut",  # Suggest chart type
                    "title": f"Attendance Summary for {today.strftime('%Y-%m-%d')}",
                    "total_eligible_students": total_eligible_students,  # Extra context for frontend
                }
            ),
            200,
        )

    except Exception as e:
        app.logger.error(f"Error fetching attendance analytics: {e}", exc_info=True)
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Failed to retrieve attendance analytics data.",
                }
            ),
            500,
        )


@app.route("/analytics/enrollment_trends")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_enrollment_trends():
    # Placeholder: This would typically involve querying student enrollment data over time periods (e.g., per year/semester)
    # Example: Counts of new student registrations per month for the last year.
    # For now, returning static placeholder data.
    try:
        # Replace with actual query logic
        labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"]  # Example labels (months)
        data_values = [20, 25, 22, 30, 28, 35]  # Example data (new enrollments)

        if not data_values:  # No data found
            labels = ["No Enrollment Trend Data"]
            data_values = [0]

        return (
            jsonify(
                {
                    "success": True,
                    "labels": labels,
                    "data": data_values,
                    "chart_type": "line",
                    "title": "Recent Enrollment Trends",
                }
            ),
            200,
        )
    except Exception as e:
        app.logger.error(
            f"Error fetching enrollment trend analytics: {e}", exc_info=True
        )
        return (
            jsonify(
                {"success": False, "error": "Failed to retrieve enrollment trend data."}
            ),
            500,
        )


@app.route("/analytics/graduation_rates")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_graduation_rates():
    # Placeholder: This would involve querying student status (e.g., 'graduated') over time or by cohort.
    # For now, returning static placeholder data.
    try:
        # Replace with actual query logic
        labels = [
            "Cohort 2020",
            "Cohort 2021",
            "Cohort 2022",
            "Cohort 2023",
        ]  # Example labels
        data_values = [85, 88, 90, 92]  # Example data (graduation percentage)

        if not data_values:
            labels = ["No Graduation Rate Data"]
            data_values = [0]

        return (
            jsonify(
                {
                    "success": True,
                    "labels": labels,
                    "data": data_values,  # Percentages
                    "chart_type": "bar",
                    "title": "Graduation Rates by Cohort (%)",
                }
            ),
            200,
        )
    except Exception as e:
        app.logger.error(
            f"Error fetching graduation rate analytics: {e}", exc_info=True
        )
        return (
            jsonify(
                {"success": False, "error": "Failed to retrieve graduation rate data."}
            ),
            500,
        )


@app.route("/analytics/demographics")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_demographics_data():
    try:
        # Gender distribution for active students
        # Ensure User, Role, func are imported
        demographics_raw = db.session.execute(
            select(User.gender, func.count(User.id).label("count"))
            .join(User.role)  # Assuming User.role relationship
            .where(
                User.is_active == True, Role.name == "student"
            )  # Focus on active students
            .group_by(User.gender)
            .order_by(User.gender.asc())  # For consistent order
        ).all()  # List of Row objects [(gender, count), ...]

        summary_dict = {}
        for row in demographics_raw:
            gender_key = (
                row.gender
                if row.gender and row.gender.strip() != ""
                else "Not Specified"
            )
            summary_dict[gender_key] = summary_dict.get(gender_key, 0) + row.count

        # Ensure all expected categories are present for consistent chart display
        # This list can be expanded or made configurable
        expected_genders = [
            "Male",
            "Female",
            "Other",
            "Prefer Not to Say",
            "Not Specified",
        ]
        labels = []
        data_values = []
        for gender_cat in expected_genders:
            count = summary_dict.get(gender_cat, 0)
            if (
                count > 0 or gender_cat in summary_dict
            ):  # Only add if data exists or it's a defined category
                labels.append(gender_cat)
                data_values.append(count)

        if not labels:  # No demographic data found
            labels = ["No Demographic Data"]
            data_values = [0]

        return (
            jsonify(
                {
                    "success": True,
                    "labels": labels,
                    "data": data_values,
                    "chart_type": "pie",  # Suggest chart type
                    "title": "Student Gender Demographics (Active)",
                }
            ),
            200,
        )

    except Exception as e:
        app.logger.error(f"Error fetching demographics analytics: {e}", exc_info=True)
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Failed to retrieve demographics analytics data.",
                }
            ),
            500,
        )


@app.route("/analytics/performance")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_performance_data():
    try:
        # Average of student averages per subject
        # Ensure Mark model and func are imported
        performance_summary_raw = db.session.execute(
            select(Mark.subject, func.avg(Mark.average).label("average_score"))
            .where(
                Mark.average.isnot(None)
            )  # Only consider students with a calculated average
            .group_by(Mark.subject)
            .order_by(Mark.subject.asc())
        ).all()  # List of Row objects [(subject, average_score), ...]

        labels = [row.subject for row in performance_summary_raw]
        data_values = [
            round(row.average_score, 2) if row.average_score is not None else 0
            for row in performance_summary_raw
        ]

        if not labels:  # No performance data found
            labels = ["No Performance Data"]
            data_values = [0]

        return (
            jsonify(
                {
                    "success": True,
                    "labels": labels,
                    "data": data_values,
                    "chart_type": "bar",  # Suggest chart type
                    "title": "Average Performance by Subject",
                }
            ),
            200,
        )

    except Exception as e:
        app.logger.error(f"Error fetching performance analytics: {e}", exc_info=True)
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Failed to retrieve performance analytics data.",
                }
            ),
            500,
        )


# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Attendance, Mark, Asset, AssetReport, etc. are defined.
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, or_), Flask imports (jsonify, request, render_template, make_response), and other Python imports (csv, io, datetime, timezone).

# --- Analytics Routes (Basic Implementations / Placeholders) ---
# These routes are for HR/CEO and System Admin roles to view basic data summaries.
# Full-featured analytics with complex calculations and filtering are beyond the scope of this V1 generation.


@app.route("/analytics/attendance")
@login_required
@role_required("hr_ceo", "system_admin")  # Allow System Admin
def attendance_analytics():
    """Provides basic attendance data summary as JSON."""
    # This is a basic placeholder. Real analytics would involve filtering by date range, grade, section, etc.

    try:
        # Get counts of attendance statuses for today
        today = datetime.now(timezone.utc).date()

        attendance_summary = db.session.execute(
            select(Attendance.status, func.count(Attendance.id))
            .where(Attendance.date == today)
            .group_by(Attendance.status)
        ).all()

        # Format the results into a dictionary
        summary_dict = dict(attendance_summary)

        # Include total students count for context
        total_students_today = sum(
            summary_dict.values()
        )  # Sum of students with *an* entry today

        # You might also want the total number of *eligible* students
        total_eligible_students = (
            db.session.scalar(
                select(func.count(User.id))
                .join(Role)
                .where(Role.name == "student", User.is_active == True)
            )
            or 0
        )

        # Structure data for a chart/display (example format)
        labels = list(summary_dict.keys())  # Status names
        values = list(summary_dict.values())  # Counts

        # Add 'Absent' if not present in results but eligible students exist
        if "Absent" not in labels and total_eligible_students > 0:
            # Calculate truly absent students = total eligible - those with entries today
            actual_absent = total_eligible_students - total_students_today
            if actual_absent > 0:
                labels.append("Absent (No Entry)")
                values.append(actual_absent)

        return jsonify(
            {
                "labels": labels,  # e.g., ['Present', 'Late', 'Absent (No Entry)']
                "data": values,  # e.g., [150, 10, 20]
                "date": today.strftime("%Y-%m-%d"),
                "total_eligible_students": total_eligible_students,
            }
        )

    except Exception as e:
        app.logger.error(
            f"Error fetching attendance analytics data by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"error": "Failed to fetch attendance data"}), 500


@app.route("/analytics/performance")
@login_required
@role_required("hr_ceo", "system_admin")
def performance_analytics():
    """Provides basic performance data summary by subject as JSON."""
    # This is a basic placeholder. Real analytics would involve filtering by grade, section, etc.

    try:
        # Get average marks per subject (using average of 'average' column in Mark model)
        performance_summary = db.session.execute(
            select(Mark.subject, func.avg(Mark.average))
            .where(
                Mark.average.isnot(None)
            )  # Only include marks where average is calculated
            .group_by(Mark.subject)
            .order_by(Mark.subject)
        ).all()

        # Format the results
        summary_dict = dict(performance_summary)

        labels = list(summary_dict.keys())  # Subject names
        values = [round(v, 2) for v in summary_dict.values()]  # Average scores, rounded

        return jsonify(
            {
                "labels": labels,  # e.g., ['Math', 'Science', 'History']
                "data": values,  # e.g., [75.5, 82.1, 68.9]
            }
        )

    except Exception as e:
        app.logger.error(
            f"Error fetching performance analytics data by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"error": "Failed to fetch performance data"}), 500


@app.route("/analytics/demographics")
@login_required
@role_required("hr_ceo", "system_admin")
def demographics_analytics():
    """Provides basic demographic breakdown (e.g., gender) as JSON."""
    try:
        # Get gender counts for all active users (or perhaps just students?)
        # Let's do all active users for a general demographic overview
        gender_counts = db.session.execute(
            select(User.gender, func.count(User.id))
            .where(User.is_active == True)  # Only active users
            .group_by(User.gender)
            .order_by(User.gender)  # Order results consistently
        ).all()

        # Format results into a dictionary, handling None/empty gender
        summary_dict = {
            (row[0] if row[0] is not None and row[0] != "" else "Not Specified"): row[1]
            for row in gender_counts
        }

        # Ensure common gender categories are present even if count is 0
        all_genders = ["Male", "Female", "Other", "Prefer Not to Say", "Not Specified"]
        final_summary = {g: summary_dict.get(g, 0) for g in all_genders}

        labels = list(final_summary.keys())
        values = list(final_summary.values())

        return jsonify(
            {
                "labels": labels,  # e.g., ['Female', 'Male', 'Not Specified', 'Other']
                "data": values,  # e.g., [120, 130, 15, 5]
            }
        )

    except Exception as e:
        app.logger.error(
            f"Error fetching demographics data by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"error": "Failed to fetch demographics data"}), 500


@app.route("/analytics/performance-comparison")
@login_required
@role_required("hr_ceo", "system_admin")
def performance_comparison():
    """Placeholder for comparing performance metrics (e.g., across grades/sections)."""
    # This route is complex and requires more specific data structure and logic.
    # Returning empty data as a placeholder.

    return jsonify(
        {
            "labels": [],
            "average_scores": [],
            "leader_averages": [],  # Example comparison metric
            "error": "Performance comparison analytics not yet implemented.",
        }
    )


# Ensure csv and io are imported at the top
# import csv
# import io


@app.route("/analytics/export/<string:export_type>")  # Make sure export_type is string
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")  # Ensure roles are correct
def export_analytics_data(export_type):
    valid_export_types = [
        "attendance_summary",
        "performance_averages",
        "demographics",
        "enrollment_trends",
        "graduation_rates",
    ]  # Add new conceptual types

    if export_type not in valid_export_types:
        flash(f"Invalid export type requested: {export_type}", "danger")
        abort(404)

    output = io.StringIO()
    writer = csv.writer(output)
    filename = f"{export_type}_export_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.csv"

    try:
        if export_type == "attendance_summary":
            writer.writerow(["Status", "Count", "Date", "Total Eligible Students"])
            today = datetime.now(timezone.utc).date()
            attendance_summary_raw = db.session.execute(
                select(Attendance.status, func.count(Attendance.id).label("count"))
                .where(Attendance.date == today)
                .group_by(Attendance.status)
            ).all()
            summary_dict = {row.status: row.count for row in attendance_summary_raw}
            total_eligible_students = (
                db.session.scalar(
                    select(func.count(User.id))
                    .join(Role)
                    .where(Role.name == "student", User.is_active == True)
                )
                or 0
            )
            students_with_entry_today = sum(summary_dict.values())
            absent_no_entry_count = total_eligible_students - students_with_entry_today

            for status, count in summary_dict.items():
                writer.writerow(
                    [status, count, today.strftime("%Y-%m-%d"), total_eligible_students]
                )
            if absent_no_entry_count > 0:
                writer.writerow(
                    [
                        "Absent (No Entry)",
                        absent_no_entry_count,
                        today.strftime("%Y-%m-%d"),
                        total_eligible_students,
                    ]
                )

        elif export_type == "performance_averages":
            writer.writerow(["Subject", "Average Score"])
            performance_summary_raw = db.session.execute(
                select(Mark.subject, func.avg(Mark.average).label("average_score"))
                .where(Mark.average.isnot(None))
                .group_by(Mark.subject)
                .order_by(Mark.subject.asc())
            ).all()
            for row in performance_summary_raw:
                writer.writerow(
                    [
                        row.subject,
                        (
                            round(row.average_score, 2)
                            if row.average_score is not None
                            else "N/A"
                        ),
                    ]
                )

        elif export_type == "demographics":  # Example: Student Demographics by Gender
            writer.writerow(["Gender", "Count"])
            demographics_raw = db.session.execute(
                select(User.gender, func.count(User.id).label("count"))
                .join(Role)
                .where(User.is_active == True, Role.name == "student")
                .group_by(User.gender)
                .order_by(User.gender.asc())
            ).all()
            summary_dict = {}
            for row in demographics_raw:
                gender_key = (
                    row.gender
                    if row.gender and row.gender.strip() != ""
                    else "Not Specified"
                )
                summary_dict[gender_key] = summary_dict.get(gender_key, 0) + row.count
            for gender, count in summary_dict.items():
                writer.writerow([gender, count])

        # Add CSV generation for 'enrollment_trends' and 'graduation_rates' using their placeholder data
        elif export_type == "enrollment_trends":
            writer.writerow(["Month", "New Enrollments"])
            labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"]
            data_values = [20, 25, 22, 30, 28, 35]
            for label, value in zip(labels, data_values):
                writer.writerow([label, value])

        elif export_type == "graduation_rates":
            writer.writerow(["Cohort", "Graduation Rate (%)"])
            labels = ["Cohort 2020", "Cohort 2021", "Cohort 2022", "Cohort 2023"]
            data_values = [85, 88, 90, 92]
            for label, value in zip(labels, data_values):
                writer.writerow([label, value])
        else:
            # Should be caught by valid_export_types check
            flash("Unknown data type for export.", "danger")
            return redirect(request.referrer or url_for("hr_ceo_dashboard"))

        csv_data = output.getvalue()
        response = make_response(csv_data)
        response.headers["Content-Disposition"] = f"attachment; filename={filename}"
        response.headers["Content-Type"] = "text/csv"
        app.logger.info(
            f"User {current_user.username} exported analytics data: {export_type}."
        )
        return response

    except Exception as e:
        app.logger.error(
            f"Error generating CSV export for {export_type} by {current_user.username}: {e}",
            exc_info=True,
        )
        flash(
            f"An error occurred while generating the {export_type} CSV export. Please try again.",
            "danger",
        )
        return redirect(request.referrer or url_for("hr_ceo_dashboard"))


# --- PART X START: Multi-Tiered Request System Features ---

# NOTE: This new part relies on:
# - Models: Request, RequestHistory, User, Role
# - Forms: CreateRequestForm, ReviewRequestForm
# - Helpers: get_request_permissions, log_request_history, notify_request_event, get_users_in_role
# - Auth: login_required, role_required

# In app.py


@app.route("/requests/submit", methods=["GET", "POST"])
@login_required
@role_required("librarian", "student", "teacher", "talent_club")
def submit_request():
    """Allows authorized users to submit a new request, supporting both standard POST and AJAX."""
    permissions = get_request_permissions(current_user)
    if not permissions["can_create_request"]:
        flash("You do not have permission to submit new requests.", "danger")
        abort(403)

    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            hr_ceo_role_name = REQUEST_SYSTEM_PERMISSIONS["tier_handlers"][1]
            hr_ceos = get_users_in_role(hr_ceo_role_name)

            if not hr_ceos:
                flash_msg = "No HR/CEO users available to handle requests. Please contact administration."
                app.logger.error("No active HR/CEO users found for new request.")
                if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                    return jsonify({"success": False, "error": flash_msg}), 400
                flash(flash_msg, "danger")
                return render_template(
                    "requests/submit.html", form=form, title="Submit New Request"
                )

            initial_handler = hr_ceos[0]
            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id,
                current_handler_id=initial_handler.id,
                status="Pending",
                tier=1,
            )
            db.session.add(new_request)
            db.session.flush()
            log_request_history(
                new_request,
                current_user,
                None,
                "Pending",
                "Submitted",
                new_request.description,
            )
            db.session.commit()
            notify_request_event(new_request, "Submitted", changed_by_user=current_user)

            flash("Your request has been submitted successfully!", "success")
            app.logger.info(
                f"Request ID {new_request.id} submitted by {current_user.username}."
            )

            # FIX: Handle AJAX request by returning JSON with redirect URL
            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return jsonify(
                    {"success": True, "redirect_url": url_for("my_requests")}
                )

            return redirect(url_for("my_requests"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error submitting request by {current_user.username}: {e}",
                exc_info=True,
            )
            error_msg = "An unexpected error occurred while submitting your request."
            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return jsonify({"success": False, "error": error_msg}), 500
            flash(error_msg, "danger")

    # Handle form validation failure
    if request.method == "POST" and form.errors:
        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
            # FIX: Return validation errors as JSON for AJAX calls
            return jsonify({"success": False, "errors": form.errors}), 400
        # For standard posts, errors are flashed automatically by WTForms or can be looped in template
        flash("Please correct the errors below and try again.", "danger")

    return render_template(
        "requests/submit.html", form=form, title="Submit New Request"
    )


# In app.py, find and update the my_requests route.


@app.route("/requests/my_requests")
@login_required
def my_requests():
    """Lists requests submitted by the current user."""
    requests_list = db.session.scalars(
        select(Request)
        .where(Request.requester_id == current_user.id)
        .options(joinedload(Request.current_handler), joinedload(Request.requester))
        .order_by(Request.last_updated_at.desc())
    ).all()

    # FIX: Pass the permissions object to the template
    permissions = get_request_permissions(current_user)

    return render_template(
        "requests/my_requests.html",
        requests=requests_list,
        permissions=permissions,  # Pass permissions for conditional button display
        title="My Submitted Requests",
    )


@app.route("/requests/<int:request_id>/view")
@login_required
def view_request_detail(request_id):
    """Displays detailed information and history for a specific request."""
    request_obj = db.get_or_404(Request, request_id)
    permissions = get_request_permissions(current_user, request_obj)

    # User must be the requester, current handler, a , or last_forwarded_by
    if (
        not permissions["is_requester_of_request"]
        and not permissions["is_handler_for_request"]
        and not (
            current_user.role
            and current_user.role.name.lower()
            in ["system_admin", "hr_ceo", "school_executive", "government"]
        )
        and (request_obj.last_forwarded_by_id != current_user.id)
    ):  # Allow previous forwarders to view for audit
        flash("You do not have permission to view this request.", "danger")
        app.logger.warning(
            f"Unauthorized view of request ID {request_id} by user {current_user.username}."
        )
        abort(403)

    # Fetch request history
    history_records = db.session.scalars(
        select(RequestHistory)
        .where(RequestHistory.request_id == request_id)
        .options(joinedload(RequestHistory.changed_by))
        .order_by(
            RequestHistory.timestamp.asc()
        )  # Oldest first for chronological display
    ).all()

    return render_template(
        "requests/detail.html",
        request_obj=request_obj,
        history_records=history_records,
        permissions=permissions,  # Pass permissions for template logic (e.g., show/hide buttons)
        title=f"Request: {request_obj.title}",
    )


@app.route("/requests/inbox")
@login_required
@role_required(
    "hr_ceo", "school_executive", "government"
)  # Only these roles have an inbox
def requests_inbox():
    """Lists requests currently assigned to the current user for review."""
    # Fetch requests where the current user is the current_handler and status is not final
    inbox_requests = db.session.scalars(
        select(Request)
        .where(
            Request.current_handler_id == current_user.id,
            Request.status.notin_(
                ["Resolved", "Denied"]
            ),  # Exclude already final statuses
        )
        .options(joinedload(Request.requester))  # Eager load requester for display
        .order_by(
            Request.urgency.desc(), Request.created_at.asc()
        )  # High urgency first, then oldest
    ).all()

    return render_template(
        "requests/inbox.html", inbox_requests=inbox_requests, title="Requests Inbox"
    )


# In app.py


@app.route("/requests/<int:request_id>/review", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "school_executive", "government")
def review_request(request_id):
    """Allows handlers to review and update a request, supporting both standard POST and AJAX."""
    request_obj = db.get_or_404(Request, request_id, description="Request not found.")
    permissions = get_request_permissions(current_user, request_obj)

    is_global_admin = current_user.role and current_user.role.name.lower() in [
        "system_admin"
    ]
    if not permissions["is_handler_for_request"] and not is_global_admin:
        flash("You do not have permission to review this request.", "danger")
        abort(403)

    if request_obj.status in ["Resolved", "Denied"]:
        flash(
            f"This request is already '{request_obj.status}' and cannot be reviewed further.",
            "info",
        )
        return redirect(url_for("view_request_detail", request_id=request_id))

    form = ReviewRequestForm(
        obj=request_obj,
        current_user_role_name=current_user.role.name.lower(),
        request_tier=request_obj.tier,
        request_status=request_obj.status,
    )

    if permissions["can_forward"]:
        next_role_name = REQUEST_SYSTEM_PERMISSIONS["forward_paths"].get(
            current_user.role.name.lower()
        )
        if next_role_name:
            next_tier_users = get_users_in_role(next_role_name)
            form.forward_to_user_id.choices = [
                (0, "--- Select User to Forward To ---")
            ] + [(u.id, f"{u.full_name} ({u.username})") for u in next_tier_users]
        else:
            form.forward_to_user_id.choices = [(0, "No forward path defined")]

    if form.validate_on_submit():
        old_status = request_obj.status
        selected_action = form.status.data

        try:
            # This block centralizes the commit and redirect/jsonify logic
            if selected_action == "Forward":
                if not permissions["can_forward"] or not form.forward_to_user_id.data:
                    # This check is now robust and will be caught by the form's validate method
                    flash(
                        "You cannot forward this request or did not select a user.",
                        "danger",
                    )
                    # Fall through to re-render form with errors
                else:
                    new_handler = db.session.get(User, form.forward_to_user_id.data)
                    request_obj.current_handler_id = new_handler.id
                    request_obj.tier += 1
                    request_obj.status = "Pending"
                    request_obj.last_forwarded_by_id = current_user.id
                    log_request_history(
                        request_obj,
                        current_user,
                        old_status,
                        request_obj.status,
                        "Forwarded",
                        form.resolution_notes.data,
                    )
                    notify_request_event(
                        request_obj, "Forwarded", changed_by_user=current_user
                    )
                    flash(f"Request forwarded to {new_handler.full_name}.", "success")

            elif selected_action == "Denied":
                request_obj.status = "Denied"
                request_obj.denial_reason = form.denial_reason.data.strip()
                request_obj.resolution_notes = form.resolution_notes.data.strip()
                request_obj.current_handler_id = None
                log_request_history(
                    request_obj,
                    current_user,
                    old_status,
                    "Denied",
                    "Denied",
                    form.denial_reason.data,
                )
                notify_request_event(
                    request_obj, "Denied", changed_by_user=current_user
                )
                flash("Request has been denied.", "info")

            elif selected_action == "Resolved":
                if not permissions["can_resolve"]:
                    flash(
                        "You do not have permission to mark this request as resolved.",
                        "danger",
                    )
                else:
                    request_obj.status = "Resolved"
                    request_obj.resolution_notes = form.resolution_notes.data.strip()
                    request_obj.denial_reason = None
                    request_obj.current_handler_id = None
                    log_request_history(
                        request_obj,
                        current_user,
                        old_status,
                        "Resolved",
                        "Resolved",
                        form.resolution_notes.data,
                    )
                    notify_request_event(
                        request_obj, "Resolved", changed_by_user=current_user
                    )
                    flash("Request has been successfully resolved.", "success")

            else:  # Handle other statuses like 'Approved' or 'On Progress'
                request_obj.status = selected_action
                request_obj.resolution_notes = form.resolution_notes.data.strip()
                request_obj.denial_reason = None
                log_request_history(
                    request_obj,
                    current_user,
                    old_status,
                    selected_action,
                    "Reviewed",
                    form.resolution_notes.data,
                )
                notify_request_event(
                    request_obj,
                    "Status_Updated",
                    old_status=old_status,
                    changed_by_user=current_user,
                )
                flash(f"Request status updated to '{selected_action}'.", "success")

            request_obj.last_updated_at = datetime.now(timezone.utc)
            db.session.commit()

            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return jsonify(
                    {"success": True, "redirect_url": url_for("requests_inbox")}
                )
            return redirect(url_for("requests_inbox"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error reviewing request ID {request_id} by {current_user.username}: {e}",
                exc_info=True,
            )
            error_msg = "An unexpected error occurred while updating the request."
            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return jsonify({"success": False, "error": error_msg}), 500
            flash(error_msg, "danger")

    # Handle form validation failure
    if request.method == "POST" and form.errors:
        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
            return jsonify({"success": False, "errors": form.errors}), 400
        # For standard posts, flash each error
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"{getattr(form, field).label.text}: {error}", "danger")

    return render_template(
        "requests/review.html",
        form=form,
        request_obj=request_obj,
        permissions=permissions,
        title=f"Review Request: {request_obj.title}",
    )


# --- Direct Initiation Routes (HR/CEO, School Executive) ---


@app.route("/requests/hr_ceo/new_to_school_exec", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")  # System Admin can also initiate this path
def hr_ceo_initiate_request():
    """Allows HR/CEO to initiate a new request directly to School Executive."""
    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            # Determine the next handler (School Executive)
            school_exec_role_name = REQUEST_SYSTEM_PERMISSIONS["tier_handlers"][2]
            school_execs = get_users_in_role(school_exec_role_name)

            if not school_execs:
                flash(
                    "No School Executive users available to handle requests. Cannot initiate.",
                    "danger",
                )
                app.logger.error(
                    "No active School Executive users found when HR/CEO attempted to initiate a request."
                )
                return render_template(
                    "requests/hr_ceo_initiate.html",
                    form=form,
                    title="New Request to School Executive",
                )

            # Assign to the first active School Executive for simplicity
            initial_handler = school_execs[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id,  # HR/CEO is the requester
                current_handler_id=initial_handler.id,
                status="Pending",  # Still pending for the next tier
                tier=2,  # Starts at Tier 2
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc),
            )

            db.session.add(new_request)
            db.session.flush()

            # Log history: Initial submission by HR/CEO
            log_request_history(
                new_request,
                current_user,
                None,
                "Pending",
                "Submitted (HR/CEO Direct)",
                new_request.description,
            )

            db.session.commit()

            # Notify the initial handler (School Executive)
            notify_request_event(new_request, "Submitted", changed_by_user=current_user)

            flash(
                "Your request has been submitted to School Executive successfully!",
                "success",
            )
            app.logger.info(
                f"HR/CEO {current_user.username} initiated request ID {new_request.id} to School Executive."
            )
            return redirect(url_for("my_requests"))  # Or requests_inbox for HR/CEO

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error HR/CEO initiating request to School Executive by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while initiating the request. Please try again.",
                "danger",
            )

    return render_template(
        "requests/hr_ceo_initiate.html",
        form=form,
        title="New Request to School Executive",
    )


@app.route("/requests/school_exec/new_to_government", methods=["GET", "POST"])
@login_required
@role_required(
    "school_executive", "system_admin"
)  # System Admin can also initiate this path
def school_exec_initiate_request():
    """Allows School Executive to initiate a new request directly to Government."""
    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            # Determine the final handler (Government)
            government_role_name = REQUEST_SYSTEM_PERMISSIONS["tier_handlers"][3]
            government_users = get_users_in_role(government_role_name)

            if not government_users:
                flash(
                    "No Government users available to handle requests. Cannot initiate.",
                    "danger",
                )
                app.logger.error(
                    "No active Government users found when School Executive attempted to initiate a request."
                )
                return render_template(
                    "requests/school_exec_initiate.html",
                    form=form,
                    title="New Request to Government",
                )

            # Assign to the first active Government user for simplicity
            initial_handler = government_users[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id,  # School Executive is the requester
                current_handler_id=initial_handler.id,
                status="Pending",  # Still pending for the final tier
                tier=3,  # Starts at Tier 3
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc),
            )

            db.session.add(new_request)
            db.session.flush()

            # Log history: Initial submission by School Executive
            log_request_history(
                new_request,
                current_user,
                None,
                "Pending",
                "Submitted (School Exec Direct)",
                new_request.description,
            )

            db.session.commit()

            # Notify the final handler (Government)
            notify_request_event(new_request, "Submitted", changed_by_user=current_user)

            flash(
                "Your request has been submitted to Government successfully!", "success"
            )
            app.logger.info(
                f"School Executive {current_user.username} initiated request ID {new_request.id} to Government."
            )
            return redirect(url_for("my_requests"))  # Or requests_inbox for School Exec

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error School Executive initiating request to Government by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while initiating the request. Please try again.",
                "danger",
            )

    return render_template(
        "requests/school_exec_initiate.html",
        form=form,
        title="New Request to Government",
    )


# --- PART X END: Multi-Tiered Request System Features ---

# --- PART 14 END: Analytics (Placeholder/Basic) ---

# --- PART X START: Talent Club Features ---


# Decorator to require user is a Talent Club member (defined in Phase 3)
# from .helpers import tc_member_required # Ensure this import is correct if moved to helpers file
@app.route(
    "/talent_club/member_dashboard"
)  # Or just /talent_club/dashboard if no coordinator dashboard
@login_required
@tc_member_required  # Ensures user is an active TC member
def talent_club_dashboard_member_view():  # Unique function name
    # --- Data for Stat Cards ---
    # My Club Memberships Count (active memberships in active clubs)
    my_club_memberships_count = (
        db.session.scalar(
            select(func.count(TalentClubMembership.talent_club_id))
            .join(TalentClubMembership.club)
            .where(
                TalentClubMembership.user_id == current_user.id,
                TalentClubMembership.is_active == True,
                TalentClub.is_active == True,
            )
        )
        or 0
    )

    # Clubs I Follow Count (for active clubs, excluding those I'm a member of)
    membered_club_ids = db.session.scalars(
        select(TalentClubMembership.talent_club_id).where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
        )
    ).all()
    my_followed_clubs_count = (
        db.session.scalar(
            select(func.count(TalentClubFollow.talent_club_id))
            .join(TalentClubFollow.club)
            .where(
                TalentClubFollow.user_id == current_user.id,
                TalentClub.is_active == True,
                TalentClub.id.notin_(
                    membered_club_ids
                ),  # Only count follows if not a member
            )
        )
        or 0
    )

    # My Pending Proposals Count
    my_pending_proposals_count = (
        db.session.scalar(
            select(func.count(TalentClubProposal.id)).where(
                TalentClubProposal.creator_id == current_user.id,
                TalentClubProposal.status.in_(
                    ["pending_leader_review", "pending_members_accept"]
                ),
            )
        )
        or 0
    )

    # TC-specific Notifications Count (placeholder, uses global for now)
    # For a more specific count, filter Notification.notification_type.startswith('tc_')
    # unread_tc_notifications_count = get_unread_notifications_count(current_user.id) # Already in context

    # --- Data for "My Active Clubs (Joined)" List ---
    my_active_club_memberships = db.session.scalars(
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category)
            # Add other eager loads for club if needed by the partial, e.g., owner for display
        )
        .order_by(TalentClub.name.asc())
        .limit(5)  # Show first 5 for dashboard snippet
    ).all()

    # --- Data for "Recent Activity in My Clubs" (Conceptual) ---
    # This would require a more complex query:
    # - Get IDs of clubs user is member of.
    # - Fetch recent TalentClubFeedPost items from those clubs' feeds.
    # - Format them into the 'activity' dictionary structure expected by the partial.
    # For now, passing an empty list.
    recent_my_clubs_activity = []
    # Example query idea (very simplified):
    if my_active_club_memberships:
        my_club_ids = [m.talent_club_id for m in my_active_club_memberships]
        recent_posts_in_my_clubs = db.session.scalars(
            select(TalentClubFeedPost)
            .join(TalentClubFeedPost.feed)
            .where(TalentClubFeed.talent_club_id.in_(my_club_ids))
            .order_by(TalentClubFeedPost.timestamp.desc())
            .limit(5)
        ).all()
        for post in recent_posts_in_my_clubs:
            recent_my_clubs_activity.append(
                {
                    "icon": "bi-chat-right-text-fill",
                    "badge_color": "primary",
                    "text": f'New post in <strong>{post.feed.talent_club.name}</strong>: "{post.content[:30]}..."',
                    "timestamp": post.timestamp,
                    "url": url_for(
                        "view_talent_club_feed",
                        club_id=post.feed.talent_club_id,
                        _anchor=f"tc_feed_post-{post.id}",
                    ),
                }
            )

    # --- Data for "System TC Leader Info" ---
    system_tc_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).limit(1)
    )

    return render_template(
        "talent_club/dashboard.html",  # The new TC Member dashboard template
        title="My Talent Club Hub - Nexus TC",
        my_club_memberships_count=my_club_memberships_count,
        my_followed_clubs_count=my_followed_clubs_count,
        my_pending_proposals_count=my_pending_proposals_count,
        my_active_club_memberships=my_active_club_memberships,
        recent_my_clubs_activity=recent_my_clubs_activity,
        system_tc_leader=system_tc_leader,
        # unread_notifications_count is from context_processor
    )


@app.route("/join_talent_club", methods=["POST"])
@login_required
@role_required("student")
def join_talent_club():
    if current_user.is_tc_member:
        flash("You are already a Talent Club member.", "info")
        return redirect(
            url_for("talent_club_dashboard_member_view")
        )  # Redirect to TC Member Dashboard

    try:
        current_user.is_tc_member = True
        # Ensure the user is added to the TC Community group
        # add_to_tc_community_group helper should be defined (from app.py Part 3 / Phase J)
        # It handles checking if already a member and commits.
        community_add_success = add_to_tc_community_group(current_user)

        db.session.commit()  # Commit user.is_tc_member change

        if not community_add_success:
            flash(
                "Welcome to the Talent Club! However, there was an issue adding you to the main community group. Please contact an administrator.",
                "warning",
            )
        else:
            flash(
                "Welcome to the Talent Club! You've also been added to the TC Community group.",
                "success",
            )

        app.logger.info(
            f"Student {current_user.username} (ID: {current_user.id}) opted in to Talent Club."
        )
        return redirect(
            url_for("talent_club_dashboard_member_view")
        )  # Redirect to TC Member Dashboard

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error student {current_user.id} joining Talent Club: {e}", exc_info=True
        )
        flash(
            "An error occurred while joining Talent Club. Please try again.", "danger"
        )
        return redirect(
            url_for("student_dashboard")
        )  # Back to general student dashboard


@app.route("/talent_club/clubs")
@login_required
@tc_member_required  # Custom decorator from app.py Part 4 / Phase J
def my_talent_clubs():
    # Clubs user is a MEMBER of (active memberships)
    my_memberships_query = (
        select(TalentClubMembership)
        .join(
            TalentClubMembership.club
        )  # Join to TalentClub for ordering and eager loading
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,  # Only active memberships
            TalentClub.is_active == True,  # Only for active clubs
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(
                TalentClub.social_category
            ),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner),
        )
        .order_by(TalentClub.name.asc())
    )
    my_memberships = db.session.scalars(my_memberships_query).all()

    # Clubs user is FOLLOWING (and is not a member of)
    # Get IDs of clubs where user is already a member
    membered_club_ids = [m.talent_club_id for m in my_memberships]

    my_follows_query = (
        select(TalentClubFollow)
        .join(TalentClubFollow.club)
        .where(
            TalentClubFollow.user_id == current_user.id,
            TalentClub.is_active == True,  # Only follow active clubs
            TalentClub.id.notin_(
                membered_club_ids
            ),  # Exclude clubs they are already a member of
        )
        .options(
            joinedload(TalentClubFollow.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubFollow.club).joinedload(TalentClub.owner),
        )
        .order_by(TalentClub.name.asc())
    )
    my_follows = db.session.scalars(my_follows_query).all()

    return render_template(
        "talent_club/my_clubs.html",
        my_memberships=my_memberships,  # List of TalentClubMembership objects
        my_follows=my_follows,  # List of TalentClubFollow objects
        title="My Clubs & Follows - Nexus TC",
    )


@app.route("/talent_club/discover")
@login_required
@tc_member_required
def talent_club_discover():
    page = request.args.get("page", 1, type=int)
    per_page = 12  # Clubs per page
    search_query = request.args.get("search_query", "", type=str).strip()
    category_id_filter = request.args.get("category_id", "", type=str)

    query = (
        select(TalentClub)
        .where(TalentClub.is_active == True)  # Only discover active clubs
        .options(
            joinedload(TalentClub.social_category),
            joinedload(TalentClub.owner),
            # Eager load counts using subqueries for efficiency if your SQLAlchemy version supports it well,
            # or rely on relationship.count() in template (can be N+1 if not careful).
            # For now, template uses .count() on relationships.
            joinedload(TalentClub.memberships),  # To allow .memberships.count()
            joinedload(TalentClub.follows),  # To allow .follows.count()
        )
    )

    if search_query:
        search_term = f"%{search_query}%"
        query = query.where(
            or_(
                TalentClub.name.ilike(search_term),
                TalentClub.description.ilike(search_term),
            )
        )

    selected_category_id_int = None
    if category_id_filter and category_id_filter.isdigit():
        selected_category_id_int = int(category_id_filter)
        query = query.where(TalentClub.social_category_id == selected_category_id_int)

    query = query.order_by(
        TalentClub.level.desc(), TalentClub.name.asc()
    )  # Example order
    pagination_obj = db.paginate(query, page=page, per_page=per_page, error_out=False)
    discoverable_clubs = pagination_obj.items

    # Get SocialCategory list for the filter dropdown
    all_social_categories_for_filter = (
        get_social_categories()
    )  # Helper from app.py Part 4 / Phase J

    # Determine current user's status (member/follower) for each displayed club
    club_statuses = {}
    if discoverable_clubs:
        club_ids = [c.id for c in discoverable_clubs]

        memberships = db.session.scalars(
            select(TalentClubMembership.talent_club_id).where(  # Select only the ID
                TalentClubMembership.user_id == current_user.id,
                TalentClubMembership.talent_club_id.in_(club_ids),
                TalentClubMembership.is_active == True,
            )
        ).all()
        member_of_club_ids = set(memberships)

        follows = db.session.scalars(
            select(TalentClubFollow.talent_club_id).where(  # Select only the ID
                TalentClubFollow.user_id == current_user.id,
                TalentClubFollow.talent_club_id.in_(club_ids),
            )
        ).all()
        following_club_ids = set(follows)

        for club_item in discoverable_clubs:
            club_statuses[club_item.id] = {
                "is_member": club_item.id in member_of_club_ids,
                "is_following": club_item.id in following_club_ids
                and club_item.id not in member_of_club_ids,
            }

    return render_template(
        "talent_club/discover.html",
        all_clubs=discoverable_clubs,  # Renamed for template consistency
        categories=all_social_categories_for_filter,  # For filter dropdown
        pagination=pagination_obj,
        search_query=search_query,
        selected_category_id=selected_category_id_int,
        club_statuses=club_statuses,
        title="Discover Talent Clubs - Nexus TC",
    )


@app.route("/talent_club/discover/search")  # AJAX Endpoint for real-time search
@login_required
@tc_member_required
def talent_club_search():
    """Handles real-time search for Talent Clubs by name."""
    search_query = request.args.get("q", "").strip()
    if not search_query:
        return jsonify([])  # Return empty list if no query

    # Search for active clubs whose name matches the query (case-insensitive)
    results_query = (
        select(TalentClub)
        .where(
            TalentClub.is_active == True,
            TalentClub.name.ilike(f"%{search_query}%"),  # Case-insensitive LIKE
        )
        .order_by(TalentClub.name)
        .limit(10)  # Limit results for performance
    )
    results = db.session.scalars(results_query).all()

    # Format results for JSON response (list of dictionaries)
    formatted_results = []
    for club in results:
        # Determine if the current user is a member or follower for display in search results
        is_member = db.session.scalar(
            select(TalentClubMembership)
            .filter_by(talent_club=club, user=current_user, is_active=True)
            .exists()
        )
        is_following = db.session.scalar(
            select(TalentClubFollow).filter_by(club=club, user=current_user).exists()
        )

        formatted_results.append(
            {
                "id": club.id,
                "name": club.name,
                "profile_photo_url": club.profile_photo_url,
                "is_member": is_member,
                "is_following": is_following,
                # Add other relevant info if needed
            }
        )

    # Return JSON response
    return jsonify(formatted_results)


# In app.py, update this route
@app.route("/talent_club/<int:club_id>/profile")
@login_required
@tc_member_required
def view_talent_club_profile(club_id):
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is no longer active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # FIX: Determine and pass the user's status relative to the club
    user_status = "none"
    is_member = db.session.scalar(
        select(TalentClubMembership)
        .filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
        .exists()
    )
    if is_member:
        user_status = "member"
    else:
        is_following = db.session.scalar(
            select(TalentClubFollow)
            .filter_by(talent_club_id=club.id, user_id=current_user.id)
            .exists()
        )
        if is_following:
            user_status = "following"

    # Check if user is a manager of this specific club
    is_manager = (club.owner_id == current_user.id) or (
        db.session.scalar(
            select(TalentClubMembership)
            .filter_by(talent_club_id=club.id, user_id=current_user.id, role="admin")
            .exists()
        )
    )

    return render_template(
        "talent_club/club_profile.html",
        club=club,
        user_status=user_status,  # Pass this for the action buttons
        is_manager=is_manager,  # Pass this for the manage button
        title=f"Profile: {club.name}",
    )
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is no longer active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # is_member and is_following needed for UI buttons on profile
    is_member = db.session.scalar(
        select(TalentClubMembership)
        .filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
        .exists()
    )
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(
            talent_club_id=club.id, user_id=current_user.id
        )
    )
    is_following = (
        follow_entry is not None
    ) and not is_member  # Don't show "following" if already a member

    # For user_status on template (determines follow/join/member button state)
    user_status = "none"
    if is_member:
        user_status = "member"
    elif is_following:
        user_status = "following"

    receive_notifications_status = (
        follow_entry.receive_notifications if follow_entry else False
    )

    # Fetch follower and member counts (these are relationship counts on the model)
    # The template used club.follows.count() and club.memberships.filter_by(is_active=True).count()
    # For follower_count on template:
    # total_engagement = (db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0) + \
    #                    (db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0)
    # Simpler in template if relationships are loaded. The template has:
    # follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
    # Ensure club.memberships and club.follows are queryable collections or efficiently countable.

    # Fetch content snippets for profile page (e.g., last 3-5 posts of each type)
    # This requires club.feed to be loaded.
    recent_posts_snippets = []
    media_snippets = []
    file_snippets = []
    text_snippets = []

    if club.feed:  # Ensure club has a feed relationship
        recent_posts_snippets_query = (
            select(TalentClubFeedPost)
            .where(TalentClubFeedPost.feed_id == club.feed.id)
            .options(
                joinedload(TalentClubFeedPost.file)
            )  # Eager load file for mimetype check
            .order_by(TalentClubFeedPost.timestamp.desc())
            .limit(9)  # Fetch a few more to try and get diverse types
        )
        recent_posts_snippets = db.session.scalars(recent_posts_snippets_query).all()

        for p in recent_posts_snippets:
            if (
                p.file
                and p.file.mimetype
                and (
                    p.file.mimetype.startswith("image/")
                    or p.file.mimetype.startswith("video/")
                )
                and len(media_snippets) < 3
            ):
                media_snippets.append(p)
            elif p.file and len(file_snippets) < 3:  # Not image/video but has a file
                file_snippets.append(p)
            elif p.content and len(text_snippets) < 3:
                text_snippets.append(p)

    return render_template(
        "talent_club/club_profile.html",
        club=club,  # Pass full club object with loaded owner, social_category, feed
        user_status=user_status,
        receive_notifications_status=receive_notifications_status,
        media_snippets=media_snippets,
        file_snippets=file_snippets,
        text_snippets=text_snippets,
        title=f"Profile: {club.name} - Nexus TC",
    )


# Endpoint to fetch full content for the Media, Files, Texts tabs


@app.route(
    "/talent_club/<int:club_id>/follow_club", methods=["POST"]
)  # Matched action in JS
@login_required
@tc_member_required
def ajax_tc_follow_club(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        return jsonify({"success": False, "error": "Club is inactive."}), 400

    is_member = db.session.scalar(
        select(TalentClubMembership)
        .filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
        .exists()
    )
    if is_member:
        return jsonify({"success": False, "error": "You are already a member."}), 400

    existing_follow = db.session.scalar(
        select(TalentClubFollow).filter_by(
            talent_club_id=club.id, user_id=current_user.id
        )
    )
    if existing_follow:
        return jsonify({"success": False, "error": "Already following."}), 400

    try:
        new_follow = TalentClubFollow(
            club_id=club.id, user_id=current_user.id, receive_notifications=True
        )
        db.session.add(new_follow)
        db.session.commit()
        app.logger.info(f"User {current_user.id} followed TC Club {club.id}.")
        # Recalculate total engagement
        member_c = (
            db.session.scalar(
                select(func.count(TalentClubMembership.user_id)).where(
                    TalentClubMembership.talent_club_id == club.id,
                    TalentClubMembership.is_active == True,
                )
            )
            or 0
        )
        follow_c = (
            db.session.scalar(
                select(func.count(TalentClubFollow.user_id)).where(
                    TalentClubFollow.talent_club_id == club.id
                )
            )
            or 0
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Now following {club.name}.",
                    "new_total_engagement": member_c + follow_c,
                }
            ),
            200,
        )
    except Exception as e:  # Catch other errors
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} following club {club.id}: {e}", exc_info=True
        )
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route(
    "/talent_club/<int:club_id>/unfollow_club", methods=["POST"]
)  # Matched action in JS
@login_required
@tc_member_required
def ajax_tc_unfollow_club(club_id):
    club = db.get_or_404(TalentClub, club_id)
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(
            talent_club_id=club.id, user_id=current_user.id
        )
    )
    if not follow_entry:
        return jsonify({"success": False, "error": "Not following this club."}), 400
    try:
        db.session.delete(follow_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.id} unfollowed TC Club {club.id}.")
        member_c = (
            db.session.scalar(
                select(func.count(TalentClubMembership.user_id)).where(
                    TalentClubMembership.talent_club_id == club.id,
                    TalentClubMembership.is_active == True,
                )
            )
            or 0
        )
        follow_c = (
            db.session.scalar(
                select(func.count(TalentClubFollow.user_id)).where(
                    TalentClubFollow.talent_club_id == club.id
                )
            )
            or 0
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Unfollowed {club.name}.",
                    "new_total_engagement": member_c + follow_c,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} unfollowing club {club.id}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/toggle_notifications", methods=["POST"])
@login_required
@tc_member_required
def ajax_tc_toggle_notifications(club_id):
    club = db.get_or_404(TalentClub, club_id)
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(
            talent_club_id=club.id, user_id=current_user.id
        )
    )
    if not follow_entry:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You must be following this club to change notification settings.",
                }
            ),
            400,
        )
    try:
        follow_entry.receive_notifications = not follow_entry.receive_notifications
        db.session.commit()
        app.logger.info(
            f"User {current_user.id} toggled TC notifications for club {club.id} to {follow_entry.receive_notifications}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Notification setting updated.",
                    "new_status": follow_entry.receive_notifications,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} toggling TC notifications for club {club.id}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/content/<string:content_type>")
@login_required
@tc_member_required
def view_talent_club_content(club_id, content_type):
    """Fetches and renders a list of content posts for a specific club by type (for tabs)."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
        return (
            jsonify({"error": "Club is inactive"}),
            404,
        )  # Or redirect on error handler

    # Validate content_type
    valid_types = ["media", "files", "texts", "all"]
    if content_type not in valid_types:
        abort(404, description="Invalid content type.")

    # Build query for posts in the club's feed
    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed == club.feed)
        .options(
            joinedload(TalentClubFeedPost.author), joinedload(TalentClubFeedPost.file)
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )

    # Filter by content type
    if content_type == "media":
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(
                or_(File.mimetype.like("image/%"), File.mimetype.like("video/%"))
            )
        )
    elif content_type == "files":
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(
                ~or_(  # NOT (image OR video)
                    File.mimetype.like("image/%"), File.mimetype.like("video/%")
                )
            )
        )
    elif content_type == "texts":
        posts_query = posts_query.where(TalentClubFeedPost.content.isnot(None))

    # Execute the query (consider pagination for large feeds)
    posts = db.session.scalars(posts_query).all()

    # Render a partial template for the list of posts and return HTML
    # Assume a template like `partials/talent_club/content_list.html` exists
    # This partial template needs to handle displaying posts based on their content type.
    return render_template(
        "partials/talent_club/content_list.html",
        posts=posts,
        club=club,  # Pass club for context in template (e.g., allow_comments/reactions)
        content_type=content_type,  # Pass type to assist template rendering
    )


@app.route("/talent_club/<int:club_id>/follow", methods=["POST"])
@login_required
@tc_member_required
def talent_club_follow(club_id):
    """Allows a TC member to follow a specific Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
        return jsonify({"success": False, "error": "Club is inactive"}), 400

    # Check if user is already a member of this club instance
    is_member = db.session.scalar(
        select(TalentClubMembership)
        .filter_by(talent_club=club, user=current_user, is_active=True)
        .exists()
    )
    if is_member:
        return (
            jsonify(
                {"success": False, "error": "You are already a member of this club"}
            ),
            400,
        )  # Cannot follow if a member

    # Check if user is already following
    is_following = db.session.scalar(
        select(TalentClubFollow).filter_by(club=club, user=current_user).exists()
    )
    if is_following:
        return (
            jsonify({"success": False, "error": "You are already following this club"}),
            400,
        )

    try:
        # Create the follow entry
        new_follow = TalentClubFollow(
            club=club,
            user=current_user,
            followed_at=datetime.now(timezone.utc),
            receive_notifications=True,  # Default to receiving notifications on follow
        )
        db.session.add(new_follow)
        db.session.commit()
        app.logger.info(
            f"User {current_user.id} started following Talent Club {club.id}."
        )
        # Return updated follower count (approx) or success message
        follower_count = (
            club.follows.count() + club.memberships.filter_by(is_active=True).count()
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Following {club.name}",
                    "follower_count": follower_count,
                }
            ),
            200,
        )

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} following club {club.id}: {e}", exc_info=True
        )
        return jsonify({"success": False, "error": "Failed to follow club"}), 500


@app.route("/talent_club/<int:club_id>/unfollow", methods=["POST"])
@login_required
@tc_member_required
def talent_club_unfollow(club_id):
    """Allows a TC member to unfollow a specific Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    # Check if user is a member (cannot unfollow if a member, must leave)
    is_member = db.session.scalar(
        select(TalentClubMembership)
        .filter_by(talent_club=club, user=current_user, is_active=True)
        .exists()
    )
    if is_member:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You are a member of this club, not just following. Use the 'Leave Club' option instead.",
                }
            ),
            400,
        )

    # Find the follow entry
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(club=club, user=current_user)
    )
    if not follow_entry:
        return (
            jsonify({"success": False, "error": "You are not following this club"}),
            400,
        )  # Or already unfollowed

    try:
        db.session.delete(follow_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.id} unfollowed Talent Club {club.id}.")
        # Return updated follower count (approx) or success message
        follower_count = (
            club.follows.count() + club.memberships.filter_by(is_active=True).count()
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": f"Unfollowed {club.name}",
                    "follower_count": follower_count,
                }
            ),
            200,
        )

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} unfollowing club {club.id}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Failed to unfollow club"}), 500


# Endpoint to toggle notifications for a followed club
@app.route("/talent_club/<int:club_id>/toggle_notifications", methods=["POST"])
@login_required
@tc_member_required
def talent_club_toggle_notifications(club_id):
    """Toggles notification preference for a followed Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    # Find the follow entry - must be FOLLOWING, not just a member
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(club=club, user=current_user)
    )
    if not follow_entry:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You must be following this club to change notification settings",
                }
            ),
            400,
        )

    try:
        # Toggle the boolean value
        follow_entry.receive_notifications = not follow_entry.receive_notifications
        db.session.commit()
        app.logger.info(
            f"User {current_user.id} toggled notifications for Talent Club {club.id} to {follow_entry.receive_notifications}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Notification setting updated",
                    "new_status": follow_entry.receive_notifications,
                }
            ),
            200,
        )

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error user {current_user.id} toggling notifications for club {club.id}: {e}",
            exc_info=True,
        )
        return (
            jsonify(
                {"success": False, "error": "Failed to update notification setting"}
            ),
            500,
        )


@app.route("/talent_club/configuration")
@login_required
@tc_member_required
def talent_club_configuration():
    """Displays the Talent Club Configuration menu for TC members."""
    # This route just renders the template with navigation options.
    return render_template("talent_club/configuration.html", title="TC Configuration")


@app.route(
    "/talent_club/<int:club_id>/feed", methods=["GET"]
)  # POST handled by a separate AJAX endpoint
@login_required
@tc_member_required
def view_talent_club_feed(club_id):
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is not active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # Ensure the club has a feed record created (should happen when club is created)
    if not club.feed:
        # This is an inconsistency; ideally, a feed is created with the club.
        # For robustness, create it if missing, though this indicates a setup issue.
        app.logger.warning(
            f"Talent Club {club.id} ('{club.name}') was missing a feed record. Creating one now."
        )
        new_feed = TalentClubFeed(talent_club_id=club.id)
        db.session.add(new_feed)
        db.session.commit()
        club = db.session.get(
            TalentClub, club_id
        )  # Re-fetch to get the new feed relationship

    # Permission to view feed (any TC member can view an active club's feed)
    # Posting permissions are checked separately.

    # Fetch initial posts (e.g., paginated)
    page = request.args.get("page", 1, type=int)
    per_page_posts = 10

    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role),
            joinedload(TalentClubFeedPost.file),
            # Eager load comments and their authors for each post
            joinedload(TalentClubFeedPost.comments)
            .joinedload(TalentClubFeedComment.author)
            .joinedload(User.role),
            # Eager load reactions for each post (for counts)
            joinedload(TalentClubFeedPost.reactions),
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )
    pagination = db.paginate(
        posts_query, page=page, per_page=per_page_posts, error_out=False
    )
    posts = pagination.items

    post_form = PostContentForm()  # For creating new posts in this feed

    # Determine if current user can post in this feed
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(
            talent_club_id=club.id, user_id=current_user.id, is_active=True
        )
    )
    can_post_in_feed = False
    if user_membership:
        can_post_in_feed = TALENT_CLUB_POSTING_PERMISSIONS.get(
            user_membership.role.lower(), False
        )

    # Determine if current user is a manager (owner or admin of this club) for edit/delete all posts
    is_club_manager = (club.owner_id == current_user.id) or (
        user_membership and user_membership.role == "admin"
    )

    return render_template(
        "talent_club/club_feed.html",
        club=club,
        posts=posts,
        pagination=pagination,
        post_form=post_form,
        can_post_in_feed=can_post_in_feed,
        is_club_manager=is_club_manager,  # Pass this for admin actions on posts
        title=f"{club.name} Feed - Nexus TC",
    )


@app.route("/talent_club/<int:club_id>/feed/posts", methods=["POST"])
@login_required
@tc_member_required
def create_talent_club_feed_post(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active or not club.feed:
        return (
            jsonify(
                {"success": False, "error": "Club or its feed is not active/available."}
            ),
            403,
        )

    # Check posting permissions
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(
            talent_club_id=club.id, user_id=current_user.id, is_active=True
        )
    )
    can_post = False
    if user_membership:
        can_post = TALENT_CLUB_POSTING_PERMISSIONS.get(
            user_membership.role.lower(), False
        )

    if not can_post:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You do not have permission to post in this club's feed.",
                }
            ),
            403,
        )

    form = PostContentForm(request.form)  # For text content
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return (
            jsonify(
                {"success": False, "error": "Post content or a file must be provided."}
            ),
            400,
        )
    if form.content.data and not form.content.validate(form):  # Validate text content
        return (
            jsonify(
                {
                    "success": False,
                    "error": (
                        form.content.errors[0]
                        if form.content.errors
                        else "Invalid content."
                    ),
                }
            ),
            400,
        )

    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(
                file_storage
            )  # Reusing general helper
            if not uploaded_file_obj:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "File upload failed. Check type/size.",
                        }
                    ),
                    400,
                )
        except Exception as e:
            app.logger.error(
                f"Error processing file for TC feed post by {current_user.username}: {e}",
                exc_info=True,
            )
            return (
                jsonify({"success": False, "error": "Error processing uploaded file."}),
                500,
            )

    try:
        new_post = TalentClubFeedPost(  # Use TalentClubFeedPost model
            feed_id=club.feed.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc),
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_post)
        db.session.commit()

        app.logger.info(
            f"User {current_user.username} created TC feed post ID {new_post.id} in club {club.id}."
        )

        post_for_render = (
            db.session.query(TalentClubFeedPost)
            .options(
                joinedload(TalentClubFeedPost.author).joinedload(User.role),
                joinedload(TalentClubFeedPost.file),
                joinedload(TalentClubFeedPost.comments),
                joinedload(TalentClubFeedPost.reactions),
            )
            .get(new_post.id)
        )

        post_html = render_template(
            "partials/_tc_feed_post_item.html",
            post=post_for_render,
            current_user=current_user,
            club=club,
        )  # Pass club to partial for context

        # TODO: Notify club followers/members (see Phase 3 TC Proposal notification logic for example)
        # notify_tc_club_new_post(new_post, club)

        return (
            jsonify(
                {"success": True, "message": "Post created!", "post_html": post_html}
            ),
            201,
        )
    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath:  # Cleanup
            try:
                os.remove(
                    os.path.join(current_app.static_folder, uploaded_file_obj.filepath)
                )
            except:
                pass
        app.logger.error(
            f"Error creating TC feed post in club {club.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error creating post."}), 500


@app.route("/talent_club/feed/posts/<int:post_id>/delete", methods=["POST"])
@login_required
@tc_member_required
def delete_tc_feed_post_ajax(
    post_id,
):  # Renamed to avoid conflict if a GET view existed
    post = db.get_or_404(TalentClubFeedPost, post_id)
    club = post.feed.talent_club

    # Permissions: Post author, Club owner, Club admin
    is_post_author = post.author_id == current_user.id
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(
            talent_club_id=club.id, user_id=current_user.id, is_active=True
        )
    )
    is_club_owner_or_admin = (club.owner_id == current_user.id) or (
        user_membership and user_membership.role == "admin"
    )

    if not (is_post_author or is_club_owner_or_admin):
        return jsonify({"success": False, "error": "Permission denied."}), 403

    try:
        # If post has an associated file, delete it from filesystem (optional, handle orphans otherwise)
        if post.file:
            file_to_delete = post.file
            full_file_path = os.path.join(
                current_app.static_folder, file_to_delete.filepath
            )
            # Delete the File DB record first or after, cascade might handle it.
            # For safety, explicitly delete file record if not cascaded by post deletion.

        db.session.delete(
            post
        )  # This should cascade to comments and reactions if model relationships are set up with cascade='all, delete-orphan'
        if post.file:  # Delete File record if post deletion doesn't cascade to it
            db.session.delete(post.file)  # This assumes a one-to-one from post to file

        db.session.commit()

        # Now delete file from disk
        if post.file and file_to_delete:  # Check if file_to_delete was set
            if os.path.exists(full_file_path):
                try:
                    os.remove(full_file_path)
                    app.logger.info(
                        f"Deleted associated file {file_to_delete.filepath} for TC post {post.id}."
                    )
                except Exception as fe:
                    app.logger.error(
                        f"Error deleting file {file_to_delete.filepath} for TC post {post.id}: {fe}"
                    )

        app.logger.info(f"User {current_user.username} deleted TC feed post {post.id}.")
        return jsonify({"success": True, "message": "Post deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting TC feed post {post.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/feed/posts/<int:post_id>/react", methods=["POST"])
@login_required
@tc_member_required
def react_tc_feed_post(post_id):
    post = db.get_or_404(TalentClubFeedPost, post_id)
    club = post.feed.talent_club

    if not club.is_active or not club.feed.allow_reactions:
        # Club owner/admin might bypass this
        user_membership = db.session.scalar(
            select(TalentClubMembership).filter_by(
                talent_club_id=club.id, user_id=current_user.id, is_active=True
            )
        )
        is_manager = (club.owner_id == current_user.id) or (
            user_membership and user_membership.role == "admin"
        )
        if not is_manager:
            return jsonify({"success": False, "error": "Reactions are disabled."}), 403

    data = request.get_json()
    emoji = data.get("emoji", "").strip()
    if not emoji or emoji not in ["", "", "", "", "", ""]:  # Allowed emojis
        return jsonify({"success": False, "error": "Invalid emoji."}), 400

    try:
        existing_reaction = db.session.scalar(
            select(TalentClubFeedReaction).where(
                TalentClubFeedReaction.post_id == post.id,
                TalentClubFeedReaction.user_id == current_user.id,
                TalentClubFeedReaction.emoji == emoji,
            )
        )
        user_reacted_flag = False
        if existing_reaction:
            db.session.delete(existing_reaction)
            action_message = "Reaction removed."
        else:
            # Optional: If only one reaction type per user is allowed, remove their other reactions first
            # db.session.query(TalentClubFeedReaction).filter_by(post_id=post.id, user_id=current_user.id).delete()
            new_reaction = TalentClubFeedReaction(
                post_id=post.id, user_id=current_user.id, emoji=emoji
            )
            db.session.add(new_reaction)
            action_message = "Reaction added."
            user_reacted_flag = True
        db.session.commit()

        new_count = (
            db.session.scalar(
                select(func.count(TalentClubFeedReaction.id)).where(
                    TalentClubFeedReaction.post_id == post.id,
                    TalentClubFeedReaction.emoji == emoji,
                )
            )
            or 0
        )

        app.logger.info(
            f"User {current_user.username} {action_message} emoji '{emoji}' on TC post {post.id}."
        )
        return (
            jsonify(
                {
                    "success": True,
                    "message": action_message,
                    "emoji": emoji,
                    "new_count": new_count,
                    "user_reacted": user_reacted_flag,
                }
            ),
            200,
        )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error reacting TC post {post.id} by {current_user.username}: {e}",
            exc_info=True,
        )
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/feed/posts")  # GET request
@login_required
@tc_member_required  # Must be TC member to view feed posts
def get_tc_feed_posts_paginated(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active or not club.feed:
        return jsonify({"success": False, "error": "Club or feed not available."}), 404

    page = request.args.get("page", 1, type=int)
    per_page_posts = 10

    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role),
            joinedload(TalentClubFeedPost.file),
            joinedload(TalentClubFeedPost.comments).joinedload(
                TalentClubFeedComment.author
            ),
            joinedload(TalentClubFeedPost.reactions),
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )
    pagination = db.paginate(
        posts_query, page=page, per_page=per_page_posts, error_out=False
    )
    posts_on_page = pagination.items

    posts_html = ""
    if posts_on_page:
        rendered_posts_list = [
            render_template(
                "partials/_tc_feed_post_item.html",
                post=p,
                current_user=current_user,
                club=club,
            )
            for p in posts_on_page
        ]
        # Also render the "Load More" button if there's a next page, for JS to replace old one
        if pagination.has_next:
            next_page_trigger_html = f"""
            <div class="text-center my-4" id="loadMoreTcPostsTrigger-{club.id}">
                <button class="btn btn-outline-primary load-more-tc-posts-btn" data-club-id="{club.id}" data-current-page="{pagination.page}">
                    <span class="spinner-border spinner-border-sm d-none me-1" role="status" aria-hidden="true"></span>
                    Load More Posts
                </button>
            </div>
            """
            rendered_posts_list.append(next_page_trigger_html)

        posts_html = "".join(rendered_posts_list)

    return jsonify(
        {
            "success": True,
            "posts_html": posts_html,  # Contains posts and potentially the next load_more button
            "has_next_page": pagination.has_next,
        }
    )


# --- ADD or VERIFY these Redirect Routes ---
@app.route("/talent_club/feed_posts/<int:post_id>/view")
def view_tc_feed_post_redirect(post_id):
    post = db.session.get(TalentClubFeedPost, post_id)
    if (
        not post
        or not post.feed
        or not post.feed.talent_club
        or not post.feed.talent_club.is_active
    ):
        abort(404, description="Talent Club feed post not found or club is inactive.")

    # Permission Check: (Simplified - e.g., all TC members can view any active TC's feed posts)
    # More granular might involve checking if club is 'public' within TC system.
    if not current_user.is_authenticated or not current_user.is_tc_member:
        flash(
            "You must be a logged-in Talent Club member to view this content.",
            "warning",
        )
        return redirect(url_for("login", next=request.url))

    # Redirect to the frontend page that displays the feed, with an anchor to the post
    # This assumes your 'view_talent_club_feed' route can scroll to an anchor.
    return redirect(
        url_for(
            "view_talent_club_feed",
            club_id=post.feed.talent_club_id,
            _anchor=f"tc_feed_post-{post.id}",
        )
    )


# Implement similar redirect routes for TalentClubCommunityMessage
@app.route("/talent_club/community_messages/<int:message_id>/view")
def view_tc_community_message_redirect(message_id):
    message = db.session.get(TalentClubCommunityMessage, message_id)
    if not message or not message.community:
        abort(404, description="Talent Club community message not found.")

    if (
        not current_user.is_authenticated or not current_user.is_tc_member
    ):  # Must be TC member
        flash(
            "You must be a logged-in Talent Club member to view this content.",
            "warning",
        )
        return redirect(url_for("login", next=request.url))

    # Ensure user is part of the TC Community group (should be if is_tc_member is true after initial join)
    if not is_tc_community_member(current_user):  # is_tc_community_member helper
        flash("You are not part of the Talent Club community group.", "warning")
        return redirect(url_for("talent_club_dashboard_member_view"))

    return redirect(
        url_for("view_tc_community_messages", _anchor=f"tcc_message-{message.id}")
    )


# --- END Redirect Routes ---


@app.route("/talent_club/configuration/current_leader")
@login_required
@tc_member_required  # Only TC members can view this page
def view_current_tc_leader():
    current_system_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).limit(1)
    )
    active_election = (
        get_active_tc_leader_election()
    )  # Helper from app.py Part 3 / Phase J

    candidates_for_voting = []
    user_has_voted_in_active_election = None
    can_user_vote = False
    vote_form = None

    if active_election:
        candidates_for_voting = (
            get_tc_leader_candidates()
        )  # Helper from app.py Part 3 / Phase J (all active TC members)
        user_has_voted_in_active_election = db.session.scalar(
            select(TalentClubLeaderVote)
            .filter_by(election_id=active_election.id, voter_id=current_user.id)
            .limit(1)
        )
        if (
            not user_has_voted_in_active_election
        ):  # Can vote if election is active and they haven't voted
            can_user_vote = True
            # Pass the list of candidates to the form's __init__
            vote_form = TalentClubLeaderVoteForm(candidates=candidates_for_voting)

    return render_template(
        "talent_club/config_current_leader.html",
        current_leader=current_system_leader,
        active_election=active_election,
        candidates=candidates_for_voting,  # For display or form population
        user_vote=user_has_voted_in_active_election,  # The vote object if they voted
        can_vote=can_user_vote,
        vote_form=vote_form,  # Pass form if user can vote
        title="TC Leadership & Election - Nexus TC",
    )


@app.route("/talent_club/leader_vote", methods=["POST"])
@login_required
@tc_member_required  # Only TC members can vote
def cast_tc_leader_vote():
    """Handles casting a vote in an active TC Leader election."""
    # Ensure user is eligible to vote (is_tc_member) - handled by decorator
    # Ensure an election is active
    active_election = get_active_tc_leader_election()
    if not active_election:
        flash("No active Talent Club Leader election is in progress.", "danger")
        return redirect(url_for("view_current_tc_leader"))

    # Ensure user hasn't already voted
    existing_vote = db.session.scalar(
        select(TalentClubLeaderVote).filter_by(
            election=active_election, voter=current_user
        )
    )
    if existing_vote:
        flash("You have already voted in this election.", "warning")
        return redirect(url_for("view_current_tc_leader"))

    # Get eligible candidates to populate the form and validate submitted candidate
    candidates = get_tc_leader_candidates()
    form = TalentClubLeaderVoteForm(
        candidates=candidates
    )  # Need to pass candidates to validate submitted candidate_id

    if form.validate_on_submit():
        candidate_id = form.candidate_id.data
        # Verify the selected candidate is actually one of the eligible candidates
        candidate = next((c for c in candidates if c.id == candidate_id), None)

        if not candidate:
            flash("Invalid candidate selected.", "danger")
            # Re-render the voting form page with error
            # Need to pass necessary data to re-render the template correctly
            return render_template(
                "talent_club/config_current_leader.html",
                current_leader=None,  # Re-fetch if needed, or pass empty
                active_election=active_election,
                candidates=candidates,
                user_vote=None,
                can_vote=True,
                vote_form=form,  # Pass the form with errors
                title="Current Talent Club Leader",
            )

        try:
            # Create the vote entry
            new_vote = TalentClubLeaderVote(
                election=active_election,
                voter=current_user,
                candidate=candidate,
                voted_at=datetime.now(timezone.utc),
            )
            db.session.add(new_vote)
            db.session.commit()

            flash("Your vote has been cast successfully!", "success")
            app.logger.info(
                f"User {current_user.id} voted for user {candidate.id} in election {active_election.id}."
            )

            # Redirect back to the leader view page
            return redirect(url_for("view_current_tc_leader"))

        except IntegrityError:
            db.session.rollback()
            flash(
                "You have already voted in this election.", "warning"
            )  # Safety net for unique constraint
            app.logger.warning(
                f"IntegrityError casting vote for user {current_user.id} in election {active_election.id}."
            )
            return redirect(url_for("view_current_tc_leader"))
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error user {current_user.id} casting vote in election {active_election.id}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while casting your vote. Please try again.", "danger"
            )
            return redirect(url_for("view_current_tc_leader"))

    # If form validation fails (unlikely with just select field but possible)
    flash("Invalid vote submission.", "danger")
    # Re-render the voting form page with errors
    # Need to pass necessary data to re-render the template correctly
    return render_template(
        "talent_club/config_current_leader.html",
        current_leader=None,
        active_election=active_election,
        candidates=candidates,
        user_vote=None,
        can_vote=True,
        vote_form=form,
        title="Current Talent Club Leader",
    )


# ute for displaying mentioned member invite response page
@app.route("/talent_club/invite/<int:mention_id>")  # GET request
@login_required
@tc_member_required
def view_tc_proposal_mention(mention_id):
    mention = db.get_or_404(
        TalentClubMention, mention_id, description="Proposal mention not found."
    )

    if mention.user_id != current_user.id:
        flash("This invitation is not for you.", "danger")
        return redirect(url_for("view_notifications"))  # Or TC dashboard

    # Eager load related proposal data
    proposal = db.session.scalar(
        select(TalentClubProposal)
        .where(TalentClubProposal.id == mention.proposal_id)
        .options(
            joinedload(TalentClubProposal.creator),
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file),
        )
    )
    if not proposal:  # Should not happen if mention exists
        flash("Associated proposal not found.", "danger")
        return redirect(url_for("view_notifications"))

    return render_template(
        "talent_club/invite_response.html",
        mention=mention,
        proposal=proposal,
        title=f"Invitation: Join '{proposal.name}' Proposal - Nexus TC",
    )


# Endpoint to handle accepting/declining a club proposal mention
@app.route(
    "/talent_club/invite/<int:mention_id>/respond/<string:response_action>",
    methods=["POST"],
)  # Renamed 'response' to 'response_action'
@login_required
@tc_member_required
def respond_tc_proposal_mention(mention_id, response_action):
    mention = db.get_or_404(
        TalentClubMention, mention_id, description="Proposal mention not found."
    )
    proposal = mention.proposal  # Assumes relationship is loaded or accessible

    if mention.user_id != current_user.id:
        flash("This is not your invitation to respond to.", "danger")
        abort(403)

    if response_action not in ["accept", "decline"]:
        flash("Invalid response action.", "danger")
        return redirect(url_for("view_tc_proposal_mention", mention_id=mention.id))

    if mention.status != "pending":
        flash(
            f"You have already responded to this invitation (your response: {mention.status.title()}).",
            "info",
        )
        return redirect(url_for("view_tc_proposal_mention", mention_id=mention.id))

    # Crucially, only allow response if the main proposal is still in a state where responses matter
    if proposal.status != "pending_leader_review":
        flash(
            f"This proposal (Status: {proposal.status.replace('_',' ').title()}) is no longer awaiting member responses.",
            "warning",
        )
        return redirect(url_for("view_tc_proposal_mention", mention_id=mention.id))

    try:
        if response_action == "accept":
            mention.status = "accepted"
        elif response_action == "decline":
            mention.status = "rejected"
        mention.responded_at = datetime.now(timezone.utc)
        db.session.commit()

        app.logger.info(
            f"User {current_user.username} {mention.status} mention ID {mention.id} for proposal '{proposal.name}'."
        )

        # Notify proposal creator
        creator = proposal.creator
        if creator and creator.is_active and creator.id != current_user.id:
            response_text = "accepted" if mention.status == "accepted" else "declined"
            content = f"{current_user.full_name or current_user.username} has {response_text} your invitation to join the '{proposal.name}' club proposal."
            link = url_for(
                "review_tc_proposal", proposal_id=proposal.id, _external=True
            )  # Link for TC Leader, or a creator view of proposal
            # Link for creator could be my_talent_club_proposals or a detail view of their own proposal
            # For now, TC Leader link is fine, creator can see status on their "My Proposals" page.

            notify_tc_member(
                receiver_user=creator,
                sender_user=current_user,
                content=content,
                notification_type="tc_mention_response_to_creator",  # New distinct type
                related_object_id=mention.id,  # Could link to the mention or the proposal
                link_url=link,  # Link to the proposal detail/review page
            )

        flash(
            f"Thank you! You have {mention.status.title()} the invitation for '{proposal.name}'.",
            "success" if mention.status == "accepted" else "info",
        )
        return redirect(url_for("view_notifications"))  # Or back to My Proposals

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error responding to TC mention {mention_id} by {current_user.id}: {e}",
            exc_info=True,
        )
        flash(
            "An error occurred while processing your response. Please try again.",
            "danger",
        )
        return redirect(url_for("view_tc_proposal_mention", mention_id=mention.id))


# Route for viewing submitted proposals (for the creator)
@app.route("/talent_club/my_proposals")
@login_required
@tc_member_required
def my_talent_club_proposals():
    proposals_query = (
        select(TalentClubProposal)
        .where(TalentClubProposal.creator_id == current_user.id)
        .options(
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file),
            joinedload(TalentClubProposal.reviewed_by),  # If displaying reviewer
            # No need to load all mentioned_members here for list view, just count
        )
        .order_by(TalentClubProposal.created_at.desc())
    )
    proposals = db.session.scalars(proposals_query).all()

    accepted_counts = {}
    for p in proposals:
        # Efficiently count accepted mentions for each proposal
        accepted_counts[p.id] = (
            db.session.scalar(
                select(func.count(TalentClubMention.id)).where(
                    TalentClubMention.proposal_id == p.id,
                    TalentClubMention.status == "accepted",
                )
            )
            or 0
        )

    return render_template(
        "talent_club/my_proposals.html",
        proposals=proposals,
        accepted_counts=accepted_counts,
        title="My Club Proposals - Nexus TC",
    )


@app.route(
    "/talent_club/configuration/community"
)  # This is a navigation link from config menu
@login_required
@tc_member_required  # Ensures only TC members can access this path
def talent_club_community_group():
    # get_tc_community_group() helper should be defined (from app.py Part 3 / Phase J)
    # It fetches the single TalentClubCommunity instance.
    community_group = get_tc_community_group()
    if not community_group:
        flash(
            "The Talent Club Community group has not been configured by an administrator yet.",
            "danger",
        )
        app.logger.error(
            "TC Community group not found in DB when navigating from config menu."
        )
        return redirect(url_for("talent_club_configuration"))

    # Ensure current user (who is a TC member due to @tc_member_required) is in the TalentClubCommunityMember table
    # is_tc_community_member() and add_to_tc_community_group() helpers are from app.py Part 3 / Phase J
    if not is_tc_community_member(current_user):
        add_success = add_to_tc_community_group(current_user)
        if not add_success:
            flash(
                "Successfully joined Talent Club, but there was an issue adding you to the TC Community group chat. Please contact an administrator.",
                "warning",
            )
            # Log is in helper
        else:
            flash("You've been added to the Talent Club Community group chat!", "info")

    # All checks passed, redirect to the actual message viewing route
    return redirect(url_for("view_tc_community_messages"))

@app.route(
    "/talent_club/community/messages", methods=["GET"]
)  # POST handled by separate AJAX endpoint
@login_required
@tc_member_required
def view_tc_community_messages():
    community_group = get_tc_community_group()
    if not community_group:
        flash("Talent Club Community group is not available.", "danger")
        return redirect(
            url_for("talent_club_dashboard_member_view")
        )  # Redirect to TC member dashboard

    # Double check membership (should be guaranteed by redirect from /talent_club/configuration/community)
    if not is_tc_community_member(current_user):
        flash("You are not a member of the TC Community group.", "danger")
        app.logger.warning(
            f"User {current_user.id} attempted direct access to TCC messages but not a member."
        )
        return redirect(url_for("talent_club_dashboard_member_view"))

    # Determine if user can post (not muted system-wide in TC)
    # is_currently_banned_muted helper from app.py Part 3 / Phase J
    active_restriction = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == current_user.id,
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc),
            ),
        )
    )
    can_post_in_community = not (
        active_restriction and active_restriction.type == "mute"
    )

    # Fetch initial messages for display
    # Template uses column-reverse, so fetch oldest first if JS will prepend, or newest if template handles display order
    messages_query = (
        select(TalentClubCommunityMessage)  # Your TalentClubCommunityMessage model
        .where(TalentClubCommunityMessage.community_id == community_group.id)
        .options(
            joinedload(TalentClubCommunityMessage.author).joinedload(User.role),
            joinedload(TalentClubCommunityMessage.file),
        )
        .order_by(
            TalentClubCommunityMessage.timestamp.asc()
        )  # Oldest first for chat-like display
        .limit(50)  # Initial batch
    )
    messages = db.session.scalars(messages_query).all()

    post_form = PostContentForm()  # For message input (reusing from social features)

    return render_template(
        "talent_club/community_group.html",
        community_group=community_group,
        messages=messages,
        form=post_form,
        can_post_in_community=can_post_in_community,
        title=f"{community_group.name} - Nexus TC",
    )

# In app.py, add these new routes and update the mismatched ones.


# FIX: New route to handle dynamic content loading on the club profile page.
@app.route("/talent_club/<int:club_id>/content/<string:content_type>")
@login_required
@tc_member_required
def get_talent_club_content(club_id, content_type):
    """
    AJAX endpoint to fetch and render a list of content posts for a specific club by type.
    This powers the "Media", "Files", and "Texts" tabs on club_profile.html.
    """
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active or not club.feed:
        return (
            "<div class='text-center p-3 text-muted'>Club or its feed is not available.</div>",
            404,
        )

    valid_types = ["media", "files", "texts", "all"]
    if content_type not in valid_types:
        return (
            "<div class='text-center p-3 text-danger'>Invalid content type requested.</div>",
            400,
        )

    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role),
            joinedload(TalentClubFeedPost.file),
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )

    if content_type == "media":
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(File.mimetype.like("image/%"))
        )
    elif content_type == "files":
        posts_query = posts_query.where(
            TalentClubFeedPost.file_id.isnot(None),
            ~TalentClubFeedPost.file.has(File.mimetype.like("image/%")),
        )
    elif content_type == "texts":
        posts_query = posts_query.where(
            TalentClubFeedPost.file_id.is_(None), TalentClubFeedPost.content.isnot(None)
        )

    # Add pagination if you expect large numbers of posts
    posts = db.session.scalars(posts_query.limit(50)).all()

    # Render a partial template that lists these posts
    return render_template(
        "partials/talent_club/_content_list.html", posts=posts, club=club
    )


# FIX: Updated leaderboard route to calculate and pass a 'points' metric.
@app.route("/talent_club/leaderboard")
@login_required
@tc_member_required
@cache.cached(timeout=600)  # Cache for 10 minutes
def talent_club_leaderboard():
    leaderboard_clubs_raw = db.session.scalars(
        select(TalentClub)
        .where(TalentClub.is_active == True)
        .options(
            joinedload(TalentClub.owner),
            joinedload(TalentClub.social_category),
            joinedload(TalentClub.memberships),
            joinedload(TalentClub.follows),
        )
    ).all()

    # Calculate points for each club and attach as a temporary attribute
    for club in leaderboard_clubs_raw:
        member_count = len([m for m in club.memberships if m.is_active])
        follower_count = len(club.follows)
        # Example points calculation: Level is most important, then engagement, then penalties.
        club.points = (
            (club.level * 100)
            + (member_count * 2)
            + follower_count
            - (club.warning_count * 10)
        )

    # Sort clubs by the calculated points
    leaderboard_clubs_sorted = sorted(
        leaderboard_clubs_raw, key=lambda c: c.points, reverse=True
    )

    return render_template(
        "talent_club/leaderboard.html",
        leaderboard_clubs=leaderboard_clubs_sorted,
        title="Talent Club Leaderboard",
    )


# FIX: Reconciled route for the mismatched `config_my_clubs.html` template.
# The template was about notification preferences, but the backend provided club management data.
# This fix aligns the route and template to be about CLUB MANAGEMENT.
# In app.py, ensure this route exists and is correct.


@app.route("/talent_club/configuration/my_club_management")
@login_required
@tc_member_required
def my_talent_club_management():
    # Clubs where the user is a manager (creator or admin)
    my_manager_memberships = db.session.scalars(
        select(TalentClubMembership)
        .join(TalentClub)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
            TalentClubMembership.role.in_(["creator", "admin"]),
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category)
        )
        .order_by(TalentClub.name.asc())
    ).all()

    # Clubs where the user is just a member
    my_member_memberships = db.session.scalars(
        select(TalentClubMembership)
        .join(TalentClub)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
            TalentClubMembership.role == "member",
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category)
        )
        .order_by(TalentClub.name.asc())
    ).all()

    # The template is now aligned with these context variables.
    return render_template(
        "talent_club/config_my_clubs.html",
        my_manager_memberships=my_manager_memberships,
        my_member_memberships=my_member_memberships,
        title="My Club Involvement",
    )


def tc_leader_required(f):
    """Decorator to restrict access to routes to the system-wide Talent Club Leader."""

    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check if the user is the system-wide TC Leader
        if not current_user.is_tc_leader:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC Leader restricted route {request.path} but is not the leader."
            )
            flash("You must be the Talent Club Leader to access this page.", "danger")
            # Redirect them back to the main TC dashboard
            return redirect(url_for("talent_club_dashboard"))

        return f(*args, **kwargs)

    return decorated_function

# In app.py, add this to the Talent Club Features section
  
# In app.py, add this right after the tc_member_required decorator definition

def tc_leader_required(f):
    """Decorator to restrict access to routes to the system-wide Talent Club Leader."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check the user's 'is_tc_leader' flag
        if not hasattr(current_user, 'is_tc_leader') or not current_user.is_tc_leader:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC Leader restricted route {request.path} but is not the leader."
            )
            flash("You must be the Talent Club Leader to access this page.", "danger")
            # Redirect to the main TC dashboard for regular members, or another appropriate page
            return redirect(url_for('talent_club_dashboard_member_view'))

        return f(*args, **kwargs)
    return decorated_function

# Route to view pending proposals for the TC Leader
@app.route("/talent_club/leader/proposals")
@login_required
@tc_leader_required  # Custom decorator for system-wide TC Leader
def review_tc_proposals():
    pending_proposals_query = (
        select(TalentClubProposal)
        .where(TalentClubProposal.status == "pending_leader_review")
        .options(
            joinedload(TalentClubProposal.creator),
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file),  # For viewing document
            # mentioned_members are loaded per proposal below for counts and details
        )
        .order_by(TalentClubProposal.created_at.asc())  # Oldest first
    )
    pending_proposals = db.session.scalars(pending_proposals_query).all()

    proposal_mentions_details = {}  # To store list of mention objects per proposal
    accepted_mention_counts = {}  # To store count of accepted mentions per proposal

    for proposal in pending_proposals:
        mentions_for_proposal = db.session.scalars(
            select(TalentClubMention)
            .where(TalentClubMention.proposal_id == proposal.id)
            .options(
                joinedload(TalentClubMention.user).joinedload(User.role)
            )  # Load user and their role
        ).all()
        proposal_mentions_details[proposal.id] = mentions_for_proposal

        accepted_mention_counts[proposal.id] = sum(
            1
            for m in mentions_for_proposal
            if m.status == "accepted" and m.user_id != proposal.creator_id
        )

    return render_template(
        "talent_club/leader/review_proposals.html",
        pending_proposals=pending_proposals,
        proposal_mentions=proposal_mentions_details,  # Pass the actual mention objects
        accepted_counts=accepted_mention_counts,  # Pass the calculated counts
        title="Review Club Proposals - TC Leader Admin - Nexus TC",
    )


@app.route(
    "/talent_club/leader/proposals/<int:proposal_id>/review", methods=["GET", "POST"]
)
@login_required
@tc_leader_required
def review_tc_proposal(proposal_id):
    proposal = db.get_or_404(
        TalentClubProposal, proposal_id, description="Proposal not found."
    )

    if proposal.status != "pending_leader_review":
        flash(
            f"This proposal (Status: {proposal.status.replace('_',' ').title()}) is no longer awaiting leader review.",
            "info",
        )
        return redirect(url_for("review_tc_proposals"))

    mentions = db.session.scalars(
        select(TalentClubMention)
        .where(TalentClubMention.proposal_id == proposal.id)
        .options(joinedload(TalentClubMention.user).joinedload(User.role))
    ).all()

    accepted_count = sum(
        1
        for m in mentions
        if m.status == "accepted" and m.user_id != proposal.creator_id
    )
    MIN_REQUIRED_ACCEPTED_FOR_CLUB = 5  # Define your constant
    meets_min_members = accepted_count >= MIN_REQUIRED_ACCEPTED_FOR_CLUB

    if request.method == "POST":
        action = request.form.get("action")
        review_notes = request.form.get("review_notes", "").strip()

        if action not in ["accept", "reject", "save_notes"]:
            flash("Invalid review action specified.", "danger")
            # Re-render with current data
            return render_template(
                "talent_club/leader/review_proposal_detail.html",
                proposal=proposal,
                mentions=mentions,
                accepted_count=accepted_count,
                meets_min_members=meets_min_members,
                title=f"Review: {proposal.name} - Nexus TC",
            )

        try:
            proposal.leader_review_notes = (
                review_notes if review_notes else proposal.leader_review_notes
            )
            proposal.reviewed_by_id = current_user.id
            proposal.reviewed_at = datetime.now(timezone.utc)

            if action == "accept":
                if not meets_min_members:
                    flash(
                        f"Cannot accept: Proposal needs at least {MIN_REQUIRED_ACCEPTED_FOR_CLUB} accepted mentions (has {accepted_count}).",
                        "danger",
                    )
                else:
                    proposal.status = "accepted"
                    # --- Create TalentClub, Feed, Memberships ---
                    new_club = TalentClub(
                        name=proposal.name,
                        description=proposal.description,
                        # profile_photo_url set later via edit club profile
                        owner_id=proposal.creator_id,
                        social_category_id=proposal.social_category_id,
                        level=1,  # Default start level
                        is_active=True,
                        created_at=datetime.now(timezone.utc),
                    )
                    db.session.add(new_club)
                    db.session.flush()  # Get new_club.id

                    new_feed = TalentClubFeed(
                        talent_club_id=new_club.id
                    )  # Create linked feed
                    db.session.add(new_feed)

                    # Add creator as 'creator' role member
                    creator_membership = TalentClubMembership(
                        club_id=new_club.id, user_id=proposal.creator_id, role="creator"
                    )
                    db.session.add(creator_membership)

                    # Add accepted mentioned members as 'member' role
                    for mention in mentions:
                        if (
                            mention.status == "accepted"
                            and mention.user_id != proposal.creator_id
                        ):
                            member_membership = TalentClubMembership(
                                club_id=new_club.id,
                                user_id=mention.user_id,
                                role="member",
                            )
                            db.session.add(member_membership)

                    db.session.commit()  # Commit proposal, new club, feed, memberships
                    app.logger.info(
                        f"TC Proposal {proposal.id} accepted by {current_user.username}. New Club ID: {new_club.id}"
                    )
                    flash(
                        f"Proposal '{proposal.name}' accepted and Talent Club created!",
                        "success",
                    )

                    # --- Notifications for Acceptance ---
                    # 1. To Creator
                    notify_tc_member(
                        proposal.creator,
                        current_user,
                        f"Your club proposal '{new_club.name}' has been APPROVED and the club is now active!",
                        "tc_proposal_approved_creator",
                        new_club.id,
                        url_for(
                            "view_talent_club_feed", club_id=new_club.id, _external=True
                        ),
                    )
                    # 2. To Accepted Members
                    for mention in mentions:
                        if (
                            mention.status == "accepted"
                            and mention.user_id != proposal.creator_id
                        ):
                            notify_tc_member(
                                mention.user,
                                current_user,
                                f"The proposal for '{new_club.name}' (which you accepted) has been approved! You are now a member.",
                                "tc_club_membership_granted",
                                new_club.id,
                                url_for(
                                    "view_talent_club_feed",
                                    club_id=new_club.id,
                                    _external=True,
                                ),
                            )
                    return redirect(url_for("review_tc_proposals"))

            elif action == "reject":
                proposal.status = "rejected"
                db.session.commit()
                app.logger.info(
                    f"TC Proposal {proposal.id} rejected by {current_user.username}."
                )
                flash(f"Proposal '{proposal.name}' has been rejected.", "info")

                # --- Notifications for Rejection ---
                # 1. To Creator
                notes_info = (
                    f" Reviewer notes: {proposal.leader_review_notes[:100]}..."
                    if proposal.leader_review_notes
                    else ""
                )
                notify_tc_member(
                    proposal.creator,
                    current_user,
                    f"Your club proposal '{proposal.name}' has been REJECTED.{notes_info}",
                    "tc_proposal_rejected_creator",
                    proposal.id,
                    url_for("my_talent_club_proposals", _external=True),
                )  # Link to their proposals list
                # 2. To Mentioned Members (who had accepted/pending)
                for mention in mentions:
                    if (
                        mention.status in ["accepted", "pending"]
                        and mention.user_id != proposal.creator_id
                    ):
                        notify_tc_member(
                            mention.user,
                            current_user,
                            f"The club proposal '{proposal.name}' (that you were mentioned in) has been rejected by the TC Leader.",
                            "tc_proposal_rejected_mention",
                            proposal.id,
                            url_for("view_notifications", _external=True),
                        )  # Generic link
                return redirect(url_for("review_tc_proposals"))

            elif action == "save_notes":
                db.session.commit()
                flash("Review notes saved for this proposal.", "success")
                # Stay on the same page to continue review
                return redirect(url_for("review_tc_proposal", proposal_id=proposal.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error processing TC proposal {proposal.id} action '{action}' by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An unexpected error occurred while processing the proposal.", "danger"
            )

    # For GET request
    return render_template(
        "talent_club/leader/review_proposal_detail.html",
        proposal=proposal,
        mentions=mentions,
        accepted_count=accepted_count,
        meets_min_members=meets_min_members,
        title=f"Review Proposal: {proposal.name} - Nexus TC",
    )


@app.route("/talent_club/leader/club/<int:club_id>/set_level", methods=["POST"])
@login_required
@tc_leader_required
def set_talent_club_level_action(
    club_id,
):  # Renamed to avoid conflict if a GET view existed
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        flash("Cannot change level of an inactive club.", "warning")
        return redirect(url_for("manage_talent_clubs_leader"))

    form = TalentClubLevelForm(request.form)  # Bind form to request data for validation

    if form.validate_on_submit():  # WTForms validation
        new_level = form.level.data
        old_level = club.level

        # Optional: Further validation if TALENT_CLUB_LEVELS is a list of allowed values
        # if new_level not in [lvl[1] if isinstance(lvl, tuple) else lvl for lvl in TALENT_CLUB_LEVELS]:
        #     flash("Invalid level selected.", "danger")
        #     return redirect(url_for("manage_talent_clubs_leader"))

        try:
            club.level = new_level
            db.session.commit()
            app.logger.info(
                f"TC Leader {current_user.username} set level of club {club.id} from {old_level} to {new_level}."
            )
            flash(
                f"Level for club '{club.name}' successfully updated to {new_level}.",
                "success",
            )

            # --- Notification for Level Change ---
            # (Similar notification logic as in your original app.py Part X for set_talent_club_level)
            # Query members and followers who want notifications.
            # Send notification with notify_tc_member(...)
            # Example:
            # users_to_notify = get_club_members_and_followers_for_notification(club) # A helper you'd create
            # for user_to_notify in users_to_notify:
            #    notify_tc_member(user_to_notify, current_user, f"Club '{club.name}' level changed to {new_level}.", 'tc_level_change', club.id, url_for('view_talent_club_profile', club_id=club.id, _external=True))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error setting level for club {club.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash("An error occurred while updating the club level.", "danger")
    else:
        # Form validation failed
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(form, field).label.text}: {error}", "danger")

    return redirect(url_for("manage_talent_clubs_leader"))


@app.route("/talent_club/leader/club/<int:club_id>/set_level", methods=["POST"])
@login_required
@tc_leader_required
def set_talent_club_level(club_id):
    """Allows the TC Leader to set the level of a Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
        flash("Cannot change level of an inactive club.", "warning")
        return redirect(request.referrer or url_for("manage_talent_clubs_leader"))

    form = TalentClubLevelForm()  # Use the level form

    if form.validate_on_submit():
        new_level = form.level.data

        # Optional validation: Ensure level is within a valid range if you have a max level
        # if new_level not in TALENT_CLUB_LEVELS and isinstance(TALENT_CLUB_LEVELS[0], int): # Check if using integer levels
        #      flash("Invalid level provided.", "danger")
        #      # Need to re-render the management page or handle AJAX error
        #      return redirect(request.referrer or url_for("manage_talent_clubs_leader")) # Redirect for simplicity

        old_level = club.level

        try:
            club.level = new_level
            db.session.commit()

            # --- Notification ---
            # Notify club members and followers (who want notifications) about level change
            members_and_followers = db.session.scalars(
                select(User)
                .join(
                    TalentClubMembership,
                    and_(
                        TalentClubMembership.talent_club_id == club.id,
                        TalentClubMembership.is_active == True,
                    ),
                    isouter=True,
                )  # Outer join for members
                .join(
                    TalentClubFollow,
                    TalentClubFollow.talent_club_id == club.id,
                    isouter=True,
                )  # Outer join for follows
                .where(
                    or_(
                        TalentClubMembership.user_id == User.id,
                        TalentClubFollow.user_id == User.id,
                    )
                )  # User is in either membership or follow
                .distinct()  # Ensure distinct users
                .where(
                    User.is_active == True, User.id != current_user.id
                )  # Only active, not the leader
            ).all()

            if members_and_followers:
                notification_content = f"Talent Club '{club.name}' level changed from {old_level} to {new_level}."
                link_url = url_for("view_talent_club_profile", club_id=club.id)

                notifications_to_add = []
                for user in members_and_followers:
                    # Only notify followers if their setting is True
                    if user.is_tc_member or (
                        user.tc_follows.filter_by(
                            club=club, receive_notifications=True
                        ).first()
                        is not None
                    ):  # Notify members, or followers with notifications on
                        try:
                            notify = Notification(
                                sender_id=current_user.id,
                                receiver_id=user.id,
                                content=notification_content,
                                link_url=link_url,
                                timestamp=datetime.now(timezone.utc),
                                is_read=False,
                                notification_type="tc_level_change",  # Specific type
                                related_object_id=club.id,
                            )
                            notifications_to_add.append(notify)
                        except Exception as notify_e:
                            app.logger.error(
                                f"Error creating TC level change notification for user {user.id}: {notify_e}"
                            )

                if notifications_to_add:
                    db.session.add_all(notifications_to_add)
                    db.session.commit()
                    app.logger.info(
                        f"Notified {len(notifications_to_add)} users about level change for club {club.id}."
                    )

            flash(f"Level for club '{club.name}' set to {new_level}.", "success")
            app.logger.info(
                f"TC Leader {current_user.id} set level of club {club.id} to {new_level}."
            )

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error TC Leader {current_user.id} setting level for club {club.id}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while setting the club level. Please try again.",
                "danger",
            )

    else:
        # If form validation failed (e.g., non-integer level)
        flash("Invalid level submitted.", "danger")

    # Redirect back to club management page
    return redirect(request.referrer or url_for("manage_talent_clubs_leader"))


@app.route("/talent_club/leader/club/<int:club_id>/warn", methods=["POST"])
@login_required
@tc_leader_required
def warn_talent_club_action(club_id):  # Renamed
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        flash("Cannot issue a warning to an inactive club.", "warning")
        return redirect(url_for("manage_talent_clubs_leader"))

    form = TalentClubWarningForm(request.form)  # Bind to request data

    if form.validate_on_submit():
        try:
            reason = form.reason.data.strip()
            new_warning = TalentClubWarning(
                talent_club_id=club.id,
                issued_by_id=current_user.id,
                reason=reason,
                issued_at=datetime.now(timezone.utc),
            )
            db.session.add(new_warning)
            club.warning_count += 1

            club_deactivated_due_to_warnings = False
            if club.level == 1 and club.warning_count >= 3:
                club.is_active = False  # Soft delete
                club_deactivated_due_to_warnings = True
                app.logger.warning(
                    f"TC Club {club.id} ('{club.name}') deactivated due to reaching 3 warnings at Level 1."
                )

            db.session.commit()

            flash_message = f"Warning issued to club '{club.name}'. Reason: {reason}. Warning count is now {club.warning_count}."
            if club_deactivated_due_to_warnings:
                flash_message += " The club has been deactivated due to exceeding warnings at Level 1."
            flash(
                flash_message,
                "success" if not club_deactivated_due_to_warnings else "danger",
            )
            app.logger.info(
                f"TC Leader {current_user.username} issued warning to club {club.id}. Reason: {reason}. Count: {club.warning_count}."
            )

            # --- Notifications for Warning & Potential Deactivation ---
            # (Similar to your original app.py Part X for warn_talent_club)
            # Notify club owner, members, followers about the warning.
            # If club deactivated, send a specific "club_destroyed" notification.

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error issuing warning to club {club.id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash("An error occurred while issuing the warning.", "danger")
    else:
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(form, field).label.text}: {error}", "danger")

    return redirect(url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/member/<int:user_id>/ban_mute", methods=["GET", "POST"])
@login_required
@tc_leader_required
def ban_mute_tc_member(user_id):
    user_to_manage = db.get_or_404(User, user_id, description="User not found.")

    if not user_to_manage.is_tc_member:  # Can only ban/mute current TC members
        flash(
            f"{user_to_manage.full_name or user_to_manage.username} is not currently a Talent Club member.",
            "warning",
        )
        return redirect(url_for("manage_tc_members_leader"))
    if user_to_manage.id == current_user.id:
        flash("You cannot ban or mute yourself.", "danger")
        return redirect(url_for("manage_tc_members_leader"))

    # Fetch current active ban/mute, if any
    active_ban_object = db.session.scalar(
        select(TalentClubBan)
        .where(
            TalentClubBan.user_id == user_to_manage.id,
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc),
            ),
        )
        .limit(1)
    )

    form = TalentClubBanMuteForm()  # Your form definition

    if form.validate_on_submit():
        ban_type_from_form = form.ban_type.data
        reason_from_form = form.reason.data.strip()
        duration_days_from_form = form.duration_days.data  # Integer or None

        if (
            ban_type_from_form not in TALENT_CLUB_BAN_TYPES
        ):  # TALENT_CLUB_BAN_TYPES from app.py config
            flash("Invalid action type selected.", "danger")
        else:
            try:
                # End any existing active ban/mute for this user before applying a new one
                if active_ban_object:
                    active_ban_object.expires_at = datetime.now(
                        timezone.utc
                    ) - timedelta(
                        seconds=1
                    )  # Expire immediately
                    db.session.add(active_ban_object)  # Add to session for commit
                    app.logger.info(
                        f"Expiring previous ban/mute ID {active_ban_object.id} for user {user_to_manage.id} before applying new one."
                    )

                expires_at_val = None
                if duration_days_from_form is not None and duration_days_from_form > 0:
                    expires_at_val = datetime.now(timezone.utc) + timedelta(
                        days=duration_days_from_form
                    )

                new_ban_entry = TalentClubBan(
                    user_id=user_to_manage.id,
                    issued_by_id=current_user.id,
                    type=ban_type_from_form,
                    reason=reason_from_form,
                    issued_at=datetime.now(timezone.utc),
                    expires_at=expires_at_val,
                )
                db.session.add(new_ban_entry)

                # Apply side-effects of 'ban'
                if ban_type_from_form == "ban":
                    user_to_manage.is_tc_member = False  # Revoke TC membership
                    # Remove from TC Community Group
                    community_group = get_tc_community_group()
                    if community_group:
                        community_member_entry = db.session.scalar(
                            select(TalentClubCommunityMember).filter_by(
                                community_id=community_group.id,
                                user_id=user_to_manage.id,
                            )
                        )
                        if community_member_entry:
                            db.session.delete(community_member_entry)
                    # Deactivate/remove from all specific club memberships
                    db.session.query(TalentClubMembership).filter_by(
                        user_id=user_to_manage.id
                    ).update({"is_active": False})
                    # Remove all club follows
                    db.session.query(TalentClubFollow).filter_by(
                        user_id=user_to_manage.id
                    ).delete()
                    if user_to_manage.is_tc_leader:  # If they were the system leader
                        user_to_manage.is_tc_leader = False
                        app.logger.warning(
                            f"System TC Leader {user_to_manage.username} was banned and demoted."
                        )
                        # TODO: Notify HR/CEO about this auto-demotion

                db.session.commit()
                flash(
                    f"{user_to_manage.full_name or user_to_manage.username} has been successfully {ban_type_from_form}ned.",
                    "success",
                )
                app.logger.info(
                    f"TC Leader {current_user.username} {ban_type_from_form}ned user {user_to_manage.id}. Reason: {reason_from_form}."
                )

                # --- Notification to the affected user ---
                notif_content = f"You have received a Talent Club system {ban_type_from_form}. Reason: {reason_from_form[:100]}..."
                if expires_at_val:
                    notif_content += (
                        f" Expires: {expires_at_val.strftime('%Y-%m-%d %H:%M')}."
                    )
                if user_to_manage.is_active:  # Only notify if user account is active
                    notify_tc_member(
                        user_to_manage,
                        current_user,
                        notif_content,
                        f"tc_system_{ban_type_from_form}",
                        new_ban_entry.id,
                        None,
                    )

                return redirect(url_for("manage_tc_members_leader"))
            except Exception as e:
                db.session.rollback()
                app.logger.error(
                    f"Error applying {ban_type_from_form} to user {user_id} by {current_user.username}: {e}",
                    exc_info=True,
                )
                flash(
                    f"An error occurred. Could not apply {ban_type_from_form}.",
                    "danger",
                )

    # For GET request or if form validation failed
    return render_template(
        "talent_club/leader/ban_mute_member.html",
        user_to_manage=user_to_manage,
        active_ban=active_ban_object,  # Pass current ban object
        form=form,
        title=f"Apply Restriction to {user_to_manage.full_name or user_to_manage.username} - Nexus TC",
    )


@app.route("/talent_club/api/community/<int:community_group_id>/messages/new")
@login_required
@tc_member_required
def ajax_get_new_tc_community_messages(community_group_id):
    # Verify community_group_id matches the single global one, or adapt if multiple could exist
    community_group = get_tc_community_group()
    if not community_group or community_group.id != community_group_id:
        return jsonify({"error": "Invalid community group."}), 404

    if not is_tc_community_member(current_user):  # Should be covered by decorator
        return jsonify({"error": "Not a member."}), 403

    since_ms_str = request.args.get("since")
    if not since_ms_str:
        return jsonify({"error": "Missing 'since' timestamp."}), 400

    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp(
            (since_ms / 1000.0) + 0.001, tz=timezone.utc
        )
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid timestamp format."}), 400

    new_messages_query = (
        select(TalentClubCommunityMessage)
        .where(
            TalentClubCommunityMessage.community_id == community_group.id,
            TalentClubCommunityMessage.timestamp > since_time,
            TalentClubCommunityMessage.author_id
            != current_user.id,  # Don't poll own messages back immediately
        )
        .options(
            joinedload(TalentClubCommunityMessage.author).joinedload(User.role),
            joinedload(TalentClubCommunityMessage.file),
        )
        .order_by(TalentClubCommunityMessage.timestamp.asc())
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data_for_client = []
    latest_ts_in_batch = since_ms
    for msg in new_messages_list:
        messages_data_for_client.append(
            {
                "id": msg.id,
                "sender_id": msg.author_id,
                "sender": {
                    "full_name": msg.author.full_name if msg.author else "N/A",
                    "username": msg.author.username if msg.author else "N/A",
                    "profile_photo_url": (
                        msg.author.profile_photo_url if msg.author else None
                    ),
                },
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat() + "Z",
                "file": (
                    {
                        "id": msg.file.id,
                        "original_filename": msg.file.original_filename,
                        "mimetype": msg.file.mimetype,
                        "size": msg.file.size,
                        "download_url": url_for(
                            "download_social_file", file_id=msg.file.id
                        ),
                    }
                    if msg.file
                    else None
                ),
            }
        )
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms

    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(
        latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0
    )

    return (
        jsonify(
            {
                "messages": messages_data_for_client,
                "latest_timestamp": final_latest_timestamp,
            }
        ),
        200,
    )

# In app.py, ADD these new routes.

@app.route("/mini-app")
@login_required
def mini_app_placeholder():
    """Renders the placeholder page for the new mini-app."""
    return render_template("mini_app.html", title="Mini App")

@app.route("/about-us")
def about_us_page():
    """Renders the About Us page."""
    # This page can be public, so no @login_required
    return render_template("about_us.html", title="About Nexus")

@app.route("/terms-and-conditions")
def terms_conditions_page():
    """Renders the Terms & Conditions page."""
    # This page can also be public
    return render_template("terms_and_conditions.html", title="Terms & Conditions")

@app.route("/talent_club/community/create_message", methods=["POST"])
@login_required
@tc_member_required
def create_tc_community_message():
    community_group = get_tc_community_group()
    if not community_group:
        return (
            jsonify({"success": False, "error": "TC Community group not available."}),
            404,
        )

    if not is_tc_community_member(
        current_user
    ):  # Redundant due to @tc_member_required but good check
        return (
            jsonify({"success": False, "error": "Not a member of TC Community."}),
            403,
        )

    # Check if muted
    active_restriction = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == current_user.id,
            TalentClubBan.type == "mute",  # Specifically check for mute
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc),
            ),
        )
    )
    if active_restriction:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "You are currently muted in the Talent Club.",
                }
            ),
            403,
        )

    form = PostContentForm(request.form)
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Message content or a file must be provided.",
                }
            ),
            400,
        )
    if form.content.data and not form.content.validate(form):
        return (
            jsonify(
                {
                    "success": False,
                    "error": (
                        form.content.errors[0]
                        if form.content.errors
                        else "Invalid content."
                    ),
                }
            ),
            400,
        )

    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage)
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed."}), 400
        except Exception as e:
            return jsonify({"success": False, "error": "Error processing file."}), 500

    try:
        new_message = TalentClubCommunityMessage(
            community_id=community_group.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc),
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_message)
        db.session.commit()

        app.logger.info(
            f"User {current_user.username} sent TCC Message ID {new_message.id}."
        )

        # Prepare data for client-side rendering via _chat_message_item.html
        message_data_for_client = {
            "id": new_message.id,
            "sender_id": new_message.author_id,
            "sender": {
                "full_name": current_user.full_name,
                "username": current_user.username,
                "profile_photo_url": current_user.profile_photo_url,
            },
            "content": new_message.content,
            "timestamp": new_message.timestamp.isoformat() + "Z",
            "file": (
                {  # Adapt based on how _chat_message_item handles files or if a different partial is used
                    "id": uploaded_file_obj.id,
                    "original_filename": uploaded_file_obj.original_filename,
                    "mimetype": uploaded_file_obj.mimetype,
                    "size": uploaded_file_obj.size,
                    "download_url": url_for(
                        "download_social_file", file_id=uploaded_file_obj.id
                    ),
                }
                if uploaded_file_obj
                else None
            ),
        }
        # Or server-render HTML:
        # msg_for_render = db.session.query(TalentClubCommunityMessage).options(...).get(new_message.id)
        # post_html = render_template("partials/_chat_message_item.html", message=msg_for_render, current_user_id=current_user.id)

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Message sent!",
                    "post_data": message_data_for_client,
                }
            ),
            201,
        )
    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath:  # Cleanup
            try:
                os.remove(
                    os.path.join(current_app.static_folder, uploaded_file_obj.filepath)
                )
            except:
                pass
        app.logger.error(
            f"Error creating TCC message by {current_user.username}: {e}", exc_info=True
        )
        return (
            jsonify({"success": False, "error": "Server error sending message."}),
            500,
        )
        
# --- Weather Routes ---

@app.route("/weather")
@login_required
def weather_dashboard():
    """Renders the main weather dashboard page."""
    user_home_city = None
    if current_user.is_authenticated and hasattr(current_user, 'home_city') and current_user.home_city:
        user_home_city = current_user.home_city
    return render_template("weather/weather.html", title="Weather Dashboard", user_home_city=user_home_city)

@app.route("/weather/api/get_data", methods=["POST"])
@login_required
@cache.cached(timeout=600, key_prefix='weather_data', query_string=True)
def get_weather_data():
    """API endpoint to fetch weather and air quality data. This is cached."""
    try:
        data = request.get_json()
        city = data.get("city")
        latitude = data.get("latitude")
        longitude = data.get("longitude")
        
        if not city and not (latitude and longitude) and current_user.is_authenticated and hasattr(current_user, 'home_city'):
             city = current_user.home_city

        if not city and not (latitude and longitude):
            return jsonify({"error": "City name or coordinates are required."}), 400

        if city:
            geo_params = {"name": city, "count": 1}
            geo_response = requests.get(WEATHER_GEOCODING_URL, params=geo_params)
            geo_response.raise_for_status()
            geo_data = geo_response.json()
            if not geo_data.get("results"):
                return jsonify({"error": "Location not found"}), 404
            latitude = geo_data["results"][0]["latitude"]
            longitude = geo_data["results"][0]["longitude"]
            location_name = geo_data["results"][0].get("name", city)
        else:
            latitude = float(latitude)
            longitude = float(longitude)
            location_name = f"Coords: {latitude:.2f}, {longitude:.2f}"

        # Weather API Call
        weather_params = {
            "latitude": latitude, "longitude": longitude,
            "current": "temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation_probability,weather_code,wind_speed_10m",
            "hourly": "temperature_2m,weather_code,is_day",
            "daily": "weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,uv_index_max",
            "timezone": "auto", "forecast_days": 5
        }
        weather_response = requests.get(WEATHER_BASE_URL, params=weather_params)
        weather_response.raise_for_status()
        weather_data = weather_response.json()

        # Air Quality API Call
        air_quality_params = {
            "latitude": latitude, "longitude": longitude,
            "current": "us_aqi,pm2_5"
        }
        air_quality_response = requests.get(WEATHER_AIR_QUALITY_URL, params=air_quality_params)
        air_quality_response.raise_for_status()
        air_quality_data = air_quality_response.json()
        
        processed = process_weather_data(weather_data, air_quality_data, location_name)
        return jsonify(processed)
        
    except requests.exceptions.RequestException as e:
        current_app.logger.error(f"Weather API request failed: {e}", exc_info=True)
        return jsonify({"error": "Could not connect to the weather service."}), 503
    except Exception as e:
        current_app.logger.error(f"Weather API processing error: {e}", exc_info=True)
        return jsonify({"error": "An internal server error occurred."}), 500

@app.route('/weather/api/save_location', methods=['POST'])
@login_required
def save_weather_location():
    """API endpoint for users to save their default location."""
    data = request.get_json()
    city = data.get('city')

    if not city:
        return jsonify({"error": "City name is required."}), 400
    
    try:
        # We need the User model and db object, which are already available in app.py
        user = db.session.get(User, current_user.id)
        user.home_city = city
        db.session.commit()
        current_app.logger.info(f"User {user.username} saved home city: {city}")
        return jsonify({"success": True, "message": f"Default location saved as {city}."})
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error saving user location for {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to save location."}), 500

# In app.py
@app.route("/debug/teacher/<int:user_id>")
def debug_teacher_profiles(user_id):
    """A temporary route to directly inspect a teacher's profiles from the DB."""
    teacher = db.session.get(User, user_id)
    if not teacher or teacher.role.name != 'teacher':
        return f"<h1>Error: User with ID {user_id} not found or is not a teacher.</h1>"

    # Directly query the TeacherProfile table for this user ID
    profiles = db.session.scalars(
        select(TeacherProfile).where(TeacherProfile.user_id == user_id)
    ).all()
    
    output = f"<h1>Debugging Teacher: {teacher.username} (ID: {teacher.id})</h1>"
    
    if not profiles:
        output += "<h2>No TeacherProfile records found for this user in the database.</h2>"
        return output

    output += f"<h2>Found {len(profiles)} profile(s):</h2>"
    output += "<table border='1' cellpadding='5'><tr><th>ID</th><th>Subject</th><th>Grade</th><th>Section</th></tr>"
    for profile in profiles:
        output += f"<tr><td>{profile.id}</td><td>{profile.subject}</td><td>{profile.grade}</td><td>{profile.section}</td></tr>"
    output += "</table>"
    
    return output

# In app.py, add this to PART 3 (Core Helpers) with other notification helpers

def notify_asset_approved(asset):
    """Notifies the user who added an asset that it has been approved."""
    if not asset or not asset.added_by_user:
        return # Cannot notify if asset or its creator is missing

    sender = current_user
    receiver = asset.added_by_user

    if not receiver.is_active or receiver.id == sender.id:
        return # Don't notify inactive users or if approver is the creator

    if is_notification_allowed(sender, receiver):
        try:
            message_content = f"Your submitted asset '{asset.name}' has been approved and is now available in the system."
            link_url = url_for("my_assets", _external=True) # Link to their list of added assets

            notification = Notification(
                sender_id=sender.id,
                receiver_id=receiver.id,
                content=message_content,
                link_url=link_url,
                timestamp=datetime.now(timezone.utc),
                notification_type="asset_approved"
            )
            db.session.add(notification)
            db.session.commit()
            app.logger.info(f"Sent 'asset_approved' notification to user {receiver.id} for asset {asset.id}.")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error sending asset approval notification for asset {asset.id}: {e}", exc_info=True)

# In app.py, add this to PART 8 (HR/CEO & System Admin Management Features)

@app.route("/assets/<int:asset_id>/approve", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def approve_asset(asset_id):
    """
    Handles the 'Quick Approve' action for a pending asset.
    Changes status from 'Pending Review' to 'Available'.
    """
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")

    if asset.status != "Pending Review":
        flash(f"This asset ('{asset.name}') is not currently pending review.", "warning")
        return redirect(url_for("list_pending_assets"))

    try:
        asset.status = "Available"
        db.session.commit()

        # Notify the user who originally added the asset
        notify_asset_approved(asset) # We will create this helper next

        flash(f"Asset '{asset.name}' has been approved and is now available.", "success")
        app.logger.info(f"User {current_user.username} quick-approved asset ID {asset.id}.")

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error quick-approving asset ID {asset.id} by {current_user.username}: {e}", exc_info=True)
        flash("An unexpected error occurred while approving the asset.", "danger")

    return redirect(url_for("list_pending_assets"))

@app.route("/talent_club/leader/member/<int:user_id>/unban_unmute", methods=["POST"])
@login_required
@tc_leader_required
def unban_unmute_tc_member(user_id):
    user_to_manage = db.get_or_404(User, user_id, description="User not found.")
    if user_to_manage.id == current_user.id:
        flash("Invalid action on self.", "danger")
        return redirect(url_for("manage_tc_members_leader"))

    active_ban = db.session.scalar(
        select(TalentClubBan)
        .where(
            TalentClubBan.user_id == user_to_manage.id,
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc),
            ),
        )
        .limit(1)
    )

    if not active_ban:
        flash(
            f"{user_to_manage.full_name or user_to_manage.username} does not have an active ban or mute.",
            "info",
        )
        return redirect(url_for("manage_tc_members_leader"))

    try:
        ban_type_lifted = active_ban.type
        active_ban.expires_at = datetime.now(timezone.utc) - timedelta(
            seconds=1
        )  # Expire it

        # If 'ban' was lifted, re-grant TC membership. This is a policy decision.
        # User might need to re-join clubs manually or be re-added.
        if ban_type_lifted == "ban":
            user_to_manage.is_tc_member = True
            # Attempt to add back to TC Community Group
            add_to_tc_community_group(user_to_manage)
            # Note: Previous club memberships are NOT automatically restored here. User would need to rejoin or be re-added.

        db.session.commit()
        flash(
            f"The {ban_type_lifted} for {user_to_manage.full_name or user_to_manage.username} has been lifted.",
            "success",
        )
        app.logger.info(
            f"TC Leader {current_user.username} lifted {ban_type_lifted} for user {user_id} (Ban ID: {active_ban.id})."
        )

        # --- Notification to the affected user ---
        if user_to_manage.is_active:
            notify_tc_member(
                user_to_manage,
                current_user,
                f"Your Talent Club system {ban_type_lifted} has been lifted.",
                f"tc_system_un{ban_type_lifted}",
                active_ban.id,
                None,
            )

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error lifting {ban_type_lifted} for user {user_id} by {current_user.username}: {e}",
            exc_info=True,
        )
        flash("An error occurred while removing the restriction.", "danger")

    return redirect(url_for("manage_tc_members_leader"))


# --- HR/CEO Specific Routes for TC Leader Management ---
@app.route("/hr_ceo/talent_club_leader_management")
@login_required
@role_required("hr_ceo", "system_admin")
def manage_system_tc_leader():
    # ADD THIS LINE: Instantiate the form to handle CSRF protection.
    form = CSRFOnlyForm()

    current_system_leader = db.session.scalar(
        select(User)
        .where(User.is_tc_leader == True, User.is_active == True)
        .options(joinedload(User.role))
    )
    active_election = get_active_tc_leader_election()  # Helper function

    total_votes_in_active_election = 0
    candidate_vote_counts_dict = {}
    eligible_candidates_list = get_tc_leader_candidates()  # Helper function

    if active_election:
        total_votes_in_active_election = (
            db.session.scalar(
                select(func.count(TalentClubLeaderVote.id)).where(
                    TalentClubLeaderVote.election_id == active_election.id
                )
            )
            or 0
        )

        # Get vote counts per candidate for the active election
        vote_counts_raw = db.session.execute(
            select(
                TalentClubLeaderVote.candidate_id,
                func.count(TalentClubLeaderVote.id).label("vote_count"),
            )
            .where(TalentClubLeaderVote.election_id == active_election.id)
            .group_by(TalentClubLeaderVote.candidate_id)
            .order_by(desc("vote_count"))  # Order by most votes
        ).all()  # Returns list of Row objects
        candidate_vote_counts_dict = {
            row.candidate_id: row.vote_count for row in vote_counts_raw
        }

    past_elections_query = (
        select(TalentClubLeaderElection)
        .where(TalentClubLeaderElection.status == "concluded")
        .options(joinedload(TalentClubLeaderElection.elected_leader))  # Load who won
        .order_by(TalentClubLeaderElection.concluded_at.desc())
        .limit(5)  # Show recent past elections
    )
    past_elections = db.session.scalars(past_elections_query).all()

    return render_template(
        "hr_ceo/manage_tc_leader.html",
        form=form,  # ADD THIS LINE: Pass the form object to the template.
        current_leader=current_system_leader,
        active_election=active_election,
        total_votes_in_active_election=total_votes_in_active_election,
        candidate_vote_counts=candidate_vote_counts_dict,
        eligible_candidates=eligible_candidates_list,
        past_elections=past_elections,
        title="Manage System TC Leader - Nexus TC",
    )

@app.route("/hr_ceo/talent_club_leader/demote/<int:user_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_demote_tc_leader(user_id):
    user_to_demote = db.get_or_404(User, user_id, description="User not found.")

    if not user_to_demote.is_tc_leader:
        flash(
            f"{user_to_demote.full_name or user_to_demote.username} is not currently the Talent Club Leader.",
            "warning",
        )
    elif (
        user_to_demote.id == current_user.id and user_to_demote.is_tc_leader
    ):  # HR/Admin trying to demote self if they were also leader
        flash(
            "You cannot demote yourself from the TC Leader role via this action. Assign another leader or contact support.",
            "danger",
        )
    else:
        try:
            user_to_demote.is_tc_leader = False
            db.session.commit()
            flash(
                f"{user_to_demote.full_name or user_to_demote.username} has been successfully demoted from System Talent Club Leader.",
                "success",
            )
            app.logger.info(
                f"User {current_user.username} demoted user {user_id} from system TC Leader."
            )

            # Notify the demoted user
            if user_to_demote.is_active:
                notify_tc_member(  # Your helper function
                    receiver_user=user_to_demote,
                    sender_user=current_user,
                    content=f"You have been demoted from the role of System Talent Club Leader by administration.",
                    notification_type="tc_leader_demoted_by_admin",  # New specific type
                    related_object_id=user_to_demote.id,  # Link to the user demoted
                    link_url=url_for(
                        "view_current_tc_leader", _external=True
                    ),  # Link to general TC Leader info page
                )
        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error demoting TC Leader {user_id} by {current_user.username}: {e}",
                exc_info=True,
            )
            flash(
                "An error occurred while demoting the leader. Please try again.",
                "danger",
            )

    return redirect(request.referrer or url_for("manage_system_tc_leader"))


@app.route("/hr_ceo/talent_club_leader/initiate_election", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_initiate_tc_leader_election():
    if get_active_tc_leader_election():  # Check if one is already active
        flash("An election for Talent Club Leader is already in progress.", "warning")
        return redirect(url_for("manage_system_tc_leader"))

    if not get_tc_leader_candidates():  # Check if there are any eligible TC members
        flash(
            "Cannot start an election: No eligible Talent Club members found to be candidates/voters.",
            "danger",
        )
        return redirect(url_for("manage_system_tc_leader"))

    try:
        new_election = TalentClubLeaderElection(
            initiated_by_id=current_user.id,
            initiated_at=datetime.now(timezone.utc),
            status="active",
        )
        db.session.add(new_election)
        db.session.commit()
        flash(
            "New Talent Club Leader election initiated successfully! Members can now vote.",
            "success",
        )
        app.logger.info(
            f"User {current_user.username} initiated TC Leader Election ID {new_election.id}."
        )

        # Notify all active TC members (who are the voters/candidates)
        tc_members_to_notify = get_tc_leader_candidates()  # Gets all active TC members
        notification_content = "A new election for System Talent Club Leader has started! Cast your vote now."
        link_url_vote = url_for(
            "view_current_tc_leader", _external=True
        )  # Link to voting page

        for member in tc_members_to_notify:
            if member.id != current_user.id:  # Don't notify the initiator (HR/Admin)
                notify_tc_member(
                    member,
                    current_user,
                    notification_content,
                    "tc_election_started",
                    new_election.id,
                    link_url_vote,
                )
    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error initiating TC Leader election by {current_user.username}: {e}",
            exc_info=True,
        )
        flash("An error occurred while initiating the election.", "danger")

    return redirect(url_for("manage_system_tc_leader"))


@app.route(
    "/hr_ceo/talent_club_leader/conclude_election/<int:election_id>", methods=["POST"]
)
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_conclude_tc_leader_election(election_id):
    """Allows HR/CEO to conclude a Talent Club Leader election and declare a winner."""
    election = db.get_or_404(TalentClubLeaderElection, election_id)

    # Check if the election is active and can be concluded
    if election.status != "active":
        flash("This election is not currently active.", "warning")
        return redirect(request.referrer or url_for("manage_system_tc_leader"))

    try:
        # Count votes per candidate
        vote_counts_query = (
            db.session.query(
                TalentClubLeaderVote.candidate_id, func.count(TalentClubLeaderVote.id)
            )
            .filter(TalentClubLeaderVote.election_id == election.id)
            .group_by(TalentClubLeaderVote.candidate_id)
            .all()
        )

        vote_counts = dict(vote_counts_query)

        elected_leader = None
        if vote_counts:
            # Find candidate(s) with the maximum votes
            max_votes = max(vote_counts.values())
            winners = [
                candidate_id
                for candidate_id, count in vote_counts.items()
                if count == max_votes
            ]

            if len(winners) == 1:
                # Clear any existing TC Leader
                current_leader = db.session.scalar(
                    select(User).where(User.is_tc_leader == True)
                )
                if current_leader and current_leader.id != winners[0]:
                    current_leader.is_tc_leader = False
                    app.logger.info(
                        f"Existing TC Leader {current_leader.id} demoted due to election conclusion."
                    )

                # Set the winner as the new TC Leader
                winner_user = db.session.get(User, winners[0])
                if winner_user:  # Ensure winner user exists and is active
                    if winner_user.is_active:
                        winner_user.is_tc_leader = True
                        elected_leader = winner_user
                        flash(
                            f"Election concluded. {winner_user.full_name or winner_user.username} is the new Talent Club Leader!",
                            "success",
                        )
                        app.logger.info(
                            f"User {winner_user.id} elected as new TC Leader (Election {election.id})."
                        )
                    else:
                        flash(
                            f"Election concluded with winner ID {winners[0]}, but user is inactive. No leader assigned.",
                            "warning",
                        )
                        app.logger.warning(
                            f"Election {election.id} winner {winners[0]} is inactive. No leader assigned."
                        )
                else:
                    flash(
                        f"Election concluded with winner ID {winners[0]}, but user not found. No leader assigned.",
                        "warning",
                    )
                    app.logger.warning(
                        f"Election {election.id} winner {winners[0]} not found. No leader assigned."
                    )

            else:
                # Handle tie (e.g., no leader assigned, manual HR decision needed)
                flash(
                    "Election resulted in a tie. No leader assigned via election.",
                    "warning",
                )
                app.logger.info(
                    f"Election {election.id} resulted in a tie among users: {winners}. No leader assigned."
                )

        else:
            # No votes were cast
            flash("No votes were cast in the election. No leader assigned.", "info")
            app.logger.info(f"Election {election.id} had no votes cast.")

        # Conclude the election status and record winner (if any)
        election.status = "concluded"
        election.concluded_at = datetime.now(timezone.utc)
        election.elected_leader = elected_leader  # Link the winner user

        db.session.commit()

        # --- Notification ---
        # Notify all active TC members about election results
        eligible_candidates = (
            get_tc_leader_candidates()
        )  # Get all TC members who *could* have voted
        notification_content = f"Talent Club Leader election concluded. Winner: {elected_leader.full_name or elected_leader.username if elected_leader else 'None'}. Check results."
        link_url = url_for(
            "manage_system_tc_leader"
        )  # Link to the management page to see results

        notifications_to_add = []
        for member in eligible_candidates:
            if member.is_active and member.id != current_user.id:
                try:
                    notify = Notification(
                        sender_id=current_user.id,
                        receiver_id=member.id,
                        content=notification_content,
                        link_url=link_url,
                        timestamp=datetime.now(timezone.utc),
                        is_read=False,
                        notification_type="tc_vote_result",  # Specific type
                        related_object_id=election.id,
                    )
                    notifications_to_add.append(notify)
                except Exception as notify_e:
                    app.logger.error(
                        f"Error creating TC vote result notification for user {member.id}: {notify_e}"
                    )

        if notifications_to_add:
            db.session.add_all(notifications_to_add)
            db.session.commit()  # Commit notifications

    except Exception as e:
        db.session.rollback()
        app.logger.error(
            f"Error HR/CEO {current_user.id} concluding TC Leader election {election_id}: {e}",
            exc_info=True,
        )
        flash(
            "An error occurred while concluding the election. Please try again.",
            "danger",
        )

    # Redirect back to management page
    return redirect(request.referrer or url_for("manage_system_tc_leader"))


# --- PART X END: Talent Club Features ---


# --- PART 15 START: CLI Commands, Error Handlers, and Main Execution ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, Role, AssetCategory, User models are defined.
# - password hashing functions (generate_password_hash) are available.
# - Werkzeug imports (NotFound) are available.
# - Other Python imports (click, sys, os, datetime, timezone).

import click  # Import click for CLI commands
import sys  # Import sys for exiting

# --- CLI Commands ---
# Use @app.cli.command() to register functions as CLI commands


# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# START MODIFICATION (create_initial CLI Command)
@app.cli.command("create-initial")
def create_initial_roles_and_categories():
    """Creates initial Role, AssetCategory, SocialCategory, and core Lab entries if they don't exist."""  # MODIFIED: Updated docstring
    with app.app_context():
        print("Creating initial roles...")
        initial_roles = [
            "system_admin",
            "hr_ceo",
            "school_executive",
            "government",
            "teacher",
            "librarian",
            "talent_club",
            "student",
            "parent",
        ]
        created_roles = []
        try:
            for role_name in initial_roles:
                role = db.session.scalar(select(Role).filter_by(name=role_name))
                if not role:
                    new_role = Role(name=role_name)
                    db.session.add(new_role)
                    created_roles.append(role_name)
            db.session.commit()
            if created_roles:
                print(f"Created roles: {', '.join(created_roles)}")
            else:
                print("All initial roles already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating roles: {e}", file=sys.stderr)
            sys.exit(1)

        print("\nCreating initial asset categories...")
        # MODIFIED: Removed social media categories from this list
        initial_asset_categories = [
            "General Equipment",
            "IT Hardware",
            "Furniture",
            "Teaching Supplies",
            "Lab Equipment",
            "Library Equipment",
            "Books",
            "Talent Club Gear",
            "Office Supplies",
            "Sports Equipment",
            "Student Activities Gear",
            "Classroom Assets",
        ]
        created_asset_categories = []
        try:
            for cat_name in initial_asset_categories:
                category = db.session.scalar(
                    select(AssetCategory).filter_by(name=cat_name)
                )
                if not category:
                    new_category = AssetCategory(name=cat_name)
                    db.session.add(new_category)
                    created_asset_categories.append(cat_name)
            db.session.commit()
            if created_asset_categories:
                print(
                    f"Created asset categories: {', '.join(created_asset_categories)}"
                )
            else:
                print("All initial asset categories already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating asset categories: {e}", file=sys.stderr)
            sys.exit(1)

        # START ADDITION (SocialCategory creation)
        print("\nCreating initial social media categories...")
        initial_social_categories = [
            "Entertainment",
            "Fun",
            "Sport",
            "Education",
            "Technology",
            "Personal",
            "Social",
            "Lifestyle",
            "Innovation",
            "Relationships",
        ]
        created_social_categories = []
        try:
            for social_cat_name in initial_social_categories:
                social_category = db.session.scalar(
                    select(SocialCategory).filter_by(name=social_cat_name)
                )
                if not social_category:
                    new_social_category = SocialCategory(name=social_cat_name)
                    db.session.add(new_social_category)
                    created_social_categories.append(social_cat_name)
            db.session.commit()
            if created_social_categories:
                print(
                    f"Created social categories: {', '.join(created_social_categories)}"
                )
            else:
                print("All initial social categories already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating social categories: {e}", file=sys.stderr)
            sys.exit(1)
        # END ADDITION (SocialCategory creation)

        print("\nCreating core Lab entries...")
        # ... (core Lab entries) ...
        # END MODIFICATION (create_initial CLI Command)
        # START ADDITION (Talent Club Community Group creation)
        print(f"\nCreating '{TC_COMMUNITY_GROUP_NAME}' group...")
        try:
            community_group = db.session.scalar(
                select(TalentClubCommunity).filter_by(name=TC_COMMUNITY_GROUP_NAME)
            )
            if not community_group:
                new_community_group = TalentClubCommunity(
                    name=TC_COMMUNITY_GROUP_NAME,
                    description="Official community group for all Talent Club members.",
                )
                db.session.add(new_community_group)
                db.session.commit()
                print(f"Created '{TC_COMMUNITY_GROUP_NAME}'.")
            else:
                print(f"'{TC_COMMUNITY_GROUP_NAME}' already exists.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating Talent Club Community group: {e}", file=sys.stderr)
            sys.exit(1)
        # END ADDITION (Talent Club Community Group creation)


# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# Add these imports if not already

# Add this near your other CLI commands

# Ensure your models are accessible: User, Role, TeacherProfile, Lab, Asset


@app.cli.command("standardize-grade-sections")
def standardize_grade_sections_command():
    """
    Standardizes grade/section data in User and TeacherProfile tables,
    and removes specific 'Grade 9, Section A/B/C' student entries.
    WARNING: This command modifies data. BACK UP YOUR DATABASE FIRST.
    """
    with app.app_context():
        print("\n--- Standardizing Grade and Section Data & Cleaning ---")
        if not click.confirm(
            "WARNING: This command will modify database records (User, TeacherProfile, Lab) and delete some User records. Ensure you have a backup. Do you want to continue?"
        ):
            print("Operation cancelled by user.")
            return

        # --- Step 1: Define Standardization Rules ---
        def normalize_grade(grade_str):
            if not grade_str:
                return None
            s = str(grade_str).strip()
            if s.lower().startswith("grade "):
                return s.split(" ", 1)[1].strip()  # "Grade 9" -> "9"
            return s  # Assumes it's already "9", "10" etc.

        def normalize_section(section_str):
            if not section_str:
                return None
            s = str(section_str).strip()
            if s.isdigit() and s.startswith("0") and len(s) > 1:
                return str(int(s))  # "01" -> "1", "09" -> "9"
            return s  # "A", "1", "10" remain as is

        # --- Step 2: Remove specific 'Grade 9, Section A/B/C' student entries ---
        print("\n1. Removing specific 'Grade 9, Section A/B/C' student entries...")
        grades_to_remove_raw = ["9", "Grade 9"]  # Cover both formats
        sections_to_remove = ["A", "B", "C"]
        users_to_delete_query = (
            select(User)
            .join(User.role)
            .where(
                Role.name == "student",
                or_(
                    User.grade.in_(grades_to_remove_raw),
                    User.grade.in_(
                        [
                            normalize_grade(g)
                            for g in grades_to_remove_raw
                            if normalize_grade(g)
                        ]
                    ),  # Normalized check
                ),
                or_(
                    User.section.in_(sections_to_remove),
                    User.section.in_(
                        [
                            normalize_section(s)
                            for s in sections_to_remove
                            if normalize_section(s)
                        ]
                    ),  # Normalized check
                ),
            )
        )
        users_to_delete = db.session.scalars(users_to_delete_query).all()
        deleted_count = 0
        if users_to_delete:
            for user in users_to_delete:
                print(
                    f"  - Preparing to delete student: {user.username} (ID: {user.id}), Grade: {user.grade}, Section: {user.section}"
                )
                # Add cascading delete logic here if needed for related records (marks, attendance, etc.)
                # For simplicity, this script just deletes the user. SQLAlchemy cascades might handle some.
                db.session.delete(user)
                deleted_count += 1
            db.session.commit()
            print(
                f"  Successfully deleted {deleted_count} student entries for Grade 9, Sections A/B/C."
            )
        else:
            print(
                "  No student entries found matching Grade 9, Sections A/B/C for deletion."
            )

        # --- Step 3: Standardize User (Student) Grade/Section Data ---
        print("\n2. Standardizing Grade/Section for all Users (Students)...")
        all_students = db.session.scalars(
            select(User).join(Role).where(Role.name == "student")
        ).all()
        student_updated_count = 0
        for student in all_students:
            original_grade = student.grade
            original_section = student.section
            normalized_g = normalize_grade(student.grade)
            normalized_s = normalize_section(student.section)

            changed = False
            if student.grade != normalized_g:
                student.grade = normalized_g
                changed = True
            if student.section != normalized_s:
                student.section = normalized_s
                changed = True

            if changed:
                print(
                    f"  - Student {student.username}: Grade '{original_grade}'->'{normalized_g}', Section '{original_section}'->'{normalized_s}'"
                )
                student_updated_count += 1
        if student_updated_count > 0:
            db.session.commit()
            print(f"  Standardized {student_updated_count} student records.")
        else:
            print("  No student records needed grade/section standardization.")

        # --- Step 4: Standardize TeacherProfile Grade/Section Data ---
        print("\n3. Standardizing Grade/Section for Teacher Profiles...")
        all_teacher_profiles = db.session.scalars(select(TeacherProfile)).all()
        tp_updated_count = 0
        for tp in all_teacher_profiles:
            original_grade = tp.grade
            original_section = tp.section
            normalized_g = normalize_grade(tp.grade)
            normalized_s = normalize_section(tp.section)

            changed = False
            if tp.grade != normalized_g:
                tp.grade = normalized_g
                changed = True
            if tp.section != normalized_s:
                tp.section = normalized_s
                changed = True

            if changed:
                teacher_name = (
                    tp.user.full_name if tp.user else f"TeacherProfile ID {tp.id}"
                )
                print(
                    f"  - TeacherProfile for {teacher_name}: Grade '{original_grade}'->'{normalized_g}', Section '{original_section}'->'{normalized_s}'"
                )
                tp_updated_count += 1
        if tp_updated_count > 0:
            db.session.commit()
            print(f"  Standardized {tp_updated_count} teacher profile records.")
        else:
            print("  No teacher profile records needed grade/section standardization.")

        # --- Step 5: Standardize Lab Names (Classroom Labs) ---
        # This assumes the desired format is "Grade X Section Y Classroom" where X and Y are normalized.
        print("\n4. Standardizing Classroom Lab Names...")
        labs_to_check = db.session.scalars(
            select(Lab).where(Lab.name.ilike("Grade %"))
        ).all()
        lab_updated_count = 0
        processed_lab_names = (
            set()
        )  # To avoid processing a lab name multiple times if it appears due to other issues

        for lab in labs_to_check:
            if lab.name in processed_lab_names:
                continue

            parts = lab.name.split(" ")
            # Example: "Grade 9 Section A Classroom" or "Grade Grade 9 Section 01 Classroom"
            # We want "Grade <NormGrade> Section <NormSection> Classroom"
            try:
                if (
                    len(parts) >= 5
                    and parts[0].lower() == "grade"
                    and parts[2].lower() == "section"
                    and parts[4].lower() == "classroom"
                ):
                    grade_part = parts[1]
                    section_part = parts[3]

                    norm_g = normalize_grade(grade_part)
                    norm_s = normalize_section(section_part)

                    if norm_g and norm_s:  # Ensure normalization was successful
                        new_lab_name = f"Grade {norm_g} Section {norm_s} Classroom"
                        if lab.name != new_lab_name:
                            # Check if a lab with the new_lab_name already exists
                            existing_target_lab = db.session.scalar(
                                select(Lab).filter_by(name=new_lab_name)
                            )
                            if existing_target_lab and existing_target_lab.id != lab.id:
                                print(
                                    f"  - Lab '{lab.name}': Target name '{new_lab_name}' already exists (ID: {existing_target_lab.id}). Manual merge of assets might be needed."
                                )
                                # You might want to move assets from 'lab' to 'existing_target_lab' then delete 'lab'
                                # For now, just log and skip renaming to avoid unique constraint violation.
                            else:
                                print(
                                    f"  - Lab: Renaming '{lab.name}' to '{new_lab_name}'"
                                )
                                lab.name = new_lab_name
                                lab_updated_count += 1
                        processed_lab_names.add(
                            lab.name
                        )  # Add original name to avoid re-processing
                        if lab.name != new_lab_name:
                            processed_lab_names.add(
                                new_lab_name
                            )  # Add new name too if changed
                    else:
                        print(
                            f"  - Lab '{lab.name}': Could not reliably parse and normalize grade/section parts."
                        )
                elif (
                    parts[0].lower() == "grade" and parts[1].lower() == "grade"
                ):  # Handle "Grade Grade X"
                    if (
                        len(parts) >= 6
                        and parts[3].lower() == "section"
                        and parts[5].lower() == "classroom"
                    ):
                        grade_part = parts[2]
                        section_part = parts[4]
                        norm_g = normalize_grade(grade_part)
                        norm_s = normalize_section(section_part)
                        if norm_g and norm_s:
                            new_lab_name = f"Grade {norm_g} Section {norm_s} Classroom"
                            # ... (rest of renaming logic as above) ...
                            if lab.name != new_lab_name:
                                existing_target_lab = db.session.scalar(
                                    select(Lab).filter_by(name=new_lab_name)
                                )
                                if (
                                    existing_target_lab
                                    and existing_target_lab.id != lab.id
                                ):
                                    print(
                                        f"  - Lab '{lab.name}': Target name '{new_lab_name}' already exists (ID: {existing_target_lab.id}). Manual merge of assets might be needed."
                                    )
                                else:
                                    print(
                                        f"  - Lab: Renaming '{lab.name}' to '{new_lab_name}'"
                                    )
                                    lab.name = new_lab_name
                                    lab_updated_count += 1
                            processed_lab_names.add(lab.name)
                            if lab.name != new_lab_name:
                                processed_lab_names.add(new_lab_name)
                        else:
                            print(
                                f"  - Lab '{lab.name}': Could not reliably parse (double 'Grade')."
                            )
            except Exception as e:
                print(f"  - Error processing lab '{lab.name}': {e}")

        if lab_updated_count > 0:
            db.session.commit()
            print(f"  Standardized {lab_updated_count} classroom lab names.")
        else:
            print(
                "  No classroom lab names needed standardization or could be safely standardized."
            )

        print("\n--- Standardization and Cleaning Complete ---")
        print("Please re-run 'flask inspect-grade-sections' to verify the changes.")


# --- CLI COMMAND TO INSPECT GRADE/SECTION DATA ---
@app.cli.command("inspect-grade-sections")
def inspect_grade_sections_command():
    """Inspects and prints distinct grade/section combinations from the database."""
    with app.app_context():
        print("\n--- Inspecting Grade and Section Data ---")

        # 1. Distinct Grade/Section combinations for active STUDENTS
        print("\n1. Distinct Grade/Section Combinations for Active Students:")
        student_blocks_query = (
            select(User.grade, User.section, func.count(User.id).label("student_count"))
            .join(User.role)
            .where(
                Role.name == "student",
                User.is_active == True,
                User.grade.isnot(None),
                User.grade != "",
                User.section.isnot(None),
                User.section != "",
            )
            .group_by(User.grade, User.section)
            .order_by(User.grade.asc(), User.section.asc())
        )
        student_blocks = db.session.execute(student_blocks_query).all()

        if student_blocks:
            for grade, section, count in student_blocks:
                print(f"  - Grade: {grade}, Section: {section} (Students: {count})")
        else:
            print("  No distinct grade/section combinations found for active students.")

        # 2. Distinct Grade/Section/Subject combinations for active TEACHERS
        print("\n2. Distinct Grade/Section/Subject Assignments for Active Teachers:")
        teacher_assignments_query = (
            select(
                User.full_name.label("teacher_name"),
                TeacherProfile.grade,
                TeacherProfile.section,
                TeacherProfile.subject,
                func.count(TeacherProfile.id).label(
                    "assignment_count"
                ),  # Count profiles
            )
            .join(User.teacher_profiles)  # From User to TeacherProfile
            .join(User.role)  # From User to Role
            .where(
                Role.name == "teacher",
                User.is_active == True,
                TeacherProfile.grade.isnot(None),
                TeacherProfile.grade != "",
                TeacherProfile.section.isnot(None),
                TeacherProfile.section != "",
                TeacherProfile.subject.isnot(None),
                TeacherProfile.subject != "",
            )
            .group_by(
                User.full_name,
                TeacherProfile.grade,
                TeacherProfile.section,
                TeacherProfile.subject,
            )
            .order_by(
                User.full_name.asc(),
                TeacherProfile.grade.asc(),
                TeacherProfile.section.asc(),
                TeacherProfile.subject.asc(),
            )
        )
        teacher_assignments = db.session.execute(teacher_assignments_query).all()

        if teacher_assignments:
            current_teacher = None
            for teacher_name, grade, section, subject, count in teacher_assignments:
                if teacher_name != current_teacher:
                    if current_teacher is not None:
                        print("")  # Newline for next teacher
                    print(f"  Teacher: {teacher_name}")
                    current_teacher = teacher_name
                print(
                    f"    - Teaches: Grade {grade} - Section {section}, Subject: {subject} (Profiles: {count})"
                )
        else:
            print(
                "  No distinct grade/section/subject assignments found for active teachers."
            )

        # 3. Labs that look like Classrooms (based on naming convention)
        print("\n3. Labs Named Like Classrooms (e.g., for Student Leaders' assets):")
        classroom_labs_query = (
            select(Lab.name, func.count(Asset.id).label("asset_count"))
            .outerjoin(
                Asset, Lab.id == Asset.lab_id
            )  # Outer join to count assets even if lab is empty
            .where(Lab.name.ilike("Grade % Section % Classroom"))
            .group_by(
                Lab.id, Lab.name
            )  # Group by Lab.id as well for safety if names aren't unique (though they should be)
            .order_by(Lab.name.asc())
        )
        classroom_labs = db.session.execute(classroom_labs_query).all()
        if classroom_labs:
            for lab_name, asset_count in classroom_labs:
                print(f"  - Lab: {lab_name} (Assets linked: {asset_count})")
        else:
            print(
                "  No labs found matching the 'Grade X Section Y Classroom' naming pattern."
            )

        print("\n--- Inspection Complete ---")
        
@app.cli.command("seed-db")
@click.argument("count", default=10)
def seed_db_command(count):
    """Seeds the database with dummy data, including specific lab/category assignments and Talent Club data.""" # Updated docstring
    with app.app_context():
        print(f"Seeding database with {count} dummy users (students, teachers, talent club) and assets...")
        try:
            # Fetch necessary roles
            student_role = db.session.scalar(select(Role).filter_by(name="student"))
            teacher_role = db.session.scalar(select(Role).filter_by(name="teacher"))
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            system_admin_role = db.session.scalar(select(Role).filter_by(name="system_admin"))
            talent_club_role = db.session.scalar(select(Role).filter_by(name="talent_club"))
            librarian_role = db.session.scalar(select(Role).filter_by(name="librarian"))

            if not all([student_role, teacher_role, hr_ceo_role, system_admin_role, talent_club_role, librarian_role]):
                print("Error: Required roles not found. Run 'flask create-initial' first.", file=sys.stderr)
                sys.exit(1)

            # Fetch necessary categories
            classroom_category = db.session.scalar(select(AssetCategory).filter_by(name="Classroom Assets"))
            lab_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="Lab Equipment"))
            books_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
            tc_gear_category = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
            general_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="General Equipment"))

            if not all([classroom_category, lab_equipment_category, books_category, tc_gear_category, general_equipment_category]):
                print("Error: Required asset categories not found. Run 'flask create-initial' first.", file=sys.stderr)
                sys.exit(1)

            # Fetch core Labs (or create if missing - create-initial should make these)
            main_library_lab = db.session.scalar(select(Lab).filter_by(name="Main Library"))
            talent_club_hq_lab = db.session.scalar(select(Lab).filter_by(name="Talent Club HQ"))
            # Create a generic Science Lab if it doesn't exist for teachers
            science_lab = db.session.scalar(select(Lab).filter_by(name="Science Lab A"))
            if not science_lab:
                science_lab = Lab(name="Science Lab A")
                db.session.add(science_lab)
                # No flush/commit here, will be committed with users later


            # Create a default admin user if one doesn't exist
            admin_user = db.session.scalar(select(User).filter_by(username="admin"))
            if not admin_user:
                 print("Creating default 'admin' user...")
                 admin_user = User(
                     username="admin",
                     email="admin@school.com",
                     full_name="System Administrator",
                     first_name="System",
                     last_name="Administrator",
                     role=system_admin_role,
                     is_active=True,
                     force_password_change=True,
                     created_at=datetime.now(timezone.utc)
                 )
                 admin_user.set_password("default_admin_password")
                 db.session.add(admin_user)
                 print("Default admin user 'admin' created with password 'default_admin_password'. PLEASE CHANGE THIS IMMEDIATELY after first login using the forced change password page.")


            # Create dummy users (mix of students, teachers, librarians, and talent_club members)
            grades = ["9", "10", "11", "12"]
            sections = ["A", "B", "C"]
            subjects = ["Math", "Science", "History", "English", "Physics", "Chemistry", "Biology"]
            genders = ["Male", "Female"]

            print("\nCreating dummy users and associated assets...")
            for i in range(count):
                role_choice = i % 4 # Now 4 categories: student, teacher, talent_club, librarian
                if role_choice == 0:
                    role = student_role
                elif role_choice == 1:
                    role = teacher_role
                elif role_choice == 2:
                    role = talent_club_role
                else: # role_choice == 3
                    role = librarian_role

                dummy_username = f"{role.name}_{i+1}".lower()
                dummy_email = f"{dummy_username}@example.com"
                dummy_full_name = f"{role.name.capitalize()} User {i+1}"
                dummy_first_name = f"{role.name.capitalize()}"
                dummy_last_name = f"User{i+1}"

                existing_user = db.session.scalar(
                    select(User).filter(
                        (User.username == dummy_username) | (User.email == dummy_email)
                    )
                )
                if existing_user:
                    print(f"Skipping user {dummy_username}: already exists.")
                    continue

                user = User(
                    username=dummy_username,
                    email=dummy_email,
                    full_name=dummy_full_name,
                    first_name=dummy_first_name,
                    last_name=dummy_last_name,
                    role=role,
                    is_active=True,
                    created_at=datetime.now(timezone.utc),
                    age=14 + i if role == student_role else 30 + i,
                    gender=genders[i % len(genders)],
                    phone=f"555-123-{1000 + i}",
                    address=f"Dummy Address {i+1}",
                    force_password_change=False,
                    is_tc_member=False, # Default False, set True below for some students
                    is_tc_leader=False # Default False, set True below for some talent_club role users
                )
                user.set_password("password")

                # --- Role-Specific Attribute Assignment and Asset Creation within the loop ---
                if role == student_role:
                    user.grade = grades[i % len(grades)]
                    user.section = sections[i % len(sections)]
                    # Dynamically create/get classroom lab for students
                    classroom_name = f"Grade {user.grade} Section {user.section} Classroom"
                    classroom_lab = db.session.scalar(select(Lab).filter_by(name=classroom_name))
                    if not classroom_lab:
                        classroom_lab = Lab(name=classroom_name)
                        db.session.add(classroom_lab)
                        db.session.flush() # Flush to get ID for newly created lab
                    # Assign student to their classroom lab (conceptual)
                    user.lab_id = classroom_lab.id

                    # Make some students leaders
                    if i % 3 == 0:
                        user.is_leader = True
                        print(f"  - User {user.username} is a Student Leader.")
                        # Add an asset for this student leader in their classroom
                        classroom_asset = Asset(
                            name=f"Classroom Projector {i}",
                            description="Projector for class use.",
                            quantity=1,
                            condition="Good",
                            added_by_user=user, # Link to the user being created
                            category=classroom_category,
                            lab=classroom_lab,
                            status="Available"
                        )
                        db.session.add(classroom_asset)
                    # Make some students TC members
                    if i % 2 == 0: # Example: Make every other student a TC member
                        user.is_tc_member = True
                        print(f"  - User {user.username} is a Talent Club Member.")
                        # Adding to community group is handled *after* the loop


                elif role == teacher_role:
                    # Assign teachers to a lab (e.g., Science Lab A)
                    # Ensure science_lab exists before assigning its ID
                    if science_lab:
                        user.lab_id = science_lab.id

                    dummy_subject = subjects[i % len(subjects)]
                    dummy_grade = grades[i % len(grades)]
                    dummy_section = sections[i % len(sections)]
                    teacher_profile = TeacherProfile(
                         user=user, # Link to the user being created
                         subject=dummy_subject,
                         grade=dummy_grade,
                         section=dummy_section,
                         salary=50000.0 + i * 1000.0
                    )
                    db.session.add(teacher_profile)

                    # Add an asset for this teacher in their lab
                    if science_lab and lab_equipment_category: # Ensure prerequisites exist
                         lab_asset = Asset(
                             name=f"Microscope {i}",
                             description="For science experiments.",
                             quantity=2,
                             condition="Good",
                             added_by_user=user, # Link to the user being created
                             category=lab_equipment_category,
                             lab=science_lab,
                             status="Available"
                         )
                         db.session.add(lab_asset)


                elif role == talent_club_role:
                    # Ensure Talent Club HQ Lab exists before assigning
                    if talent_club_hq_lab:
                         user.lab_id = talent_club_hq_lab.id

                    if i % 2 == 0:
                        user.is_tc_leader = True
                        print(f"  - User {user.username} is a Talent Club Leader.")
                        # Add an asset for this talent club leader in Talent Club HQ
                        if talent_club_hq_lab and tc_gear_category: # Ensure prerequisites exist
                             tc_asset = Asset(
                                 name=f"Stage Light {i}",
                                 description="Lighting equipment for club performances.",
                                 quantity=1,
                                 condition="Fair",
                                 added_by_user=user, # Link to the user being created
                                 category=tc_gear_category,
                                 lab=talent_club_hq_lab,
                                 status="Available"
                             )
                             db.session.add(tc_asset)


                elif role == librarian_role:
                    # Ensure Main Library Lab exists before assigning
                    if main_library_lab:
                         user.lab_id = main_library_lab.id
                    # Add a book asset for the librarian
                    if main_library_lab and books_category: # Ensure prerequisites exist
                         book_asset = Asset(
                             name=f"Math Textbook Vol {i}",
                             description="Calculus textbook.",
                             quantity=10,
                             condition="New",
                             added_by_user=user, # Link to the user being created
                             category=books_category, # Corrected typo here as well
                             lab=main_library_lab,
                             status="Available"
                         )
                         db.session.add(book_asset)

                # Add the user to the session after all specific attributes/relations are set for their role
                db.session.add(user)

            # --- Code AFTER the main user loop finishes ---

            db.session.commit() # Commit all users and assets created *within* the loop

            # Ensure TC Community group exists (should be done by create-initial, but double-check)
            community_group = get_tc_community_group()
            if not community_group:
                 print(f"Error: '{TC_COMMUNITY_GROUP_NAME}' group not found. Run 'flask create-initial' first.", file=sys.stderr)
                 sys.exit(1)


            # Add all is_tc_member students to the TC Community group
            print("\nAdding TC Members to Community Group...")
            tc_members = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True)).all()
            for member in tc_members:
                 # Use the helper which checks if they are already a member
                 add_to_tc_community_group(member)
                 # The helper commits internally, so no separate commit needed here for this loop

            # Create some dummy Talent Clubs, Feeds, Memberships, and Follows
            print("\nCreating dummy Talent Clubs...")
            tc_categories = db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all()
            if not tc_categories:
                 print("Error: No Social Categories found. Cannot create dummy Talent Clubs.", file=sys.stderr)
            else:
                 # Select some TC members to be club owners (ensure they are active and TC members)
                 tc_owners = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True).order_by(User.id).limit(3)).all() # Get 3 owners, consistent order
                 if not tc_owners:
                      print("Warning: No TC members found to be club owners. Skipping dummy club creation.")
                 else:
                      for i, owner in enumerate(tc_owners):
                          club_name = f"{owner.full_name}'s Awesome Club {i+1}"
                          # Check if club name already exists
                          existing_club = db.session.scalar(select(TalentClub).filter_by(name=club_name))
                          if existing_club:
                               print(f"Skipping club '{club_name}': already exists.")
                               continue

                          try:
                              category = tc_categories[i % len(tc_categories)]
                              new_club = TalentClub(
                                   name=club_name,
                                   description=f"A dummy club created by {owner.full_name or owner.username}.",
                                   owner=owner,
                                   social_category=category,
                                   level=(i % 5) + 1, # Levels 1-5
                                   warning_count=i % 3, # Warnings 0-2
                                   is_active=True,
                                   created_at=datetime.now(timezone.utc) - timedelta(days=i*10) # Backdate creation
                              )
                              db.session.add(new_club)
                              db.session.flush() # Flush to get club ID

                              # Create the linked feed
                              club_feed = TalentClubFeed(talent_club=new_club)
                              db.session.add(club_feed)

                              # Add owner as a member ('creator' role)
                              owner_membership = TalentClubMembership(club=new_club, user=owner, role='creator')
                              db.session.add(owner_membership)

                              # Add a few other random TC members as 'member' (ensure they are active TC members)
                              other_members = db.session.scalars(
                                   select(User)
                                   .where(User.is_tc_member == True, User.id != owner.id, User.is_active == True)
                                   .order_by(db.func.random()) # Random members
                                   .limit(5)
                              ).all()
                              for other_member in other_members:
                                   try:
                                        # Check if they are already a member of this specific club instance (unlikely but safe)
                                        is_already_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=new_club, user=other_member).exists())
                                        if not is_already_member:
                                            member_membership = TalentClubMembership(club=new_club, user=other_member, role='member')
                                            db.session.add(member_membership)
                                            # Add some dummy posts to the feed from a few members
                                            if len(new_club.feed.posts.all()) < 5: # Add a few posts per club
                                                 post_content = f"Hello from {other_member.full_name or other_member.username} in {new_club.name}!"
                                                 feed_post = TalentClubFeedPost(feed=club_feed, author=other_member, content=post_content)
                                                 db.session.add(feed_post)
                                   except IntegrityError:
                                        db.session.rollback() # Rollback only this specific membership/post add
                                        print(f"    - User {other_member.username} already member of club {new_club.name} (IntegrityError).", file=sys.stderr)
                                   except Exception as e:
                                        db.session.rollback() # Rollback only this specific membership/post add
                                        print(f"    - Error adding member {other_member.username} or post to club {new_club.name}: {e}", file=sys.stderr)


                              # Add some dummy followers (can be any active user)
                              followers = db.session.scalars(select(User).where(User.is_active == True).order_by(db.func.random()).limit(10)).all() # Any active user can follow
                              for follower in followers:
                                  # Avoid adding user if they are already a member of this specific club instance
                                  is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=new_club, user=follower).exists())
                                  # Avoid adding user if they already follow this specific club instance
                                  is_already_following = db.session.scalar(select(TalentClubFollow).filter_by(club=new_club, user=follower).exists())
                                  if not is_member and not is_already_following:
                                      try:
                                          follow_entry = TalentClubFollow(club=new_club, user=follower)
                                          db.session.add(follow_entry)
                                      except IntegrityError:
                                          db.session.rollback() # Rollback only this specific follow add
                                          print(f"    - User {follower.username} already follows club {new_club.name} (IntegrityError).", file=sys.stderr)
                                      except Exception as e:
                                          db.session.rollback() # Rollback only this specific follow add
                                          print(f"    - Error adding follower {follower.username} to club {new_club.name}: {e}", file=sys.stderr)


                              db.session.commit() # Commit the new club, feed, memberships, posts, and follows
                              print(f"Created club '{new_club.name}' (ID: {new_club.id}) with {new_club.memberships.filter_by(is_active=True).count()} members and {new_club.follows.count()} followers.")


                          except IntegrityError:
                               db.session.rollback()
                               print(f"Skipping club '{club_name}': name already exists.", file=sys.stderr)
                          except Exception as e:
                              db.session.rollback()
                              print(f"Error creating club '{club_name}': {e}", file=sys.stderr)

            # Add a few general assets by admin for testing HR/CEO view (if admin_user was created/exists)
            if admin_user and general_equipment_category: # Ensure prerequisites exist
                 print("\nCreating dummy admin assets...")
                 for i in range(3):
                     admin_asset = Asset(
                         name=f"Admin PC {i + 1}",
                         description="Office computer for staff.",
                         quantity=1,
                         condition="Good",
                         added_by_user=admin_user,
                         category=general_equipment_category,
                         lab=None, # No specific lab initially
                         status="Pending Review"
                     )
                     db.session.add(admin_asset)
                 db.session.commit() # Commit admin assets


            print("\nDatabase seeding process complete.")
            sys.exit(0) # Exit successfully

        except Exception as e:
            db.session.rollback() # Rollback everything in case of a general error
            print(f"General error during seeding: {e}", file=sys.stderr)
            sys.exit(1) # Exit with error code

# --- Error Handlers ---
# Define custom error pages for common HTTP errors


@app.errorhandler(403)  # Forbidden
def forbidden_error(error):
    """Render custom 403 Forbidden page."""
    # Log the 403 error, including the user and path
    user_info = (
        f"User {current_user.username} (ID: {current_user.id})"
        if current_user.is_authenticated
        else "Unauthenticated user"
    )
    app.logger.warning(
        f"403 Forbidden: {user_info} attempted access to {request.path} from IP {request.remote_addr}"
    )
    # Render a template specific to 403 errors
    return render_template("errors/403.html", title="Forbidden", error=error), 403


@app.errorhandler(404)  # Not Found
def not_found_error(error):
    """Render custom 404 Not Found page."""
    # Log the 404 error, including the requested path and source IP
    app.logger.info(f"404 Not Found: Path {request.path} from IP {request.remote_addr}")
    # Render a template specific to 404 errors
    return render_template("errors/404.html", title="Page Not Found", error=error), 404


@app.errorhandler(500)  # Internal Server Error
def internal_error(error):
    """Render custom 500 Internal Server Error page."""
    # Log the 500 error with traceback for debugging
    user_info = (
        f"User {current_user.username} (ID: {current_user.id})"
        if current_user.is_authenticated
        else "Unauthenticated user"
    )
    app.logger.error(
        f"500 Internal Server Error: {user_info} on path {request.path} from IP {request.remote_addr}",
        exc_info=True,
    )  # Log traceback

    # Ensure the database session is properly rolled back in case of an error
    # Flask-SQLAlchemy usually handles this, but explicit rollback in 500 handler is safer.
    db.session.rollback()
    # Render a template specific to 500 errors
    return render_template("errors/500.html", title="Server Error", error=error), 500

# In app.py, inside PART 15 with other CLI commands
# In app.py, inside PART 15, REPLACE the old inspect-parent-student-links command with this one.

@app.cli.command("inspect-parent-student-links")
@click.option('--limit', default=15, help='Number of parents to inspect. Set to 0 for all.')
def inspect_parent_student_links_command(limit):
    """Inspects the database to verify parent-student relationships for a sample of parents."""
    with app.app_context():
        print("\n--- Inspecting Parent-Student Relationships ---")

        parent_role = db.session.scalar(select(Role).filter_by(name='parent'))
        if not parent_role:
            print("Error: 'parent' role not found in the database. Cannot proceed.")
            return

        parent_users_query = select(User).where(User.role == parent_role).options(
            joinedload(User.parent_profile)
            .joinedload(Parent.student_associations)
            .joinedload(ParentStudent.student)
            .joinedload(User.role)
        )

        if limit > 0:
            # MODIFIED LINE: Added .execute() and .unique() to handle duplicate rows from the JOIN.
            parent_users = db.session.execute(parent_users_query.limit(limit)).scalars().unique().all()
            print(f"Showing relationships for a sample of up to {limit} parents (use --limit 0 for all).")
        else:
            # MODIFIED LINE: Added .execute() and .unique() here as well.
            parent_users = db.session.execute(parent_users_query).scalars().unique().all()
            print(f"Showing relationships for all {len(parent_users)} parents.")

        if not parent_users:
            print("No users with the 'parent' role found in the database.")
            return

        found_links = 0
        for parent_user in parent_users:
            print("-" * 40)
            print(f"[PARENT] ID: {parent_user.id}, Username: {parent_user.username}, Name: {parent_user.full_name}")

            parent_profile = parent_user.parent_profile
            if not parent_profile:
                print("  -> This parent user does NOT have an associated Parent profile record.")
                continue

            associations = parent_profile.student_associations
            if not associations:
                print("  -> No children linked to this parent.")
                continue

            found_links += len(associations)
            for assoc in associations:
                student = assoc.student
                if student:
                    print(f"  - Linked to [STUDENT] ID: {student.id}, Name: {student.full_name} (Grade: {student.grade or 'N/A'})")
                    print(f"    - Relationship Type: {assoc.relationship or 'Not Set'}")
                    print(f"    - Verification Status: {assoc.verification_status or 'N/A'}")
                else:
                    print(f"  - WARNING: Broken link found. Association record exists but student with ID {assoc.student_id} was not found.")

        print("-" * 40)
        if found_links == 0:
            print("\nConclusion: No parent-student links were found in the sample.")
        else:
            print(f"\n--- Inspection Complete: Found {found_links} total parent-student links in the sample. ---")
            
# In app.py, inside PART 15 with other CLI commands

@app.cli.command("count-linked-parents")
def count_linked_parents_command():
    """Counts the total number of parents and how many are linked to students."""
    with app.app_context():
        print("\n--- Counting Parent-Student Links ---")
        try:
            # 1. Count the total number of parent records in the 'parent' table.
            total_parents = db.session.scalar(select(func.count(Parent.id))) or 0

            # 2. Count the number of parents who have at least one entry in the 'parent_student' table.
            #    The .any() method is very efficient for this, translating to an SQL EXISTS clause.
            linked_parents_query = select(func.count(Parent.id)).where(Parent.student_associations.any())
            linked_parents_count = db.session.scalar(linked_parents_query) or 0

            # 3. Count the total number of links (e.g., if a parent has 2 children, this counts as 2 links).
            total_links_count = db.session.scalar(select(func.count(ParentStudent.parent_id))) or 0

            # 4. Count total students for context
            student_role = db.session.scalar(select(Role).filter_by(name='student'))
            if not student_role:
                print("Error: 'student' role not found. Cannot count students.")
                total_students_count = "N/A"
            else:
                total_students_count = db.session.scalar(select(func.count(User.id)).where(User.role == student_role)) or 0


            print(f"Total Parent Records in DB: {total_parents}")
            print(f"Total Student Records in DB: {total_students_count}")
            print("-" * 40)
            print(f"Parents Linked to at least one Student: {linked_parents_count}")
            print(f"Total Individual Parent-Student Links: {total_links_count}")

            if total_parents > 0:
                percentage = (linked_parents_count / total_parents) * 100
                print(f"\nLinkage Percentage: {percentage:.2f}% of parent records are linked to students.")
            else:
                print("\nNo parent records found in the database.")

            print("\n--- Count Complete ---")

        except Exception as e:
            print(f"\nAn error occurred while querying the database: {e}")
            print("Please ensure your database is running and the models are correct.")
  
@app.cli.command("sync-grade-sections")
def sync_grade_sections_command():
    """
    Synchronizes grade and section data between User, TeacherProfile, and Student models.
    - For Teachers: Copies grade/section from TeacherProfile to the User model.
    - For Students: Copies grade/section from the User model to the Student model.
    WARNING: This command modifies data directly. Please back up your database first.
    """
    with app.app_context():
        if not click.confirm(
            "This will modify User, and Student records based on data in TeacherProfile and User. "
            "It is recommended to back up your database first. Do you want to continue?"
        ):
            print("Operation cancelled.")
            return

        # --- 1. Sync Teacher Data (TeacherProfile -> User) ---
        print("\nStarting teacher data synchronization (TeacherProfile -> User)...")
        try:
            teacher_role = db.session.scalar(select(Role).filter_by(name="teacher"))
            if not teacher_role:
                print("Error: 'teacher' role not found. Cannot sync teacher data.", file=sys.stderr)
                return

            # --- FIX: REMOVED the .options(joinedload(...)) part ---
            # We will access the 'dynamic' relationship inside the loop.
            teachers = db.session.scalars(
                select(User)
                .where(User.role == teacher_role, User.is_active == True)
            ).all()

            updated_teachers_count = 0
            for teacher_user in teachers:
                # Accessing the dynamic relationship now executes a query for this specific user.
                # Find the first associated profile that has a grade and section.
                primary_profile = teacher_user.teacher_profiles.filter(
                    TeacherProfile.grade.isnot(None),
                    TeacherProfile.section.isnot(None)
                ).first()

                if primary_profile:
                    if teacher_user.grade != primary_profile.grade or teacher_user.section != primary_profile.section:
                        print(f"  - Updating Teacher '{teacher_user.username}': "
                              f"Grade '{teacher_user.grade}' -> '{primary_profile.grade}', "
                              f"Section '{teacher_user.section}' -> '{primary_profile.section}'")
                        teacher_user.grade = primary_profile.grade
                        teacher_user.section = primary_profile.section
                        updated_teachers_count += 1
                else:
                    print(f"  - Skipping Teacher '{teacher_user.username}': No suitable TeacherProfile with grade/section found.")
            
            if updated_teachers_count > 0:
                db.session.commit()
                print(f"Successfully updated {updated_teachers_count} teacher records in the User table.")
            else:
                print("No teacher records in the User table required updates.")

        except Exception as e:
            db.session.rollback()
            print(f"An error occurred during teacher synchronization: {e}", file=sys.stderr)
            return

        # --- 2. Sync Student Data (User -> Student) ---
        # (This part was correct and remains the same)
        print("\nStarting student data synchronization (User -> Student)...")
        try:
            student_role = db.session.scalar(select(Role).filter_by(name="student"))
            if not student_role:
                print("Error: 'student' role not found. Cannot sync student data.", file=sys.stderr)
                return
            
            student_users = db.session.scalars(
                select(User)
                .where(User.role == student_role, User.is_active == True)
                .options(joinedload(User.student))
            ).all()
            
            updated_students_count = 0
            for student_user in student_users:
                if student_user.grade and student_user.section:
                    student_record = student_user.student
                    if not student_record:
                        print(f"  - WARNING: User '{student_user.username}' is a student but has no associated record in the 'students' table. Creating one.")
                        student_record = Student(user_id=student_user.id)
                        db.session.add(student_record)
                    
                    if student_record.grade != student_user.grade or student_record.section != student_user.section:
                        print(f"  - Updating Student Record for '{student_user.username}': "
                              f"Grade '{student_record.grade}' -> '{student_user.grade}', "
                              f"Section '{student_record.section}' -> '{student_user.section}'")
                        student_record.grade = student_user.grade
                        student_record.section = student_user.section
                        updated_students_count += 1
                else:
                    print(f"  - Skipping User '{student_user.username}': No grade/section data found on the User record to sync.")

            if updated_students_count > 0:
                db.session.commit()
                print(f"Successfully updated {updated_students_count} records in the 'students' table.")
            else:
                print("No records in the 'students' table required updates.")

        except Exception as e:
            db.session.rollback()
            print(f"An error occurred during student synchronization: {e}", file=sys.stderr)
            return
        
        print("\nSynchronization complete!")
@app.route("/favicon.ico")
def favicon():
    try:
        return send_from_directory(
            os.path.join(app.root_path, "static"),
            "favicon.ico",
            mimetype="image/vnd.microsoft.icon",
        )
    except NotFound:
        app.logger.debug("favicon.ico not found in static directory.")
        abort(404)

# In app.py, PART 15, after your other CLI commands

def generate_parent_secret_code(session, existing_codes_set):
    """Generates a unique 6-character code for parent registration."""
    # Using a slightly different length/format to distinguish from student codes
    chars = string.ascii_uppercase + string.digits
    while True:
        code = ''.join(random.choices(chars, k=6))
        if code not in existing_codes_set:
            # Final check against the database to be absolutely sure
            if not session.scalar(select(SecretCode).filter_by(code=code)):
                existing_codes_set.add(code)
                return code

# In app.py, PART 15, with other CLI commands

@app.cli.command("link-teachers")
def link_teachers_command():
    """
    Interactively links Teacher user records to TeacherProfile records.
    This is for fixing cases where the user_id in teacher_profile might be incorrect or missing.
    WARNING: This command modifies data. BACK UP YOUR DATABASE FIRST.
    """
    with app.app_context():
        print("\n--- Interactive Teacher Profile Linker ---")
        
        # --- Step 1: Fetch all teachers and all profiles ---
        teacher_role = db.session.scalar(select(Role).filter_by(name='teacher'))
        if not teacher_role:
            print("Error: 'teacher' role not found. Cannot proceed.")
            return

        all_teachers = db.session.scalars(select(User).where(User.role_id == teacher_role.id)).all()
        # Fetch profiles that might be unlinked (user_id is NULL or points to a non-existent/non-teacher user)
        all_profiles = db.session.scalars(select(TeacherProfile)).all()
        
        teacher_map = {t.id: t for t in all_teachers}
        linked_profile_ids = set()

        print(f"Found {len(all_teachers)} users with the 'teacher' role.")
        print(f"Found {len(all_profiles)} total records in 'teacher_profile'.")

        # --- Step 2: Identify already correctly linked profiles ---
        print("\n--- Checking for correctly linked profiles ---")
        for profile in all_profiles:
            if profile.user_id in teacher_map:
                print(f"  - Profile ID {profile.id} (Subject: {profile.subject}) is already correctly linked to Teacher: {teacher_map[profile.user_id].username}")
                linked_profile_ids.add(profile.id)

        unlinked_profiles = [p for p in all_profiles if p.id not in linked_profile_ids]

        if not unlinked_profiles:
            print("\nAll TeacherProfile records seem to be correctly linked. No action needed.")
            return

        print(f"\n--- Found {len(unlinked_profiles)} potentially unlinked or mislinked profiles ---")
        
        # --- Step 3: Interactive Linking ---
        for profile in unlinked_profiles:
            print("-" * 40)
            print(f"Processing Profile ID: {profile.id}")
            print(f"  - Subject: {profile.subject}")
            print(f"  - Grade: {profile.grade}, Section: {profile.section}")
            
            # Suggest potential matches based on grade/section if possible
            # This is a heuristic and might not be accurate.
            suggested_teachers = [
                t for t in all_teachers 
                if t.grade == profile.grade and t.section == profile.section
            ]

            print("\nAvailable Teachers:")
            for i, teacher in enumerate(all_teachers):
                suggestion_marker = " (Suggested Match)" if teacher in suggested_teachers else ""
                print(f"  {i+1}) ID: {teacher.id}, Username: {teacher.username}, Name: {teacher.full_name}{suggestion_marker}")

            while True:
                choice = input("\nEnter the number of the teacher to link this profile to (or 's' to skip, 'q' to quit): ").strip().lower()
                
                if choice == 'q':
                    print("Quitting process.")
                    return
                if choice == 's':
                    print("Skipping this profile.")
                    break
                
                try:
                    choice_index = int(choice) - 1
                    if 0 <= choice_index < len(all_teachers):
                        selected_teacher = all_teachers[choice_index]
                        
                        # Confirmation before making the change
                        if click.confirm(f"\nLink Profile ID {profile.id} (Subject: {profile.subject}) to Teacher '{selected_teacher.username}'?"):
                            profile.user_id = selected_teacher.id
                            db.session.commit()
                            print(f"  [SUCCESS] Linked profile {profile.id} to {selected_teacher.username}.")
                            break
                        else:
                            print("  Operation cancelled for this profile. Please choose again.")
                            continue
                    else:
                        print("  Invalid number. Please try again.")
                except ValueError:
                    print("  Invalid input. Please enter a number, 's', or 'q'.")
        
        print("\n--- Linking Process Finished ---")

# In app.py

# Make sure these imports are at the top of your file
import click
from sqlalchemy.orm import joinedload
from sqlalchemy import select
import sys
# ... other imports ...

# ... (Your existing Flask app, models, etc.) ...


# Add this new command with your other CLI commands
@app.cli.command("link-users")
def link_users_to_secret_codes():
    """
    Links existing Users to SecretCodes if they are not already linked.

    This command iterates through all users. For each user, it checks if they
    already have an associated secret code.
    - If a link exists, it skips the user.
    - If no link exists, it searches for an available (unclaimed) SecretCode
      with a matching full_name and establishes the link by setting the
      user_id on the secret_code record.
    """
    with app.app_context():
        # Safety confirmation prompt
        if not click.confirm(
            "This command will modify the 'secret_codes' table by linking it to 'users'.\n"
            "It is highly recommended to back up your database before proceeding.\n"
            "Do you want to continue?"
        ):
            click.echo("Operation cancelled by user.")
            return

        click.echo("\n--- Starting User to Secret Code Linking Process ---")

        # Fetch all users, pre-loading the secret_code relationship
        # to prevent N+1 query issues.
        all_users = db.session.scalars(select(User).options(joinedload(User.secret_code))).all()

        if not all_users:
            click.echo("No users found in the database. Exiting.")
            return

        linked_count = 0
        skipped_count = 0
        not_found_count = 0

        # --- Main Logic Loop ---
        for user in all_users:
            # 1. Check if the user is already linked. If so, skip.
            if user.secret_code:
                skipped_count += 1
                click.echo(
                    f"[SKIP] User '{user.username}' (ID: {user.id}) is already linked."
                )
                continue

            # 2. If not linked, find a matching and available secret code.
            # An "available" code is one that has not been claimed yet (user_id is NULL).
            click.echo(f"[PROCESS] User '{user.username}' is not linked. Searching for code...")
            matching_code = db.session.scalar(
                select(SecretCode).where(
                    SecretCode.full_name == user.full_name,
                    SecretCode.user_id.is_(None)  # Most important check: is it available?
                ).limit(1) # Get the first available one
            )

            # 3. If a matching code is found, establish the link.
            if matching_code:
                # This assignment is the magic. SQLAlchemy updates the
                # secret_code.user_id column with user.id behind the scenes.
                matching_code.user = user

                linked_count += 1
                click.secho(
                    f"[SUCCESS] Linked User '{user.username}' to SecretCode ID {matching_code.id}.",
                    fg="green",
                )
            else:
                # 4. If no code is found, report it.
                not_found_count += 1
                click.secho(
                    f"[WARN] No available SecretCode found for User '{user.username}' (Full Name: '{user.full_name}').",
                    fg="yellow",
                )

        # --- Commit and Summarize ---
        if linked_count > 0:
            try:
                click.echo(f"\nCommitting {linked_count} new link(s) to the database...")
                db.session.commit()
                click.secho("Database commit successful!", fg="green", bold=True)
            except Exception as e:
                db.session.rollback()
                click.secho(f"\nERROR: An error occurred during commit: {e}", fg="red", err=True)
                click.secho("All changes have been rolled back.", fg="red", err=True)
                sys.exit(1) # Exit with an error code
        else:
            click.echo("\nNo new links were made. No changes to commit.")

        click.echo("\n--- Linking Process Summary ---")
        click.echo(f"  Users already linked (Skipped): {skipped_count}")
        click.secho(f"  New links created successfully: {linked_count}", fg="green")
        click.secho(f"  Users without a matching code: {not_found_count}", fg="yellow")
        click.echo("--- Process Complete ---")

@app.cli.command("link-parents")
def link_parents_command():
    """
    Creates parent accounts based on student last names and links them.
    - Groups students by last_name.
    - For each group, creates one parent user (e.g., 'p_lastname').
    - Generates a unique secret code for each new parent.
    - Links all students in the group to that parent.
    - Skips families where a parent account already exists.
    """
    with app.app_context():
        print("\n--- Starting Parent-Student Linking Process ---")

        # 1. Get necessary Role objects
        student_role = db.session.scalar(select(Role).filter_by(name='student'))
        parent_role = db.session.scalar(select(Role).filter_by(name='parent'))

        if not student_role or not parent_role:
            print("Error: 'student' or 'parent' role not found. Run 'flask create-initial' first.")
            return

        # 2. Pre-fetch all existing usernames and secret codes for efficiency
        print("Fetching existing user and code data...")
        existing_usernames = {u.username for u in db.session.query(User.username).all()}
        existing_secret_codes = {s.code for s in db.session.query(SecretCode.code).all()}

        # 3. Get all active students with a valid last name
        all_students = db.session.scalars(
            select(User)
            .where(
                User.role_id == student_role.id,
                User.is_active == True,
                User.last_name.isnot(None),
                User.last_name != ''
            )
            .order_by(User.last_name)
        ).all()

        if not all_students:
            print("No active students with last names found to process.")
            return

        # 4. Group students by their last name (case-insensitive)
        families = defaultdict(list)
        for student in all_students:
            # Sanitize last name for use in username
            clean_last_name = ''.join(e for e in student.last_name.lower() if e.isalnum())
            if clean_last_name:
                families[clean_last_name].append(student)

        print(f"Found {len(all_students)} students grouped into {len(families)} families.")
        
        created_parents = 0
        created_links = 0

        # 5. Iterate through each family and create/link parents
        for last_name, students_in_family in families.items():
            parent_username = f"p_{last_name}"
            family_name_display = students_in_family[0].last_name # Use original casing for display

            print(f"\nProcessing family: '{family_name_display}' ({len(students_in_family)} student(s))")
            
            # Check if a parent user for this family already exists
            parent_user = db.session.scalar(select(User).filter_by(username=parent_username))

            if parent_user:
                print(f"  [INFO] Parent user '{parent_username}' already exists. Skipping user creation.")
            else:
                # --- Create the Parent User and Secret Code ---
                print(f"  [CREATE] Creating new parent account with username '{parent_username}'.")
                
                # Generate a unique secret code for the parent
                secret_code_str = generate_parent_secret_code(db.session, existing_secret_codes)
                
                # Create User object
                parent_full_name = f"Guardian of the {family_name_display} Family"
                parent_user = User(
                    username=parent_username,
                    full_name=parent_full_name,
                    role_id=parent_role.id,
                    is_active=False,  # Parent is inactive until they complete registration
                    force_password_change=True # They must set a password
                )
                parent_user.set_password(str(uuid.uuid4())) # Set a random, unusable password
                
                # Create Parent profile object
                parent_profile = Parent(user=parent_user)
                
                # Create SecretCode object
                parent_secret_code = SecretCode(
                    code=secret_code_str,
                    full_name=parent_full_name,
                    role_id=parent_role.id
                )
                
                db.session.add(parent_user)
                db.session.add(parent_profile)
                db.session.add(parent_secret_code)
                
                created_parents += 1
                print(f"  [INFO] Generated Secret Code for '{parent_username}': {secret_code_str}")

            # --- Link all students in this family to the parent ---
            parent_profile_obj = parent_user.parent_profile
            if not parent_profile_obj:
                 # This can happen if the parent_user existed but the Parent record didn't
                 print(f"  [WARN] Parent user '{parent_username}' exists but has no Parent profile. Creating one now.")
                 parent_profile_obj = Parent(user=parent_user)
                 db.session.add(parent_profile_obj)

            for student in students_in_family:
                # Check if a link already exists
                existing_link = db.session.scalar(
                    select(ParentStudent).filter_by(parent_id=parent_profile_obj.id, student_id=student.id)
                )
                if existing_link:
                    print(f"  [SKIP] Link for student '{student.full_name}' to parent '{parent_username}' already exists.")
                else:
                    print(f"  [LINK] Linking student '{student.full_name}' to parent '{parent_username}'.")
                    new_link = ParentStudent(
                        parent=parent_profile_obj,
                        student=student,
                        verification_status='verified', # Auto-verify since admin is running this
                        verified_at=datetime.now(timezone.utc)
                    )
                    db.session.add(new_link)
                    created_links += 1

        # 6. Final commit to the database
        try:
            print("\nCommitting all changes to the database...")
            db.session.commit()
            print("Commit successful!")
        except Exception as e:
            db.session.rollback()
            print(f"\nAn error occurred during the final commit: {e}", file=sys.stderr)
            print("All changes have been rolled back.")
            return

        print("\n--- Linking Process Summary ---")
        print(f"New Parent Accounts Created: {created_parents}")
        print(f"New Parent-Student Links Created: {created_links}")
        print("--- Process Complete ---")
# In app.py, replace the populate-labs command with this one

@app.cli.command("populate-labs")
def populate_labs_command():
    """
    Clears and repopulates the Lab table with standardized classroom and subject labs.
    WARNING: This is a destructive operation on the Lab table.
    """
    with app.app_context():
        if not click.confirm(
            "\nWARNING: This will DELETE all existing entries in the 'lab' table and repopulate it.\n"
            "This will also UNASSIGN all users and assets from their current labs.\n"
            "This is a destructive action. Make sure you have a backup.\n"
            "Do you want to continue?"
        ):
            print("Operation cancelled by user.")
            return

        print("\n--- Starting Lab Population Process ---")
        try:
            print("1. Un-assigning all users from their current labs...")
            user_update_count = db.session.query(User).update({User.lab_id: None})
            print(f"   Cleared lab assignments for {user_update_count} users.")

            print("2. Un-assigning all assets from their current labs...")
            asset_update_count = db.session.query(Asset).update({Asset.lab_id: None})
            print(f"   Cleared lab assignments for {asset_update_count} assets.")

            db.session.commit()
            print("   Un-assignment complete.")

            print("\n3. Clearing all existing records from the Lab table...")
            num_deleted = db.session.query(Lab).delete()
            print(f"   Deleted {num_deleted} existing lab records.")
            
            lab_names_to_add = set()

            print("\n4. Creating Classroom Labs from unique Grade/Section pairs in the User table...")
            student_role = db.session.scalar(select(Role).filter_by(name='student'))
            if student_role:
                # --- THIS IS THE FIX ---
                # The checks for `!= ''` have been removed. `isnot(None)` is all that's needed for an Integer column.
                grade_section_pairs_query = (
                    select(User.grade, User.section)
                    .where(
                        User.role_id == student_role.id,
                        User.is_active == True,
                        User.grade.isnot(None),  # Keep this check
                        User.section.isnot(None) # Keep this check
                    )
                    .distinct()
                )
                # --- END OF FIX ---
                
                grade_section_pairs = db.session.execute(grade_section_pairs_query).all()

                for grade, section in grade_section_pairs:
                    lab_name = f"Grade {grade} - Section {section}"
                    if lab_name not in lab_names_to_add:
                        new_lab = Lab(
                            name=lab_name,
                            lab_type='classroom',
                            grade=str(grade),
                            section=str(section),
                            subject=None
                        )
                        db.session.add(new_lab)
                        lab_names_to_add.add(lab_name)
                        print(f"   - Added: {lab_name}")

            print("\n5. Creating Subject Labs from unique subjects in the TeacherProfile table...")
            subjects = db.session.scalars(
                select(TeacherProfile.subject).where(
                    TeacherProfile.subject.isnot(None),
                    TeacherProfile.subject != ''
                ).distinct()
            ).all()

            for subject in subjects:
                lab_name = f"{subject} Lab"
                if lab_name not in lab_names_to_add:
                    new_lab = Lab(
                        name=lab_name,
                        lab_type='subject',
                        grade=None,
                        section=None,
                        subject=subject
                    )
                    db.session.add(new_lab)
                    lab_names_to_add.add(lab_name)
                    print(f"   - Added: {lab_name}")
            
            print("\n6. Adding essential facility labs...")
            essential_labs = ["Main Library", "Talent Club HQ", "General Storage"]
            for lab_name in essential_labs:
                if lab_name not in lab_names_to_add:
                    new_lab = Lab(name=lab_name, lab_type='facility')
                    db.session.add(new_lab)
                    lab_names_to_add.add(lab_name)
                    print(f"   - Added Essential Lab: {lab_name}")

            print("\n7. Committing all new lab records to the database...")
            db.session.commit()
            print(f"\n--- Process Complete! Successfully added {len(lab_names_to_add)} labs. ---")

        except Exception as e:
            db.session.rollback()
            print(f"\nAn error occurred: {e}", file=sys.stderr)
            print("The transaction has been rolled back. No changes were saved to the database.")
            
# In app.py, add this to PART 15 with other CLI commands

@app.cli.command("migrate-students")
def migrate_students_command():
    """
    Synchronizes data from the User table to the Student table for all student-role users.

    This command will:
    1. Find all active users with the 'student' role.
    2. For each student user, check if a corresponding record exists in the 'students' table.
       - If it does NOT exist, a new Student record is created using the User's grade and section.
       - If it DOES exist, it checks if the grade/section are in sync and updates them if they are not.
    
    WARNING: This command directly modifies the 'students' table. Please back up your database first.
    """
    with app.app_context():
        # Safety confirmation prompt
        if not click.confirm(
            "This will create or update records in the 'students' table based on data from the 'users' table.\n"
            "It is highly recommended to back up your database before proceeding.\n"
            "Do you want to continue?"
        ):
            click.echo("Operation cancelled by user.")
            return
            
        click.echo("\n--- Starting Student Data Migration (User -> Student) ---")

        try:
            # 1. Verify the student role and its ID
            click.echo("1. Verifying student role...")
            student_role = db.session.scalar(select(Role).filter_by(name='student'))
            
            if not student_role:
                click.secho("ERROR: The 'student' role was not found in the 'role' table. Cannot proceed.", fg='red', err=True)
                sys.exit(1)
            
            # As requested, check if the student role ID is 8.
            if student_role.id == 8:
                click.secho(f"  [OK] Found 'student' role with the expected ID: {student_role.id}.", fg='green')
            else:
                click.secho(f"  [WARN] The 'student' role was found, but its ID is {student_role.id}, not 8.", fg='yellow')
                click.secho("         The migration will proceed using the found ID.", fg='yellow')

            # 2. Fetch all active student users, eager-loading their existing student record
            click.echo("\n2. Fetching all active student users...")
            student_users_query = (
                select(User)
                .where(User.role_id == student_role.id, User.is_active == True)
                .options(joinedload(User.student)) # Eager load to avoid N+1 queries
            )
            all_student_users = db.session.scalars(student_users_query).all()

            if not all_student_users:
                click.echo("No active users with the 'student' role found. Nothing to migrate.")
                return
            
            click.echo(f"   Found {len(all_student_users)} student users to process.")

            # 3. Initialize counters and process each user
            created_count = 0
            updated_count = 0
            skipped_count = 0
            
            click.echo("\n3. Processing records...")
            for user in all_student_users:
                existing_student_record = user.student # Access the pre-loaded record

                if not existing_student_record:
                    # --- CREATE new Student record ---
                    click.echo(f"  - [CREATE] No Student record for '{user.username}'. Creating one...")
                    new_student_record = Student(
                        user_id=user.id,
                        grade=user.grade,
                        section=user.section
                    )
                    db.session.add(new_student_record)
                    created_count += 1
                else:
                    # --- UPDATE existing Student record if needed ---
                    is_changed = False
                    if existing_student_record.grade != user.grade:
                        click.echo(f"    - [UPDATE] Syncing grade for '{user.username}': '{existing_student_record.grade}' -> '{user.grade}'")
                        existing_student_record.grade = user.grade
                        is_changed = True
                    
                    if existing_student_record.section != user.section:
                        click.echo(f"    - [UPDATE] Syncing section for '{user.username}': '{existing_student_record.section}' -> '{user.section}'")
                        existing_student_record.section = user.section
                        is_changed = True
                    
                    if is_changed:
                        updated_count += 1
                    else:
                        skipped_count += 1
            
            # 4. Commit changes to the database
            if created_count > 0 or updated_count > 0:
                click.echo("\n4. Committing changes to the database...")
                db.session.commit()
                click.secho("   Commit successful!", fg='green')
            else:
                click.echo("\n4. No new records or updates to commit.")

            # 5. Print summary
            click.echo("\n--- Migration Summary ---")
            click.secho(f"  New Student records created: {created_count}", fg='cyan')
            click.secho(f"  Existing Student records updated: {updated_count}", fg='cyan')
            click.echo(f"  Up-to-date records skipped: {skipped_count}")
            click.secho("\nMigration process complete.", bold=True)

        except Exception as e:
            db.session.rollback()
            click.secho(f"\nAn unexpected error occurred: {e}", fg='red', err=True)
            click.secho("The database transaction has been rolled back. No changes were saved.", fg='red', err=True)
            sys.exit(1)            

if __name__ == "__main__":
    # If you are using Flask-SocketIO, you should run the app using socketio.run()
    # in the main execution block, not app.run().
    # Using host='0.0.0.0' makes the server accessible on your local network.
    print("Starting Nexus server...")
    # MODIFIED: Changed host to '0.0.0.0' to make it accessible on the local network.
    socketio.run(app, host="0.0.0.0", port=5000, debug=app.debug)
    # For production, use a production WSGI server like Gunicorn with gevent/eventlet workers for SocketIO.

    # Example production start: gunicorn --worker-class eventlet -w 1 app:app

# --- PART 15 END ---
