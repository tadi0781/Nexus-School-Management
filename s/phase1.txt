===== PHASE 1: CORE FRAMEWORK & LAYOUT =====
# --- Imports ---
import logging
import os
from collections import defaultdict
from datetime import datetime, timedelta, timezone
from functools import wraps
import uuid
from logging.handlers import RotatingFileHandler
import humanize
from markupsafe import Markup
from collections import defaultdict
from flask import (
    Flask,
    abort,
    flash,
    redirect,
    render_template,
    request,
    session,
    url_for,
    make_response,
    jsonify,  # Keep for future AJAX
    send_from_directory,
    current_app
)
from flask_login import (
    LoginManager,
    UserMixin,
    current_user,
    login_required,
    login_user,
    logout_user,
)
from flask_migrate import Migrate
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy
from flask_wtf import FlaskForm
from flask_wtf.file import FileAllowed, FileField
from flask_socketio import SocketIO, emit, join_room, leave_room

# Keep if using
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.routing import BuildError
from werkzeug.utils import secure_filename  # For file uploads
from werkzeug.urls import url_parse  # For safe redirects
from werkzeug.exceptions import NotFound  # For send_from_directory
from flask_wtf.csrf import CSRFProtect, generate_csrf as wtf_generate_csrf
from sqlalchemy import (
    desc,
    exc,
    func,
    select,
    over,
    event,
    UniqueConstraint,
    Index,
    or_,
    and_,
    text,
    Column,
    Integer,
    String,
    ForeignKey,
    Date,
    Boolean,
    Text,
    case,
    literal_column,
)
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import joinedload, relationship
from sqlalchemy.ext.associationproxy import association_proxy

from wtforms import (
    BooleanField,
    DateField,
    FieldList,
    FormField,
    PasswordField,
    SelectField,
    StringField,
    SubmitField,
    TextAreaField,
    IntegerField,
    FloatField,
    HiddenField,
    RadioField
    # FileField is already imported via flask_wtf.file
)
from wtforms.validators import (
    DataRequired,
    Email,
    EqualTo,
    Length,
    Optional,
    Regexp,
    ValidationError,
    NumberRange,
    URL
)

# --- Your Model Imports ---
# from .models import User, Role, SecretCode, AssetCategory, Lab, Message, Notification
# --- Your Form Imports ---
# from .forms import LoginForm, PreForm

# =================================================================
# GEMINI 3 PRO: PHASE 3.1 - High-Performance Caching with Redis
# =================================================================
from flask_caching import Cache

# --- Application Setup ---
app = Flask(__name__)

# Configure cache (moved *after* app creation)
config = {
    "DEBUG": True,
    "CACHE_TYPE": "RedisCache",
    "CACHE_REDIS_URL": "redis://localhost:6379/0",
    "CACHE_DEFAULT_TIMEOUT": 300  # Default 5-minute cache
}
app.config.from_mapping(config)
cache = Cache(app)


# --- (Your Session Configuration) ---
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"


# --- (Your General Application Configuration - SECRET_KEY, SQLALCHEMY_DATABASE_URI) ---
app.config["ENV_MODE"] = os.getenv("APP_ENV", "development")
if app.config["ENV_MODE"] == "development":
    app.config["SECRET_KEY"] = "your_strong_development_secret_key_here"  # CHANGE THIS IN PRODUCTION
    app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 0
    app.config["TEMPLATES_AUTO_RELOAD"] = True
    app.debug = True
    print("Running in development mode")
else:
    app.config["SECRET_KEY"] = os.getenv("SECRET_KEY")
    if not app.config["SECRET_KEY"]:
        raise ValueError("No SECRET_KEY set for Flask application in production")
    app.debug = True
    print(f"Running in {app.config['ENV_MODE']} mode")

# NOTE: SQLALCHEMY_DATABASE_URI and TRACK_MODIFICATIONS are now set *before* db initialization
app.config["SQLALCHEMY_DATABASE_URI"] = "postgresql://classicboy0781:nexus@localhost/nexus"  # CHANGE THIS IN PRODUCTION
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False


# --- Initialize SQLAlchemy  ---
db = SQLAlchemy()
db.init_app(app) # Initialize SQLAlchemy with the app


# Development-specific settings (already mostly covered above, but ensures clarity)
# Removed redundant settings - Keeping only what's truly needed

# --- ADDED: Social Media File Upload Configuration ---
# Define directory for uploaded files (create if it doesn't exist)
UPLOAD_FOLDER = os.path.join(app.root_path, 'uploads', 'social_files')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Optional: Configure max file size (e.g., 16MB)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 megabytes
# --- END ADDED ---


# --- ADDED THIS LOGGING SETUP SECTION ---
# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')
app.logger.setLevel(logging.INFO)

# Optional: Configure file handler for production logging
if not app.debug:
    file_handler = RotatingFileHandler('app.log', maxBytes=1024000, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.info('Nexus school management system startup')

Session(app)
socketio = SocketIO(app)
csrf = CSRFProtect(app)
# --- PART 1 END ---
# --- PART 2 START: Model Definitions ---

class Role(db.Model):
    __tablename__ = "role"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)

    users = db.relationship("User", back_populates="role", lazy="dynamic")
    secret_codes = db.relationship("SecretCode", back_populates="role", lazy=True)

    def __repr__(self):
        return f"<Role {self.name}>"

class Lab(db.Model):
    __tablename__ = "lab"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)

    lab_assignments = db.relationship("User", back_populates="lab", lazy="dynamic")

    def __repr__(self):
        return f"<Lab {self.name}>"

class AssetCategory(db.Model):
    __tablename__ = 'asset_category'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    description = db.Column(db.Text)

    assets = db.relationship("Asset", back_populates="category", lazy="dynamic")
    # channels = db.relationship('Channel', back_populates='category', lazy='dynamic')

    def __repr__(self):
        return f"<AssetCategory {self.name}>"

# ADD THIS NEW MODEL DEFINITION:
class SocialCategory(db.Model):
    __tablename__ = 'social_category'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    description = db.Column(db.Text)

    channels = db.relationship('Channel', back_populates='social_category', lazy='dynamic')

    def __repr__(self):
        return f"<SocialCategory {self.name}>"

class Message(db.Model):
    __tablename__ = "message"
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    receiver_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    sender_role = db.Column(db.String(50))
    receiver_role = db.Column(db.String(50))
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), index=True)
    is_read = db.Column(db.Boolean, default=False, index=True)

    sender = db.relationship("User", foreign_keys=[sender_id], back_populates="sent_messages")
    receiver = db.relationship("User", foreign_keys=[receiver_id], back_populates="received_messages")

    def __repr__(self):
        return f"<Message from {self.sender_id} to {self.receiver_id} at {self.timestamp}>"

    __table_args__ = (
        db.Index('idx_message_pair', 'sender_id', 'receiver_id'),
        db.Index('idx_message_status', 'is_read'),
        db.Index('idx_message_timestamp', 'timestamp'),
    )

# --- NEW MODELS: Task System (Ordered correctly) ---

# Define UserTask first as Task depends on it for relationship definition
class UserTask(db.Model):
    __tablename__ = 'user_task'
    id = db.Column(db.Integer, primary_key=True)
    task_id = db.Column(db.Integer, db.ForeignKey('task.id'), nullable=False, index=True) # <-- FK to task
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # <-- FK to assigned user

    assigned_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    assigned_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # <-- FK to assigning user

    # Status specific to THIS user's assignment
    status = db.Column(db.String(30), nullable=False, default='Open', index=True) # e.g., 'Open', 'In Progress', 'Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Accepted', 'Review Rejected'
    completion_notes = db.Column(db.Text, nullable=True) # Notes from assigned user (Completed, Delayed, Rejected)
    last_status_update_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)

    reviewed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True) # <-- FK to the reviewer

    reviewed_at = db.Column(db.DateTime, nullable=True)
    reviewer_notes = db.Column(db.Text, nullable=True) # Notes from creator during review

    # Relationships
    # Note: task relationship must be defined *after* Task class is defined, but SQLAlchemy allows string name
    task = db.relationship('Task', back_populates='user_assignments')

    # Specify the foreign_keys for the 'user' relationship to point to user_id
    user = db.relationship(
        'User',
        foreign_keys=[user_id],  # Use the user_id column
        back_populates='assigned_tasks' # Ensure this back_populates exists on User model
    )

    # Specify the foreign_keys for the 'assigned_by' relationship to point to assigned_by_id
    assigned_by = db.relationship(
        'User',
        foreign_keys=[assigned_by_id], # Use the assigned_by_id column
        back_populates='assigned_tasks_instances' # Ensure this back_populates exists on User model
    )

    # ADD a new relationship for the 'reviewed_by' foreign key (Fix from previous exchange)
    reviewed_by = db.relationship(
        'User',
        foreign_keys=[reviewed_by_id], # Use the reviewed_by_id column
        back_populates='reviewed_tasks_instances' # This will be defined on the User model
    )


    history = db.relationship('TaskHistory', back_populates='user_task', lazy='dynamic', cascade='all, delete-orphan')

    __table_args__ = (
        db.UniqueConstraint('task_id', 'user_id', name='_task_user_uc'), # A user gets one instance per task instruction
        db.Index('idx_user_task_user_status', 'user_id', 'status'),
        db.Index('idx_user_task_task_status', 'task_id', 'status'),
        db.Index('idx_user_task_reviewed_by', 'reviewed_by_id'), # Optional: Add index for reviewed_by
    )


    def __repr__(self):
        return f"<UserTask ID:{self.id} Task:{self.task_id} User:{self.user_id} Status:'{self.status}'>"

# Define Task after UserTask
class Task(db.Model):
    __tablename__ = 'task'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    urgency = db.Column(db.String(20), nullable=False, default='Medium') # e.g., 'Low', 'Medium', 'High', 'Critical'
    due_date = db.Column(db.Date, nullable=True) # Overall task due datehkj

    created_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    last_updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    created_by = db.relationship('User', back_populates='created_tasks')
    # UserTask is defined BEFORE Task now, so the string name 'UserTask' is resolvable
    user_assignments = db.relationship('UserTask', back_populates='task', lazy='dynamic', cascade='all, delete-orphan')

    __table_args__ = (
        db.Index('idx_task_creator', 'created_by_id'),
        db.Index('idx_task_created_at', 'created_at'),
    )

    def __repr__(self):
        return f"<Task ID:{self.id} Title:'{self.title}' CreatedBy:{self.created_by_id}>"

# Define TaskHistory after UserTask (as it depends on UserTask)
class TaskHistory(db.Model):
    __tablename__ = 'task_history'
    id = db.Column(db.Integer, primary_key=True)
    user_task_id = db.Column(db.Integer, db.ForeignKey('user_task.id'), nullable=False, index=True)
    changed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # User who initiated the change

    old_status = db.Column(db.String(30), nullable=True) # Can be null for initial assignment
    new_status = db.Column(db.String(30), nullable=False)
    action = db.Column(db.String(50), nullable=False) # e.g., 'Assigned', 'Status Update', 'Review Accepted', 'Review Rejected'
    notes = db.Column(db.Text, nullable=True) # Notes relevant to this history entry (e.g., copied from completion_notes or reviewer_notes)

    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)

    # Relationships
    user_task = db.relationship('UserTask', back_populates='history')
    changed_by = db.relationship('User', back_populates='task_history_entries')

    __table_args__ = (
        db.Index('idx_task_history_usertask_ts', 'user_task_id', 'timestamp'),
    )

    def __repr__(self):
        return f"<TaskHistory ID:{self.id} UserTask:{self.user_task_id} Action:'{self.action}' New Status:'{self.new_status}'>"


# Define User Model (includes all previous relationships + the fix)
class User(db.Model, UserMixin):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=True, index=True)
    password_hash = db.Column(db.String(128), nullable=False)
    first_name = db.Column(db.String(50), nullable=True)
    last_name = db.Column(db.String(50), nullable=True)
    full_name = db.Column(db.String(120), nullable=False, index=True)
    date_of_birth = db.Column(db.Date, nullable=True)
    gender = db.Column(db.String(20), nullable=True)
    phone = db.Column(db.String(20), nullable=True)
    address = db.Column(db.Text, nullable=True)
    is_active = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    last_login = db.Column(db.DateTime, nullable=True)
    is_leader = db.Column(db.Boolean, default=False, nullable=False)
    force_password_change = db.Column(db.Boolean, default=False, nullable=False)
    is_tc_leader = db.Column(db.Boolean, default=False, nullable=False)
    is_tc_member = db.Column(db.Boolean, default=False, nullable=False)
    leader_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True)
    age = db.Column(db.Integer, nullable=True)
    sex = db.Column(db.String(20), nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)
    grade = db.Column(db.String(10), nullable=True, index=True)
    section = db.Column(db.String(10), nullable=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('role.id'), nullable=False)
    lab_id = db.Column(db.Integer, db.ForeignKey('lab.id'), nullable=True)
    channel_preferences = db.relationship('UserChannelPreference', foreign_keys='UserChannelPreference.user_id', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    custom_channel_categories = db.relationship('UserChannelCategory', foreign_keys='UserChannelCategory.user_id', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
# --- End of User model additions for channel preferences ---  
    # --- Add this relationship to your User model ---
    saved_items = db.relationship('UserSavedItem', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    # --- End of User model addition for saved_items ---
    global_posts = db.relationship('GlobalPost', foreign_keys='GlobalPost.author_id', back_populates='author', lazy='dynamic', cascade='all, delete-orphan')
    global_comments = db.relationship('GlobalComment', foreign_keys='GlobalComment.author_id', back_populates='author', lazy='dynamic', cascade='all, delete-orphan')
    global_likes = db.relationship('GlobalLike', foreign_keys='GlobalLike.user_id', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    # --- End of User model additions ---
    # Relationships
    role = db.relationship("Role", back_populates="users")
    lab = db.relationship("Lab", back_populates="lab_assignments")
    leader = db.relationship('User', remote_side=[id], backref=db.backref('followers', lazy='dynamic'))

    # Message relationships using Column objects
    sent_messages = db.relationship("Message", foreign_keys=[Message.sender_id], back_populates="sender", lazy="dynamic")
    received_messages = db.relationship("Message", foreign_keys=[Message.receiver_id], back_populates="receiver", lazy="dynamic")

    # Other relationships (using string references)
    submitted_requests = db.relationship('Request', foreign_keys='Request.requester_id', back_populates='requester', lazy='dynamic')
    assigned_requests = db.relationship('Request', foreign_keys='Request.current_handler_id', back_populates='current_handler', lazy='dynamic')
    forwarded_requests = db.relationship('Request', foreign_keys='Request.last_forwarded_by_id', back_populates='last_forwarded_by', lazy='dynamic')
    request_history_entries = db.relationship('RequestHistory', back_populates='changed_by', lazy='dynamic')
    staff_attendance_records = db.relationship("StaffAttendance", back_populates="user", lazy="dynamic")
    attendance_entries = db.relationship("Attendance", back_populates="student", lazy="dynamic")
    parent_profile = db.relationship("Parent", back_populates="user", uselist=False)
    teacher_profiles = db.relationship("TeacherProfile", back_populates="user", lazy="dynamic")
    sent_notifications = db.relationship("Notification", foreign_keys="Notification.sender_id", back_populates="sender", lazy="dynamic")
    received_notifications = db.relationship("Notification", foreign_keys="Notification.receiver_id", back_populates="receiver", lazy="dynamic")
    marks = db.relationship('Mark', back_populates='student', lazy="dynamic")
    added_assets = db.relationship("Asset", back_populates="added_by_user", lazy="dynamic")
    submitted_reports = db.relationship("AssetReport", foreign_keys="AssetReport.reported_by_id", back_populates="reporter", lazy="dynamic")
    resolved_reports = db.relationship("AssetReport", foreign_keys="AssetReport.resolved_by_id", back_populates="resolver", lazy="dynamic")
    book_checkouts = db.relationship("BookCheckout", back_populates="user", lazy="dynamic")
    borrowed_assets = db.relationship('BorrowedAsset', back_populates='user', lazy='dynamic')
    channel_posts = db.relationship("ChannelPost", back_populates="author", lazy="dynamic")
    channel_comments = db.relationship("ChannelComment", back_populates="author", lazy="dynamic")
    channel_reactions = db.relationship("ChannelReaction", back_populates="user", lazy="dynamic")
    group_messages = db.relationship("GroupMessage", back_populates="author", lazy="dynamic")
    social_group_memberships = db.relationship("SocialGroupMember", back_populates="user", lazy="dynamic")
    owned_channels = db.relationship("Channel", back_populates="owner", lazy="dynamic")
    owned_social_groups = db.relationship("SocialGroup", foreign_keys="SocialGroup.owner_id", back_populates="owner", lazy="dynamic")
    uploaded_social_files = db.relationship("File", back_populates="uploader", lazy="dynamic")
    parent_associations = db.relationship("ParentStudent", back_populates="student")
    behavior_records = db.relationship("BehaviorRecord", foreign_keys="BehaviorRecord.student_id", back_populates="student", lazy="dynamic")
    recorded_behavior_records = db.relationship("BehaviorRecord", foreign_keys="BehaviorRecord.recorded_by_id", back_populates="recorded_by", lazy="dynamic")
    channel_subscriptions = db.relationship('ChannelSubscriber', back_populates='user', lazy='dynamic')
    tc_memberships = db.relationship('TalentClubMembership', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    tc_follows = db.relationship('TalentClubFollow', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    owned_talent_clubs = db.relationship('TalentClub', back_populates='owner', lazy='dynamic')
    tc_leader_election_initiated = db.relationship(
        'TalentClubLeaderElection',
        foreign_keys='TalentClubLeaderElection.initiated_by_id',
        back_populates='initiated_by',
        lazy='dynamic'
    )
    tc_leader_votes_cast = db.relationship(
        'TalentClubLeaderVote',
        foreign_keys='TalentClubLeaderVote.voter_id',
        back_populates='voter',
        lazy='dynamic'
    )
    tc_bans_issued = db.relationship('TalentClubBan', foreign_keys='TalentClubBan.issued_by_id', back_populates='issued_by', lazy='dynamic')
    tc_bans_received = db.relationship('TalentClubBan', foreign_keys='TalentClubBan.user_id', back_populates='user', lazy='dynamic')
    tc_penalties_issued = db.relationship('TalentClubPenalty', foreign_keys='TalentClubPenalty.issued_by_id', back_populates='issued_by', lazy='dynamic')
    tc_penalties_received = db.relationship('TalentClubPenalty', foreign_keys='TalentClubPenalty.user_id', back_populates='user', lazy='dynamic')
    tc_proposals_created = db.relationship(
        'TalentClubProposal',
        foreign_keys='TalentClubProposal.creator_id',
        back_populates='creator',
        lazy='dynamic',
        cascade='all, delete-orphan'
    )
    tc_mentions_received = db.relationship('TalentClubMention', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')

    # Task System Relationships
    created_tasks = db.relationship('Task', back_populates='created_by', lazy='dynamic') # Tasks created by this user
    assigned_tasks_instances = db.relationship('UserTask', foreign_keys='UserTask.assigned_by_id', back_populates='assigned_by', lazy='dynamic') # UserTask instances assigned by this user
    assigned_tasks = db.relationship('UserTask', foreign_keys='UserTask.user_id', back_populates='user', lazy='dynamic') # UserTask instances assigned *to* this user
    task_history_entries = db.relationship('TaskHistory', back_populates='changed_by', lazy='dynamic') # History entries created by this user

    # *** FIX: ADDED THE MISSING RELATIONSHIP *** (Confirmed this is present)
    reviewed_tasks_instances = db.relationship(
        'UserTask',
        foreign_keys='UserTask.reviewed_by_id',
        back_populates='reviewed_by',
        lazy='dynamic'
    )

    # --- METHODS ---

    def set_password(self, password):
        # Assumes generate_password_hash is available globally
        from werkzeug.security import generate_password_hash # Local import for method
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        # Assumes check_password_hash is available globally
        from werkzeug.security import check_password_hash # Local import for method
        return check_password_hash(self.password_hash, password)

    # --- FLASK-LOGIN PROPERTIES ---
    # These properties are handled by inheriting from UserMixin

    # @property
    # def is_authenticated(self):
    #     return True

    # @property
    # def is_active(self):
    #     # Refers to the is_active column
    #     return self.is_active # This should likely return self.is_active

    # @property
    # def is_anonymous(self):
    #     return False

    # def get_id(self):
    #     # Returns the primary key as a string
    #     return str(self.id)

    # --- SOCIAL MEDIA HELPERS ---
    # These should ideally be methods of the User model

    def is_channel_member(self, channel):
        # Assumes select, ChannelSubscriber are available globally
        if not channel or not self.is_authenticated:
            return False
        # Ensure context is available if called outside a request
        try:
            return db.session.scalar(
                select(ChannelSubscriber).where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.user_id == self.id
                )
            ) is not None
        except Exception as e:
            current_app.logger.error(f"Error in is_channel_member for user {self.id}, channel {channel.id}: {e}", exc_info=True)
            return False


    def get_channel_role(self, channel):
        # Assumes select, ChannelSubscriber, joinedload are available globally
        if not channel or not self.is_authenticated:
            return None
        try:
            subscription = db.session.scalar(
                select(ChannelSubscriber).where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.user_id == self.id
                ).options(joinedload(ChannelSubscriber.user), joinedload(ChannelSubscriber.channel))
            )
            return subscription.role if subscription else None
        except Exception as e:
            current_app.logger.error(f"Error in get_channel_role for user {self.id}, channel {channel.id}: {e}", exc_info=True)
            return None


    def is_group_member(self, group):
        # Assumes select, SocialGroupMember are available globally
        if not group or not self.is_authenticated:
            return False
        try:
            return db.session.scalar(
                select(SocialGroupMember).where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.user_id == self.id
                )
            ) is not None
        except Exception as e:
            current_app.logger.error(f"Error in is_group_member for user {self.id}, group {group.id}: {e}", exc_info=True)
            return False


    def get_group_role(self, group):
        # Assumes select, SocialGroupMember, joinedload are available globally
        if not group or not self.is_authenticated:
            return None
        try:
            membership = db.session.scalar(
                select(SocialGroupMember).where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.user_id == self.id
                ).options(joinedload(SocialGroupMember.user), joinedload(SocialGroupMember.group))
            )
            return membership.role if membership else None
        except Exception as e:
            current_app.logger.error(f"Error in get_group_role for user {self.id}, group {group.id}: {e}", exc_info=True)
            return None


    def __repr__(self):
        return f"<User ID:{self.id} Username:'{self.username}' Role:'{self.role.name if self.role else 'N/A'}'>"

    # __table_args__ (optional, indexes already defined on columns or via tuple)

# Social Media Group Model (The correct one)
class SocialGroup(db.Model):
    __tablename__ = 'social_groups'
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False, unique=True, index=True)
    description = Column(String(255))
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True)
    is_active = db.Column(db.Boolean, default=True, nullable=False)

    owner = db.relationship('User', foreign_keys=[owner_id], back_populates='owned_social_groups')
    members = db.relationship("SocialGroupMember", back_populates="group", lazy="dynamic", cascade="all, delete-orphan")
    messages = db.relationship('GroupMessage', back_populates='group', lazy='dynamic', cascade='all, delete-orphan') # Reciprocal

    def __repr__(self):
        return f"<SocialGroup(name='{self.name}')>"

# Social Media Group Membership (The correct one)
class SocialGroupMember(db.Model):
    __tablename__ = 'social_group_members'
    group_id = db.Column(db.Integer, db.ForeignKey('social_groups.id'), primary_key=True) # Correct FK to social_groups
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)

    role = db.Column(db.String(20), default='member', nullable=False)
    joined_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    group = db.relationship('SocialGroup', back_populates='members') # Correct back_populates name
    user = db.relationship('User', back_populates='social_group_memberships', foreign_keys=[user_id]) # Correct back_populates name and add FK

    __table_args__ = (UniqueConstraint('group_id', 'user_id', name='_group_user_uc'),)

    def __repr__(self):
         return f"<SocialGroupMember UserID:{self.user_id} in GroupID:{self.group_id} as {self.role}>"


# Other Supporting Models
class SecretCode(db.Model):
    __tablename__ = "secret_code"
    id = db.Column(db.Integer, primary_key=True)
    code = db.Column(db.String(20), unique=True, nullable=False, index=True)
    full_name = db.Column(db.String(120), nullable=False)
    role_id = db.Column(db.Integer, db.ForeignKey('role.id'), nullable=False)
    is_used = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    teacher_profiles = db.relationship('TeacherProfile', back_populates='secret_code')

    role = db.relationship('Role', back_populates='secret_codes')

    def __repr__(self):
        return f"<SecretCode {self.code} (Role: {self.role.name if self.role else 'N/A'}) Used: {self.is_used}>"

class TeacherProfile(db.Model):
    __tablename__ = "teacher_profile"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    secret_code_id = db.Column(db.Integer, db.ForeignKey('secret_code.id'), nullable=True, index=True)

    subject = db.Column(db.String(100), nullable=False)
    salary = db.Column(db.Float, nullable=True)
    grade = db.Column(db.String(10), nullable=True)
    section = db.Column(db.String(10), nullable=True)

    secret_code = db.relationship('SecretCode', back_populates='teacher_profiles')
    user = db.relationship("User", back_populates="teacher_profiles")

    __table_args__ = (
        db.UniqueConstraint('user_id', 'secret_code_id', 'grade', 'section', name='uq_teacher_profile_assignment'),
        db.Index('idx_teacher_profile_user', 'user_id'),
        db.Index('idx_teacher_profile_secret_code', 'secret_code_id'),
        db.Index('idx_teacher_profile_grade_section', 'grade', 'section'),
    )

    def __repr__(self):
        return f"<TeacherProfile UserID: {self.user_id}, Subject: {self.subject}, Grade/Section: {self.grade}/{self.section}>"

class Student(db.Model):
    __tablename__ = 'students'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True)
    grade = db.Column(db.String(10))
    section = db.Column(db.Integer)
    # Add other student-specific fields
    
    # Relationship to User
    user = db.relationship('User', backref=db.backref('student', uselist=False))


# ... (rest of your app.py code) ...
class ParentStudent(db.Model):
    """Association table between parents and their students"""
    __tablename__ = 'parent_student'
    parent_id = db.Column(db.Integer, db.ForeignKey('parent.id'), primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    verification_status = db.Column(db.String(20), default='pending')
    relationship = db.Column(db.String(50))
    verified_at = db.Column(db.DateTime, nullable=True)

    parent = db.relationship('Parent', back_populates='student_associations')
    student = db.relationship('User', back_populates='parent_associations')

class Parent(db.Model):
    __tablename__ = 'parent'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True, nullable=False)

    preferred_contact_method = db.Column(db.String(20), default='email')
    receive_grade_updates = db.Column(db.Boolean, default=True)
    receive_behavior_updates = db.Column(db.Boolean, default=True)

    user = db.relationship('User', back_populates='parent_profile')
    student_associations = db.relationship('ParentStudent', back_populates='parent', cascade='all, delete-orphan')
    students = association_proxy('student_associations', 'student',
                                creator=lambda student: ParentStudent(student=student))
                                
class BehaviorRecord(db.Model):
    __tablename__ = "behavior_record"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    recorded_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    date = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    behavior_type = db.Column(db.String(50), nullable=False)
    description = db.Column(db.Text, nullable=False)
    severity = db.Column(db.String(20), default='Medium', nullable=False)
    resolution = db.Column(db.Text, nullable=True)
    is_resolved = db.Column(db.Boolean, default=False, nullable=False, index=True)

    student = db.relationship('User', foreign_keys=[student_id], back_populates='behavior_records')
    recorded_by = db.relationship('User', foreign_keys=[recorded_by_id], back_populates='recorded_behavior_records')

    __table_args__ = (
        db.Index('idx_behavior_student_date', 'student_id', 'date'),
    )

    def __repr__(self):
        return f"<BehaviorRecord ID:{self.id} Student:{self.student_id} Type:{self.behavior_type} Date:{self.date.strftime('%Y-%m-%d')}>"

# --- NEW MODELS: Request System ---

class Request(db.Model):
    __tablename__ = 'request'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    request_type = db.Column(db.String(50), nullable=False) # e.g., 'Deficiency', 'Purchase', 'General'
    urgency = db.Column(db.String(20), nullable=False, default='Medium') # e.g., 'Low', 'Medium', 'High', 'Critical'

    requester_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    current_handler_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True)
    last_forwarded_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True) # Who last forwarded it

    status = db.Column(db.String(20), nullable=False, default='Pending', index=True) # e.g., 'Pending', 'Approved', 'On Progress', 'Denied', 'Resolved'
    tier = db.Column(db.Integer, nullable=False, default=1, index=True) # 1: HR/CEO, 2: School Exec, 3: Government

    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    last_updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)

    resolution_notes = db.Column(db.Text, nullable=True) # Notes from handlers during review/resolution
    denial_reason = db.Column(db.Text, nullable=True) # Reason for denial, if status is 'Denied'

    # Relationships
    requester = db.relationship('User', foreign_keys=[requester_id], back_populates='submitted_requests')
    current_handler = db.relationship('User', foreign_keys=[current_handler_id], back_populates='assigned_requests')
    last_forwarded_by = db.relationship('User', foreign_keys=[last_forwarded_by_id], back_populates='forwarded_requests')

    history = db.relationship('RequestHistory', back_populates='request', lazy='dynamic', cascade='all, delete-orphan')

    __table_args__ = (
        db.Index('idx_request_status_tier', 'status', 'tier'),
        db.Index('idx_request_requester_status', 'requester_id', 'status'),
    )

    def __repr__(self):
        return f"<Request ID:{self.id} Title:'{self.title}' Status:'{self.status}' Tier:{self.tier}>"

class RequestHistory(db.Model):
    __tablename__ = 'request_history'
    id = db.Column(db.Integer, primary_key=True)
    request_id = db.Column(db.Integer, db.ForeignKey('request.id'), nullable=False, index=True)
    changed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    old_status = db.Column(db.String(20), nullable=True) # Can be null if first entry (Submitted)
    new_status = db.Column(db.String(20), nullable=False)
    action = db.Column(db.String(50), nullable=False) # e.g., 'Submitted', 'Reviewed', 'Forwarded', 'Resolved', 'Denied', 'Edited'
    notes = db.Column(db.Text, nullable=True) # Specific notes for this history entry
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    request = db.relationship('Request', back_populates='history')
    changed_by = db.relationship('User', back_populates='request_history_entries')

    __table_args__ = (
        db.Index('idx_request_history_request_ts', 'request_id', 'timestamp'),
    )

    def __repr__(self):
        return f"<RequestHistory ID:{self.id} Request:{self.request_id} Action:'{self.action}' New Status:'{self.new_status}'>"

# --- END NEW MODELS ---

# Around line 694 in your app.py
class Asset(db.Model):
    __tablename__ = "asset"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, index=True)
    description = db.Column(db.Text, nullable=True)
    quantity = db.Column(db.Integer, nullable=False, default=1)
    purchase_cost = db.Column(db.Float, nullable=True)
    condition = db.Column(db.String(50), nullable=False, default='New')
    is_consumable = db.Column(db.Boolean, nullable=False, default=False)
    expiry_date = db.Column(db.Date, nullable=True)
    last_maintenance_date = db.Column(db.Date, nullable=True)
    status = db.Column(db.String(50), nullable=False, default="Pending Review", index=True)
    location_description = db.Column(db.String(255), nullable=True)

    # --- ADD THE FOLLOWING LINE ---
    created_at = db.Column(db.DateTime(timezone=True), server_default=func.now(), nullable=False)
    # --- END OF ADDED LINE ---

    added_by_user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True, index=True)
    category_id = db.Column(db.Integer, db.ForeignKey("asset_category.id"), nullable=True, index=True)
    lab_id = db.Column(db.Integer, db.ForeignKey("lab.id"), nullable=True, index=True)

    category = db.relationship("AssetCategory", back_populates="assets")
    added_by_user = db.relationship("User", foreign_keys=[added_by_user_id], back_populates="added_assets")
    lab = db.relationship("Lab", backref=db.backref("assets", lazy="dynamic"))

    reports = db.relationship("AssetReport", back_populates="asset", lazy="dynamic", cascade="all, delete-orphan")
    book_checkouts = db.relationship("BookCheckout", back_populates="asset", lazy="dynamic", cascade="all, delete-orphan")
    borrowed_by = db.relationship('BorrowedAsset', back_populates='asset', lazy='dynamic')

    def __repr__(self):
        return f"<Asset ID:{self.id} Name:{self.name} Status:{self.status}>"
class AssetReport(db.Model):
    __tablename__ = "asset_reports"
    id = db.Column(db.Integer, primary_key=True)
    asset_id = db.Column(db.Integer, db.ForeignKey("asset.id"), nullable=True, index=True)
    reported_by_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    report_date = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    damage_description = db.Column(db.Text, nullable=False)
    date_of_damage = db.Column(db.Date, nullable=True)
    quantity_damaged = db.Column(db.Integer, default=1, nullable=False)
    status = db.Column(db.String(50), default="Pending", nullable=False, index=True)
    resolution_notes = db.Column(db.Text, nullable=True)
    resolved_by_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    resolved_date = db.Column(db.DateTime, nullable=True)

    asset = db.relationship("Asset", back_populates="reports")
    reporter = db.relationship("User", foreign_keys=[reported_by_id], back_populates="submitted_reports")
    resolver = db.relationship("User", foreign_keys=[resolved_by_id], back_populates="resolved_reports")

    __table_args__ = (
        db.Index('idx_asset_report_status', 'status'),
        db.Index('idx_asset_report_asset', 'asset_id'),
        db.Index('idx_asset_report_reporter', 'reported_by_id'),
        db.Index('idx_asset_report_date', 'report_date'),
        db.Index('idx_asset_report_resolver', 'resolved_by_id'),
    )

    def __repr__(self):
        return f"<AssetReport ID:{self.id} for Asset:{self.asset_id} Status:{self.status}>"

class BookCheckout(db.Model):
    __tablename__ = "book_checkout"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    asset_id = db.Column(db.Integer, db.ForeignKey("asset.id"), nullable=False, index=True)
    checkout_date = db.Column(db.Date, nullable=False, default=lambda: datetime.now(timezone.utc).date())
    due_date = db.Column(db.Date, nullable=False)
    return_date = db.Column(db.Date, nullable=True)
    returned = db.Column(db.Boolean, default=False, nullable=False, index=True)

    user = db.relationship("User", back_populates="book_checkouts")
    asset = db.relationship("Asset", back_populates="book_checkouts")

    __table_args__ = (
         db.Index('idx_book_checkout_dates', 'checkout_date', 'due_date', 'return_date'),
    )

    def __repr__(self):
        return f"<BookCheckout UserID: {self.user_id}, AssetID: {self.asset_id}, Due: {self.due_date}, Returned: {self.returned}>"

# --- START ADDITION: TalentClub Model ---
# --- NEW MODELS: Talent Club Subsystem ---

class TalentClub(db.Model):
    __tablename__ = 'talent_club_instances' # Renamed for clarity
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False, index=True)
    description = db.Column(db.Text, nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True) # Added for club photo
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The creator/primary manager of THIS club instance
    social_category_id = db.Column(db.Integer, db.ForeignKey('social_category.id'), nullable=False, index=True) # Category of the club
    level = db.Column(db.Integer, default=1, nullable=False) # Club level
    warning_count = db.Column(db.Integer, default=0, nullable=False) # Warning count
    is_active = db.Column(db.Boolean, default=True, nullable=False) # For soft deletion (e.g., after too many warnings)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    owner = db.relationship('User', back_populates='owned_talent_clubs') # Link back to User owner
    social_category = db.relationship('SocialCategory') # Link to category

    # Relationships to new associated models
    # CORRECTED: Removed lazy='dynamic'
    memberships = db.relationship('TalentClubMembership', back_populates='club', cascade='all, delete-orphan')
    follows = db.relationship('TalentClubFollow', back_populates='club', cascade='all, delete-orphan')
    
    feed = db.relationship('TalentClubFeed', back_populates='talent_club', uselist=False, cascade='all, delete-orphan') # Link to its content feed
    warnings = db.relationship('TalentClubWarning', back_populates='club', lazy='dynamic', cascade='all, delete-orphan') # Keep lazy='dynamic' if you perform sub-filtering often here


    def __repr__(self):
        return f"<TalentClub ID:{self.id} Name:'{self.name}' Level:{self.level} Active:{self.is_active}>"

# ... (rest of app.py) ...
class TalentClubMembership(db.Model):
    __tablename__ = 'talent_club_memberships' # Link users to specific clubs (official members)
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    role = db.Column(db.String(20), default='member', nullable=False) # Role within THIS club (creator, admin, member)
    joined_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    is_active = db.Column(db.Boolean, default=True, nullable=False) # Allow suspending membership within a club

    # Relationships
    club = db.relationship('TalentClub', back_populates='memberships')
    user = db.relationship('User', back_populates='tc_memberships', foreign_keys=[user_id])

    __table_args__ = (UniqueConstraint('talent_club_id', 'user_id', name='_tc_membership_uc'),)

    def __repr__(self):
        return f"<TalentClubMembership ClubID:{self.talent_club_id} UserID:{self.user_id} as {self.role}>"

class TalentClubFollow(db.Model):
    __tablename__ = 'talent_club_follows' # Link users to specific clubs they follow (not members)
    id = db.Column(db.Integer, primary_key=True) # Added ID as PK
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    followed_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    receive_notifications = db.Column(db.Boolean, default=True, nullable=False) # Toggle for content notifications

    # Relationships
    club = db.relationship('TalentClub', back_populates='follows')
    user = db.relationship('User', back_populates='tc_follows', foreign_keys=[user_id])

    __table_args__ = (UniqueConstraint('talent_club_id', 'user_id', name='_tc_follow_uc'),)
    __mapper_args__ = {'confirm_deleted_rows': False} # Avoids a warning with bulk updates

    def __repr__(self):
        return f"<TalentClubFollow ClubID:{self.talent_club_id} UserID:{self.user_id}>"


class TalentClubFeed(db.Model):
    __tablename__ = 'talent_club_feeds' # Content feed for a specific TalentClub instance
    id = db.Column(db.Integer, primary_key=True)
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), unique=True, nullable=False) # Link to the club

    allow_comments = db.Column(db.Boolean, default=True, nullable=False) # Feed settings
    allow_reactions = db.Column(db.Boolean, default=True, nullable=False)

    # Relationships
    talent_club = db.relationship('TalentClub', back_populates='feed')
    posts = db.relationship('TalentClubFeedPost', back_populates='feed', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubFeed ID:{self.id} for Club ID:{self.talent_club_id}>"

class TalentClubFeedPost(db.Model):
    __tablename__ = 'talent_club_feed_posts' # Posts within a TalentClub feed
    id = db.Column(db.Integer, primary_key=True)
    feed_id = db.Column(db.Integer, db.ForeignKey('talent_club_feeds.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # Must be a club member with posting rights
    content = db.Column(db.Text, nullable=True) # Text content
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), unique=True, nullable=True, index=True) # Link to existing File model
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    # Relationships
    feed = db.relationship('TalentClubFeed', back_populates='posts')
    author = db.relationship('User') # Link to the user who posted
    file = db.relationship('File', uselist=False) # Link to attached file

    comments = db.relationship('TalentClubFeedComment', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')
    reactions = db.relationship('TalentClubFeedReaction', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubFeedPost ID:{self.id} FeedID:{self.feed_id} AuthorID:{self.author_id}>"

class TalentClubFeedComment(db.Model):
    __tablename__ = 'talent_club_feed_comments' # Comments on a TalentClub feed post
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('talent_club_feed_posts.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)

    # Relationships
    post = db.relationship('TalentClubFeedPost', back_populates='comments')
    author = db.relationship('User')

    def __repr__(self):
        return f"<TalentClubFeedComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"

class TalentClubFeedReaction(db.Model):
    __tablename__ = 'talent_club_feed_reactions' # Reactions on a TalentClub feed post
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('talent_club_feed_posts.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # User who reacted
    emoji = db.Column(db.String(50), nullable=False) # The emoji string
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    post = db.relationship('TalentClubFeedPost', back_populates='reactions')
    user = db.relationship('User')

    __table_args__ = (UniqueConstraint('post_id', 'user_id', 'emoji', name='_tc_post_user_emoji_uc'),)

    def __repr__(self):
        return f"<TalentClubFeedReaction ID:{self.id} PostID:{self.post_id} UserID:{self.user_id} Emoji:{self.emoji}>"


class TalentClubCommunity(db.Model):
    __tablename__ = 'talent_club_community' # The single global TC Community group
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False) # e.g. "TC Community Group"
    description = db.Column(db.String(255), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    messages = db.relationship('TalentClubCommunityMessage', back_populates='community', lazy='dynamic', cascade='all, delete-orphan')
    members = db.relationship('TalentClubCommunityMember', back_populates='community', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubCommunity ID:{self.id} Name:'{self.name}'>"

class TalentClubCommunityMember(db.Model):
    __tablename__ = 'talent_club_community_members' # Users in the TC Community group
    community_id = db.Column(db.Integer, db.ForeignKey('talent_club_community.id'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), primary_key=True) # ADDED ondelete='CASCADE'
    role = db.Column(db.String(20), default='member', nullable=False) # e.g. 'admin', 'member'
    joined_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    community = db.relationship('TalentClubCommunity', back_populates='members')
    user = db.relationship('User') # Link to user

    __table_args__ = (UniqueConstraint('community_id', 'user_id', name='_tcc_membership_uc'),)

    def __repr__(self):
        return f"<TalentClubCommunityMember CommID:{self.community_id} UserID:{self.user_id} as {self.role}>"

class TalentClubCommunityMessage(db.Model):
    __tablename__ = 'talent_club_community_messages' # Messages in the TC Community group
    id = db.Column(db.Integer, primary_key=True)
    community_id = db.Column(db.Integer, db.ForeignKey('talent_club_community.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # Must be a TCC member
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), unique=True, nullable=True, index=True) # Link to existing File model
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    # Relationships
    community = db.relationship('TalentClubCommunity', back_populates='messages')
    author = db.relationship('User') # Link to author
    file = db.relationship('File', uselist=False) # Link to attached file

    def __repr__(self):
        return f"<TalentClubCommunityMessage ID:{self.id} CommID:{self.community_id} AuthorID:{self.author_id}>"


class TalentClubProposal(db.Model):
    __tablename__ = 'talent_club_proposals' # Proposal for a new club instance
    id = db.Column(db.Integer, primary_key=True)
    creator_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The user initiating the proposal
    name = db.Column(db.String(100), nullable=False) # Proposed name
    description = db.Column(db.Text, nullable=False) # Proposed description
    social_category_id = db.Column(db.Integer, db.ForeignKey('social_category.id'), nullable=False, index=True) # Proposed category
    proposal_file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), unique=True, nullable=True) # Optional attachment (reusing File model)
    status = db.Column(db.String(30), default='pending_leader_review', nullable=False, index=True) # pending_leader_review, pending_members_accept, accepted, rejected
    leader_review_notes = db.Column(db.Text, nullable=True) # Notes from TC Leader review
    reviewed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True) # The TC Leader who reviewed
    reviewed_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    creator = db.relationship('User', back_populates='tc_proposals_created', foreign_keys=[creator_id])
    social_category = db.relationship('SocialCategory')
    proposal_file = db.relationship('File', uselist=False)
    mentioned_members = db.relationship('TalentClubMention', back_populates='proposal', lazy='dynamic', cascade='all, delete-orphan') # Students mentioned in the proposal
    reviewed_by = db.relationship('User', foreign_keys=[reviewed_by_id])


    def __repr__(self):
        return f"<TalentClubProposal ID:{self.id} Name:'{self.name}' Status:'{self.status}' Creator:{self.creator_id}>"


class TalentClubMention(db.Model):
    __tablename__ = 'talent_club_proposal_mentions' # Students mentioned in a proposal
    id = db.Column(db.Integer, primary_key=True) # Added PK for notification linking
    proposal_id = db.Column(db.Integer, db.ForeignKey('talent_club_proposals.id'), nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The student user being mentioned
    status = db.Column(db.String(20), default='pending', nullable=False, index=True) # pending, accepted, rejected
    responded_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    proposal = db.relationship('TalentClubProposal', back_populates='mentioned_members')
    user = db.relationship('User', back_populates='tc_mentions_received', foreign_keys=[user_id])

    __table_args__ = (UniqueConstraint('proposal_id', 'user_id', name='_tc_proposal_mention_uc'),)

    def __repr__(self):
        return f"<TalentClubMention ID:{self.id} ProposalID:{self.proposal_id} UserID:{self.user_id} Status:'{self.status}'>"

class TalentClubWarning(db.Model):
    __tablename__ = 'talent_club_warnings' # Warnings issued to a TalentClub instance
    id = db.Column(db.Integer, primary_key=True)
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), nullable=False, index=True)
    issued_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # Should be the TC Leader
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    club = db.relationship('TalentClub', back_populates='warnings')
    issued_by = db.relationship('User')

    def __repr__(self):
        return f"<TalentClubWarning ID:{self.id} ClubID:{self.talent_club_id} IssuedBy:{self.issued_by_id} at {self.issued_at}>"

# Optional Models for more detailed Ban/Penalty tracking
class TalentClubBan(db.Model):
    __tablename__ = 'talent_club_bans' # System-wide TC bans/mutes
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Member banned/muted
    issued_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Leader or Admin
    type = db.Column(db.String(20), nullable=False) # e.g., 'ban', 'mute'
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=True) # Null for permanent ban

    # Relationships
    user = db.relationship('User', foreign_keys=[user_id], back_populates='tc_bans_received')
    issued_by = db.relationship('User', foreign_keys=[issued_by_id], back_populates='tc_bans_issued')

    def __repr__(self):
        return f"<TalentClubBan ID:{self.id} User:{self.user_id} Type:'{self.type}' IssuedBy:{self.issued_by_id}>"

class TalentClubPenalty(db.Model):
    __tablename__ = 'talent_club_penalties' # System-wide TC penalties (if needed, distinct from bans/warnings)
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Member penalized
    issued_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Leader or Admin
    type = db.Column(db.String(50), nullable=False) # e.g., 'points_deduction', 'feature_restriction'
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=True) # For temporary penalties

    # Relationships
    user = db.relationship('User', foreign_keys=[user_id], back_populates='tc_penalties_received')
    issued_by = db.relationship('User', foreign_keys=[issued_by_id], back_populates='tc_penalties_issued')

    def __repr__(self):
        return f"<TalentClubPenalty ID:{self.id} User:{self.user_id} Type:'{self.type}' IssuedBy:{self.issued_by_id}>"


class TalentClubLeaderElection(db.Model):
    __tablename__ = 'tc_leader_elections' # Tracks elections for the system-wide TC Leader
    id = db.Column(db.Integer, primary_key=True)
    initiated_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # HR/CEO who started it
    initiated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    concluded_at = db.Column(db.DateTime, nullable=True)
    status = db.Column(db.String(20), default='active', nullable=False, index=True) # active, concluded, cancelled
    elected_leader_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True) # The user who won

    # Relationships
    initiated_by = db.relationship('User', foreign_keys=[initiated_by_id], back_populates='tc_leader_election_initiated')
    elected_leader = db.relationship('User', foreign_keys=[elected_leader_id]) # User who won
    votes = db.relationship('TalentClubLeaderVote', back_populates='election', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubLeaderElection ID:{self.id} Status:'{self.status}' Initiated:{self.initiated_at.strftime('%Y-%m-%d')}>"

class TalentClubLeaderVote(db.Model):
    __tablename__ = 'tc_leader_votes' # Individual votes in a TC Leader election
    id = db.Column(db.Integer, primary_key=True) # Added PK
    election_id = db.Column(db.Integer, db.ForeignKey('tc_leader_elections.id'), nullable=False, index=True)
    voter_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The user who voted (must be is_tc_member)
    candidate_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The user they voted for (must be is_tc_member)
    voted_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    election = db.relationship('TalentClubLeaderElection', back_populates='votes')
    voter = db.relationship('User', foreign_keys=[voter_id], back_populates='tc_leader_votes_cast')
    candidate = db.relationship('User', foreign_keys=[candidate_id]) # The candidate user

    __table_args__ = (UniqueConstraint('election_id', 'voter_id', name='_tc_leader_vote_uc'),) # Each voter gets one vote per election

    def __repr__(self):
        return f"<TalentClubLeaderVote ID:{self.id} Election:{self.election_id} Voter:{self.voter_id} Candidate:{self.candidate_id}>"
class BorrowedAsset(db.Model): # Added BorrowedAsset model
    __tablename__ = 'borrowed_asset'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    asset_id = db.Column(db.Integer, db.ForeignKey('asset.id'), nullable=False, index=True)
    checkout_date = db.Column(db.Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False)
    due_date = db.Column(db.Date, nullable=False)
    return_date = db.Column(db.Date, nullable=True)
    returned = db.Column(db.Boolean, default=False, nullable=False, index=True)

    user = db.relationship('User', back_populates='borrowed_assets')
    asset = db.relationship('Asset', back_populates='borrowed_by')

    def __repr__(self):
        return f"<BorrowedAsset UserID: {self.user_id}, AssetID: {self.asset_id}, Due: {self.due_date}, Returned: {self.returned}>"


class Notification(db.Model):
    __tablename__ = "notification"
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    receiver_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), index=True)
    is_read = db.Column(db.Boolean, default=False, nullable=False, index=True)
    link_url = db.Column(db.String(255), nullable=True)

    sender = db.relationship("User", foreign_keys=[sender_id], back_populates="sent_notifications")
    receiver = db.relationship("User", foreign_keys=[receiver_id], back_populates="received_notifications")
    notification_type = db.Column(db.String(50), nullable=True) # e.g., 'chat', 'general', 'request', 'tc_invite', 'tc_warning', 'tc_level_change', 'tc_vote_open', 'tc_vote_result'
    related_object_id = db.Column(db.Integer, nullable=True, index=True) # ID of related object (e.g., TalentClubMention ID for invite, TalentClub ID for warning/level, Election ID for vote)
    __table_args__ = (
        db.Index('idx_notification_receiver_read', 'receiver_id', 'is_read'),
    )

    def __repr__(self):
        return f"<Notification from {self.sender_id} to {self.receiver_id} at {self.timestamp}>"

class Attendance(db.Model): # Student Attendance
    __tablename__ = "student_attendance"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    date = db.Column(db.Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False, index=True)
    status = db.Column(db.String(10), default="Present", nullable=False)
    notes = db.Column(db.Text)

    student = db.relationship("User", back_populates="attendance_entries")

    __table_args__ = (
        db.UniqueConstraint("student_id", "date", name="_student_date_uc"),
    )

    def __repr__(self):
        return f"<StudentAttendance StudentID: {self.student_id}, Date: {self.date}, Status: {self.status}>"

class StaffAttendance(db.Model): # Staff Attendance
    __tablename__ = "staff_attendance"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False, index=True)
    date = Column(Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False, index=True)
    present = Column(Boolean, default=False, nullable=False)
    notes = Column(Text)

    user = relationship("User", back_populates="staff_attendance_records")

    __table_args__ = (db.UniqueConstraint("user_id", "date", name="_staff_attendance_uc"),)

    def __repr__(self):
        status = "Present" if self.present else "Absent"
        return f"<StaffAttendance UserID: {self.user_id}, Date: {self.date}, Status: {status}>"

class File(db.Model):
    __tablename__ = 'social_files'
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(255), nullable=False)
    original_filename = db.Column(db.String(255), nullable=False)
    mimetype = db.Column(db.String(100), nullable=True)
    filepath = db.Column(db.String(255), unique=True, nullable=False)
    size = db.Column(db.BigInteger, nullable=False)
    uploaded_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    
    global_post_attachment = db.relationship('GlobalPost', back_populates='attached_file', uselist=False)
    # --- End of File model addition ---
    uploader = db.relationship('User', back_populates='uploaded_social_files')
    channel_post = db.relationship('ChannelPost', back_populates='file', uselist=False)
    group_message = db.relationship('GroupMessage', back_populates='file', uselist=False)

    def get_download_url(self):
        try:
            from flask import url_for
            return url_for('download_social_file', file_id=self.id, _external=True)
        except RuntimeError:
            print(f"Warning: url_for called outside application context for File {self.id}")
            return f"/social/files/download/{self.id}"


# --- NEW FORMS: Task System ---

class CreateTaskForm(FlaskForm):
    """Form for creating a new task."""
    title = StringField("Task Title", validators=[DataRequired(), Length(max=255)])
    description = TextAreaField("Detailed Description", validators=[DataRequired(), Length(min=10, max=2000)])
    due_date = DateField("Due Date (YYYY-MM-DD) (Optional)", format='%Y-%m-%d', validators=[Optional()])
    urgency = SelectField("Urgency", choices=[
        ('Low', 'Low'),
        ('Medium', 'Medium'),
        ('High', 'High'),
        ('Critical', 'Critical')
    ], default='Medium', validators=[DataRequired()])

    # Field to select assignment type - will control visibility of subsequent fields via JS
    assignment_type = RadioField(
        "Assign To",
        choices=[('individual', 'Individual User(s)'), ('group', 'Group(s)')],
        validators=[DataRequired()],
        default='individual' # Default to individual
    )

    # Fields for assignment targets (populated dynamically/via JS)
    # Individual User IDs will be sent via a hidden field populated by a JS picker
    individual_user_ids = HiddenField("Individual User IDs") # No validator here, validation in route logic

    # Group assignments - These will likely be selected via separate dropdowns/checkboxes in the template,
    # controlled by `assignment_type`. The selected values will be sent in `request.form`.
    # We *could* add SelectMultipleFields here if WTForms handles the rendering better, but given
    # the dynamic nature (list of roles, dynamic list of grades/sections), reading directly from request.form
    # might be simpler alongside JS.
    # Placeholder for validation in route:
    # group_roles = FieldList(StringField('Role Name')) # Not used directly for data, more for validation structure
    # group_grade_sections = FieldList(StringField('Grade Section')) # Not used directly

    submit = SubmitField("Create Task")

    def validate_due_date(self, field):
        # Allow empty date if Optional
        if field.data and field.data < datetime.now(timezone.utc).date():
            raise ValidationError("Due date cannot be in the past.")

    # Custom validation for assignment target based on type will be in the route

class UpdateUserTaskStatusForm(FlaskForm):
    """Form for an assigned user to update their task status."""
    status = SelectField("Update Status", validators=[DataRequired()], choices=[
        ('In Progress', 'In Progress'),
        ('Completed (Pending Review)', 'Completed'),
        ('Delayed (Pending Review)', 'Delayed'),
        ('Rejected (Pending Review)', 'Cannot Complete') # Renamed to clarify user cannot/will not do it
    ]) # 'Open' status is default, not a choice here

    completion_notes = TextAreaField(
        "Notes / Reason for Status",
        validators=[Optional(), Length(max=1000)]
    )
    submit = SubmitField("Submit Status Update")

    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        # Custom validation: Require notes if status is Delayed or Rejected
        if self.status.data in ['Delayed (Pending Review)', 'Rejected (Pending Review)'] and not self.completion_notes.data:
            self.completion_notes.errors.append("Reason/notes are required for Delayed or Cannot Complete statuses.")
            return False

        return True


class ReviewUserTaskForm(FlaskForm):
    """Form for the task creator to review a user's status update."""
    review_outcome = SelectField("Review Outcome", validators=[DataRequired()], choices=[
        ('Accepted', 'Accept Completion/Status'),
        ('Review Rejected', 'Reject Completion/Status')
    ])
    reviewer_notes = TextAreaField(
        "Reviewer Notes (Optional)",
        validators=[Optional(), Length(max=1000)]
    )
    submit = SubmitField("Submit Review")

    # Custom validation: Require notes if review is Rejected
    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        if self.review_outcome.data == 'Review Rejected' and not self.reviewer_notes.data:
             self.reviewer_notes.errors.append("Reviewer notes are required if the review is rejected.")
             return False

        return True

# Channel Models
# START MODIFICATION (Channel Model)
# START MODIFICATION (Channel Model - REMOVING TC Link)
class Channel(db.Model):
    __tablename__ = 'social_channels'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True, index=True)
    bio = db.Column(db.Text, nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    social_category_id = db.Column(db.Integer, db.ForeignKey('social_category.id'), nullable=False, index=True)
    type = db.Column(db.String(20), default='private', nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    allow_comments = db.Column(db.Boolean, default=True, nullable=False)
    allow_reactions = db.Column(db.Boolean, default=True, nullable=False)
   # --- Add this relationship to your Channel (SocialChannel) model ---
   user_preferences = db.relationship('UserChannelPreference', foreign_keys='UserChannelPreference.channel_id', back_populates='channel', lazy='dynamic', cascade='all, delete-orphan')

    owner = db.relationship('User', foreign_keys=[owner_id], back_populates='owned_channels')
    social_category = db.relationship('SocialCategory', back_populates='channels')
    subscribers = db.relationship('ChannelSubscriber', back_populates='channel', lazy='dynamic', cascade='all, delete-orphan')
    posts = db.relationship('ChannelPost', back_populates='channel', lazy='dynamic', cascade='all, delete-orphan')

    # REMOVED: back_populates='linked_channel' is gone because the relationship is gone

    def __repr__(self):
        return f"<Channel ID:{self.id} Name:'{self.name}' Type:'{self.type}'>"
# END MODIFICATION (Channel Model - REMOVING TC Link)
    
# END MODIFICATION (Channel Model)
class ChannelSubscriber(db.Model):
    __tablename__ = 'social_channel_subscribers'
    channel_id = db.Column(db.Integer, db.ForeignKey('social_channels.id'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    role = db.Column(db.String(20), default='subscriber', nullable=False)
    subscribed_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    user = db.relationship('User', back_populates='channel_subscriptions')
    channel = db.relationship('Channel', back_populates='subscribers')

    __table_args__ = (UniqueConstraint('channel_id', 'user_id', name='_channel_user_uc'),)

    def __repr__(self):
        return f"<ChannelSubscriber UserID: {self.user_id} in ChannelID: {self.channel_id} as {self.role}>"



#add THIS NEW MODEL ---
# --- User Channel Category Model ---

class UserChannelCategory(db.Model):
    __tablename__ = "user_channel_category"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False, index=True)
    name = db.Column(db.String(100), nullable=False)
    order = db.Column(db.Integer, default=0, nullable=False) # For user-defined category order
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    
    # Security features
    security_type = db.Column(db.String(20), nullable=True) # e.g., 'none', 'pin_code', 'pattern'
    security_payload_hash = db.Column(db.String(255), nullable=True) # Increased length for robust hashes

    _metadata = db.Column(db.JSON, nullable=True) # For icon, color, etc.

    # Relationships
    # user relationship defined in User model via back_populates='custom_channel_categories'
    # channel_assignments: channels this user has put into this category
    channel_assignments = db.relationship('UserChannelPreference', back_populates='user_channel_category', lazy='dynamic')


    __table_args__ = (
        db.UniqueConstraint('user_id', 'name', name='_user_category_name_uc'),
        db.Index('idx_user_channel_category_user_order', 'user_id', 'order'),
    )

    def __repr__(self):
        return f"<UserChannelCategory ID:{self.id} UserID:{self.user_id} Name:'{self.name}'>"

    def set_security_payload(self, plain_payload):
        """Hashes and sets the security payload."""
        if plain_payload:
            # Ensure generate_password_hash is imported from werkzeug.security
            self.security_payload_hash = generate_password_hash(plain_payload)
        else:
            self.security_payload_hash = None

    def check_security_payload(self, plain_payload_attempt):
        """Checks a plain payload attempt against the stored hash."""
        if not self.security_payload_hash or not plain_payload_attempt:
            return False
        # Ensure check_password_hash is imported from werkzeug.security
        return check_password_hash(self.security_payload_hash, plain_payload_attempt)

# --- END User Channel Category Model ---

# --- User Saved Item Model (Polymorphic) ---

class UserSavedItem(db.Model):
    __tablename__ = "user_saved_item"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False, index=True)
    # item_type stores the model name as a string, e.g., 'GlobalPost', 'ChannelPost', 'DirectMessage'
    item_type = db.Column(db.String(50), nullable=False, index=True) 
    item_id = db.Column(db.Integer, nullable=False, index=True) # ID of the actual saved item
    saved_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    notes = db.Column(db.Text, nullable=True) # Optional user notes
    custom_tags = db.Column(db.JSON, nullable=True) # Future: user-defined tags

    # user relationship defined in User model via back_populates='saved_items'

    __table_args__ = (
        db.UniqueConstraint('user_id', 'item_type', 'item_id', name='_user_saved_item_uc'),
        db.Index('idx_user_item_type_id', 'user_id', 'item_type', 'item_id'), # For efficient querying
    )

    def __repr__(self):
        return f"<UserSavedItem UserID:{self.user_id} Type:'{self.item_type}' ItemID:{self.item_id}>"

    # Polymorphic loading helper (optional, but highly recommended for convenience)
    def get_actual_item(self):
        """
        Dynamically fetches the actual saved item based on item_type and item_id.
        Returns the SQLAlchemy object or None if not found/type is unknown.
        Requires models to be imported or accessible in the scope where this is called.
        """
        # Ensure model names match exactly how they are defined (case-sensitive)
        model_map = {
            'GlobalPost': GlobalPost,
            'ChannelPost': ChannelPost,
            'GroupMessage': GroupMessage,
            'DirectMessage': Message, # Assuming 'DirectMessage' refers to your existing 'Message' model
            'TalentClubFeedPost': TalentClubFeedPost,
            'TalentClubCommunityMessage': TalentClubCommunityMessage,
            # Add other saveable models here
        }
        ModelClass = model_map.get(self.item_type)
        if ModelClass:
            return db.session.get(ModelClass, self.item_id)
        app.logger.warning(f"Unknown item_type '{self.item_type}' for UserSavedItem ID {self.id}.")
        return None

# --- END User Saved Item Model ---

class ChannelPost(db.Model):
    __tablename__ = 'social_channel_posts'
    id = db.Column(db.Integer, primary_key=True)
    channel_id = db.Column(db.Integer, db.ForeignKey('social_channels.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), nullable=True, unique=True, index=True)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    channel = db.relationship('Channel', back_populates='posts', foreign_keys=[channel_id])
    author = db.relationship('User', foreign_keys=[author_id], back_populates='channel_posts')
    file = db.relationship('File', back_populates='channel_post', uselist=False)

    comments = db.relationship('ChannelComment', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')
    reactions = db.relationship('ChannelReaction', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')


    def get_share_url(self):
         try:
              from flask import url_for
              return url_for('view_social_channel_post_redirect', post_id=self.id, _external=True)
         except RuntimeError:
              print(f"Warning: url_for called outside application context for ChannelPost {self.id}")
              return f"/social/posts/{self.id}/view"

    def __repr__(self):
         return f"<ChannelPost ID:{self.id} ChannelID:{self.channel_id} AuthorID:{self.author_id}>"

class GlobalPost(db.Model):
    __tablename__ = "global_post"
    id = db.Column(db.Integer, primary_key=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id', ondelete='SET NULL'), nullable=True, unique=True, index=True)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)
    visibility = db.Column(db.String(20), default='public', nullable=False, index=True) # 'public', 'connections_only', 'private'
    allow_comments = db.Column(db.Boolean, default=True, nullable=False)
    allow_likes = db.Column(db.Boolean, default=True, nullable=False)
    shared_post_id = db.Column(db.Integer, db.ForeignKey('global_post.id', ondelete='SET NULL'), nullable=True, index=True) # For reposts
    _metadata = db.Column(db.JSON, nullable=True) # For future: location, polls, link previews

    # Relationships
    # author defined in User model via back_populates='global_posts'
    # attached_file defined in File model via back_populates='global_post_attachment'
    comments = db.relationship('GlobalComment', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')
    likes = db.relationship('GlobalLike', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')
    
    # For shared posts: relationship to the original post
    original_shared_post = db.relationship('GlobalPost', remote_side=[id], backref=db.backref('shares', lazy='dynamic'), uselist=False) # A post is a share of ONE original post

    def __repr__(self):
        return f"<GlobalPost ID:{self.id} AuthorID:{self.author_id} Visibility:'{self.visibility}'>"

    def get_share_url(self): # Consistent with other post types
         try:
              from flask import url_for
              # Define a route like 'view_global_post_redirect' similar to channel/group posts
              return url_for('view_global_post_redirect', post_id=self.id, _external=True)
         except RuntimeError:
              # Fallback if url_for fails outside request context (e.g. in a model method called by a script)
              return f"/global_posts/{self.id}/view" # Example placeholder URL

class GlobalComment(db.Model):
    __tablename__ = "global_comment"
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('global_post.id', ondelete='CASCADE'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False, index=True)
    parent_comment_id = db.Column(db.Integer, db.ForeignKey('global_comment.id', ondelete='CASCADE'), nullable=True, index=True) # Threaded comments
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)
    _metadata = db.Column(db.JSON, nullable=True) # For reactions on comments, etc.

    # Relationships
    post = db.relationship('GlobalPost', back_populates='comments')
    # author defined in User model via back_populates='global_comments'
    
    # For threaded comments: relationship to parent and replies
    replies = db.relationship('GlobalComment', backref=db.backref('parent', remote_side=[id]), lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<GlobalComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"

class GlobalLike(db.Model):
    __tablename__ = "global_like"
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('global_post.id', ondelete='CASCADE'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    post = db.relationship('GlobalPost', back_populates='likes')
    # user defined in User model via back_populates='global_likes'
    
    __table_args__ = (
        db.UniqueConstraint('post_id', 'user_id', name='_global_post_user_like_uc'),
        db.Index('idx_global_like_post_user', 'post_id', 'user_id'), # Index for the unique constraint
    )

    def __repr__(self):
        return f"<GlobalLike ID:{self.id} PostID:{self.post_id} UserID:{self.user_id}>"

# --- END Global Engagement Core Models ---

class ChannelComment(db.Model):
    __tablename__ = 'social_channel_comments'
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('social_channel_posts.id'), nullable=False)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)

    post = db.relationship('ChannelPost', back_populates='comments')
    author = db.relationship('User', back_populates='channel_comments', foreign_keys=[author_id])

    def __repr__(self):
         return f"<ChannelComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"


class ChannelReaction(db.Model):
    __tablename__ = 'social_channel_reactions'
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('social_channel_posts.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    emoji = db.Column(db.String(50), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    post = db.relationship('ChannelPost', back_populates='reactions')
    user = db.relationship('User', back_populates='channel_reactions')

    __table_args__ = (UniqueConstraint('post_id', 'user_id', 'emoji', name='_post_user_emoji_uc'),)

    def __repr__(self):
         return f"<ChannelReaction ID:{self.id} PostID:{self.post_id} UserID:{self.user_id} Emoji:{self.emoji}>"


class GroupMessage(db.Model): # Corrected model name
    __tablename__ = 'social_group_messages'
    id = db.Column(db.Integer, primary_key=True)
    group_id = db.Column(db.Integer, db.ForeignKey('social_groups.id'), nullable=False, index=True) # FK points to social_groups
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), nullable=True, unique=True, index=True)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    group = db.relationship('SocialGroup', back_populates='messages', foreign_keys=[group_id]) # Corrected relationship target and added FK
    author = db.relationship('User', foreign_keys=[author_id], back_populates='group_messages')
    file = db.relationship('File', back_populates='group_message', uselist=False)

    def get_share_url(self):
         try:
              from flask import url_for
              return url_for('view_social_group_message_redirect', message_id=self.id, _external=True)
         except RuntimeError:
              print(f"Warning: url_for called outside application context for GroupMessage {self.id}")
              return f"/social/messages/{self.id}/view"

    def __repr__(self):
         return f"<GroupMessage ID:{self.id} GroupID:{self.group_id} AuthorID:{self.author_id}>"


class Mark(db.Model):
    __tablename__ = 'mark'
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    subject = db.Column(db.String(100), nullable=False, index=True)
    semester_1 = db.Column(db.Float, nullable=True)
    semester_2 = db.Column(db.Float, nullable=True)
    total = db.Column(db.Float, nullable=True)
    average = db.Column(db.Float, nullable=True, index=True)
    rank = db.Column(db.Integer, nullable=True)

    student = db.relationship('User', back_populates='marks')

    __table_args__ = (
        db.UniqueConstraint('student_id', 'subject', name='_student_subject_uc'),
        db.Index('idx_mark_subject_average', 'subject', 'average'),
    )

    def __repr__(self):
        return f"<Mark StudentID: {self.student_id}, Subject: {self.subject}, Avg: {self.average}>"
        
# --- PART 2 END: Model Definitions ---

# --- PART 3 START: SQLAlchemy Init, LoginManager, Core Helpers & Context ---

migrate = Migrate(app, db)

# Initialize LoginManager *AFTER* the User model is defined and db is initialized
login_manager = LoginManager(app)
login_manager.login_view = "login"
login_manager.login_message_category = "info"

# ... rest of PART 3 ...
@login_manager.user_loader
def load_user(user_id):
    """Required by Flask-Login to load a user from the user ID stored in the session."""
    if user_id is not None:
        # Use db.session.get for retrieving by primary key
        # Ensure user is active before loading
        user = db.session.get(User, int(user_id))
        if user and user.is_active:
            return user
    return None # Return None if user_id is invalid or user is not found/inactive

# --- Helper Functions (Consolidated and placed here) ---

# Helper to get roles a given role can send to or receive from (used by Notification & Chat helpers)
# --- Helper Functions (Consolidated and placed here) ---

# Helper to get roles a given role can send to or receive from (used by Notification & Chat helpers)
# UPDATED: Now takes a 'user' object instead of separate 'role_name' and 'is_leader'
def get_allowed_roles_helper(config_dict, direction, user):
    """Helper to get roles a given role can send to or receive from based on a config dictionary."""
    if not user or not user.is_authenticated or not user.role:
        return [] # No permissions for unauthenticated or rol-less users

    role_name_lower = user.role.name.lower()
    perms = config_dict.get(role_name_lower, {})

    # --- NEW TC Leader Send Override (Applies only to 'send_to') ---
    if direction == 'send_to':
        if user.is_tc_leader:
            # If the user is the system-wide TC Leader, they can send chat/notifications to:
            # 1. Other Talent Club members (primary role 'student', is_tc_member=True) -> target role 'student'
            # 2. Other Talent Club role users (e.g. coordinators, other leaders) -> target role 'talent_club'
            # 3. HR/CEO users -> target role 'hr_ceo'
            # This overrides any more restrictive send_to rules for the specific roles listed here.
            return ['student', 'talent_club', 'hr_ceo'] # Specific roles the leader can send *to*.

    # --- Logic for other users OR for the 'receive_from' direction ---

    # Resolve specific permissions based on primary role and exceptions (if applicable)
    specific_perms = perms
    if 'exceptions' in perms:
        # Check for role-specific exceptions based on boolean flags on the user object
        # Order matters: prioritize the most specific exception if multiple apply
        # Assuming tc_leader and tc_member on a student use the 'tc_member' exception primarily,
        # unless a nested exception is defined. For simplicity, let's rely on the config.
        # The helper as written looks for a direct match in the 'exceptions' dictionary key.

        # Prioritize 'tc_member' exception for 'student' role
        if role_name_lower == 'student' and user.is_tc_member and 'tc_member' in perms['exceptions']:
             specific_perms = perms['exceptions']['tc_member']
        # Check 'leader' exception for 'student' role (applies if is_leader is True and tc_member isn't primary exception)
        elif role_name_lower == 'student' and user.is_leader and 'leader' in perms['exceptions']:
            specific_perms = perms['exceptions']['leader']
        # Check 'tc_leader' exception for 'talent_club' role
        elif role_name_lower == 'talent_club' and user.is_tc_leader and 'tc_leader' in perms['exceptions']:
            specific_perms = perms['exceptions']['tc_leader']
        # Add more exception checks here for other roles/leader types if they emerge
        # E.g., if a 'teacher' could also be 'is_tc_member', you'd need an exception for that.


    # Get the permissions dictionary for the determined direction (send_to or receive_from)
    direction_perms = specific_perms.get(direction, {})

    # Resolve the final list of allowed roles based on 'all', 'specific', or 'none'
    if direction_perms.get('all'):
        exceptions = [exc.lower() for exc in direction_perms.get('exceptions', [])]
        # Use the global VALID_ROLE_NAMES defined earlier (assumed to exist)
        # from flask import current_app # Need current_app if VALID_ROLE_NAMES is in app.config
        return [r.lower() for r in VALID_ROLE_NAMES if r.lower() not in exceptions]
    elif direction_perms.get('specific'):
        return [r.lower() for r in direction_perms.get('specific', [])]
    else: # 'none' or not defined
        return []
# Specific helper for Chat permissions
# UPDATED: Now takes a 'user' object
def get_allowed_chat_roles(direction, user):
     # Access app config within the function if needed
     from flask import current_app # This import is often needed if run standalone or in contexts.
     # Pass the user object directly to the general helper
     return get_allowed_roles_helper(CHAT_PERMISSIONS, direction, user)


# Specific helper for Notification permissions
# UPDATED: Now takes a 'user' object
def get_allowed_notification_roles(direction, user):
     # Access app config within the function if needed
     from flask import current_app # This import is often needed if run standalone or in contexts.
     # Pass the user object directly to the general helper
     return get_allowed_roles_helper(NOTIFICATION_PERMISSIONS, direction, user)

# --- NEW HELPER FUNCTIONS: Talent Club Subsystem ---

def is_tc_leader(user):
    """Checks if the given user is the current system-wide Talent Club Leader."""
    if not user or not user.is_authenticated:
        return False
    # Direct check on the flag on the user object is sufficient
    return user.is_tc_leader

def get_tc_community_group():
    """Fetches the single Talent Club Community group instance."""
    # This group should be created during initial setup/seeding
    return db.session.scalar(select(TalentClubCommunity).limit(1))

def is_tc_community_member(user):
    """Checks if a user is a member of the main TC Community group."""
    if not user or not user.is_authenticated or not user.is_tc_member:
        return False

    community_group = get_tc_community_group()
    if not community_group:
        app.logger.warning("Talent Club Community group not found in DB.")
        return False

    membership_record = db.session.scalar(
        select(TalentClubCommunityMember).where(
            TalentClubCommunityMember.community_id == community_group.id,
            TalentClubCommunityMember.user_id == user.id
        ).limit(1) # Optimization: only need to find one record
    )
    return membership_record is not None # True if a record was found, False otherwise

def add_to_tc_community_group(user):
    """Adds a user to the TC Community group if they are a TC member and not already added."""
    if not user or not user.is_tc_member:
        app.logger.warning(f"Attempted to add non-TC member user {user.id if user else 'N/A'} to TC Community.")
        return False

    community_group = get_tc_community_group()
    if not community_group:
        app.logger.error("Talent Club Community group not found. Cannot add member.")
        return False

    # Check if already a member
    if is_tc_community_member(user):
        app.logger.debug(f"User {user.id} already in TC Community group.")
        return True # Already done

    try:
        member_entry = TalentClubCommunityMember(
            community=community_group,
            user=user,
            role='member', # Default role
            joined_at=datetime.now(timezone.utc)
        )
        db.session.add(member_entry)
        db.session.commit()
        app.logger.info(f"User {user.id} added to TC Community group ID {community_group.id}.")
        return True
    except IntegrityError:
        db.session.rollback()
        app.logger.warning(f"IntegrityError adding user {user.id} to TC Community group {community_group.id} (already member?).")
        # This might happen if is_tc_community_member check failed due to cache, or concurrent op
        return False # Or True if you assume the exception means they are already in
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error adding user {user.id} to TC Community group {community_group.id}: {e}", exc_info=True)
        return False


def notify_tc_member(receiver_user, sender_user, content, notification_type, related_object_id=None, link_url=None):
    """
    Sends a notification specifically within the Talent Club subsystem.
    Checks if receiver is a TC member and if notification type/sender is allowed within TC context (optional check).
    """
    if not receiver_user or not receiver_user.is_tc_member:
        # Cannot notify non-TC members via this helper
        app.logger.warning(f"Attempted to send TC notification to non-TC member user {receiver_user.id if receiver_user else 'N/A'}.")
        return False

    # Optional: Add specific checks based on TC notification types and sender roles
    # For now, assume if you are allowed to send TC notifications, you can use this.
    # The main NOTIFICATION_PERMISSIONS config can be updated to reflect TC-specific flows.
    # E.g., TC Leader can send tc_warning/tc_level_change to TC Members.
    # A proposal creator can send tc_invite to mentioned members.

    # Let's use the general notification permission checks, assuming sender is allowed to notify the receiver's role.
    # The `notification_type` adds context but doesn't automatically bypass role permissions.

    # Use 'system' user as sender if sender_user is None (e.g., automated warnings)
    sender = sender_user
    if not sender:
         sender = db.session.scalar(select(User).filter_by(username='system'))
         if not sender:
             app.logger.error("System user not found for TC notification sender.")
             return False

    # Re-use the existing notification permission check
    if not is_notification_allowed(sender, receiver_user):
         app.logger.warning(f"TC Notification not allowed: Sender {sender.username} ({sender.role.name if sender.role else 'N/A'}) to Receiver {receiver_user.username} ({receiver_user.role.name if receiver_user.role else 'N/A'}).")
         return False


    try:
        notification = Notification(
            sender_id=sender.id,
            receiver_id=receiver_user.id,
            content=content,
            link_url=link_url,
            timestamp=datetime.now(timezone.utc),
            is_read=False,
            notification_type=notification_type, # Store the specific type
            related_object_id=related_object_id # Store related object ID
        )
        db.session.add(notification)
        db.session.commit() # Commit immediately for notifications
        app.logger.info(f"TC Notification sent (Type: {notification_type}, Related ID: {related_object_id}) to user {receiver_user.id} by sender {sender.id}.")
        return True

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error sending TC notification (Type: {notification_type}, Related ID: {related_object_id}) to user {receiver_user.id}: {e}", exc_info=True)
        return False


# Helper for TC Leader to check if a user is eligible to be banned/muted
def is_eligible_for_tc_ban_mute(user_to_check):
    """Checks if a user is a TC member and thus eligible for TC-specific bans/mutes."""
    # Only TC members can receive TC-specific bans/mutes applied by the TC Leader
    return user_to_check and user_to_check.is_tc_member

# Helper for TC Leader to check if a user is currently banned/muted
def is_currently_banned_muted(user):
    """Checks if a user has an active TC ban or mute."""
    if not user:
        return False

    # Check for active bans/mutes (expires_at is null or in the future)
    active_ban = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == user.id,
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc)
            )
        ).limit(1) # Just need to find one
    )
    return active_ban is not None

# Helper to get eligible candidates for TC Leader election (users who are is_tc_member = True)
def get_tc_leader_candidates():
    """Fetches all active users who are Talent Club members."""
    return db.session.scalars(
        select(User)
        .where(User.is_tc_member == True, User.is_active == True)
        .order_by(User.full_name)
    ).all()

# Helper to find the active TC Leader election
def get_active_tc_leader_election():
    """Finds the current active Talent Club Leader election."""
    return db.session.scalar(
        select(TalentClubLeaderElection)
        .where(TalentClubLeaderElection.status == 'active')
        .order_by(TalentClubLeaderElection.initiated_at.desc())
        .limit(1) # Should be only one active at a time
    )



# Specific helper for Chat permissions check
# UPDATED: Now takes sender_user and receiver_user objects
def is_chat_allowed(sender_user, receiver_user):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    if not receiver_user or not receiver_user.role:
        return False

    allowed_to_send = get_allowed_chat_roles('send_to', sender_user)
    allowed_to_receive = get_allowed_chat_roles('receive_from', receiver_user)

    return receiver_user.role.name.lower() in allowed_to_send and sender_user.role.name.lower() in allowed_to_receive


# Specific helper for Notification permissions check
# UPDATED: Now takes sender_user and receiver_user objects
def is_notification_allowed(sender_user, receiver_user):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    if not receiver_user or not receiver_user.role:
        return False

    allowed_to_send = get_allowed_notification_roles('send_to', sender_user)
    allowed_to_receive = get_allowed_notification_roles('receive_from', receiver_user)

    return receiver_user.role.name.lower() in allowed_to_send and sender_user.role.name.lower() in allowed_to_receive


# Helper to check if sender is allowed to send notifications to receiver role (Used in send_notification_to_user)
# UPDATED: Now takes sender_user object and receiver_role_name (string)
def can_send(sender_user, receiver_role_name):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    allowed_roles = get_allowed_notification_roles('send_to', sender_user)
    return receiver_role_name.lower() in allowed_roles

# Helper to check if receiver is allowed to receive notifications from sender role (Used in send_notification_to_user)
# UPDATED: Now takes receiver_user object and sender_role_name (string)
def can_receive(receiver_user, sender_role_name):
    if not receiver_user or not receiver_user.role:
        return False
    allowed_roles = get_allowed_notification_roles('receive_from', receiver_user)
    return sender_role_name.lower() in allowed_roles


# Helper to determine which assets a user should see based on their role (Implemented in Part 2/Previous block)
# Keeping the definition here for reference, but the function body was already provided.
# def get_user_assets_query(user):
#     pass # Body is in Part 2

# Placeholder Notification Helpers (These now need actual implementations or placeholders)
# ADDING SIMPLE PLACEHOLDERS HERE
def notify_hr_ceo_new_asset(asset):
    """Placeholder to notify HR/CEO about a new asset."""
    try:
        with app.app_context(): # Ensure context if called outside a request handler
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            if not hr_ceo_role:
                 app.logger.warning("HR/CEO role not found for new asset notification.")
                 return # Cannot notify if role doesn't exist

            hr_ceos = db.session.scalars(
                 select(User)
                 .where(User.role == hr_ceo_role, User.is_active == True)
             ).all()

            if not hr_ceos:
                app.logger.warning("No active HR/CEO users found for new asset notification.")
                return # Cannot notify if no HR/CEOs exist

            message_content = f"A new asset '{asset.name}' (ID: {asset.id}) has been added and is pending review."
            link_url = url_for('edit_asset', asset_id=asset.id) # Link to the edit page

            # Create a notification for each HR/CEO
            notifications = []
            for hr_ceo in hr_ceos:
                 # Check if notification is allowed based on permission config (HR/CEO can receive from any role that can add assets)
                 # Sender role is the role of the user who added the asset (asset.added_by_user.role)
                 sender_role_name = asset.added_by_user.role.name.lower() if asset.added_by_user and asset.added_by_user.role else 'unknown'
                 receiver_role_name = hr_ceo_role.name.lower()

                 if is_notification_allowed(asset.added_by_user, hr_ceo):
                     notification = Notification(
                         sender_id=asset.added_by_user_id or db.session.scalar(select(User.id).filter_by(username='system')), # Link sender to user who added, or a system user if not linked
                         receiver_id=hr_ceo.id,
                         content=message_content,
                         link_url=link_url,
                         timestamp=datetime.now(timezone.utc),
                         is_read=False
                     )
                     notifications.append(notification)

            if notifications:
                 db.session.add_all(notifications)
                 db.session.commit()
                 app.logger.info(f"Notified {len(notifications)} HR/CEO(s) about new asset ID {asset.id}.")

    except Exception as e:
         # Log the error but don't roll back the main transaction that added the asset
         app.logger.error(f"Error sending new asset notification for asset ID {asset.id}: {e}", exc_info=True)
         db.session.rollback() # Rollback only the notification transaction if any commits happened here


def notify_hr_ceo_new_report(report):
    """Placeholder to notify HR/CEO about a new asset report."""
    try:
        with app.app_context(): # Ensure context
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            if not hr_ceo_role:
                 app.logger.warning("HR/CEO role not found for new report notification.")
                 return

            hr_ceos = db.session.scalars(
                 select(User)
                 .where(User.role == hr_ceo_role, User.is_active == True)
             ).all()

            if not hr_ceos:
                app.logger.warning("No active HR/CEO users found for new report notification.")
                return

            asset_name = report.asset.name if report.asset else "General Asset"
            message_content = f"A new asset report (ID: {report.id}) has been submitted for '{asset_name}'. Status: {report.status}."
            link_url = url_for('resolve_asset_report', report_id=report.id) # Link to the resolve page

            notifications = []
            for hr_ceo in hr_ceos:
                 # Check if notification is allowed
                 sender_role_name = report.reporter.role.name.lower() if report.reporter and report.reporter.role else 'unknown'
                 receiver_role_name = hr_ceo_role.name.lower()

                 if is_notification_allowed(sender_role_name, receiver_role_name):
                     notification = Notification(
                         sender_id=report.reported_by_id or db.session.scalar(select(User.id).filter_by(username='system')), # Link sender to reporter, or system user
                         receiver_id=hr_ceo.id,
                         content=message_content,
                         link_url=link_url,
                         timestamp=datetime.now(timezone.utc),
                         is_read=False
                     )
                     notifications.append(notification)

            if notifications:
                 db.session.add_all(notifications)
                 db.session.commit()
                 app.logger.info(f"Notified {len(notifications)} HR/CEO(s) about new report ID {report.id}.")

    except Exception as e:
         app.logger.error(f"Error sending new report notification for report ID {report.id}: {e}", exc_info=True)
         db.session.rollback()


def notify_reporter_report_update(report):
    """Placeholder to notify the reporter when their asset report is updated."""
    try:
        with app.app_context(): # Ensure context
            reporter = report.reporter # Get the user who reported
            if not reporter or not reporter.is_active:
                 app.logger.warning(f"Reporter user {report.reported_by_id} not found or inactive for report update notification (Report ID: {report.id}).")
                 return # Cannot notify if reporter is missing or inactive

            # Prevent notifying the reporter if the updater is the reporter themselves (e.g., admin editing their own test report)
            if current_user and current_user.id == reporter.id:
                 app.logger.debug(f"Skipping reporter notification for report ID {report.id}: updater is the reporter ({reporter.username}).")
                 return

            # Check if notification is allowed
            sender_role_name = current_user.role.name.lower() if current_user.role else 'unknown'
            receiver_role_name = reporter.role.name.lower() if reporter.role else 'unknown'

            if not is_notification_allowed(sender_role_name, receiver_role_name):
                 app.logger.warning(f"Notification not allowed for report update (Report ID: {report.id}): {sender_role_name} cannot send to {receiver_role_name}.")
                 return

            asset_name = report.asset.name if report.asset else "General Asset"
            message_content = f"Your report (ID: {report.id}) for '{asset_name}' has been updated. New status: {report.status}."
            if report.resolution_notes:
                 message_content += f" Notes: {report.resolution_notes[:100]}..." # Truncate notes for notification

            link_url = url_for('list_asset_reports') # Link to the reports list (reporter might not have resolve access)
            # Or link to a specific report detail page if one exists for non-admin users

            notification = Notification(
                 sender_id=current_user.id, # The user resolving the report is the sender
                 receiver_id=reporter.id,
                 content=message_content,
                 link_url=link_url,
                 timestamp=datetime.now(timezone.utc),
                 is_read=False
            )
            db.session.add(notification)
            db.session.commit()
            app.logger.info(f"Notified reporter {reporter.username} about update to report ID {report.id}.")

    except Exception as e:
         app.logger.error(f"Error sending reporter notification for report ID {report.id}: {e}", exc_info=True)
         db.session.rollback()


# Unread counts (These now need actual implementations or placeholders)
# ADDING SIMPLE PLACEHOLDERS HERE that query the database
def get_unread_message_count(user_id):
    """Returns the count of unread messages for a user."""
    try:
        with app.app_context(): # Ensure context if called outside request
            # Use db.session.scalar(select(func.count())...) for counting
            count = db.session.scalar(
                select(func.count(Message.id))
                .where(Message.receiver_id == user_id, Message.is_read == False)
            )
            return count if count is not None else 0 # Return 0 if no messages found
    except Exception as e:
        app.logger.error(f"Error fetching unread message count for user {user_id}: {e}", exc_info=True)
        return 0 # Return 0 on error

def get_unread_notifications_count(user_id):
    """Returns the count of unread notifications for a user."""
    try:
        with app.app_context(): # Ensure context if called outside request
            # Use db.session.scalar(select(func.count())...) for counting
            count = db.session.scalar(
                select(func.count(Notification.id))
                .where(Notification.receiver_id == user_id, Notification.is_read == False)
            )
            return count if count is not None else 0 # Return 0 if no notifications found
    except Exception as e:
        app.logger.error(f"Error fetching unread notification count for user {user_id}: {e}", exc_info=True)
        return 0 # Return 0 on error


# Save uploaded file (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def save_uploaded_file(file_storage):
    """
    Placeholder to save an uploaded file securely to disk and create a File DB entry.
    Returns the File object (not committed) or None on failure.
    """
    if not file_storage:
        flash("No file provided for upload.", "warning")
        return None

    # Get filename securely
    original_filename = secure_filename(file_storage.filename)
    if not original_filename:
         flash("Invalid filename.", "danger")
         return None

    # Generate a unique internal filename using UUID
    # Keep the original extension (or attempt to guess mimetype)
    file_extension = os.path.splitext(original_filename)[1].lower()
    unique_filename = str(uuid.uuid4()) + file_extension

    # Build the full path to save the file within the UPLOAD_FOLDER configured in app.py
    # Assumes app.config['UPLOAD_FOLDER'] is correctly set
    if not app.config.get('UPLOAD_FOLDER'):
        app.logger.error("UPLOAD_FOLDER not configured in app.py")
        flash("File upload failed: Server configuration error.", "danger")
        return None

    save_directory = app.config['UPLOAD_FOLDER']
    save_path_full = os.path.join(save_directory, unique_filename)

    # Check max file size (optional, but good practice)
    file_storage.seek(0, os.SEEK_END) # Move cursor to end to get size
    file_size = file_storage.tell() # Get file size
    file_storage.seek(0) # Reset cursor to beginning for saving

    max_size = app.config.get('MAX_CONTENT_LENGTH', 16 * 1024 * 1024) # Default to 16MB
    if file_size > max_size:
         flash(f"File size exceeds the maximum allowed size ({max_size / (1024 * 1024):.0f} MB).", "danger")
         return None

    # Basic allowed file type check (optional, but recommended)
    # Could inspect mimetype or check extensions
    # Example extension check:
    ALLOWED_SOCIAL_EXTENSIONS = {'txt', 'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip', 'rar', 'jpg', 'jpeg', 'png', 'gif', 'mp4', 'mp3', 'wav', 'odt', 'ods', 'odp'}
    if file_extension.strip('.') not in ALLOWED_SOCIAL_EXTENSIONS:
        flash(f"File type '{file_extension}' is not allowed for upload. Allowed types: {', '.join(ALLOWED_SOCIAL_EXTENSIONS)}", "danger")
        return None


    try:
        # Save the file to the filesystem
        file_storage.save(save_path_full)

        # Get mimetype (optional, can be None)
        mimetype = file_storage.mimetype

        # Create a new File database record
        new_file = File(
            filename=unique_filename, # Store the unique server-side filename
            original_filename=original_filename, # Store the user's original filename
            mimetype=mimetype,
            # Store the filepath relative to the app root for portability
            # This path will be used by send_from_directory
            filepath=os.path.join('uploads', 'social_files', unique_filename),
            size=file_size,
            uploaded_by_id=current_user.id, # Link to the user who uploaded
            uploaded_at=datetime.now(timezone.utc)
        )

        # Do NOT commit here. The calling route is responsible for adding and committing
        # this File object along with the associated message/post.
        # db.session.add(new_file) # The calling route will add it
        app.logger.info(f"File '{original_filename}' saved to '{save_path_full}' by user {current_user.id}. Size: {file_size} bytes.")
        return new_file # Return the uncommitted DB object

    except Exception as e:
        # Log the error and cleanup the saved file if it exists
        app.logger.error(f"Error saving uploaded file '{original_filename}' for user {current_user.id}: {e}", exc_info=True)
        if os.path.exists(save_path_full):
             try: os.remove(save_path_full)
             except Exception as cleanup_e: app.logger.error(f"Error cleaning up failed upload file {save_path_full}: {cleanup_e}")

        flash("File upload failed due to an internal error. Please try again.", "danger")
        return None


# Can access social media file (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def can_access_file(user, file):
    """
    Placeholder to check if a user has permission to access a specific social file.
    Logic depends on where the file is linked (channel, group) and user's membership/role.
    """
    if not user or not user.is_authenticated or not file:
        return False # Must be logged in and file must exist

    # Check if the user uploaded the file
    if file.uploaded_by_id == user.id:
        return True

    # Check if the file is linked to a Channel Post
    if file.channel_post:
        # User can access if they are a member of the channel the post is in
        return user.is_channel_member(file.channel_post.channel)

    # Check if the file is linked to a Group Message
    if file.group_message:
        # User can access if they are a member of the group the message is in
        return user.is_group_member(file.group_message.group)

    # If the file is not linked to any post/message, maybe only the uploader or admin can access?
    # For now, assume unlinked files are not publicly accessible unless uploaded by the user.
    # Add administrative bypass for system_admin, hr_ceo etc.
    if user.role and user.role.name.lower() in ['system_admin', 'hr_ceo']:
         return True


    # If none of the above conditions are met, access is denied
    return False

# Can view behavior records (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
# In Part 3, the can_view_behavior_records helper function remains as previously updated:
def can_view_behavior_records(viewer, student):
    """
    Determines if a 'viewer' user has permission to view the
    behavior records of a 'student' user.
    (All authenticated users can view behavior records).
    """
    if not viewer or not viewer.is_authenticated or not student:
        return False
    return True # All authenticated users can view behavior records

# Notify student and parents of behavior record (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def notify_student_and_parents(student, behavior_record):
    """
    Placeholder to send notifications about a new behavior record to the student and their verified parents.
    """
    try:
        with app.app_context(): # Ensure context
            # Build the notification content
            message_content = f"A new behavior record has been added for you. Type: {behavior_record.behavior_type}, Severity: {behavior_record.severity}."
            # Optional: Add a link to view the behavior record details page (if one exists for students/parents)
            # link_url = url_for('view_behavior_record', record_id=behavior_record.id) # Example link

            # Notify the student
            # Check if notification is allowed (e.g. 'teacher'/'hr_ceo'/etc. sending to 'student')
            sender_role_name = behavior_record.recorded_by.role.name.lower() if behavior_record.recorded_by and behavior_record.recorded_by.role else 'unknown'
            receiver_role_name = student.role.name.lower() if student.role else 'unknown'

            if is_notification_allowed(sender_role_name, receiver_role_name):
                notification_student = Notification(
                    sender_id=behavior_record.recorded_by_id, # The user who recorded it
                    receiver_id=student.id,
                    content=message_content,
                    link_url=None, # Add link_url if applicable
                    timestamp=datetime.now(timezone.utc),
                    is_read=False
                )
                db.session.add(notification_student)
                app.logger.info(f"Notified student {student.username} about new behavior record ID {behavior_record.id}.")
            else:
                 app.logger.warning(f"Notification not allowed for student {student.username} about behavior record {behavior_record.id} from sender role {sender_role_name}.")


            # Notify verified parents of the student
            if student.parent_associations: # Check if the student has parent associations
                 parent_associations = db.session.scalars(select(ParentStudent).filter_by(student_id=student.id, verification_status='verified')).all()

                 parent_message_content = f"A new behavior record has been added for your child, {student.full_name or student.username}. Type: {behavior_record.behavior_type}, Severity: {behavior_record.severity}."
                 # Optional: Add a link to view the behavior record from the parent dashboard/student profile
                 # link_url_parent = url_for('parent_view_student_behavior', student_id=student.id) # Example link

                 for assoc in parent_associations:
                      parent = assoc.parent.user # Get the Parent User object from the association
                      if parent and parent.is_active and parent.role and parent.role.name.lower() == 'parent':
                           # Check if notification is allowed (e.g. 'teacher'/'hr_ceo'/etc. sending to 'parent')
                           # Sender role is the role of the user who recorded it
                           receiver_role_name_parent = parent.role.name.lower()

                           if is_notification_allowed(sender_role_name, receiver_role_name_parent):
                                notification_parent = Notification(
                                     sender_id=behavior_record.recorded_by_id, # The user who recorded it
                                     receiver_id=parent.id,
                                     content=parent_message_content,
                                     link_url=None, # Add link_url_parent if applicable
                                     timestamp=datetime.now(timezone.utc),
                                     is_read=False
                                )
                                db.session.add(notification_parent)
                                app.logger.info(f"Notified parent {parent.username} about new behavior record ID {behavior_record.id} for child {student.username}.")
                           else:
                                app.logger.warning(f"Notification not allowed for parent {parent.username} about behavior record {behavior_record.id} from sender role {sender_role_name}.")


            db.session.commit() # Commit all notifications (student and parents)

    except Exception as e:
         # Log the error but don't roll back the main transaction that added the behavior record
         app.logger.error(f"Error sending behavior record notifications for student {student.id}, record ID {behavior_record.id}: {e}", exc_info=True)
         db.session.rollback() # Rollback only the notification transaction


# Helper to save social media files (distinct from profile photos, defined in Part 12)
# Keeping definition here for reference, but the actual function body was provided in Part 12.
# def save_uploaded_file(file_storage):
#      pass # Body is in Part 12


# Helper to save profile photos (defined in Part 12)
# Keeping definition here for reference, but the actual function body was provided in Part 12.
# def save_profile_photo(file_storage):
#      pass # Body is in Part 12


# --- END PART 3 ---

# --- PART 4 START: WTForms Definitions ---
# ... (WTForms definitions from your code) ...
# --- END PART 4 ---

# --- PART 5 START: Authentication Routes ---
# ... (Authentication routes from your code) ...
# --- END PART 5 ---

# --- PART 6 START: Role Dashboards & Core Navigation ---
# ... (Role Dashboards & Core Navigation routes from your code) ...
# --- END PART 6 ---

# --- PART 7 START: Teacher/Librarian Specific Features ---
# ... (Teacher/Librarian Specific Features routes from your code) ...
# --- END PART 7 ---

# --- PART 8 START: HR/CEO & System Admin Management Features ---
# ... (HR/CEO & System Admin Management Features routes from your code) ...
# --- END PART 8 ---

# --- PART 9 START: Book Checkout & Management ---
# ... (Book Checkout & Management routes from your code) ...
# --- END PART 9 ---

# --- PART 10 START: Chat and Contacts ---
# ... (Chat and Contacts routes from your code) ...
# --- END PART 10 ---

# --- PART 11 START: Notifications ---
# ... (Notifications routes from your code) ...
# --- END PART 11 ---

# --- Group Routes ---
# ... (Group routes from your code) ...
# --- PART 12 END: Social Media Features ---

# --- PART 13 START: Settings ---
# ... (Settings routes from your code) ...
# --- PART 13 END: Settings ---

# --- PART 14 START: Analytics (Placeholder/Basic) ---
# ... (Analytics routes from your code) ...
# --- PART 14 END: Analytics (Placeholder/Basic) ---

# --- PART 15 START: CLI Commands, Error Handlers, and Main Execution ---
# ... (CLI Commands, Error Handlers, and Main Execution from your code) ...
# --- PART 15 END ---

# --- PART 4 START: WTForms Definitions ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models like User, AssetCategory, Lab are defined.
# - Helpers like get_social_categories are defined.
# - SQLAlchemy imports (select, func, etc.) and WTForms imports are available.

# START MODIFICATION (get_social_categories helper)
def get_social_categories():
    """Helper to query and format social categories for select fields."""
    # Requires an active application context and initialized db
    try:
        with app.app_context(): # Ensure context if called during app setup
             return db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all() # MODIFIED: Query SocialCategory
    except Exception as e:
        # Log or handle the error appropriately
        app.logger.error(f"Error fetching social categories: {e}")
        return [] # Return empty list on error
# END MODIFICATION (get_social_categories helper)

# Add this new helper function
def get_asset_categories():
    """Helper to query and format asset categories for select fields."""
    try:
        with app.app_context(): # Ensure context if called during app setup
             return db.session.scalars(select(AssetCategory).order_by(AssetCategory.name)).all()
    except Exception as e:
        app.logger.error(f"Error fetching asset categories: {e}")
        return []

# ... (rest of get_social_categories and @app.context_processor) ...

# --- Custom Jinja Filters ---
@app.template_filter("datetimeformat")
def datetimeformat(value, format="%Y-%m-%d %H:%M"):
    """Formats a datetime object to a string."""
    if isinstance(value, datetime):
        # Ensure timezone-aware conversion if needed, or assume UTC as per model defaults
        # For simplicity, direct format assuming UTC or naive UTC objects
        return value.strftime(format)
    if isinstance(value, str):  # Basic attempt to handle string dates
        try:
            # Handle common ISO format with Z or offset
            dt_obj = datetime.fromisoformat(value.replace("Z", "+00:00"))
            return dt_obj.strftime(format)
        except ValueError:
            pass  # Fall through if parsing fails
    return value if value is not None else "" # Return original value or empty string if None


@app.template_filter('dateformat')
def dateformat_filter(value, format='%Y-%m-%d'):
    """Formats a date or datetime object to a date string."""
    if isinstance(value, (datetime, Date)):
        return value.strftime(format)
    return value if value is not None else ""


# --- Role Management Decorator ---
def role_required(*required_roles):
    """Decorator to restrict access to routes based on user roles."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash("Please log in to access this page.", "warning")
                return redirect(url_for("login", next=request.url))

            user_role_name = (
                current_user.role.name.lower() if current_user.role else None
            )
            normalized_required_roles = [role.lower() for role in required_roles]

            if user_role_name not in normalized_required_roles:
                app.logger.warning(
                    f"User {current_user.username} (Role: {user_role_name}) "
                    f"attempted to access restricted route requiring roles: {required_roles}"
                )
                abort(403)  # Forbidden
            return f(*args, **kwargs)

        return decorated_function

    return decorator

def tc_member_required(f):
    """Decorator to restrict access to routes to users who are Talent Club members."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check if the user is marked as a Talent Club member
        if not current_user.is_tc_member:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC restricted route {request.path} but is not a TC member."
            )
            flash("You must be a Talent Club member to access this area.", "warning")
            # Redirect them back to their dashboard or a page prompting them to join TC
            # Redirect to a generic TC join page if it exists, or fallback
            return redirect(url_for('student_dashboard')) # Assuming students start here

        return f(*args, **kwargs)

    return decorated_function

# --- Define VALID_ROLES GLOBALLY (Needed for permission configs and helpers) ---
VALID_ROLES = [
    ('system_admin', 'System Administrator (Full Access)'),
    ('school_executive', 'School Executive Board Member'),
    ('government', 'Government Compliance Officer'),
    ('hr_ceo', 'HR & Academic CEO'),
    ('teacher', 'Teaching Staff'),
    ('librarian', 'Library Management'),
    ('talent_club', 'Talent Club Coordinator'),
    ('student', 'Enrolled Student'),
    ('parent', 'Student Parent/Guardian')
]
# Make VALID_ROLES available in the app config for easier access in helpers
app.config['VALID_ROLES'] = VALID_ROLES
# Extract just the role names for easier lookup
VALID_ROLE_NAMES = [role[0] for role in VALID_ROLES]


# --- Permission Configurations (Chat & Notification) ---

# --- Permission Configurations (Chat & Notification) ---

# Updated CHAT_PERMISSIONS configuration
CHAT_PERMISSIONS = {
    # Role: { 'send_to': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'receive_from': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'exceptions': {'leader': {'send_to': {...}, 'receive_from': {...}}} }
    'government': {
        'send_to': {'specific': ['hr_ceo', 'school_executive']}, # UPDATED
        'receive_from': {'specific': ['school_executive', 'government']}
    },
    'school_executive': {
        'send_to': {'all': True, 'exceptions': ['student', 'talent_club']}, # UPDATED (added 'student')
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
    'system_admin': { # No explicit rules provided for System Admin, keeping previous configuration
        'send_to': {'all': True, 'exceptions': ['government', 'talent_club']},
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
    'student': {
        'send_to': {'none': True}, # Default students cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'teacher', 'librarian', 'talent_club']}, # Receives from relevant staff roles and Talent Club leaders
        'exceptions': {
            'tc_member': { # Talent Club Member Exception (Students who opted-in)
                'send_to': {'specific': ['student', 'talent_club']}, # MODIFIED: Can send general chat to other students (who are TC members) and Talent Club role users (TC Leader, coordinators)
                'receive_from': {'specific': ['student', 'talent_club', 'hr_ceo', 'teacher', 'librarian', 'school_executive', 'system_admin']}, # MODIFIED: Can receive from TC network, HR/CEO, and other relevant staff roles. Explicitly listing allows more control than 'all' with exceptions.
            },
            'leader': { # Student Leaders Exception (keep existing if any)
                'send_to': {'specific': ['student', 'hr_ceo', 'system_admin']},
                'receive_from': {'all': True, 'exceptions': ['government', 'talent_club', 'school_executive', 'parent']}, # Keep as is or adjust
             }
        }
    },
    'teacher': {
        'send_to': {'all': True, 'exceptions': ['government', 'talent_club']}, # UPDATED (removed 'student')
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
    'hr_ceo': {
        'send_to': {'all': True, 'exceptions': ['government', 'student', 'talent_club']}, # UPDATED (added 'student')
        'receive_from': {'all': True, 'exceptions': ['government', 'student', 'talent_club']} # UPDATED (added 'student')
    },
    'parent': {
        'send_to': {'specific': ['teacher', 'hr_ceo', 'parent']},
        'receive_from': {'specific': ['teacher', 'hr_ceo', 'parent', 'school_executive', 'system_admin']},
    },
    'librarian': {
        'send_to': {'all': True, 'exceptions': ['government', 'talent_club', 'student', 'parent']}, # UPDATED (added 'parent')
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
        'talent_club': { # Talent Club Role (e.g. System-wide Coordinators, or the Leader's role)
        'send_to': {'none': True}, # MODIFIED: Default Talent Club role users (non-leader) CANNOT send chat
        'receive_from': {'specific': ['student', 'talent_club', 'hr_ceo', 'teacher', 'librarian', 'school_executive', 'system_admin']}, # MODIFIED: Can receive from TC network and relevant staff/admin
        'exceptions': {
            'tc_leader': { # Talent Club Leaders Exception (users with talent_club role AND is_tc_leader=True)
                # NOTE: 'send_to' here is LESS important now because the helper overrides it globally
                # if user.is_tc_leader is True. Keeping it here for documentation/clarity.
                'send_to': {'specific': ['student', 'talent_club', 'hr_ceo']},
                'receive_from': {'specific': ['student', 'talent_club', 'hr_ceo', 'teacher', 'librarian', 'school_executive', 'system_admin']} # MODIFIED: Same broad receiving as default Talent Club role user
            }
        }
    }
}
NOTIFICATION_PERMISSIONS = {
    # Role: { 'send_to': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'receive_from': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]} }

    'government': {
        'send_to': {'all': True}, # Full permission to send
        'receive_from': {'none': True} # Government receives no notifications
    },
    'school_executive': {
        'send_to': {'all': True, 'exceptions': ['government']}, # Can send to all except government
        'receive_from': {'all': True, 'exceptions': ['student', 'parent', 'talent_club']} # Receives from all who can send (except non-senders)
    },
    'system_admin': {
        'send_to': {'all': True}, # Can send to all
        'receive_from': {'all': True, 'exceptions': ['student', 'parent', 'talent_club']} # Receives from all who can send (except non-senders)
    },
    'hr_ceo': {
        'send_to': {'all': True, 'exceptions': ['school_executive', 'government']}, # Can send to all except school_executive and government
        'receive_from': {'all': True, 'exceptions': ['student', 'parent', 'talent_club']} # Receives from all who can send (except non-senders)
    },
    'teacher': {
        'send_to': {'specific': ['student', 'parent']}, # Teachers notify students and parents
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive']} # Receives from these staff roles
    },
    'librarian': {
        'send_to': {'specific': ['student']}, # Librarian notifies students
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive']} # Receives from these staff roles
    },
    'talent_club': {
        'send_to': {'none': True}, # Regular Talent Club members cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'talent_club']}, # Receives from relevant staff and other Talent Club members (leaders)
        'exceptions': {
            'tc_leader': { # Talent Club Leaders Exception (uses is_tc_leader)
                'send_to': {'specific': ['talent_club']} # Leader can send to other Talent Club members
            }
        }
    },
    'student': {
        'send_to': {'none': True}, # Students cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'teacher', 'librarian', 'talent_club']} # Receives from relevant staff roles and Talent Club leaders
    },
    'parent': {
        'send_to': {'none': True}, # Parents cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'teacher']} # Receives from relevant staff roles
    }
}

# --- NEW CONFIGURATIONS: Talent Club Subsystem ---

# Configuration for allowed roles/members to post in a specific Talent Club's feed channel
# Key is the TalentClubMembership role name (lowercase)
TALENT_CLUB_POSTING_PERMISSIONS = {
    'creator': True,
    'admin': True,
    'member': False, # Default members cannot post
}

# --- NEW CONFIGURATIONS: Task System ---

TASK_CREATOR_ROLES = ['hr_ceo', 'system_admin', 'school_executive'] # Define which roles can create tasks
# You can add other roles here if needed, e.g., 'teacher' for class tasks.

# Define valid statuses for UserTask for clarity
USER_TASK_STATUSES = [
    'Open',
    'In Progress',
    'Completed (Pending Review)',
    'Delayed (Pending Review)',
    'Rejected (Pending Review)',
    'Accepted', # Creator accepted completion/status update
    'Review Rejected' # Creator rejected status update, task is sent back
]

TASK_HISTORY_ACTIONS = [
    'Assigned',
    'Status Update', # User updated status to In Progress, Completed, Delayed, Rejected
    'Review Accepted', # Creator accepted user's status update
    'Review Rejected' # Creator rejected user's status update
]

# --- NEW HELPER FUNCTIONS: Task System ---

def get_allowed_task_creators():
    """Fetches User objects for roles allowed to create tasks."""
    with app.app_context(): # Ensure context
        return db.session.scalars(
            select(User).join(Role).where(Role.name.in_(TASK_CREATOR_ROLES), User.is_active == True).order_by(User.full_name)
        ).all()

def get_assignable_users():
    """Fetches User objects eligible for individual task assignment (e.g., all active users except creators?)."""
    # For simplicity, let's allow assigning to all active users except system admins
    with app.app_context(): # Ensure context
         system_admin_role = db.session.scalar(select(Role).filter_by(name='system_admin'))
         query = select(User).where(User.is_active == True)
         if system_admin_role:
              query = query.where(User.role != system_admin_role)
         return db.session.scalars(query.order_by(User.full_name)).all()
    # You might want more granular control here based on roles that can receive tasks

def get_assignable_roles():
    """Returns a list of valid role names that can be targets for group assignment."""
    # For V1, let's make all standard roles assignable as groups, maybe exclude admins?
    # Or, keep it simple and allow assigning to any defined role in VALID_ROLE_NAMES
    return [role_name for role_name, _ in VALID_ROLES] # Use the global VALID_ROLES defined earlier


def get_assignable_grade_sections():
    """Fetches distinct grade-section pairs for student group assignment."""
    with app.app_context(): # Ensure context
        # Query active students for their grade/section pairs
        stmt = (
            select(User.grade, User.section)
            .join(Role).filter(Role.name == 'student')
            .where(User.is_active == True, User.grade.isnot(None), User.section.isnot(None))
            .distinct()
            .order_by(User.grade, User.section)
        )
        return db.session.execute(stmt).all() # Returns list of (grade, section) tuples


def log_user_task_history(user_task, changed_by_user, old_status, new_status, action, notes=None):
    """
    Logs an action to the TaskHistory for a given UserTask.
    This function should be called within a database session.
    """
    history_entry = TaskHistory(
        user_task=user_task, # Link to the UserTask object
        changed_by=changed_by_user, # Link to the User who made the change
        old_status=old_status,
        new_status=new_status,
        action=action,
        notes=notes,
        timestamp=datetime.now(timezone.utc)
    )
    db.session.add(history_entry)
    # Note: Commit should be handled by the calling route, not here.


def notify_task_assigned(user_task):
    """Sends a notification to a user that a task has been assigned to them."""
    with app.app_context(): # Ensure context
        try:
            receiver = user_task.user # The assigned user
            sender = user_task.assigned_by # The user who assigned this instance (usually creator)
            if not receiver or not receiver.is_active:
                 app.logger.warning(f"Cannot notify inactive user {receiver.id if receiver else 'N/A'} about assigned task {user_task.task_id}.")
                 return
            if not sender:
                 sender = db.session.scalar(select(User).filter_by(username='system')) # Fallback to system user
                 if not sender:
                      app.logger.error("System user not found for task assignment notification sender.")
                      return

            notification_content = f"You have been assigned a new task: '{user_task.task.title}'."
            link_url = url_for('view_user_task', user_task_id=user_task.id) # Link to the user's task detail page

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(sender, receiver):
                 notification = Notification(
                     sender_id=sender.id,
                     receiver_id=receiver.id,
                     content=notification_content,
                     link_url=link_url,
                     timestamp=datetime.now(timezone.utc),
                     is_read=False,
                     notification_type='task_assigned', # Specific type
                     related_object_id=user_task.id # Link to the UserTask instance
                 )
                 db.session.add(notification)
                 db.session.commit() # Commit notification immediately
                 app.logger.info(f"Notification sent to user {receiver.id} about assigned task {user_task.id}.")
            else:
                 app.logger.warning(f"Notification not allowed for task assignment: Sender '{sender.role.name if sender.role else 'N/A'}' to Receiver '{receiver.role.name if receiver.role else 'N/A'}'.")

        except Exception as e:
            db.session.rollback() # Rollback only the notification transaction
            app.logger.error(f"Error sending task assigned notification for UserTask {user_task.id}: {e}", exc_info=True)


def notify_user_task_status_update(user_task):
    """Sends a notification to the task creator when an assigned user updates status."""
    with app.app_context(): # Ensure context
        try:
            creator = user_task.task.created_by # The task creator (receiver)
            assigned_user = user_task.user # The user who updated status (sender)
            if not creator or not creator.is_active:
                 app.logger.warning(f"Cannot notify inactive creator {creator.id if creator else 'N/A'} about status update for UserTask {user_task.id}.")
                 return
            # Assigned user must be active to be the sender
            if not assigned_user or not assigned_user.is_active:
                app.logger.warning(f"Assigned user {assigned_user.id if assigned_user else 'N/A'} for UserTask {user_task.id} is inactive. Cannot use as notification sender.")
                assigned_user = db.session.scalar(select(User).filter_by(username='system')) # Fallback sender


            notification_content = f"Status update for task '{user_task.task.title}' by {assigned_user.full_name or assigned_user.username}: '{user_task.status}'."
            link_url = url_for('review_user_task', user_task_id=user_task.id) # Link to the review page for this UserTask instance

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(assigned_user, creator):
                 notification = Notification(
                     sender_id=assigned_user.id,
                     receiver_id=creator.id,
                     content=notification_content,
                     link_url=link_url,
                     timestamp=datetime.now(timezone.utc),
                     is_read=False,
                     notification_type='task_status_update', # Specific type
                     related_object_id=user_task.id # Link to the UserTask instance
                 )
                 db.session.add(notification)
                 db.session.commit() # Commit notification immediately
                 app.logger.info(f"Notification sent to creator {creator.id} about status update for UserTask {user_task.id}.")
            else:
                app.logger.warning(f"Notification not allowed for task status update: Sender '{assigned_user.role.name if assigned_user.role else 'N/A'}' to Receiver '{creator.role.name if creator.role else 'N/A'}'.")


        except Exception as e:
            db.session.rollback() # Rollback only the notification transaction
            app.logger.error(f"Error sending task status update notification for UserTask {user_task.id}: {e}", exc_info=True)


def notify_user_task_review_result(user_task):
    """Sends a notification to the assigned user about the creator's review outcome."""
    with app.app_context(): # Ensure context
        try:
            assigned_user = user_task.user # The assigned user (receiver)
            creator = user_task.task.created_by # The task creator (sender/reviewer)
            if not assigned_user or not assigned_user.is_active:
                 app.logger.warning(f"Cannot notify inactive user {assigned_user.id if assigned_user else 'N/A'} about review result for UserTask {user_task.id}.")
                 return
            # Creator must be active to be the sender
            if not creator or not creator.is_active:
                 app.logger.warning(f"Creator {creator.id if creator else 'N/A'} for UserTask {user_task.id} is inactive. Cannot use as notification sender.")
                 creator = db.session.scalar(select(User).filter_by(username='system')) # Fallback sender


            review_outcome_text = user_task.status # e.g., 'Accepted', 'Review Rejected'
            notification_content = f"Review for your task assignment '{user_task.task.title}': Status is now '{review_outcome_text}'."
            if user_task.reviewer_notes:
                 notification_content += f" Notes: {user_task.reviewer_notes[:100]}..."

            link_url = url_for('view_user_task', user_task_id=user_task.id) # Link back to the user's task detail page

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(creator, assigned_user):
                 notification = Notification(
                     sender_id=creator.id,
                     receiver_id=assigned_user.id,
                     content=notification_content,
                     link_url=link_url,
                     timestamp=datetime.now(timezone.utc),
                     is_read=False,
                     notification_type='task_review_result', # Specific type
                     related_object_id=user_task.id # Link to the UserTask instance
                 )
                 db.session.add(notification)
                 db.session.commit() # Commit notification immediately
                 app.logger.info(f"Notification sent to user {assigned_user.id} about review result for UserTask {user_task.id}.")
            else:
                app.logger.warning(f"Notification not allowed for task review result: Sender '{creator.role.name if creator.role else 'N/A'}' to Receiver '{assigned_user.role.name if assigned_user.role else 'N/A'}'.")


        except Exception as e:
            db.session.rollback() # Rollback only the notification transaction
            app.logger.error(f"Error sending task review result notification for UserTask {user_task.id}: {e}", exc_info=True)


# Assignment helpers that create UserTask instances and trigger initial notifications/history
def assign_task_to_users(task, user_ids, assigned_by_user, assignment_type='individual', assignment_detail=None):
    """Assigns a Task to a list of specific user IDs."""
    assigned_count = 0
    # Fetch actual user objects to ensure they exist and are active
    users_to_assign = db.session.scalars(
        select(User).where(User.id.in_(user_ids), User.is_active == True)
    ).all()

    if not users_to_assign:
        app.logger.warning(f"No active users found for assignment to task {task.id} with IDs {user_ids}.")
        return 0 # No users assigned

    try:
        for user in users_to_assign:
            # Check if a UserTask already exists for this specific task and user
            existing_assignment = db.session.scalar(select(UserTask).filter_by(task=task, user=user).limit(1))
            if existing_assignment:
                app.logger.warning(f"User {user.username} already has an assignment for task {task.id}. Skipping duplicate assignment.")
                continue # Skip if already assigned

            new_assignment = UserTask(
                task=task,
                user=user,
                assigned_by=assigned_by_user,
                assignment_type=assignment_type,
                assignment_detail=assignment_detail,
                status='Open', # Initial status
                assigned_at=datetime.now(timezone.utc),
                last_status_update_at=datetime.now(timezone.utc)
            )
            db.session.add(new_assignment)
            db.session.flush() # Flush to get UserTask ID for history

            # Log initial assignment history
            log_user_task_history(new_assignment, assigned_by_user, None, 'Open', 'Assigned', task.description[:100] + '...' if task.description else None)

            assigned_count += 1
            # Notify user after assignment (each notification commit is separate)
            notify_task_assigned(new_assignment)

        db.session.commit() # Commit all new UserTask entries and history entries added in this function call

        app.logger.info(f"Task {task.id} assigned to {assigned_count} users by {assigned_by_user.username}.")
        return assigned_count # Return count of successfully assigned users

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error assigning task {task.id} to users by {assigned_by_user.username}: {e}", exc_info=True)
        return 0 # Return 0 on error


def assign_task_to_role(task, role_name, assigned_by_user):
    """Assigns a Task to all active users in a specific role."""
    role = db.session.scalar(select(Role).filter_by(name=role_name))
    if not role:
        app.logger.warning(f"Role '{role_name}' not found for task assignment.")
        return 0 # No users assigned

    # Find all active users in this role
    users_in_role = db.session.scalars(
        select(User).where(User.role == role, User.is_active == True)
    ).all()

    if not users_in_role:
        app.logger.info(f"No active users found in role '{role_name}' for task assignment {task.id}.")
        return 0 # No users to assign

    user_ids = [user.id for user in users_in_role]
    return assign_task_to_users(task, user_ids, assigned_by_user, assignment_type='group_role', assignment_detail=role_name)


def assign_task_to_grade_section(task, grade, section, assigned_by_user):
    """Assigns a Task to all active students in a specific grade and section."""
    # Find all active students in this grade and section
    student_role = db.session.scalar(select(Role).filter_by(name='student'))
    if not student_role:
        app.logger.error("Student role not found for grade/section assignment.")
        return 0

    users_in_class = db.session.scalars(
        select(User).where(
            User.role == student_role,
            User.grade == grade,
            User.section == section,
            User.is_active == True
        )
    ).all()

    if not users_in_class:
        app.logger.info(f"No active students found in grade {grade}, section {section} for task assignment {task.id}.")
        return 0 # No users to assign

    user_ids = [user.id for user in users_in_class]
    return assign_task_to_users(task, user_ids, assigned_by_user, assignment_type='group_section', assignment_detail=f"{grade}-{section}")

# --- END NEW HELPER FUNCTIONS ---

# Configuration for Talent Club levels
TALENT_CLUB_LEVELS = [
    1, 2, 3, 4, 5, # Example levels
    # Define level names if using strings instead of integers:
    # ('Level 1', 1), ('Level 2', 2), ...
]

# Configuration for ban/mute types if using the models
TALENT_CLUB_BAN_TYPES = ['ban', 'mute'] # Corresponds to TalentClubBan.type

# Configuration for penalty types if using the models
TALENT_CLUB_PENALTY_TYPES = ['warning_points', 'temporary_restriction'] # Corresponds to TalentClubPenalty.type

# Constant for the name of the main Talent Club Community group
TC_COMMUNITY_GROUP_NAME = "Talent Club Community"


# --- NEW: Request System Permissions Configuration ---
REQUEST_SYSTEM_PERMISSIONS = {
    'can_initiate': ['librarian', 'student_leader', 'teacher', 'talent_club_leader'], # Roles that can start a request
    'tier_handlers': { # Maps tier to the role responsible for handling that tier
        1: 'hr_ceo',
        2: 'school_executive',
        3: 'government',
    },
    'forward_paths': { # Maps current handler role to next handler role for forwarding
        'hr_ceo': 'school_executive',
        'school_executive': 'government',
    },
    'final_tiers': ['government'], # Roles that cannot forward further
    'resolver_roles': ['hr_ceo', 'school_executive'], # Roles that can mark a request as 'Resolved' at their tier
}

# --- END NEW: Request System Permissions Configuration ---

# --- NEW: Request System Helper Functions ---

def log_request_history(request_obj, changed_by_user, old_status, new_status, action, notes=None):
    """
    Logs an action to the RequestHistory for a given request.
    This function should be called within a database session.
    """
    history_entry = RequestHistory(
        request_id=request_obj.id,
        changed_by_id=changed_by_user.id,
        old_status=old_status,
        new_status=new_status,
        action=action,
        notes=notes,
        timestamp=datetime.now(timezone.utc)
    )
    db.session.add(history_entry)
    # Note: Commit should be handled by the calling route, not here,
    # so that the history entry is committed along with the request changes.


def notify_request_event(request_obj, event_type, old_status=None, changed_by_user=None):
    """
    Sends notifications related to a request event (submission, status change, forward).
    Leverages the existing Notification model and `send_notification_to_user` logic.
    Assumes `send_notification_to_user` (or `Notification` creation) handles permissions
    between sender/receiver roles based on NOTIFICATION_PERMISSIONS.
    """
    with app.app_context(): # Ensure app context for DB operations and url_for
        try:
            sender = changed_by_user if changed_by_user else db.session.scalar(select(User).filter_by(username='system')) # Use a 'system' user if no specific changed_by
            if not sender:
                app.logger.error("System user not found for request notification sender.")
                return

            notification_content = ""
            receiver_user_id = None
            link_url = url_for('view_request_detail', request_id=request_obj.id) # Link to the request detail page

            if event_type == 'Submitted':
                notification_content = f"A new request '{request_obj.title}' (ID: {request_obj.id}) has been submitted by {request_obj.requester.full_name or request_obj.requester.username} and is awaiting your review."
                receiver_user_id = request_obj.current_handler_id # Notify the assigned handler
            elif event_type == 'Status_Updated':
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been updated. New status: '{request_obj.status}'."
                receiver_user_id = request_obj.requester_id # Notify the original requester
            elif event_type == 'Forwarded':
                notification_content = f"A request '{request_obj.title}' (ID: {request_obj.id}) has been forwarded to you for review by {sender.full_name or sender.username}."
                receiver_user_id = request_obj.current_handler_id # Notify the new handler
            elif event_type == 'Resolved':
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been successfully resolved."
                receiver_user_id = request_obj.requester_id # Notify requester of resolution
            elif event_type == 'Denied':
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been denied. Reason: {request_obj.denial_reason[:100]}..." if request_obj.denial_reason else "Your request has been denied."
                receiver_user_id = request_obj.requester_id # Notify requester of denial

            if receiver_user_id:
                receiver = db.session.get(User, receiver_user_id)
                if receiver and receiver.is_active and receiver.role:
                    # Check permission using the can_send / can_receive helpers
                    # These helpers are already defined in Part 3 and use NOTIFICATION_PERMISSIONS
                    # The `send_notification_to_user` route implicitly handles permission checks when creating the notification.
                    # Here, we are constructing the notification object directly.
                    # So, we should check `can_send` and `can_receive` here or trust the overall permission config.
                    # For simplicity, we'll assume the notification config dictates who should *get* these, and the sender is typically a system/admin or authorized handler.

                    # It's better to explicitly check if the sender can send to the receiver's role
                    # This check is crucial for ensuring valid notifications are created.
                    if can_send(sender, receiver.role.name) and can_receive(receiver, sender.role.name):
                        notification = Notification(
                            sender_id=sender.id,
                            receiver_id=receiver.id,
                            content=notification_content,
                            link_url=link_url,
                            timestamp=datetime.now(timezone.utc),
                            is_read=False
                        )
                        db.session.add(notification)
                        db.session.commit()
                        app.logger.info(f"Notification '{event_type}' sent for request ID {request_obj.id} to user {receiver.id}.")
                    else:
                        app.logger.warning(f"Notification not allowed for request ID {request_obj.id}: Sender '{sender.role.name}' to Receiver '{receiver.role.name}'.")
                else:
                    app.logger.warning(f"Receiver user (ID: {receiver_user_id}) for request ID {request_obj.id} notification not found or inactive.")
            else:
                app.logger.warning(f"No valid receiver_user_id for request ID {request_obj.id} event '{event_type}'.")

        except Exception as e:
            db.session.rollback() # Rollback notification creation if it fails
            app.logger.error(f"Error in notify_request_event for request ID {request_obj.id}, event '{event_type}': {e}", exc_info=True)


def get_request_permissions(user_obj, request_obj=None):
    """
    Determines detailed permissions for a user regarding the request system or a specific request.
    Returns a dictionary of boolean flags.
    """
    permissions = {
        'can_create_request': False,
        'can_review': False,        # Can review requests in their inbox
        'can_forward': False,       # Can forward to next tier
        'can_resolve': False,       # Can mark as 'Resolved'
        'can_deny': False,          # Can mark as 'Denied'
        'can_see_history': False,   # Can view full history of a request
        'is_handler_for_request': False, # True if request_obj.current_handler_id == user_obj.id
        'is_requester_of_request': False, # True if request_obj.requester_id == user_obj.id
    }

    if not user_obj or not user_obj.is_authenticated or not user_obj.role:
        return permissions # No permissions for unauthenticated or rol-less users

    user_role_name = user_obj.role.name.lower()

    # Determine can_create_request (initial submission)
    # Check for student leader and talent club leader roles
    if user_role_name == 'student' and user_obj.is_leader:
        permissions['can_create_request'] = True
    elif user_role_name == 'talent_club' and user_obj.is_tc_leader:
        permissions['can_create_request'] = True
    elif user_role_name in REQUEST_SYSTEM_PERMISSIONS['can_initiate']:
        # This will cover 'librarian', 'teacher'
        permissions['can_create_request'] = True

    # Global admin override for review/management (System Admin has full control)
    is_global_admin = user_role_name in ['system_admin', 'hr_ceo'] # HR/CEO can also manage (Tier 1 handler)

    # Permissions related to a specific request
    if request_obj:
        permissions['is_requester_of_request'] = (request_obj.requester_id == user_obj.id)
        permissions['is_handler_for_request'] = (request_obj.current_handler_id == user_obj.id)

        # Anyone related to the request can see its history
        if permissions['is_requester_of_request'] or permissions['is_handler_for_request'] or is_global_admin:
            permissions['can_see_history'] = True

        # Reviewer permissions
        if permissions['is_handler_for_request'] or is_global_admin:
            # A user can review if they are the current handler or a global admin.
            # However, if it's already Denied/Resolved at the current tier, they can't 'review' further directly.
            if request_obj.status not in ['Denied', 'Resolved']:
                permissions['can_review'] = True
                permissions['can_deny'] = True # Handlers can always deny at their tier

                # Specific actions based on tier
                if request_obj.tier == 1 and user_role_name == 'hr_ceo':
                    permissions['can_forward'] = True # Can forward to School Exec
                    permissions['can_resolve'] = True # Can resolve (final for HR/CEO)
                elif request_obj.tier == 2 and user_role_name == 'school_executive':
                    permissions['can_forward'] = True # Can forward to Government
                    permissions['can_resolve'] = True # Can resolve (final for School Exec)
                elif request_obj.tier == 3 and user_role_name == 'government':
                    # Government can only approve/deny (no 'On Progress' or 'Resolve' in the same sense, 'Approved' is final)
                    # And they cannot forward
                    permissions['can_resolve'] = True # Denotes 'Approved' as final action
                    permissions['can_forward'] = False # Explicitly cannot forward

        # HR/CEO and School Exec can initiate requests directly to the next tier
        if user_role_name == 'hr_ceo' and not request_obj.id: # Not editing an existing request, initiating new
            permissions['can_create_request'] = True
        elif user_role_name == 'school_executive' and not request_obj.id: # Not editing an existing request, initiating new
            permissions['can_create_request'] = True

    return permissions

# Helper to get users of a specific role (re-using existing pattern)
# This was implicitly assumed to be available. If not, add this:
def get_users_in_role(role_name):
    """Fetches all active users belonging to a specific role."""
    with app.app_context():
        role = db.session.scalar(select(Role).filter_by(name=role_name))
        if role:
            return db.session.scalars(select(User).where(User.role == role, User.is_active == True).order_by(User.full_name)).all()
    return []

# --- END NEW: Request System Helper Functions ---

# --- NEW FORMS: Talent Club Subsystem ---

class CreateTalentClubProposalForm(FlaskForm):
    """Form for submitting a proposal to create a new Talent Club instance."""
    name = StringField("Club Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[DataRequired(), Length(min=10, max=500)])
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # Reuse SocialCategory
    proposal_file = FileField("Proposal Document (Optional)", validators=[Optional(), FileAllowed(['pdf', 'doc', 'docx', 'txt', 'odt'], 'Documents only!')])

    # mentioned_members field is handled dynamically via JavaScript for searching/selecting users.
    # We will receive the list of IDs in request.form or request.json on POST.
    # Add a hidden field or similar if needed for form submission structure, but validation is manual.
    # Example: mentioned_member_ids = HiddenField("mentioned_member_ids", validators=[DataRequired()]) # Requires JS to populate value


    submit = SubmitField("Submit Proposal")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices dynamically
        # Assuming get_social_categories() helper exists and queries SocialCategory
        self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
        if not self.social_category_id.choices:
             self.social_category_id.choices = [('', 'No categories available')]

    # Custom validation for minimum mentioned members will happen in the route handler

class EditTalentClubProfileForm(FlaskForm):
    """Form for editing an existing Talent Club instance profile."""
    name = StringField("Club Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!')]) # Reuse photo helper logic
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()])

    # Options from TalentClubFeed linked settings (will be edited via the linked channel's settings if implemented)
    # For simplicity, we won't include linked channel settings here unless explicitly needed.
    # allow_comments = BooleanField("Allow Comments on Posts") # These fields belong on the linked Channel/Feed

    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
        if not self.social_category_id.choices:
            self.social_category_id.choices = [('', 'No categories available')]

    # Add custom validation for name uniqueness if needed (excluding self)

class TalentClubLeaderVoteForm(FlaskForm):
    """Form for TC Members to vote for the System-wide TC Leader."""
    candidate_id = SelectField("Select Your Candidate", coerce=int, validators=[DataRequired()])
    submit = SubmitField("Cast Vote")

    def __init__(self, *args, candidates=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate candidate choices with eligible users (is_tc_member=True)
        if candidates is not None:
             self.candidate_id.choices = [(u.id, f"{u.full_name} ({u.username})") for u in candidates]
        else:
             self.candidate_id.choices = [(0, 'No candidates available')]

class TalentClubWarningForm(FlaskForm):
    """Form for the TC Leader to issue a warning to a Talent Club."""
    reason = TextAreaField("Reason for Warning", validators=[DataRequired(), Length(min=10, max=500)])
    submit = SubmitField("Issue Warning")

class TalentClubLevelForm(FlaskForm):
    """Form for the TC Leader to change a Talent Club's level."""
    # Levels could be integer input or select from predefined levels
    level = IntegerField("New Level", validators=[DataRequired(), NumberRange(min=1)]) # Assuming minimum level 1
    # Alternatively, if levels are tiered strings:
    # level = SelectField("New Level", choices=[('Level 1', 'Level 1'), ('Level 2', 'Level 2'), ...], validators=[DataRequired()])
    submit = SubmitField("Set Level")

# Optional forms for Ban/Penalty (basic versions)
class TalentClubBanMuteForm(FlaskForm):
    """Form for the TC Leader to ban or mute a TC Member."""
    ban_type = SelectField("Action Type", choices=[('ban', 'Ban (Remove from TC)'), ('mute', 'Mute (Restrict Posting)')], validators=[DataRequired()])
    reason = TextAreaField("Reason", validators=[DataRequired(), Length(min=10, max=500)])
    duration_days = IntegerField("Duration (days, leave empty for permanent)", validators=[Optional(), NumberRange(min=1)])
    submit = SubmitField("Apply Action")

# Placeholder for a Penalty form if different from Ban/Mute
# class TalentClubPenaltyForm(FlaskForm):
#      pass

# --- Authentication Forms ---

class PreForm(FlaskForm):
    """Form for initial registration code verification."""
    code = StringField(
        "Registration Code",
        validators=[DataRequired()]
    )
    submit = SubmitField("Verify Code")

class CompleteRegistrationForm(FlaskForm):
    """Form for completing user registration after code verification."""
    # Use the full_name field added to the User model in Part 2
    full_name = StringField("Full Name", validators=[DataRequired(), Length(max=120)])
    username = StringField(
        "Username",
        validators=[
            DataRequired(),
            Length(min=4, max=80),
            Regexp(
                "^[A-Za-z0-9_]+$",
                message="Username can only contain letters, numbers, and underscores.",
            ),
        ],
    )
    # Email is now nullable on User model, but required by this form
    email = StringField("Email", validators=[DataRequired(), Email(), Length(max=120)])

    password = PasswordField(
        "Password",
        validators=[
            DataRequired(),
            Length(min=8, message="Password must be at least 8 characters long."),
            # Optional: Add complexity validators here
            # Example: Regexp('^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\W_]).+$', message="Password must include uppercase, lowercase, number, and special character.")
        ],
    )
    password2 = PasswordField(
        "Confirm Password",
        validators=[
            DataRequired(),
            EqualTo("password", message="Passwords must match."),
        ],
    )

    # --- Fields Corresponding to User Model Additions ---
    # These match nullable columns added to User in Part 2
    age = IntegerField("Age", validators=[Optional(), NumberRange(min=5, max=100, message="Please enter a valid age.")])
    sex = SelectField("Sex", choices=[('', 'Select...'), ('Male', 'Male'), ('Female', 'Female'), ('Other', 'Other'), ('Prefer Not to Say', 'Prefer Not to Say')], validators=[Optional()])
    profile_photo_url = StringField("Profile Photo URL (Optional)", validators=[Optional(), Length(max=255)])
    # If you added grade/section to User model for students in Part 2, add fields here if needed
    # grade = StringField("Grade", validators=[Optional(), Length(max=10)])
    # section = StringField("Section", validators=[Optional(), Length(max=10)])


    submit = SubmitField("Complete Registration")


    # Custom validation for username and email uniqueness
    def validate_username(self, username_field):
        # Check if the chosen username already exists in the database (case-insensitive)
        user = db.session.scalar(
            select(User).filter(
                func.lower(User.username) == func.lower(username_field.data.strip())
            )
        )
        if user:
            raise ValidationError(
                "This username is already taken. Please choose a different one."
            )

    def validate_email(self, email_field):
        # Check if email exists (case-insensitive), assuming email is required by this form
        if email_field.data: # Only validate if email is provided
             user = db.session.scalar(
                 select(User).filter(
                     func.lower(User.email) == func.lower(email_field.data.strip())
                 )
             )
             if user:
                 raise ValidationError(
                     "This email address is already used. Please use a different one."
                 )


class LoginForm(FlaskForm):
    """Form for user login."""
    username = StringField(
        "Username", validators=[DataRequired(), Length(min=3, max=80)]
    )
    password = PasswordField("Password", validators=[DataRequired()])
    submit = SubmitField("Login")

class ChangePasswordForm(FlaskForm):
    """Form for a logged-in user to change their password (requires current password)."""
    current_password = PasswordField("Current Password", validators=[DataRequired()])
    new_password = PasswordField(
        "New Password",
        validators=[
            DataRequired(),
            Length(min=8, message="New password must be at least 8 characters long."),
            # Optional: Add custom complexity validators here
        ],
    )
    confirm_new_password = PasswordField(
        "Confirm New Password",
        validators=[
            DataRequired(),
            EqualTo("new_password", message="Passwords must match."),
        ],
    )
    submit = SubmitField("Change Password")

class ForcedChangePasswordForm(FlaskForm):
     """Form for a user forced to change their password (does not require current password)."""
     new_password = PasswordField(
        "New Password",
        validators=[
            DataRequired(),
            Length(min=8, message="New password must be at least 8 characters long."),
            # Optional: Add complexity validators here
        ],
    )
     confirm_new_password = PasswordField(
        "Confirm New Password",
        validators=[
            DataRequired(),
            EqualTo("new_password", message="Passwords must match."),
        ],
    )
     submit = SubmitField("Set New Password")


# --- Settings Form ---
class UniversalSettingsForm(FlaskForm):
    """Form for editing universal user profile and settings."""

    # Profile Fields (from User model)
    full_name = StringField("Full Name", validators=[DataRequired(), Length(max=120)])
    username = StringField(
        "Username",
        validators=[
            DataRequired(),
            Length(min=4, max=80),
            Regexp("^[A-Za-z0-9_]+$", message="Username can only contain letters, numbers, and underscores."),
        ],
    )
    email = StringField("Email", validators=[Optional(), Email(), Length(max=120)])

    # Additional Profile Fields (from User model - matching nullable columns)
    age = IntegerField("Age", validators=[Optional(), NumberRange(min=5, max=100, message="Please enter a valid age.")])
    sex = SelectField("Sex", choices=[('', 'Select...'), ('Male', 'Male'), ('Female', 'Female')], validators=[Optional()])

    # Talent Club Status (Display only - handled by join/leave button elsewhere)
    is_tc_member_display = BooleanField("Talent Club Member", render_kw={'disabled': 'disabled'})  # Display status, not editable here

    profile_visibility = SelectField(
        "Profile Visibility",
        choices=[("everyone", "Everyone"), ("teachers", "Teachers Only"), ("students", "Students Only"), ("private", "Only Me")],
        validators=[Optional()],  # If profile_visibility is nullable
    )
    data_analytics = BooleanField("Allow anonymous usage data collection")
    data_research = BooleanField("Allow academic research participation")
    profile_photo = FileField(
        "Update Profile Photo",
        validators=[
            Optional(),
            FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!'),
        ],
    )

    submit = SubmitField("Save Changes")

    def __init__(self, original_username=None, original_email=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.original_username = original_username
        self.original_email = original_email

    def validate_username(self, username_field):
        if username_field.data.lower() != (self.original_username or "").lower():  # Handle case where original_username is None
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.username) == func.lower(username_field.data.strip()),
                    User.id != current_user.id,
                )
            )
            if user:
                raise ValidationError("This username is already taken.")

    def validate_email(self, email_field):
        original_email_lower = (self.original_email or "").lower()
        submitted_email_lower = (email_field.data or "").lower()

        if submitted_email_lower and submitted_email_lower != original_email_lower:  # Check for change and not empty
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.email) == submitted_email_lower,
                    User.id != current_user.id,
                )
            )
            if user:
                raise ValidationError("This email address is already used by another account.")
# --- NEW FORMS: Request System ---

class CreateRequestForm(FlaskForm):
    """Form for submitting a new request."""
    title = StringField("Request Title", validators=[DataRequired(), Length(max=255)])
    description = TextAreaField("Detailed Description", validators=[DataRequired(), Length(min=10, max=2000)])
    request_type = SelectField("Request Type", choices=[
        ('Deficiency', 'Deficiency'),
        ('Purchase', 'Purchase'),
        ('General', 'General'),
        # Add more types if needed, e.g., 'Maintenance', 'Staffing', 'Curriculum'
    ], validators=[DataRequired()])
    urgency = SelectField("Urgency", choices=[
        ('Low', 'Low'),
        ('Medium', 'Medium'),
        ('High', 'High'),
        ('Critical', 'Critical')
    ], default='Medium', validators=[DataRequired()])
    submit = SubmitField("Submit Request")


class ReviewRequestForm(FlaskForm):
    """Form for handlers to review and process requests."""
    status = SelectField("Status", validators=[DataRequired()]) # Choices populated dynamically in route
    resolution_notes = TextAreaField("Resolution Notes (Optional)", validators=[Optional(), Length(max=1000)])
    denial_reason = TextAreaField("Reason for Denial (Required if 'Denied')", validators=[Optional(), Length(max=500)])
    forward_to_user_id = SelectField("Forward To (Optional)", coerce=int, validators=[Optional()]) # Choices populated dynamically

    submit = SubmitField("Update Request")

    def __init__(self, *args, current_user_role_name, request_tier, request_status, **kwargs):
        super().__init__(*args, **kwargs)
        self.current_user_role_name = current_user_role_name # Store for validation
        self.request_tier = request_tier
        self.request_status = request_status # Store for validation

        # Dynamically populate status choices based on current handler's role and request tier
        # These reflect the allowed transitions for each tier.
        if request_tier == 1 and current_user_role_name == 'hr_ceo':
            self.status.choices = [
                ('Approved', 'Approve'),
                ('On Progress', 'Mark On Progress'),
                ('Denied', 'Deny'),
                ('Resolved', 'Resolve (Final for HR/CEO)'),
                ('Forward', 'Forward to School Executive') # This is an action, not a status in DB, handled as transition
            ]
        elif request_tier == 2 and current_user_role_name == 'school_executive':
            self.status.choices = [
                ('Approved', 'Approve'),
                ('On Progress', 'Mark On Progress'),
                ('Denied', 'Deny'),
                ('Resolved', 'Resolve (Final for School Executive)'),
                ('Forward', 'Forward to Government')
            ]
        elif request_tier == 3 and current_user_role_name == 'government':
            self.status.choices = [
                ('Approved', 'Accept (Final for Government)'), # Equivalent to resolved
                ('Denied', 'Deny (Final for Government)')
            ]
        else: # Fallback or for global admins seeing the form
            self.status.choices = [
                ('Pending', 'Pending'),
                ('Approved', 'Approved'),
                ('On Progress', 'On Progress'),
                ('Denied', 'Denied'),
                ('Resolved', 'Resolved')
            ]

        # Conditionally make denial_reason required
        # This will be validated on form.validate_on_submit()
        if self.status.data == 'Denied':
            self.denial_reason.validators = [DataRequired(message="Denial reason is required if status is 'Denied'."), Length(max=500)]
        else:
            self.denial_reason.validators = [Optional(), Length(max=500)]

    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        # Custom validation for forwarding and denying
        if self.status.data == 'Forward':
            # Check if there are choices for forward_to_user_id (meaning populate was called)
            if not self.forward_to_user_id.choices or self.forward_to_user_id.data == 0:
                self.forward_to_user_id.errors.append("Please select a user to forward the request to.")
                return False
        
        if self.status.data == 'Denied' and not self.denial_reason.data:
            self.denial_reason.errors.append("Denial reason is required if status is 'Denied'.")
            return False

        return True


# --- END NEW FORMS ---

# --- Behavior Record Form ---
class BehaviorRecordForm(FlaskForm):
    """Form for adding/editing a student behavior record."""
    behavior_type = SelectField(
        "Behavior Type",
        choices=[
            ('Positive', 'Positive Behavior'),
            ('Needs Improvement', 'Needs Improvement'),
            ('Concern', 'Behavior Concern')
        ],
        validators=[DataRequired()]
    )
    description = TextAreaField(
        "Description",
        validators=[DataRequired(), Length(max=1000)]
    )
    severity = SelectField(
        "Severity",
        choices=[
            ('Low', 'Low'),
            ('Medium', 'Medium'),
            ('High', 'High')
        ],
        default='Medium',
        validators=[DataRequired()] # Added DataRequired
    )
    resolution = TextAreaField(
        "Resolution (if applicable)",
        validators=[Optional(), Length(max=1000)]
    )
    is_resolved = BooleanField("Mark as resolved") # Checkbox
    submit = SubmitField("Save Record")


# --- Attendance Form (for Teachers/Librarians marking student attendance) ---
# Helper form for FieldList in AttendanceForm - only used to structure the FieldList
class StudentAttendanceSubForm(FlaskForm):
    # No fields here. The actual status/notes fields are generated dynamically in the template
    # with names like status_{{ student.id }} and notes_{{ student.id }}
    pass

class AttendanceForm(FlaskForm):
    """Form structure for marking attendance for multiple students."""
    # FieldList to indicate that multiple student entries are expected.
    # The data for these entries is *not* automatically populated or validated by WTForms
    # in the typical way; it is read directly from request.form in the route.
    students = FieldList(FormField(StudentAttendanceSubForm), min_entries=0)

    # The date is typically passed via URL args or a hidden field, not a validated form field here
    # date = DateField("Date", format="%Y-%m-%d") # Not used with current route logic

    submit = SubmitField("Save Attendance")

    # __init__ is needed to dynamically add entries to the FieldList for rendering the template correctly
    def __init__(self, *args, students=None, **kwargs):
        super().__init__(*args, **kwargs)
        if students is not None:
             # Clear any existing entries added by default or previous processing
             while len(self.students.entries) > 0:
                  self.students.pop_entry()

             # Append a new entry (a subform) for each student object passed in
             for student in students:
                  # The 'data' dictionary here is just to conceptually link the subform
                  # entry to the student ID for rendering purposes, not for WTForms data processing.
                  self.students.append_entry(data={'student_id': student.id})


# --- Asset Management Forms ---

# Helper to get Labs for SelectFields
def get_labs():
    """Helper to query and format labs for select fields."""
    try:
        with app.app_context():
            return db.session.scalars(select(Lab).order_by(Lab.name)).all()
    except Exception as e:
        app.logger.error(f"Error fetching labs: {e}")
        return []

class AddAssetForm(FlaskForm):
    """Form for adding a new asset."""
    name = StringField("Asset Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    quantity = IntegerField("Quantity", default=1, validators=[DataRequired(), NumberRange(min=1)]) # Min quantity 1
    purchase_cost = FloatField("Purchase Cost (Optional)", validators=[Optional(), NumberRange(min=0)]) # Min cost 0
    condition = SelectField("Condition", choices=[
        ('New', 'New'), ('Good', 'Good'), ('Fair', 'Fair'),
        ('Poor', 'Poor'), ('Needs Repair', 'Needs Repair'), ('Broken', 'Broken') # Added Broken
    ], default='New', validators=[DataRequired()])
    is_consumable = BooleanField("Is Consumable?")
    expiry_date = DateField("Expiry Date (YYYY-MM-DD) (if consumable)", format='%Y-%m-%d', validators=[Optional()])
    last_maintenance_date = DateField("Last Maintenance Date (YYYY-MM-DD) (if applicable)", format='%Y-%m-%d', validators=[Optional()])
    # Suggested category is optional for the requester
    suggested_category_id = SelectField("Suggested Category (Optional)", coerce=int, validators=[Optional()])
    # Lab assignment is optional for the requester (e.g. teacher adding to their lab)
    # Added to allow teacher/librarian to suggest a lab
    suggested_lab_id = SelectField("Suggested Lab/Location (Optional)", coerce=int, validators=[Optional()])
    location_description = StringField("Specific Location Details (Optional)", validators=[Optional(), Length(max=255)]) # More specific location details

    submit = SubmitField("Add Asset")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices dynamically
        self.suggested_category_id.choices = [(0, '--- Select Category (Optional) ---')] + \
                                             [(c.id, c.name) for c in get_social_categories()] # Re-using social categories helper as it queries AssetCategory
        # Populate lab choices dynamically
        self.suggested_lab_id.choices = [(0, '--- Select Location (Optional) ---')] + \
                                       [(l.id, l.name) for l in get_labs()]

class ReportAssetForm(FlaskForm):
    """Form for reporting an issue with an asset (specific or general)."""
    damage_description = TextAreaField("Description of Damage/Issue", validators=[DataRequired(), Length(max=1000)]) # Increased length
    date_of_damage = DateField("Approximate Date of Damage/Issue (YYYY-MM-DD)", format='%Y-%m-%d', validators=[Optional()]) # Make date optional
    quantity_damaged = IntegerField("Quantity Damaged/Affected", default=1, validators=[DataRequired(), NumberRange(min=1)]) # Min quantity 1
    submit = SubmitField("Submit Report")

    def validate_date_of_damage(self, field):
        # Allow empty date if optional
        if field.data and field.data > datetime.now(timezone.utc).date():
            raise ValidationError("Date of damage cannot be in the future.")


class EditAssetForm(FlaskForm):
    """Form for HR/CEO/Admin to edit and review an asset."""
    # Name should probably be editable by admin
    name = StringField("Asset Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    quantity = IntegerField("Quantity", validators=[DataRequired(), NumberRange(min=0)]) # Quantity can be 0
    purchase_cost = FloatField("Purchase Cost (Optional)", validators=[Optional(), NumberRange(min=0)])
    # Category and Status are key fields for HR/Admin to manage
    category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # Now required
    status = SelectField("Status", choices=[
        ('Pending Review', 'Pending Review'), ('Available', 'Available'), # Added Available
        ('CheckedOut', 'CheckedOut'), ('Under Maintenance', 'Under Maintenance'),
        ('Retired', 'Retired'), ('Lost', 'Lost')
    ], validators=[DataRequired()])
    condition = SelectField("Condition", choices=[
        ('New', 'New'), ('Good', 'Good'), ('Fair', 'Fair'),
        ('Poor', 'Poor'), ('Needs Repair', 'Needs Repair'), ('Broken', 'Broken')
    ], validators=[DataRequired()])
    is_consumable = BooleanField("Is Consumable?")
    expiry_date = DateField("Expiry Date (YYYY-MM-DD) (if consumable)", format='%Y-%m-%d', validators=[Optional()])
    last_maintenance_date = DateField("Last Maintenance Date (YYYY-MM-DD) (if applicable)", format='%Y-%m-%d', validators=[Optional()])
    # Lab assignment is managed by HR/Admin here
    lab_id = SelectField("Assigned Lab/Location (Optional)", coerce=int, validators=[Optional()])
    location_description = StringField("Specific Location Details (Optional)", validators=[Optional(), Length(max=255)])

    # added_by_user_id is informational, not editable here

    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices (required for HR/Admin)
        self.category_id.choices = [(c.id, c.name) for c in get_social_categories()] # Re-using helper
        # Populate lab choices (optional for HR/Admin)
        self.lab_id.choices = [(0, '--- Select Location (Optional) ---')] + \
                             [(l.id, l.name) for l in get_labs()]

    def validate_expiry_date(self, field):
         # If the asset is consumable, the expiry date might be required or validated further
         # Basic validation: Ensure expiry date is in the future if set for a new/active consumable asset
         # This form can edit, so maybe only validate if setting a *future* date is required.
         pass # Add specific logic if needed


class ResolveReportForm(FlaskForm):
    """Form for HR/CEO/Admin to update the status and notes of an asset report."""
    status = SelectField("Report Status", choices=[
        ('Pending', 'Pending'), ('In Progress', 'In Progress'),
        ('Resolved', 'Resolved'), ('Rejected', 'Rejected')
    ], validators=[DataRequired()])
    resolution_notes = TextAreaField("Resolution Notes", validators=[Optional(), Length(max=1000)]) # Increased length
    # Option to link report to an asset if it was a general report (requires search/select field)
    # For V1, skip complex linking via this form. Linking happens when resolving.
    # link_to_asset_id = SelectField("Link to Asset (Optional)", coerce=int, validators=[Optional()]) # Example if implementing linking here
    submit = SubmitField("Update Report Status")

    # If linking is implemented, need __init__ to populate link_to_asset_id choices
    # def __init__(self, *args, **kwargs):
    #      super().__init__(*args, **kwargs)
    #      self.link_to_asset_id.choices = [(0, '--- Select Asset (Search not implemented) ---')] + [
    #          (a.id, f"{a.name} ({a.id})") for a in db.session.scalars(select(Asset)).limit(100).all() # Limit for large databases
    #      ]


# --- Asset Category Management Forms ---
class AddCategoryForm(FlaskForm):
    """Form for adding a new asset category."""
    name = StringField("Category Name", validators=[DataRequired(), Length(max=50)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=200)])
    submit = SubmitField("Add Category")

class EditCategoryForm(FlaskForm):
    """Form for editing an existing asset category."""
    name = StringField("Category Name", validators=[DataRequired(), Length(max=50)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=200)])
    submit = SubmitField("Save Changes")
    
# Around line 2387 in your app.py
class BookCheckoutForm(FlaskForm):
    """Form for checking out a book asset with proper empty state handling."""

    asset_id = SelectField(
        "Select Book",
        coerce=int,
        validators=[Optional()],  # Remains Optional
        choices=[], # Initialize empty, populated by __init__
        description="Available books will appear here"
    )

    user_id = SelectField(
        "Select User (for Librarians)",
        coerce=int,
        validators=[Optional()],
        choices=[] # Initialize empty, populated by __init__
    )

    due_date = DateField(
        "Due Date",
        format="%Y-%m-%d",
        validators=[DataRequired()],
        render_kw={"min": lambda: datetime.now(timezone.utc).date().isoformat()} # Use lambda for dynamic min date
    )

    submit = SubmitField("Checkout Book")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # It's good practice to call these population methods after super().__init__
        self._populate_asset_choices()
        self._populate_user_choices()

    def _populate_asset_choices(self):
        """Populate book choices with proper empty state handling"""
        # Using app.app_context() is good if this form might be instantiated outside a request context,
        # but within a request context (like in a Flask route), it's usually not strictly necessary
        # as the context is already active. However, it doesn't harm.
        with app.app_context():
            book_category = db.session.scalar(
                select(AssetCategory).filter_by(name="Books")
            )

            available_books = []
            if book_category:
                available_books = db.session.scalars(
                    select(Asset)
                    .where(
                        Asset.category_id == book_category.id,
                        Asset.status == "Available",
                        Asset.quantity > 0
                    )
                    .order_by(Asset.name)
                ).all()

            if not available_books:
                self.asset_id.choices = []  # IMPORTANT: Set to empty list
                self.asset_id.render_kw = {
                    "disabled": True,
                    "class": "form-select" # Base class, template handles tom-select & is-invalid
                    # The placeholder will be handled by the template or TomSelect default.
                    # If you want to override it when no books:
                    # "placeholder": "No books available for checkout"
                }
                # Optionally add a form-level error if no books is a "validation" issue for the form's purpose
                # self.asset_id.errors.append("No books are currently available for checkout.")
            else:
                self.asset_id.choices = [
                    (a.id, f"{a.name} (Available: {a.quantity})")
                    for a in available_books
                ]
                self.asset_id.render_kw = {
                    "class": "form-select" # Base class
                    # Placeholder from template: "Search and select a book..."
                }

    def _populate_user_choices(self):
        """Populate user choices for librarians"""
        # Default to hidden, and enable for librarians
        self.user_id.render_kw = {"class": "form-select d-none"} # Start hidden
        self.user_id.choices = [] # Default to empty

        if current_user.is_authenticated and hasattr(current_user, 'role'):
            if current_user.role.name.lower() == "librarian":
                with app.app_context():
                    users = db.session.scalars(
                        select(User)
                        .join(Role)
                        .where(
                            Role.name.in_(["student", "teacher"]), # Users who can check out books
                            User.is_active == True
                        )
                        .order_by(User.full_name)
                    ).all()

                if not users:
                    # self.user_id.choices remains []
                    self.user_id.render_kw.update({ # Update existing render_kw
                        "disabled": True,
                        # "placeholder": "No users available for selection" # If you want to override template/TomSelect
                    })
                else:
                    self.user_id.choices = [
                        (u.id, f"{u.full_name} ({u.username})")
                        for u in users
                    ]
                    # "placeholder": "--- Select User ---" # If you want to override template/TomSelect
                
                # Make visible for librarian
                current_classes = self.user_id.render_kw.get("class", "")
                self.user_id.render_kw["class"] = current_classes.replace("d-none", "").strip()

    def validate_due_date(self, field):
        """Ensure due date is not in the past."""
        if field.data and field.data < datetime.now(timezone.utc).date():
            raise ValidationError("Due date cannot be in the past.")

    # Added custom validation for asset_id if it's not Optional anymore for submission
    # (though the original had Optional(), so this might not be needed if that stays)
    def validate_asset_id(self, field):
        # If the field is not Optional and no books were available (choices is empty),
        # it would fail DataRequired. If it's Optional, this validation is not strictly needed
        # unless you want a specific message when it's disabled due to no books.
        if not self.asset_id.choices and not self.asset_id.validators[0].optional: # Check if not optional
            raise ValidationError("No books available to select.")
# --- Student Leader Assignment Form ---
class AssignLeaderForm(FlaskForm):
    """Form for assigning students to a student leader."""
    # SelectField for choosing a student leader from the list of existing leaders
    leader = SelectField("Select Leader", coerce=int, validators=[DataRequired()])
    # Students to assign are selected via checkboxes in the template, not defined as form fields here.
    submit = SubmitField("Assign Students")

    def __init__(self, *args, current_leaders=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate the leader dropdown with current student leaders
        # current_leaders should be a list of User objects who are leaders
        if current_leaders is not None: # Check if list was provided
             self.leader.choices = [(l.id, f"{l.full_name} (Grade {l.grade or 'N/A'}, Section {l.section or 'N/A'})") for l in current_leaders]
        else:
             # If no leaders are passed (e.g., empty DB), provide a default empty choice
             self.leader.choices = [(0, '--- No Leaders Found ---')] # Use 0 as a placeholder value


# --- Notification Form ---
class NotificationForm(FlaskForm):
    """Form for composing and sending a notification message."""
    content = TextAreaField(
        "Message Content", validators=[DataRequired(), Length(min=1, max=1000)]
    )
    # Receiver selection is handled outside this form (via route parameter)
    # link_url = StringField("Link URL (Optional)", validators=[Optional(), URL(), Length(max=255)]) # Optional field for a link
    submit = SubmitField("Send Notification")


# --- Social Media Forms --- (Copied from previous parts for completeness here)
# START MODIFICATION (CreateChannelForm)
class CreateChannelForm(FlaskForm):
    name = StringField("Channel Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    channel_type = SelectField("Channel Type", choices=[('public', 'Public'), ('private', 'Private')], validators=[DataRequired()])
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # MODIFIED: Field name changed to social_category_id and is required
    allow_comments = BooleanField("Allow Comments on Posts", default=True)
    allow_reactions = BooleanField("Allow Reactions on Posts", default=True)
    submit = SubmitField("Create Channel")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # MODIFIED: Removed optional '--- Select Category ---' as it's now required. Access social_category_id.
        self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
        # If no categories exist, add a dummy entry to prevent errors, but form will still be invalid due to DataRequired
        if not self.social_category_id.choices:
            self.social_category_id.choices = [('', 'No categories available')]
# END MODIFICATION (CreateChannelForm)
# START MODIFICATION (EditChannelForm)
class EditChannelForm(FlaskForm):
    name = StringField("Channel Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # MODIFIED: Field name changed to social_category_id and is required
    allow_comments = BooleanField("Allow Comments on Posts")
    allow_reactions = BooleanField("Allow Reactions on Posts")
    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
         # MODIFIED: Removed optional '--- Select Category ---' as it's now required. Access social_category_id.
         self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
         if not self.social_category_id.choices:
            self.social_category_id.choices = [('', 'No categories available')]
# END MODIFICATION (EditChannelForm)
class CreateGroupForm(FlaskForm):
    name = StringField("Group Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    submit = SubmitField("Create Group")

class EditGroupForm(FlaskForm):
    name = StringField("Group Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    submit = SubmitField("Save Changes")

class PostContentForm(FlaskForm):
    """Form for posting content (text and/or file) in channels/groups."""
    content = TextAreaField("Your message", validators=[Optional(), Length(max=2000)])
    attached_file = FileField("Attach File (Optional)")
    submit = SubmitField("Send")

    # Custom validation: Require EITHER content OR file
    def validate(self, extra_validators=None):
         # Run standard WTForms validation first
         initial_validation = super().validate(extra_validators=extra_validators)

         # If standard validation fails, don't proceed with custom validation
         if not initial_validation:
             return False

         # Now, check our custom requirement: EITHER content OR attached_file
         # file.data will be a FileStorage object if a file was uploaded, otherwise None
         if not self.content.data and not self.attached_file.data:
              # Add an error message to a field, e.g., the content field
              # Using `self.content.errors` is standard practice
              self.content.errors.append("Message content or a file must be provided.")
              # Indicate that the form is now invalid due to custom validation
              return False

         # If standard validation passed AND at least one field has data, the form is valid
         return True


class CommentForm(FlaskForm):
    """Form for adding a comment to a post."""
    content = TextAreaField("Your comment", validators=[DataRequired(), Length(max=500)])
    submit = SubmitField("Comment")


# --- END PART 4 ---

# --- PART 5 START: Authentication Routes ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, SecretCode are defined.
# - Forms: PreForm, CompleteRegistrationForm, LoginForm, ChangePasswordForm, ForcedChangePasswordForm are defined.
# - Helpers: get_unread_message_count, get_unread_notifications_count are defined and potentially used in context processor.
# - role_required decorator is defined.
# - url_for is available.

# --- (After app = Flask(__name__) and before routes) ---

# Global Constants (if you want to access them in templates easily)
# TASK_CREATOR_ROLES was defined in your original app.py for backend logic.
# Making it available to templates if needed, e.g. to conditionally show a "Create Task" button.
TASK_CREATOR_ROLES = ['hr_ceo', 'system_admin', 'school_executive']

# This part enables CSRF protection for your forms
csrf = CSRFProtect(app) # Make sure this is initialized if not alread

@app.context_processor
def inject_global_vars():
    """Injects common variables into all Jinja2 templates."""
    unread_messages_count_val = 0
    unread_notifications_count_val = 0

    # Ensure current_user is available and authenticated before querying DB
    if hasattr(current_user, 'is_authenticated') and current_user.is_authenticated:
        try:
            unread_messages_count_val = get_unread_message_count(current_user.id)
            unread_notifications_count_val = get_unread_notifications_count(current_user.id)

        except Exception as e:
            # Use app.logger if available and configured
            logger = getattr(current_app, 'logger', None)
            if logger:
                logger.error(f"Error fetching counts/permissions for user {current_user.id} in context processor: {e}")
            else: # Fallback print if logger not set up on current_app
                print(f"ERROR in context_processor: Error fetching counts/permissions for user {current_user.id}: {e}")

            unread_messages_count_val = "Err"
            unread_notifications_count_val = "Err"

    # Define the lambda function here for clarity and correct scope
    # Ensure 'csrf' is your CSRFProtect instance (e.g., from flask_wtf.csrf import CSRFProtect; csrf = CSRFProtect(app))
    # and wtf_generate_csrf is imported correctly.
    csrf_token_value_lambda = lambda: wtf_generate_csrf() if csrf else ''

    return {
        "now": datetime.now(timezone.utc),
        "current_year": datetime.now(timezone.utc).year,
        "unread_messages_count": unread_messages_count_val,
        "unread_notifications_count": unread_notifications_count_val,
        "TASK_CREATOR_ROLES": TASK_CREATOR_ROLES, # Makes this list available in templates

        # This provides a function to get the CSRF token string
        "get_csrf_token_value": csrf_token_value_lambda
    }

@app.template_filter('humanize_time_diff')
def humanize_time_diff_filter(dt, default="just now"):
    """
    Converts a datetime object or a parsable datetime string to a human-readable relative time.
    e.g., "5 minutes ago", "2 hours ago", "3 days ago".
    """
    if not dt:
        return default
    
    # If dt is already a datetime object, ensure it's offset-aware (UTC)
    if isinstance(dt, datetime):
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
    # If dt is a string, try to parse it
    elif isinstance(dt, str):
        try:
            # Attempt to parse ISO format, common from JS new Date().toISOString()
            dt_parsed = datetime.fromisoformat(dt.replace("Z", "+00:00"))
            dt = dt_parsed # Use the parsed datetime object
        except ValueError:
            # Fallback for other potential string formats if necessary, or return default
            app.logger.warning(f"Could not parse datetime string for humanize_time_diff: {dt}")
            return default # Or format dt as string if parsing fails but it's a date
    else: # Not a datetime object or string
        return default

    now = datetime.now(timezone.utc)
    try:
        diff = now - dt
        if diff.total_seconds() < 0: # Datetime is in the future
             return f"in {humanize.naturaldelta(-diff)}" # "in 5 minutes"
        if diff.total_seconds() < 60: # Less than a minute
            return default # "just now"
        return humanize.naturaltime(diff)
    except (TypeError, ValueError) as e:
        app.logger.error(f"Error humanizing time diff for {dt}: {e}")
        return default

@app.template_filter('nl2br')
def nl2br_filter(s):
    """Converts newlines in a string to HTML <br> tags."""
    if not s:
        return ''
    return Markup(str(s).replace('\n', '<br>\n'))

@app.route("/")
def home():
    if current_user.is_authenticated:
        # This correctly redirects to role_redirect which then sends them to their dashboard
        return redirect(url_for("role_redirect"))
    else:
        # Instantiate LoginForm to pass to the index.html template
        form = LoginForm() # Make sure LoginForm is defined/imported in your app.py
        return render_template("index.html", 
                               title="Welcome to Nexus - Kechene Debre Selam G.S.S.", 
                               form=form)


@app.route("/pre_register", methods=["GET", "POST"])
def pre_register():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    form = PreForm() # Make sure PreForm is defined/imported

    if form.validate_on_submit():
        code_input = form.code.data.strip()
        # Using joinedload(SecretCode.role) to eager load the role
        secret_code = db.session.scalar(
            select(SecretCode).filter(
                func.lower(SecretCode.code) == func.lower(code_input),
                SecretCode.is_used == False
            ).options(joinedload(SecretCode.role)) 
        )

        if secret_code:
            session['pre_reg_code_id'] = secret_code.id
            session['pre_reg_full_name'] = secret_code.full_name
            session['pre_reg_role_id'] = secret_code.role_id
            session['pre_reg_code_value'] = secret_code.code 
            app.logger.info(f"Pre-registration code '{code_input[:2]}...{code_input[-2:]}' (ID: {secret_code.id}) found. Proceeding to confirmation.")
            return redirect(url_for('confirm_identity'))
        else:
            flash('Invalid or already used registration code.', 'danger')
            app.logger.warning(f"Failed pre-registration attempt with code '{code_input[:2]}...{code_input[-2:]}'.")
            # No need to return render_template here again, the final one handles GET and failed POST
            
    # For GET request or if form validation failed on POST
    return render_template('auth/pre_register.html', 
                           form=form, 
                           title="Pre-Register - Nexus")

@app.route("/confirm-identity")
def confirm_identity():
    if current_user.is_authenticated:
         flash("You are already logged in.", "info")
         return redirect(url_for("role_redirect"))

    code_id = session.get('pre_reg_code_id')
    full_name = session.get('pre_reg_full_name')
    role_id = session.get('pre_reg_role_id')
    code_value = session.get('pre_reg_code_value')

    if not all([code_id, full_name, role_id, code_value]): # Simplified check
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        # Clear potentially incomplete session data
        session.pop('pre_reg_code_id', None)
        session.pop('pre_reg_full_name', None)
        session.pop('pre_reg_role_id', None)
        session.pop('pre_reg_code_value', None)
        return redirect(url_for('pre_register'))

    secret_code = db.session.get(SecretCode, code_id)
    # Fetch the Role object to get its name
    role_obj = db.session.get(Role, role_id) if role_id else None

    if not secret_code or secret_code.is_used or \
       secret_code.full_name != full_name or \
       secret_code.role_id != role_id or \
       secret_code.code != code_value or not role_obj:
        flash("Pre-registration data mismatch, code used, or role invalid. Please start over.", "danger")
        session.pop('pre_reg_code_id', None)
        session.pop('pre_reg_full_name', None)
        session.pop('pre_reg_role_id', None)
        session.pop('pre_reg_code_value', None)
        return redirect(url_for('pre_register'))
    
    # Prepare role name for display
    display_role_name = role_obj.name.replace('_', ' ').title() if role_obj else "Unknown Role"

    return render_template('auth/confirm_identity.html',
                           full_name=full_name,
                           role_name=display_role_name, # Pass formatted role name
                           title="Confirm Your Identity - Nexus")

@app.route("/handle-confirmation", methods=["POST"])
def handle_confirmation():
    """Processes the user's confirmation choice."""
    # Retrieve data from session
    code_id = session.get('pre_reg_code_id')
    full_name = session.get('pre_reg_full_name')
    role_id = session.get('pre_reg_role_id')
    code_value = session.get('pre_reg_code_value')

    # Check if essential session data is present
    if current_user.is_authenticated:
         flash("You are already logged in.", "info")
         return redirect(url_for("role_redirect"))

    if not code_id or not full_name or not role_id or not code_value:
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        return redirect(url_for('pre_register'))

    # Re-validate the code against the database just in case it was used between pages
    secret_code = db.session.get(SecretCode, code_id)
    if not secret_code or secret_code.is_used or secret_code.code != code_value:
         flash("Pre-registration data mismatch or code used. Please start over.", "danger")
         # Clear session data if code is invalid or used
         session.pop('pre_reg_code_id', None)
         session.pop('pre_reg_full_name', None)
         session.pop('pre_reg_role_id', None)
         session.pop('pre_reg_code_value', None)
         return redirect(url_for('pre_register'))


    # Process the confirmation response from the form
    if request.form.get('confirmation') == 'yes':
        # User confirmed identity, proceed to complete registration
        # Session data is kept and will be validated again in complete_registration
        app.logger.info(f"Identity confirmed for code ID {code_id}. Redirecting to complete registration.")
        return redirect(url_for('complete_registration'))
    else:
        # User declined or submitted form incorrectly
        flash("Identity confirmation declined. Please start over or contact school administration.", "info")
        # Clear session data as registration flow is abandoned
        session.pop('pre_reg_code_id', None)
        session.pop('pre_reg_full_name', None)
        session.pop('pre_reg_role_id', None)
        session.pop('pre_reg_code_value', None)
        app.logger.warning(f"Identity confirmation declined for code ID {code_id}.")
        return redirect(url_for('home')) # Redirect back to the home page

@app.route("/complete-registration", methods=["GET", "POST"])
def complete_registration():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    code_id = session.get('pre_reg_code_id')
    pre_reg_full_name = session.get('pre_reg_full_name')
    pre_reg_role_id = session.get('pre_reg_role_id')
    pre_reg_code_value = session.get('pre_reg_code_value')

    if not all([code_id, pre_reg_full_name, pre_reg_role_id, pre_reg_code_value]):
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        return redirect(url_for('pre_register'))

    secret_code = db.session.get(SecretCode, code_id)
    if not secret_code or secret_code.is_used or \
       secret_code.full_name != pre_reg_full_name or \
       secret_code.role_id != pre_reg_role_id or \
       secret_code.code != pre_reg_code_value:
        flash("Pre-registration data mismatch or code used. Please start over.", "danger")
        session.pop('pre_reg_code_id', None)
        # ... clear other session keys ...
        return redirect(url_for('pre_register'))

    form = CompleteRegistrationForm() # Your CompleteRegistrationForm

    if request.method == 'GET':
        form.full_name.data = pre_reg_full_name # Pre-fill full name

    if form.validate_on_submit():
        try:
            user_full_name = form.full_name.data.strip()
            name_parts = user_full_name.split(' ', 1)
            first_name = name_parts[0]
            last_name = name_parts[1] if len(name_parts) > 1 else None

            user = User(
                username=form.username.data.strip(),
                email=form.email.data.strip() if form.email.data else None,
                full_name=user_full_name,
                first_name=first_name,
                last_name=last_name,
                role_id=pre_reg_role_id,
                is_active=True,
                force_password_change=False, # Password set now
                created_at=datetime.now(timezone.utc),
                age=form.age.data, # From form
                sex=form.sex.data if form.sex.data else None, # From form
                # Assuming profile_photo_url is a StringField in the form for Phase A
                profile_photo_url=form.profile_photo_url.data.strip() if form.profile_photo_url.data else None
            )
            user.set_password(form.password.data)
            secret_code.is_used = True

            db.session.add(user)
            db.session.add(secret_code) # Mark code as used
            db.session.commit()

            session.pop('pre_reg_code_id', None)
            session.pop('pre_reg_full_name', None)
            session.pop('pre_reg_role_id', None)
            session.pop('pre_reg_code_value', None)

            flash("Registration complete! Please log in with your new username and password.", "success")
            app.logger.info(f"New user '{user.username}' (ID: {user.id}) registered successfully using secret code ID {secret_code.id}.")
            return redirect(url_for('login'))

        except IntegrityError: # Usually duplicate username/email
            db.session.rollback()
            app.logger.warning(f"Complete registration failed for code ID {code_id} due to IntegrityError.")
            # Form validators for username/email should catch this first and add errors to form fields.
            # If an error still occurs here, it's a fallback.
            flash('Registration failed: Username or email is already in use. Please check the form.', 'danger')
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error during complete registration for code ID {code_id}: {e}", exc_info=True)
            flash("An unexpected error occurred during registration. Please try again.", "danger")
            
    # For GET or if form validation fails on POST
    return render_template('auth/complete_registration.html',
                           form=form,
                           pre_reg_full_name=pre_reg_full_name, # For template greeting
                           title="Complete Your Registration - Nexus")

@app.route("/role-redirect")
@login_required
def role_redirect():
    """
    Redirects authenticated users to their primary role dashboard.
    Students (including TC members) will initially go to the student_dashboard.
    If a student is a TC member, they will also be processed for TC community group membership.
    Flexibility to access other dashboards (like Talent Club for eligible students)
    is handled by the frontend navigation.
    """
    
    ROLE_DASHBOARD_ENDPOINTS = {
        'student': 'student_dashboard',         # ALL students go here first
        'teacher': 'teacher_dashboard',
        'system_admin': 'system_admin_dashboard',
        'hr_ceo': 'hr_ceo_dashboard',
        'school_executive': 'school_exec_dashboard',
        'government': 'government_dashboard',
        'librarian': 'librarian_dashboard',
        'talent_club': 'talent_club_dashboard',  # For users whose ROLE is 'talent_club' (e.g., coordinators)
        'parent': 'parent_dashboard',
    }

    user_role_name = current_user.role.name.lower() if current_user.role else None
    destination_endpoint = None

    # 1. Handle TC Community Group enrollment for students who are TC members
    # This happens regardless of their initial redirect destination if they are a student TC member.
    if user_role_name == 'student' and current_user.is_tc_member:
        if not is_tc_community_member(current_user):  # is_tc_community_member helper
            add_to_tc_community_group(current_user)     # add_to_tc_community_group helper
            app.logger.info(f"Student TC Member {current_user.username} processed for TC Community Group membership.")

    # 2. Determine destination endpoint based on primary role
    if user_role_name:
        destination_endpoint = ROLE_DASHBOARD_ENDPOINTS.get(user_role_name)
        if destination_endpoint:
            app.logger.info(f"User {current_user.username} (Role: {user_role_name}, TC Member: {current_user.is_tc_member}) initial redirect to primary role dashboard: {destination_endpoint}.")
        else:
            app.logger.warning(f"No dashboard endpoint defined in ROLE_DASHBOARD_ENDPOINTS for role: {user_role_name}. Redirecting to fallback.")
            destination_endpoint = 'fallback_dashboard'
    else:
        app.logger.warning(f"User {current_user.username} has no role assigned. Redirecting to fallback.")
        destination_endpoint = 'fallback_dashboard'

    # 3. Perform the redirect
    try:
        return redirect(url_for(destination_endpoint))
    except BuildError:
        app.logger.error(f"BuildError: Dashboard endpoint '{destination_endpoint}' not found for role '{user_role_name}'. Redirecting to fallback.")
        flash(f"Configuration error: Your role dashboard ('{destination_endpoint}') is not defined. Contact administration.", "danger")
        return redirect(url_for('fallback_dashboard'))
    except Exception as e:
        app.logger.error(f"Unexpected error during role redirect for user {current_user.username} (ID: {current_user.id}): {e}", exc_info=True)
        flash("An unexpected error occurred during redirection. Please try logging in again.", "danger")
        return redirect(url_for('login'))
@app.route("/login", methods=["GET", "POST"])
def login():
    """Handles user login."""
    # If user is already authenticated, redirect to their dashboard
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    form = LoginForm() # Use the LoginForm defined in Part 4

    if form.validate_on_submit():
        # Get username input (keep original case for logging, use lower for lookup)
        username_input = form.username.data.strip()
        username_lower = username_input.lower()

        # Log the login attempt
        app.logger.info(f"Login attempt for username: '{username_input}' from IP: {request.remote_addr}")

        # Find user by lowercase username
        user = db.session.scalar(
            select(User).filter(func.lower(User.username) == username_lower).options(joinedload(User.role)) # Eager load role
        )

        if user:
            # Check if user is active BEFORE checking password
            if not user.is_active:
                 app.logger.warning(f"Login failed for inactive user: '{username_input}' (ID: {user.id}) from IP: {request.remote_addr}")
                 flash('Your account is inactive. Please contact administration.', 'danger')
                 return render_template("auth/login.html", title="Login", form=form)

            # User is active, now check password using the method from User model (Part 2)
            if user.check_password(form.password.data):
                # Password is correct and user is active - Login the user
                login_user(user) # Logs the user in using Flask-Login
                app.logger.info(f"Login successful for user: '{username_input}' (ID: {user.id}, Role: {user.role.name if user.role else 'N/A'}) from IP: {request.remote_addr}")

                # Update last login timestamp (optional, but good practice)
                user.last_login = datetime.now(timezone.utc)
                db.session.commit()

                # Check if user is required to change password (flag on User model from Part 2)
                if user.force_password_change:
                     flash('You must change your password before continuing.', 'warning')
                     # Store the intended 'next' URL so we can redirect there after forced change
                     # Get the 'next' parameter from the URL query string (if any)
                     next_url = request.args.get('next') or url_for('role_redirect') # Default to dashboard
                     session['_forced_change_next'] = next_url # Store the URL in the session
                     app.logger.debug(f"User {user.id} needs forced password change. Storing next URL: {next_url}")
                     # Redirect to the forced password change page
                     return redirect(url_for('change_password_forced'))

                # If no forced change, proceed to intended destination
                # Check for a 'next' parameter in the URL query string (e.g., /login?next=/some-page)
                next_page = request.args.get('next')
                if next_page:
                     try:
                          # Basic security check: ensure the next_page is a local path starting with /
                          # Use werkzeug.urls.url_parse for safer validation
                          target = url_parse(next_page)
                          if not target.scheme and not target.netloc: # Check if it's a relative path
                               app.logger.debug(f"Redirecting to 'next' page: {next_page}")
                               return redirect(next_page)
                          else:
                               # Log suspicious activity if an external URL is attempted
                               app.logger.warning(f"Invalid 'next' URL '{next_page}' provided during login (not a local path). Falling back to role redirect.")
                               # Fall through to default redirect below
                     except Exception as e: # Catch parsing errors etc.
                          app.logger.error(f"Unexpected error parsing 'next' URL '{next_page}': {e}. Falling back.", exc_info=True)

                # Default redirect if no valid 'next' page parameter or no force change required
                app.logger.debug("No valid 'next' page or forced change, redirecting to role dashboard.")
                return redirect(url_for("role_redirect"))

            else:
                # Invalid password
                app.logger.warning(f"Login failed for username: '{username_input}' (Invalid password) from IP: {request.remote_addr}")
                flash('Invalid username or password.', 'danger') # Use a generic message for security
        else:
            # User not found
            app.logger.warning(f"Login failed for username: '{username_input}' (User not found) from IP: {request.remote_addr}")
            flash('Invalid username or password.', 'danger') # Use a generic message for security

    # For GET request or failed POST validation (e.g., empty fields)
    # Render the login template again, which will display any flash messages and form errors.
    return render_template("auth/login.html", title="Login", form=form)


@app.route("/logout")
@login_required # User must be logged in to log out
def logout():
    """Handles user logout securely."""
    try:
        # Get username before logging out for logging purposes
        username = current_user.username if current_user.is_authenticated else "N/A (unauthenticated)"

        # Log the logout attempt
        app.logger.info(f"Logout attempt for user: {username} from IP: {request.remote_addr}")

        # Clear Flask-Login's session
        logout_user()

        # Clear Flask-Session data to remove any lingering information
        session.clear()

        # Create a response object for the redirect
        response = make_response(redirect(url_for("login")))

        # Add security headers to prevent browser caching of potentially sensitive pages
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '-1' # Historical date

        # Log the successful logout event
        app.logger.info(f"Secure logout successful for user: {username} from IP: {request.remote_addr}")

        flash("You have been securely logged out.", "success")
        return response

    except Exception as e:
        # Log any unexpected errors during the logout process
        username = current_user.username if current_user.is_authenticated else "N/A (unauthenticated)"
        app.logger.error(f"Error during logout for user {username}: {str(e)}", exc_info=True)
        flash("An error occurred during logout. Please clear your browser cache.", "danger")
        # Even if an error occurs, attempt to redirect to the login page
        response = make_response(redirect(url_for("login")))
        # Add headers even on error to attempt cache clearing
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '-1'
        return response

@app.route("/change-password", methods=["GET", "POST"])
@login_required
def change_password():
    form = ChangePasswordForm() # Your ChangePasswordForm
    if form.validate_on_submit():
        if not current_user.check_password(form.current_password.data):
            flash("Incorrect current password.", "danger")
        elif current_user.check_password(form.new_password.data):
            flash("New password cannot be the same as your current password.", "danger")
        else:
            try:
                current_user.set_password(form.new_password.data)
                current_user.force_password_change = False # Clear flag if it was set
                db.session.commit()
                flash("Your password has been changed successfully.", "success")
                app.logger.info(f"Password changed successfully for user {current_user.username} (ID: {current_user.id}).")
                return redirect(url_for("settings")) # Redirect to settings page
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error changing password for user {current_user.username}: {e}", exc_info=True)
                flash("An unexpected error occurred. Please try again.", "danger")
    
    return render_template("auth/change_password.html", 
                           form=form, 
                           title="Change Password - Nexus")
@app.route("/change-password-forced", methods=["GET", "POST"])
@login_required
def change_password_forced():
    if not current_user.force_password_change:
        flash("Password change not required at this time.", "info")
        return redirect(url_for("role_redirect"))

    form = ForcedChangePasswordForm() # Your ForcedChangePasswordForm
    if form.validate_on_submit():
        # Optional: Check if new password is same as old one, if User model has password_hash already
        # This is less critical here as the goal is to set *any* new password.
        try:
            current_user.set_password(form.new_password.data)
            current_user.force_password_change = False # CRITICAL: Clear the flag
            db.session.commit()
            flash("Your new password has been set successfully. You can now access the system.", "success")
            app.logger.info(f"Forced password change completed for user {current_user.username}.")
            
            next_page = session.pop('_forced_change_next', None)
            if next_page:
                try:
                    target = url_parse(next_page)
                    if not target.scheme and not target.netloc:
                        return redirect(next_page)
                    else:
                         app.logger.warning(f"Invalid stored 'next' URL '{next_page}' after forced password change. Falling back.")
                except Exception as e:
                    app.logger.error(f"Error parsing 'next' URL '{next_page}': {e}. Falling back.", exc_info=True)
            return redirect(url_for("role_redirect")) # Default redirect
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error during forced password change for user {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
    
    return render_template("auth/change_password_forced.html", 
                           form=form, 
                           title="Set New Password - Nexus")

# --- Fallback Dashboard (Needed for role_redirect) ---
@app.route("/dashboard") # Or your specific fallback URL
@login_required
def fallback_dashboard():
    flash(
        "Your role-specific dashboard may not be fully configured or is currently unavailable. Displaying a generic dashboard.",
        "info",
    )
    return render_template("dashboard_fallback.html", title="Dashboard - Nexus")

# --- PART 5 END ---

# --- PART 6 START: Role Dashboards & Core Navigation ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Message, Notification, BorrowedAsset, Attendance, Mark, TeacherProfile, Asset, AssetCategory, BehaviorRecord, Parent, ParentStudent are defined.
# - Helpers: get_unread_message_count, get_unread_notifications_count, get_user_assets_query are defined and potentially used in context processor.
# - role_required decorator is defined.
# - url_for, request, flash, render_template, redirect, abort, jsonify are available.
# - The context processor injects unread message/notification counts and `current_user`.

# --- Dashboard Routes (Specific Roles) ---

@app.route("/student/dashboard")
@login_required
@role_required("student") # Make sure your role_required decorator is defined and working
def student_dashboard():
    user_id = current_user.id

    # Teachers in the student's grade and section
    teachers = []
    teachers_count = 0
    if current_user.grade and current_user.section:
        # Ensure TeacherProfile and Role models are correctly imported and joined
        teachers = db.session.scalars(
            select(User)
            .join(User.teacher_profiles) # Assuming 'teacher_profiles' is the relationship name on User to TeacherProfile model
            .where(
                TeacherProfile.grade == current_user.grade,
                TeacherProfile.section == current_user.section,
                User.is_active == True,
                User.role.has(Role.name == "teacher") # Ensure it's a teacher
            )
            .distinct() # Avoid duplicates if a teacher has multiple profiles for the same class (unlikely)
            .order_by(User.full_name)
        ).all()
        teachers_count = len(teachers)

    # Borrowed books (not returned)
    borrowed_books = db.session.scalars(
        select(BorrowedAsset) # Make sure BorrowedAsset model is imported
        .where(BorrowedAsset.user_id == user_id, BorrowedAsset.returned == False)
        .options(joinedload(BorrowedAsset.asset).joinedload(Asset.category)) # Eager load asset and its category
        .order_by(BorrowedAsset.due_date.asc())
    ).all()

    # Recent attendance records (last 5)
    recent_attendance = db.session.scalars(
        select(Attendance) # Make sure Attendance model is imported
        .where(Attendance.student_id == user_id)
        .order_by(Attendance.date.desc())
        .limit(5)
    ).all()

    # Marks for all subjects
    marks_records = db.session.scalars(
        select(Mark) # Make sure Mark model is imported
        .where(Mark.student_id == user_id)
        .order_by(Mark.subject)
    ).all()

    # My Tasks (actionable ones for the student)
    actionable_task_statuses = [
        'Open', 'In Progress', 'Completed (Pending Review)',
        'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Review Rejected'
    ]
    # Ensure UserTask and Task models are imported
    my_tasks = db.session.scalars(
        select(UserTask)
        .join(UserTask.task) # Explicit join to Task for ordering or filtering by task attributes
        .where(UserTask.user_id == user_id, UserTask.status.in_(actionable_task_statuses))
        .options(joinedload(UserTask.task).joinedload(Task.created_by)) # Eager load related task and its creator
        .order_by(Task.due_date.asc().nulls_last(), UserTask.assigned_at.asc()) # Order by task's due_date
    ).all()
    
    # Recent activities for student (placeholder for now, could be recent important notifications)
    # Example: Fetch last 5 notifications of specific types relevant to students
    student_activity_types = ['task_assigned', 'task_review_result', 'behavior_recorded', 'general_announcement_student'] # Define relevant types
    recent_activities = db.session.scalars(
        select(Notification)
        .where(Notification.receiver_id == user_id, Notification.notification_type.in_(student_activity_types))
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()
    # Format these activities for the partial if needed
    # The partial expects: activity.icon, activity.text, activity.timestamp, activity.url, activity.badge_color
    # You'll need to map Notification objects to this structure.
    # For simplicity in this step, we'll pass them directly and let the template adapt or be updated.

    return render_template(
        "student/dashboard.html",
        title="Student Dashboard - Nexus",
        teachers=teachers,
        teachers_count=teachers_count,
        borrowed_books=borrowed_books,
        recent_attendance=recent_attendance,
        marks_records=marks_records,
        my_tasks=my_tasks, # This variable is used in the student dashboard template for a stat card
        # recent_activities=student_activities_formatted # If you format them
        recent_activities=recent_activities # Pass raw notifications for now
        # unread_notifications_count and unread_messages_count are from context_processor
    )
    
@app.route("/teacher/student/<int:user_id>/profile") # Example path
@login_required
@role_required("teacher") # Or any role that should see this teacher-centric view
def teacher_student_profile_view(user_id):
    student = db.get_or_404(User, user_id, description="Student not found.")
    if not student.role or student.role.name.lower() != 'student':
        flash("The specified user is not a student.", "warning")
        abort(404) # Or redirect

    # --- Data specific to Teacher's view of this student ---
    # Current teacher's profile (to check if they teach this student)
    # This logic assumes a teacher might have multiple profiles (grade/section/subject combinations)
    teacher_profiles_for_this_student = [
        tp for tp in current_user.teacher_profiles 
        if tp.grade == student.grade and tp.section == student.section
    ]
    # For simplicity, let's assume the first matching profile or any match grants "teaches this student" status
    teacher_teaches_this_student = bool(teacher_profiles_for_this_student)
    # If a specific subject context is needed:
    # teacher_teaches_subject_to_student = any(tp.subject == "SomeSpecificSubject" for tp in teacher_profiles_for_this_student)

    # Get student's marks (all subjects, or filter by subjects teacher teaches)
    student_marks_query = select(Mark).where(Mark.student_id == student.id)
    # Optional: Filter by subjects this teacher teaches, if applicable
    # taught_subjects = {tp.subject for tp in teacher_profiles_for_this_student if tp.subject}
    # if taught_subjects:
    #     student_marks_query = student_marks_query.where(Mark.subject.in_(taught_subjects))
    student_marks = db.session.scalars(student_marks_query.order_by(Mark.subject)).all()

    # Get student's recent attendance (e.g., last 10 records)
    student_attendance = db.session.scalars(
        select(Attendance).where(Attendance.student_id == student.id).order_by(Attendance.date.desc()).limit(10)
    ).all()

    # Get student's recent behavior records (e.g., last 5)
    student_behavior_records = db.session.scalars(
        select(BehaviorRecord)
        .where(BehaviorRecord.student_id == student.id)
        .options(joinedload(BehaviorRecord.recorded_by)) # Eager load who recorded it
        .order_by(BehaviorRecord.date.desc())
        .limit(5)
    ).all()
    
    # Get the current teacher's profile if needed by template (e.g. to check section)
    # This is slightly different from teacher_profiles_for_this_student
    # current_teacher_primary_profile = current_user.teacher_profiles.first() # Or some other logic
    # Using a simplified version for the template logic
    teacher_profile_context = current_user.teacher_profiles.filter_by(grade=student.grade, section=student.section).first()


    return render_template("teacher/student_profile_view.html",
                           student=student,
                           student_marks=student_marks,
                           student_attendance=student_attendance,
                           student_behavior_records=student_behavior_records,
                           teacher_profile=teacher_profile_context, # Pass current teacher's relevant profile
                           # permissions=get_request_permissions(current_user) # If quick links use it
                           title=f"Profile: {student.full_name or student.username} - Nexus")    
    
@app.route("/teacher/dashboard")
@login_required
@role_required("teacher")
def teacher_dashboard():
    # teacher_profile is used to find students in their class.
    # Assuming a teacher is primarily associated with one main class for dashboard stats.
    # If a teacher can have multiple (grade, section, subject) assignments,
    # this logic might need to pick the "primary" one or aggregate data.
    teacher_profile = db.session.scalar(
        select(TeacherProfile).where(
            TeacherProfile.user_id == current_user.id
            # Add conditions if teachers can have multiple profiles, e.g., filter by a 'is_primary' flag
        ).order_by(TeacherProfile.id.desc()).limit(1) # Get the latest or primary profile
    )

    students_count = 0
    if teacher_profile and teacher_profile.grade and teacher_profile.section:
        students_count = (
            db.session.scalar(
                select(func.count(User.id))
                .join(User.role) # Assuming User.role relationship
                .where(
                    Role.name == "student",
                    User.grade == teacher_profile.grade,
                    User.section == teacher_profile.section,
                    User.is_active == True,
                )
            ) or 0
        )
    
    lab_name = current_user.lab.name if current_user.lab else "Not Assigned"

    # My Tasks (actionable ones for the teacher)
    actionable_task_statuses = [
        'Open', 'In Progress', 'Completed (Pending Review)',
        'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Review Rejected'
    ]
    my_tasks = db.session.scalars(
        select(UserTask)
        .join(UserTask.task)
        .where(UserTask.user_id == current_user.id, UserTask.status.in_(actionable_task_statuses))
        .options(joinedload(UserTask.task).joinedload(Task.created_by))
        .order_by(Task.due_date.asc().nulls_last(), UserTask.assigned_at.asc())
    ).all()

    # Recent activities for teacher (e.g., new submissions for review, system announcements)
    teacher_activity_types = ['task_status_update_for_creator', 'request_submitted_to_handler', 'general_announcement_teacher']
    recent_activities = db.session.scalars(
        select(Notification)
        .where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(teacher_activity_types))
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()
    # You might need a new notification_type like 'task_status_update_for_creator'
    # and ensure notify_user_task_status_update uses it.

    return render_template(
        "teacher/dashboard.html",
        title="Teacher Dashboard - Nexus",
        teacher_profile=teacher_profile, # Pass the single profile object
        students_count=students_count,
        lab_name=lab_name,
        my_tasks=my_tasks,
        recent_activities=recent_activities
        # permissions (for quick links) and unread counts are from context_processor
    )
    
    
@app.route("/librarian/dashboard")
@login_required
@role_required("librarian")
def librarian_dashboard():
    """Librarian specific dashboard."""
    user_id = current_user.id

    # Recent notifications are in context processor

    # Fetch book category ID safely (assuming 'Books' is the standard category name)
    book_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
    book_category_id = book_category.id if book_category else None

    total_books = 0
    available_books = 0
    checked_out_books = 0

    if book_category_id:
        # Total count of assets in the 'Books' category
        total_books = (
            db.session.scalar(
                select(func.sum(Asset.quantity)).where( # Sum quantity for total stock
                    Asset.category_id == book_category_id,
                    Asset.status.in_(['Available', 'CheckedOut', 'Under Maintenance']) # Consider relevant statuses for total stock
                )
            )
            or 0
        )
        # Count of *items* currently marked as Available (quantity > 0)
        available_books = (
            db.session.scalar(
                select(func.sum(Asset.quantity)).where(
                    Asset.category_id == book_category_id,
                    Asset.status == "Available",
                    Asset.quantity > 0
                )
            )
            or 0
        )
        # Count *individual checkouts* that are not yet returned
        checked_out_books = (
            db.session.scalar(
                select(func.count(BookCheckout.id))
                .join(Asset) # Join to filter by category
                .where(
                    Asset.category_id == book_category_id,
                    BookCheckout.returned == False,
                )
            )
            or 0
        )

    # Reports related to library assets (e.g., status 'Needs Repair', 'Broken' for book category)
    library_category_ids = []
    if book_category: library_category_ids.append(book_category.id)
    library_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="Library Equipment"))
    if library_equipment_category: library_category_ids.append(library_equipment_category.id)

    open_library_reports = 0
    if library_category_ids:
         open_library_reports = db.session.scalar(
             select(func.count(AssetReport.id))
             .join(Asset)
             .where(
                 Asset.category_id.in_(library_category_ids),
                 AssetReport.status.in_(['Pending', 'In Progress']) # Open reports
             )
         ) or 0


    return render_template(
        "librarian/dashboard.html",
        title="Librarian Dashboard",
        total_books=total_books,
        available_books=available_books,
        checked_out_books=checked_out_books,
        open_library_reports=open_library_reports, # Pass count of reports related to library
        # recent_notifications and unread_notifications_count are in context
    )
@app.route("/hr_ceo/dashboard")
@login_required
@role_required("hr_ceo") # Assuming "hr_ceo" is the role name
def hr_ceo_dashboard():
    student_count = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_active == True)) or 0
    teacher_count = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == "teacher", User.is_active == True)) or 0
    student_leader_count = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_leader == True, User.is_active == True)) or 0
    
    pending_assets = db.session.scalar(select(func.count(Asset.id)).where(Asset.status == "Pending Review")) or 0
    reports_open = db.session.scalar(select(func.count(AssetReport.id)).where(AssetReport.status.in_(['Pending', 'In Progress']))) or 0

    my_assigned_tasks_count = db.session.scalar(
        select(func.count(Task.id))
        .where(Task.created_by_id == current_user.id)
        # Optionally filter by tasks that are not yet fully completed by all assignees
    ) or 0
    
    requests_inbox_count = db.session.scalar(
        select(func.count(Request.id))
        .where(
            Request.current_handler_id == current_user.id,
            Request.tier == 1, # HR/CEO is Tier 1
            Request.status.in_(['Pending', 'Approved', 'On Progress']) # Actionable requests
        )
    ) or 0
    
    # Recent admin activities (placeholder - e.g., recent important system notifications or audit logs)
    admin_activity_types = ['new_user_registered', 'system_error_report', 'asset_approved', 'request_tier1_escalated']
    recent_activities = db.session.scalars(
        select(Notification) # Or from a dedicated AuditLog model if you have one
        .where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(admin_activity_types))
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()

    return render_template(
        "hr_ceo/dashboard.html",
        title="HR & Academics Dashboard - Nexus",
        student_count=student_count,
        teacher_count=teacher_count,
        student_leader_count=student_leader_count,
        pending_assets=pending_assets,
        reports_open=reports_open,
        my_assigned_tasks_count=my_assigned_tasks_count,
        requests_inbox_count=requests_inbox_count,
        recent_activities=recent_activities
    )

@app.route("/school_exec/dashboard")
@login_required
@role_required("school_executive")
def school_exec_dashboard():
    """School Executive specific dashboard."""
    # Unread counts are in context processor via inject_global_vars

    # Relevant stats for School Executive overview
    student_count = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    teacher_count = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )
    total_users = db.session.scalar(select(func.count(User.id)).where(User.is_active == True)) or 0

    total_assets = db.session.scalar(select(func.count(Asset.id))) or 0
    open_reports = db.session.scalar(select(func.count(AssetReport.id)).where(AssetReport.status.in_(['Pending', 'In Progress']))) or 0

    # --- ADDED/CORRECTED SECTION ---
    # Count requests assigned to this School Executive (Tier 2 handler)
    # Ensure Request model and current_user are available
    requests_inbox_count = 0
    if current_user.is_authenticated and current_user.role.name.lower() == 'school_executive':
        requests_inbox_count = db.session.scalar(
            select(func.count(Request.id))
            .where(
                Request.current_handler_id == current_user.id,
                Request.tier == 2, # Tier 2 for School Executive
                Request.status.in_(['Pending', 'Approved', 'On Progress']) # Actionable requests
            )
        ) or 0

    # Placeholder for recent_executive_activities - define it even if empty for now
    # Populate this with actual activity data similar to other dashboards
    recent_executive_activities = []
    # Example:
    # relevant_notification_types = ['request_tier2_escalated', 'system_policy_updated', 'major_incident_report']
    # activities_raw = db.session.scalars(
    #     select(Notification)
    #     .where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(relevant_notification_types))
    #     .options(joinedload(Notification.sender))
    #     .order_by(Notification.timestamp.desc())
    #     .limit(5)
    # ).all()
    # for act in activities_raw:
    #     recent_executive_activities.append({
    #         'icon': 'bi-bell-fill', # Placeholder icon
    #         'badge_color': 'primary',
    #         'text': f"{act.content[:100]}..." if act.content else "Notification",
    #         'timestamp': act.timestamp,
    #         'url': act.link_url or "#"
    #     })
    # --- END ADDED/CORRECTED SECTION ---

    return render_template(
        "school_exec/dashboard.html",
        title="School Executive Dashboard",
        student_count=student_count,
        teacher_count=teacher_count,
        total_users=total_users,
        total_assets=total_assets,
        open_reports=open_reports,
        requests_inbox_count=requests_inbox_count,             # Now passed
        recent_executive_activities=recent_executive_activities # Now passed
    )
@app.route("/government/dashboard")
@login_required
@role_required("government")
def government_dashboard():
    """Government oversight specific dashboard."""
    # Stats for government view - high level numbers
    total_students = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    total_teachers = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )
    # Could add average scores, attendance rates across the whole school if data is structured for it.
    # Placeholder for total number of assets managed by the school
    total_assets_count = db.session.scalar(select(func.count(Asset.id))) or 0


    return render_template(
        "government/dashboard.html",
        title="Government Oversight Dashboard",
        total_students=total_students,
        total_teachers=total_teachers,
        total_assets_count=total_assets_count, # Example stat
    )

# In app.py

@app.route("/talent_club/dashboard")
@login_required
@tc_member_required
def talent_club_dashboard():
    """Talent Club specific dashboard."""
    # Unread counts in context processor

    # --- START OF FIX ---
    # Count active users who are TC Members (is_tc_member == True)
    member_count = db.session.scalar(
        select(func.count(User.id))
        .where(User.is_tc_member == True, User.is_active == True) # CORRECTED QUERY
    ) or 0
    # --- END OF FIX ---

    # Assets specifically designated for the Talent Club (assuming a category 'Talent Club Gear')
    talent_club_category = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
    talent_club_assets = []
    if talent_club_category:
        talent_club_assets = db.session.scalars(
            select(Asset)
            .where(Asset.category == talent_club_category, Asset.status.in_(['Available', 'Under Maintenance', 'Needs Repair'])) # Show relevant statuses
            .order_by(Asset.name)
        ).all()

    return render_template(
        "talent_club/dashboard.html",
        title="Talent Club Dashboard",
        member_count=member_count,
        talent_club_assets=talent_club_assets, # Pass assets
        # recent_notifications, unread_notifications_count are in context
    )
    
@app.route("/parent/dashboard")
@login_required
@role_required("parent")
def parent_dashboard():
    children_list = []
    recent_behavior_records_for_children = []

    # Assuming ParentStudent links Parent to student User, and User has parent_associations
    if current_user.parent_profile and current_user.parent_profile.student_associations:
        # Get verified children
        verified_associations = [
            assoc for assoc in current_user.parent_profile.student_associations 
            if assoc.verification_status == 'verified' and assoc.student # Ensure student exists
        ]
        children_list = [assoc.student for assoc in verified_associations]
        
        if children_list:
            child_ids = [child.id for child in children_list]
            recent_behavior_records_for_children = db.session.scalars(
                select(BehaviorRecord)
                .where(BehaviorRecord.student_id.in_(child_ids))
                .options(joinedload(BehaviorRecord.student)) # Eager load student for display in record
                .order_by(BehaviorRecord.date.desc())
                .limit(5) # Limit for dashboard snippet
            ).all()

    return render_template(
        "parent/dashboard.html",
        title="Parent Dashboard - Nexus",
        children=children_list,
        recent_behavior_records=recent_behavior_records_for_children
    )
    
@app.route("/library")
@login_required
# Student can see their borrowed books. Librarian view redirects to list_checkouts.
@role_required("student", "librarian") 
def view_library():
    if current_user.role.name.lower() == "student":
        # Ensure BorrowedAsset and its relationships (asset, asset.category) are loaded
        checkouts = db.session.scalars(
            select(BorrowedAsset)  # Using BorrowedAsset, as per student dashboard and models
            .where(
                BorrowedAsset.user_id == current_user.id,
                BorrowedAsset.returned == False
            )
            .options(joinedload(BorrowedAsset.asset).joinedload(Asset.category))
            .order_by(BorrowedAsset.due_date.asc())
        ).all()
        # The template "student/library_view.html" needs to be created if not already.
        # For now, let's assume it's similar to a simplified list_checkouts or uses _book_checkout_item.
        # If "student/library_view.html" does not exist, you might need to create it or reuse parts of list_checkouts.
        # For simplicity, let's assume it expects 'checkouts' and can iterate them.
        # If student/library_view.html was intended to list BookCheckout model items,
        # then query BookCheckout instead of BorrowedAsset.
        # Given the backend definition used BorrowedAsset for student dashboard, let's stick to it.
        # If the student dashboard used BookCheckout then query BookCheckout here.
        # *** Assuming `student/library_view.html` will use `_book_checkout_item.html` for consistency. ***
        # This means we should pass BookCheckout objects, not BorrowedAsset.
        
        select(BookCheckout)  # QUERYING BookCheckout FOR CONSISTENCY WITH _book_checkout_item.html
        book_checkouts = db.session.scalars(
            select(BookCheckout)
            .where(
                BookCheckout.user_id == current_user.id,
                BookCheckout.returned == False
            )
            .options(joinedload(BookCheckout.asset).joinedload(Asset.category), joinedload(BookCheckout.user))  # User is already current_user but good for partial
            .order_by(BookCheckout.due_date.asc())
        ).all()

        return render_template("student/library_view.html", 
                               checkouts=book_checkouts,  # Pass BookCheckout objects
                               title="My Borrowed Books - Nexus")

    elif current_user.role.name.lower() == "librarian":
        return redirect(url_for('list_checkouts'))
    
    abort(403)  # Should not be reached

# --- PART 6 END ---

# --- PART 7 START: Teacher/Librarian Specific Features ---


# --- Teacher Specific Routes (Marks, Attendance, Lab) ---

# Helper function to update ranks for a subject (Needed by enter_marks)
def update_ranks_for_subject(subject_name):
    """Calculates and updates ranks for all students for a given subject based on average marks."""
    # Ensure app context for DB operations if this function is called outside a request context
    # If only called within request handlers (like enter_marks POST), app_context is implicit.
    # Adding it defensively if there's a CLI command or background task that uses this.
    with app.app_context():
        try:
            # Select relevant marks, calculate rank using a window function
            ranked_marks_stmt = (
                select(
                    Mark.id,
                    over(func.rank(), order_by=Mark.average.desc()).label("new_rank")
                )
                .where(Mark.subject == subject_name, Mark.average.isnot(None))
                .subquery() # Use subquery to get ranks
            )

            # Update the Mark table using the ranks from the subquery
            stmt = (
                db.update(Mark)
                .where(Mark.id == ranked_marks_stmt.c.id) # Join condition to subquery
                .values(rank=ranked_marks_stmt.c.new_rank)
            )
            result = db.session.execute(stmt)

            # Update students who have no average (set rank to None)
            stmt_clear_rank = (
                 db.update(Mark)
                 .where(Mark.subject == subject_name, Mark.average.is_(None))
                 .values(rank=None)
            )
            db.session.execute(stmt_clear_rank)

            # Commit the rank updates
            db.session.commit()

            app.logger.info(
                f"Ranks updated for subject '{subject_name}'. {result.rowcount} students ranked."
            )
        except Exception as e:
            # Rollback only the rank updates if an error occurs here
            db.session.rollback()
            app.logger.error(f"Error updating ranks for subject '{subject_name}': {e}", exc_info=True)
            # Optionally re-raise or flash a message


@app.route("/teacher/marks", methods=["GET", "POST"])
@login_required
@role_required("teacher")
def enter_marks():
    """Allows teachers to enter and update marks for their students and subject."""
    # Assuming a teacher is primarily associated with one profile/class/subject for marks entry
    teacher_profile = current_user.teacher_profiles.filter(
        TeacherProfile.subject.isnot(None),
        TeacherProfile.grade.isnot(None),
        TeacherProfile.section.isnot(None)
    ).first()

    if (
        not teacher_profile
        or not teacher_profile.grade
        or not teacher_profile.section
        or not teacher_profile.subject
    ):
        flash(
            "Your teacher profile is incomplete (grade, section, or subject missing). Please contact an administrator.",
            "warning",
        )
        return redirect(url_for("teacher_dashboard"))

    # Get active students in this teacher's assigned grade and section
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.grade == teacher_profile.grade,
            User.section == teacher_profile.section,
            User.is_active == True,
        )
        .order_by(User.full_name)
    ).all()

    # The subject for marks entry is determined by the teacher's profile
    subject_taught = teacher_profile.subject

    # Pre-fetch existing marks for these students and this subject to display
    existing_marks_map = {}
    if students:
        student_ids = [s.id for s in students]
        if student_ids: # Prevent empty IN clause in query
             existing_marks_records = db.session.scalars(
                 select(Mark).where(
                     Mark.student_id.in_(student_ids), Mark.subject == subject_taught
                 )
             ).all()
             # Map records by student_id for easy lookup in template
             for mark_record in existing_marks_records:
                 existing_marks_map[mark_record.student_id] = mark_record

    # No WTForms form instance is strictly needed for validation here as data is read directly from request.form
    # However, you *could* define a FormField with fields for s1, s2, etc., and use a FieldList.
    # For consistency with the provided POST handling pattern, we read request.form directly.

    if request.method == "POST":
        marks_to_process = []
        validation_errors = {} # Dictionary to store validation errors per student

        # Process submitted data directly from request.form
        for student in students:
            student_id = student.id
            # Get scores as strings, strip whitespace
            s1_str = request.form.get(f"semester_1_{student_id}", "").strip()
            s2_str = request.form.get(f"semester_2_{student_id}", "").strip()

            s1 = None
            s2 = None
            current_student_errors = [] # List for errors specific to this student

            # Attempt to convert to float, handle empty strings and invalid formats
            try:
                if s1_str:
                    s1 = float(s1_str)
                    if not (0 <= s1 <= 100):
                        current_student_errors.append("Semester 1 score must be between 0 and 100.")
                        s1 = None # Treat as invalid if out of range
            except ValueError:
                if s1_str: # Only add error if input wasn't empty
                    current_student_errors.append("Invalid format for Semester 1 score.")

            try:
                if s2_str:
                    s2 = float(s2_str)
                    if not (0 <= s2 <= 100):
                        current_student_errors.append("Semester 2 score must be between 0 and 100.")
                        s2 = None # Treat as invalid if out of range
            except ValueError:
                if s2_str: # Only add error if input wasn't empty
                    current_student_errors.append("Invalid format for Semester 2 score.")

            # Store parsed data (even if None) and any errors for this student
            marks_to_process.append({"student_id": student_id, "s1": s1, "s2": s2})
            if current_student_errors:
                 validation_errors[student_id] = current_student_errors


        if validation_errors:
             # If there are any validation errors for any student, flash them and re-render
             for student_id, errors in validation_errors.items():
                 # Find the student object again to display name
                 student = next((s for s in students if s.id == student_id), None)
                 student_name = student.full_name or student.username if student else f"Student ID {student_id}"
                 for err in errors:
                      flash(f"Error for {student_name}: {err}", "danger")

             # Re-render the page. Submitted data will be available in request.form for the template.
             return render_template(
                 "teacher/marks.html",
                 students=students,
                 subject_taught=subject_taught,
                 existing_marks_map=existing_marks_map, # Pass existing for comparison on re-render
                 validation_errors=validation_errors, # Pass errors to template for field highlighting
                 title=f"Enter Marks for {subject_taught}",
             )

        # If no validation errors, proceed to save to database
        try:
            for mark_data in marks_to_process:
                student_id = mark_data["student_id"]
                s1 = mark_data["s1"]
                s2 = mark_data["s2"]

                # Calculate total and average only if BOTH scores are numeric (not None)
                total = None
                average = None
                if s1 is not None and s2 is not None:
                    total = s1 + s2
                    average = total / 2.0
                # If only one score is provided, leave total/avg as None

                # Find or create attendance record for this student and date
                # Use db.session.scalar and filter_by for unique lookup (student+subject)
                record = db.session.scalar(
                    select(Mark).filter_by(student_id=student_id, subject=subject_taught)
                )

                if record:  # Update existing record
                    # Only update if the input field was not empty.
                    # This allows teacher to submit only S1 or only S2 at different times.
                    if request.form.get(f"semester_1_{student_id}", "").strip():
                         record.semester_1 = s1
                    if request.form.get(f"semester_2_{student_id}", "").strip():
                         record.semester_2 = s2

                    # Recalculate total and average based on current (potentially updated) S1 and S2
                    if record.semester_1 is not None and record.semester_2 is not None:
                        record.total = record.semester_1 + record.semester_2
                        record.average = record.total / 2.0
                    else:
                        record.total = None
                        record.average = None


                else:  # Create new record
                    # Only create if at least one score was successfully parsed and provided
                    if request.form.get(f"semester_1_{student_id}", "").strip() or request.form.get(f"semester_2_{student_id}", "").strip():
                         # Calculate initial total and average if both are present on creation
                         initial_total = s1 + s2 if s1 is not None and s2 is not None else None
                         initial_average = initial_total / 2.0 if initial_total is not None else None

                         record = Mark(
                             student_id=student_id,
                             subject=subject_taught,
                             semester_1=s1,
                             semester_2=s2,
                             total=initial_total,
                             average=initial_average,
                         )
                         db.session.add(record)

                # Ranks are updated separately after the commit

            db.session.commit()

            # Update ranks for this subject AFTER all marks for it are committed
            update_ranks_for_subject(subject_taught) # This function handles its own commit/rollback

            flash(f"Marks for {subject_taught} entered successfully!", "success")
            app.logger.info(
                f"Marks for {subject_taught} updated by {current_user.username} for Grade {teacher_profile.grade}, Section {teacher_profile.section}"
            )
            # Redirect to refresh the page and show updated data/ranks
            return redirect(url_for("enter_marks"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error saving marks for {subject_taught} by {current_user.username}: {e}", exc_info=True
            )
            flash(
                "An unexpected error occurred while saving marks. Please try again.", "danger"
            )
            # Re-render form with submitted data (available in request.form) and error message
            # Need to re-fetch existing marks map for template rendering
            existing_marks_records_after_error = db.session.scalars(
                 select(Mark).where(
                     Mark.student_id.in_(student_ids), Mark.subject == subject_taught
                 )
             ).all()
            existing_marks_map_after_error = {mark_record.student_id: mark_record for mark_record in existing_marks_records_after_error}

            return render_template(
                 "teacher/marks.html",
                 students=students,
                 subject_taught=subject_taught,
                 existing_marks_map=existing_marks_map_after_error, # Pass re-fetched map
                 validation_errors={}, # No input validation errors here, only DB error
                 title=f"Enter Marks for {subject_taught}",
             )


    # For GET request, render the template
    # existing_marks_map is used to pre-fill the form elements in the template
    return render_template(
        "teacher/marks.html",
        students=students,
        subject_taught=subject_taught,
        existing_marks_map=existing_marks_map, # Pass map for pre-filling
        validation_errors={}, # No errors on GET
        title=f"Enter Marks for {subject_taught}",
    )


@app.route("/teacher/attendance", methods=["GET", "POST"])
@login_required
@role_required("teacher")
def mark_attendance():
    """Allows teachers to mark student attendance for their class."""
    # Assuming a teacher is primarily associated with one profile/class for attendance
    teacher_profile = current_user.teacher_profiles.filter(
        TeacherProfile.grade.isnot(None),
        TeacherProfile.section.isnot(None)
    ).first() # Get the first profile if multiple

    if not teacher_profile or not teacher_profile.grade or not teacher_profile.section:
        flash(
            "Your teacher profile is incomplete (grade or section missing). Please contact an administrator.",
            "warning",
        )
        return redirect(url_for("teacher_dashboard"))

    # Get active students in this teacher's assigned grade and section
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.grade == teacher_profile.grade,
            User.section == teacher_profile.section,
            User.is_active == True,
        )
        .order_by(User.full_name)
    ).all()

    # Handle invalid grade/section if no students are found for some reason
    if not students:
         flash(f"No active students found for Grade {teacher_profile.grade}, Section {teacher_profile.section}.", "warning")
         return redirect(url_for('teacher_dashboard')) # Redirect teacher back


    # Determine the date for attendance. Use request.args.get('date') for GET requests/redirects
    attendance_date_str = request.args.get(
        "date", datetime.now(timezone.utc).strftime("%Y-%m-%d")
    )
    try:
        # Validate the date string from args
        attendance_date_obj = datetime.strptime(attendance_date_str, "%Y-%m-%d").date()
        # Prevent viewing future dates
        if attendance_date_obj > datetime.now(timezone.utc).date():
            flash("Cannot view attendance for future dates.", "warning")
            attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
            attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string

    except ValueError:
        flash(
            "Invalid date format provided in URL. Using today's date.", # Clarify it's from URL
            "warning",
        )
        attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
        attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string

    # Pre-fetch existing attendance records for the determined date and students
    # Use the correct Attendance model (student attendance)
    existing_records = db.session.scalars(
        select(Attendance).where(
            Attendance.student_id.in_([s.id for s in students]), # Filter by student IDs
            Attendance.date == attendance_date_obj # Filter by date
        )
    ).all()

    # Map existing records by student_id for easy lookup in template
    existing_attendance_map = {record.student_id: record for record in existing_records}

    # Instantiate the form. Pass the students list to the form's __init__
    # This is primarily for the template to correctly generate the FieldList structure,
    # as data processing happens via request.form directly.
    form = AttendanceForm(students=students) # Pass students list

    if request.method == "POST":
        # Re-validate the date from the POST form data (hidden field or similar)
        form_date_str = request.form.get("date")
        try:
            date_for_marking = datetime.strptime(form_date_str, "%Y-%m-%d").date()
            if date_for_marking > datetime.now(timezone.utc).date():
                flash("Cannot mark attendance for future dates.", "danger")
                # Redirect back with the invalid date string, preserving it in the URL
                return redirect(url_for("mark_attendance", date=form_date_str))
        except (ValueError, TypeError): # TypeError if form_date_str is None
            flash("Invalid date format submitted. Please use YYYY-MM-DD.", "danger")
            # Redirect back, defaulting date to today's format
            return redirect(url_for("mark_attendance")) # Defaults to today's date


        try:
            # Process form data directly from request.form
            # Loop through students to find their status and notes in the POST data
            valid_statuses = ["Present", "Absent", "Late", "Excused"]
            students_processed = 0

            for student in students:
                student_id = student.id
                # Status field names are e.g., status_123, notes_123 (matching template)
                status = request.form.get(f"status_{student_id}")
                notes = request.form.get(f"notes_{student_id}", "").strip()

                # Basic validation: ensure status is one of the valid options
                if status not in valid_statuses:
                     # This indicates unexpected input, likely manipulation
                     app.logger.warning(f"Invalid status '{status}' submitted for student {student_id} by teacher {current_user.username}.")
                     flash(f"Invalid attendance status submitted for {student.full_name or student.username}. Please re-select.", "danger")
                     # Rollback any changes made in this batch and redirect
                     db.session.rollback()
                     return redirect(url_for("mark_attendance", date=form_date_str)) # Redirect back to the form with errors

                # Enforce notes max length
                if len(notes) > 255:
                    app.logger.warning(f"Notes too long for student {student_id} by teacher {current_user.username}.")
                    flash(f"Notes for {student.full_name or student.username} are too long (max 255 characters).", "danger")
                    db.session.rollback() # Rollback
                    return redirect(url_for("mark_attendance", date=form_date_str))


                # Find or create attendance record for this student and date
                # Use db.session.scalar and filter_by for this unique constraint lookup (_student_date_uc)
                record = db.session.scalar(
                    select(Attendance).filter_by(student_id=student_id, date=date_for_marking)
                )

                if record: # Update existing record
                    record.status = status
                    record.notes = notes
                else: # Create new record
                    new_attendance_record = Attendance(
                        student_id=student_id,
                        date=date_for_marking,
                        status=status,
                        notes=notes,
                    )
                    db.session.add(new_attendance_record)

                students_processed += 1

            db.session.commit() # Commit all changes in one transaction

            flash(
                f"Attendance for {date_for_marking.strftime('%Y-%m-%d')} marked successfully for {students_processed} student(s)!",
                "success",
            )
            app.logger.info(
                f"Attendance for {date_for_marking} (Grade {teacher_profile.grade}-{teacher_profile.section}) updated by teacher {current_user.username}. {students_processed} records processed."
            )
            # Redirect back to the same date's attendance page
            return redirect(
                url_for(
                    "mark_attendance",
                    date=date_for_marking.strftime("%Y-%m-%d"),
                )
            )

        except IntegrityError:
            db.session.rollback()
            # This error should ideally be prevented by the find-or-create logic,
            # but it's a fallback.
            app.logger.error(f"Attendance IntegrityError for {date_for_marking}, Grade {teacher_profile.grade}, Section {teacher_profile.section} by {current_user.username}: potentially duplicate entry attempt.", exc_info=True)
            flash(
                "Error saving attendance: A record for one or more students might already exist for this date. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            # Need to re-fetch existing marks map for template rendering on error re-render
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_(student_ids), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "teacher/attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )


        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error saving attendance for {date_for_marking}, Grade {teacher_profile.grade}, Section {teacher_profile.section} by {current_user.username}: {e}", exc_info=True)
            flash(
                "An unexpected error occurred while saving attendance. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_(student_ids), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "teacher/attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )


    # For GET request or failed POST validation/error, render the template
    # existing_attendance_map is used to pre-fill the form elements in the template
    # Pass the form instance to ensure the FieldList structure is available to the template
    return render_template(
        "teacher/attendance.html",
        form=form,
        students=students,
        attendance_date_str=attendance_date_str, # Pass the date string for the input field value
        existing_attendance_map=existing_attendance_map, # Pass map for pre-filling
        title="Mark Attendance",
    )

@app.route("/teacher/lab_equipment")
@login_required
@role_required("teacher")
def teacher_lab_equipment():
    """Displays equipment assigned to the teacher's lab."""
    # Check if teacher is assigned to a lab via lab_id (column added in Part 2)
    if not current_user.lab_id:
        flash("You are not currently assigned to a lab.", "info")
        return redirect(url_for("teacher_dashboard"))

    # Fetch equipment belonging to the teacher's lab (Asset model filtering by lab_id)
    lab_equipment = db.session.scalars(
        select(Asset).where(Asset.lab_id == current_user.lab_id).order_by(Asset.name)
    ).all()

    # Fetch the Lab object to get the name easily
    lab = db.session.get(Lab, current_user.lab_id)
    lab_name = lab.name if lab else "Unknown Lab"

    app.logger.info(
        f"Teacher {current_user.username} (ID: {current_user.id}) accessed equipment for lab {lab_name} (ID: {current_user.lab_id}). Found {len(lab_equipment)} assets."
    )

    return render_template(
        "teacher/lab_equipment.html",
        lab_equipment=lab_equipment,
        lab_name=lab_name,
        title=f"Equipment in {lab_name}",
    )


# --- Librarian Specific Routes ---

@app.route("/librarian/attendance")
@login_required
@role_required("librarian")
def librarian_attendance():
    """Librarian view of student attendance and related stats per class."""
    # Get all distinct grade-section pairs for student attendance tracking
    # Filter for active students who have a grade and section
    stmt = (
        select(User.grade, User.section)
        .join(Role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade.isnot(None),
            User.section.isnot(None)
        )
        .distinct() # Get unique pairs
        .order_by(User.grade, User.section) # Order for display
    )

    grade_section_pairs = db.session.execute(stmt).all()
    today = datetime.now(timezone.utc).date()

    # Calculate attendance statistics for today for each class
    attendance_stats = {}
    # Fetch role and category IDs once for efficiency in the loop
    student_role_id = db.session.scalar(select(Role.id).where(Role.name == "student"))
    book_category_id = db.session.scalar(select(AssetCategory.id).filter_by(name="Books"))

    for grade, section in grade_section_pairs:
        # Total active students in this specific grade-section
        total_students = db.session.scalar(
            select(func.count(User.id)).where(
                User.grade == grade,
                User.section == section,
                User.is_active == True,
                User.role_id == student_role_id # Filter by role ID
            )
        ) or 0 # Default to 0 if count is None

        # Present students for today in this grade-section (using the Attendance model)
        present_students_count = db.session.scalar(
            select(func.count(Attendance.id)).join(User).where( # Join User to filter by grade/section
                Attendance.date == today,
                Attendance.status == "Present", # Use status for student attendance
                User.grade == grade,
                User.section == section,
                User.is_active == True, # Ensure the student is active
            )
        ) or 0

        # Overdue book checkouts count for students in this grade-section
        overdue_books = 0
        if book_category_id: # Only check if book category exists
             overdue_books = db.session.scalar(
                 select(func.count(BookCheckout.id)) # Count checkouts
                 .join(User) # Join to filter by student's grade/section
                 .join(Asset) # Join to filter by asset category
                 .where(
                     BookCheckout.returned == False, # Not returned
                     BookCheckout.due_date < today, # Due date is in the past
                     User.grade == grade,
                     User.section == section,
                     User.is_active == True, # Ensure the student is active
                     Asset.category_id == book_category_id # Filter by book category
                 )
             ) or 0

        # Store stats using a composite key like "grade_section"
        attendance_stats[f"{grade}_{section}"] = {
            "total": total_students,
            "present": present_students_count,
            "absent": total_students - present_students_count, # Simple absent count
            "overdue_books": overdue_books,
            "percentage_present": (present_students_count / total_students * 100) if total_students else 0 # Percentage calc
        }

    # Pass sorted pairs and stats to the template
    # The template can iterate through grade_section_pairs and use the corresponding stats
    return render_template(
        "librarian/attendance_dashboard.html",
        grade_section_pairs=grade_section_pairs, # List of tuples (grade, section)
        attendance_stats=attendance_stats, # Dict keyed by "grade_section" string
        today=today,
        title="Student Attendance Overview",
    )


@app.route("/librarian/attendance/take/<string:grade>/<string:section>", methods=["GET", "POST"]) # Explicitly string type
@login_required
@role_required("librarian")
def take_attendance(grade, section):
    """Allows librarians to mark student attendance for a specific class."""
    # Get active students in this specific grade-section
    student_role = db.session.scalar(select(Role).where(Role.name == "student"))
    # Ensure student role exists and fetch students
    if not student_role:
         flash("Student role not found. Cannot take attendance.", "danger")
         return redirect(url_for('librarian_attendance')) # Redirect back to attendance dashboard

    students = db.session.scalars(
        select(User).where(
            User.grade == grade,
            User.section == section,
            User.is_active == True, # Only active students
            User.role == student_role # Filter by role object or role_id
        ).order_by(User.full_name) # Order students alphabetically
    ).all()

    # Handle invalid grade/section if no active students are found
    if not students:
         flash(f"No active students found for Grade {grade}, Section {section}.", "warning")
         return redirect(url_for('librarian_attendance')) # Redirect back


    # Determine the date for attendance marking
    # Use request.args.get('date') for GET requests/redirects from URL query
    attendance_date_str = request.args.get(
        "date", datetime.now(timezone.utc).strftime("%Y-%m-%d")
    )
    try:
        # Validate the date string from args
        attendance_date_obj = datetime.strptime(attendance_date_str, "%Y-%m-%d").date()
        # Prevent marking/viewing future dates
        if attendance_date_obj > datetime.now(timezone.utc).date():
            flash("Cannot mark attendance for future dates.", "warning")
            attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
            attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string

    except ValueError:
        flash(
            "Invalid date format provided in URL. Using today's date.",
            "warning",
        )
        attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
        attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string


    # Pre-fetch existing attendance records for the determined date and students
    existing_records = db.session.scalars(
        select(Attendance).where(
            Attendance.student_id.in_([s.id for s in students]), # Filter by student IDs
            Attendance.date == attendance_date_obj # Filter by date
        )
    ).all()

    # Map existing records by student_id for easy lookup in template
    existing_attendance_map = {record.student_id: record for record in existing_records}

    # Instantiate the form. Pass the students list to the form's __init__
    # This is needed for the template to correctly generate the FieldList structure,
    # even though data processing happens via request.form directly.
    form = AttendanceForm(students=students)

    if request.method == "POST":
        # Re-validate the date from the POST form data (e.g., a hidden input field)
        form_date_str = request.form.get("date")
        try:
            date_for_marking = datetime.strptime(form_date_str, "%Y-%m-%d").date()
            # Prevent marking future dates from POST data as well
            if date_for_marking > datetime.now(timezone.utc).date():
                flash("Cannot mark attendance for future dates.", "danger")
                # Redirect back with the invalid date string, preserving it
                return redirect(url_for("take_attendance", grade=grade, section=section, date=form_date_str))
        except (ValueError, TypeError):
            flash("Invalid date format submitted. Please use YYYY-MM-DD.", "danger")
            # Redirect back, defaulting date to today
            return redirect(url_for("take_attendance", grade=grade, section=section))


        try:
            # Process form data directly from request.form
            valid_statuses = ["Present", "Absent", "Late", "Excused"]
            students_processed = 0

            for student in students:
                student_id = student.id
                # Status field names are e.g., status_123, notes_123 (matching template)
                status = request.form.get(f"status_{student_id}")
                notes = request.form.get(f"notes_{student_id}", "").strip()

                # Basic validation: ensure status is one of the valid options
                if status not in valid_statuses:
                     app.logger.warning(f"Invalid status '{status}' submitted for student {student_id} by librarian {current_user.username}.")
                     flash(f"Invalid attendance status submitted for {student.full_name or student.username}. Please re-select.", "danger")
                     db.session.rollback() # Rollback any changes made in this batch
                     # Redirect back, preserving the date and class context
                     return redirect(url_for("take_attendance", grade=grade, section=section, date=form_date_str))


                # Enforce notes max length
                if len(notes) > 255:
                    app.logger.warning(f"Notes too long for student {student_id} by librarian {current_user.username}.")
                    flash(f"Notes for {student.full_name or student.username} are too long (max 255 characters).", "danger")
                    db.session.rollback() # Rollback
                    return redirect(url_for("take_attendance", grade=grade, section=section, date=form_date_str))

                # Find or create attendance record for this student and date
                # Use db.session.scalar and filter_by for this unique constraint lookup (_student_date_uc)
                record = db.session.scalar(
                    select(Attendance).filter_by(student_id=student_id, date=date_for_marking)
                )

                if record: # Update existing record
                    record.status = status
                    record.notes = notes
                else: # Create new record
                    new_attendance_record = Attendance(
                        student_id=student_id,
                        date=date_for_marking,
                        status=status,
                        notes=notes,
                    )
                    db.session.add(new_attendance_record)

                students_processed += 1


            db.session.commit() # Commit all changes in one transaction

            flash(
                f"Attendance for {date_for_marking.strftime('%Y-%m-%d')} marked successfully for {students_processed} student(s)!",
                "success",
            )
            app.logger.info(
                f"Attendance for {date_for_marking} (Grade {grade}-{section}) updated by librarian {current_user.username}. {students_processed} records processed."
            )
            # Redirect back to the same date's attendance page for the same class
            return redirect(
                url_for(
                    "take_attendance",
                    grade=grade,
                    section=section,
                    date=date_for_marking.strftime("%Y-%m-%d"),
                )
            )

        except IntegrityError:
            db.session.rollback()
            # This error should ideally be prevented by the find-or-create logic, but it's a fallback.
            app.logger.error(f"Attendance IntegrityError for {date_for_marking}, Grade {grade}, Section {section} by {current_user.username}: potentially duplicate entry attempt.", exc_info=True)
            flash(
                "Error saving attendance: A record for one or more students might already exist for this date. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            # Need to re-fetch existing records map on error re-render
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_([s.id for s in students]), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "librarian/take_attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error saving attendance for {date_for_marking}, Grade {grade}, Section {section} by {current_user.username}: {e}", exc_info=True)
            flash(
                "An unexpected error occurred while saving attendance. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_([s.id for s in students]), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "librarian/take_attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )


    # For GET request or failed POST validation/error, render the template
    # existing_attendance_map is used to pre-fill the form elements in the template
    # Pass the form instance to ensure the FieldList structure is available to the template
    return render_template(
        "librarian/take_attendance.html",
        form=form,
        students=students,
        grade=grade, # Pass grade for template
        section=section, # Pass section for template
        attendance_date_str=attendance_date_str, # Pass the date string for the input field value
        existing_attendance_map=existing_attendance_map, # Pass map for pre-filling
        title=f"Mark Attendance - Grade {grade}, Section {section}",
    )

@app.route("/librarian/student/<int:user_id>")
@login_required
@role_required("librarian")
def librarian_student_profile(user_id):
    student = db.get_or_404(User, user_id, description="Student user not found.")
    if not student.role or student.role.name.lower() != 'student':
        flash("The specified user is not a student.", "warning")
        abort(404) # Or redirect

    # Current Book Checkouts for this student (using BookCheckout, not BorrowedAsset for consistency with form)
    current_checkouts = db.session.scalars(
        select(BookCheckout) # Use BookCheckout
        .where(
            BookCheckout.user_id == student.id,
            BookCheckout.returned == False
        )
        .options(joinedload(BookCheckout.asset).joinedload(Asset.category)) # Load asset info
        .order_by(BookCheckout.due_date.asc())
    ).all()
    
    # Other data the template might show (already fetched in your Part 7 for this route)
    # For simplicity, let's assume the template focuses on checkouts.
    # recent_attendance = db.session.scalars(...).all()
    # recent_behavior_records = db.session.scalars(...).all()
    # recent_marks = db.session.scalars(...).all()


    return render_template(
        "librarian/student_profile.html",
        student=student,
        current_checkouts=current_checkouts, # Pass current checkouts
        # Pass other data if your template uses it:
        # recent_attendance=recent_attendance,
        # recent_behavior_records=recent_behavior_records,
        # recent_marks=recent_marks,
        title=f"Student Library Profile: {student.full_name or student.username} - Nexus"
    )

# Missing endpoint for returning a book from this profile view (can implement similar to /books/return)
# @app.route("/librarian/student/<int:user_id>/return_book/<int:checkout_id>", methods=["POST"])
# @login_required
# @role_required("librarian")
# def librarian_return_book_from_profile(user_id, checkout_id):
#      # Logic to find and mark the BorrowedAsset record as returned
#      # Update asset quantity
#      # Commit changes
#      # Redirect back to librarian_student_profile(user_id)
#      pass


# --- PART 7 END ---

# --- PART 8 START: HR/CEO & System Admin Management Features ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, TeacherProfile, Asset, AssetReport, AssetCategory, Lab, BehaviorRecord, Mark are defined.
# - Forms: AddAssetForm, ReportAssetForm, EditAssetForm, ResolveReportForm, AddCategoryForm, EditCategoryForm, BehaviorRecordForm, AssignLeaderForm are defined.
# - Helpers: get_user_assets_query, notify_hr_ceo_new_asset, notify_hr_ceo_new_report, notify_reporter_report_update, can_view_behavior_records, notify_student_and_parents, save_profile_photo, update_ranks_for_subject (used in teacher routes but defined earlier).
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, joinedload, etc.), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, os, uuid, secure_filename) are available.


# --- HR/CEO Student Database Routes ---
@app.route("/database/students")
@login_required
@role_required("hr_ceo", "system_admin", "teacher") # Allow teachers to see the index
def student_database_index():
    # Valid grades to display blocks for (can be made dynamic or configurable)
    # VALID_GRADES_FOR_DB_VIEW = ["9", "10", "11", "12"] # Or fetch distinct grades from User table

    # Fetch distinct, active grade/section pairs where students exist
    active_student_blocks_query = (
        select(User.grade, User.section)
        .join(User.role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade.isnot(None), User.grade != '', # Ensure grade has a value
            User.section.isnot(None), User.section != '' # Ensure section has a value
            # User.grade.in_(VALID_GRADES_FOR_DB_VIEW) # Optional: Filter by predefined valid grades
        )
        .distinct()
        .order_by(User.grade.asc(), User.section.asc()) # Order for display
    )
    grade_section_pairs = db.session.execute(active_student_blocks_query).all() # List of (grade, section) tuples

    grouped_blocks = defaultdict(list) # To group sections under each grade
    if grade_section_pairs:
        for grade_val, section_val in grade_section_pairs:
            # For each block, find subjects taught by active teachers in that specific grade/section
            subjects_taught_in_block_query = (
                select(TeacherProfile.subject)
                .join(TeacherProfile.user)  # CORRECTED LINE: Was TeacherProfile.user_obj
                .join(User.role) # This join is now from User (via TeacherProfile.user) to Role
                .where(
                    Role.name == "teacher",
                    User.is_active == True,
                    TeacherProfile.grade == grade_val,
                    TeacherProfile.section == section_val,
                    TeacherProfile.subject.isnot(None), TeacherProfile.subject != ''
                )
                .distinct()
                .order_by(TeacherProfile.subject.asc())
            )
            subjects = db.session.scalars(subjects_taught_in_block_query).all()
            
            grouped_blocks[grade_val].append({
                "section": section_val,
                "subjects": subjects if subjects else [] # Ensure it's a list
            })

    # Sort by grade keys (though defaultdict might preserve insertion order for modern Python)
    # Then sort sections within each grade (already done by the initial query order)
    ordered_grouped_blocks = {grade: sorted(sections, key=lambda s: s['section']) for grade, sections in sorted(grouped_blocks.items())}


    return render_template(
        "Database/students/index.html", # Correct template path
        ordered_grouped_blocks=ordered_grouped_blocks,
        # valid_grades=VALID_GRADES_FOR_DB_VIEW, # If you pass this to template for other UI
        title="Student Database Index - Nexus"
    )

@app.route("/database/students/<string:grade>/<string:section>") # Ensure grade/section are strings
@login_required
@role_required("hr_ceo", "system_admin", "teacher")
def student_database_block(grade, section):
    # Permission check for teachers: Can only view their assigned grade/section block(s)
    if current_user.role.name.lower() == 'teacher':
        # Construct the subquery for existence check
        subquery = select(TeacherProfile.id).where( # Select any single column
            TeacherProfile.user_id == current_user.id,
            TeacherProfile.grade == grade,
            TeacherProfile.section == section
        ).limit(1) # Important: limit 1 for efficiency

        # Check if the subquery returns any rows
        can_view_block = db.session.execute(select(subquery.exists())).scalar_one()

        if not can_view_block:
            flash("You do not have permission to view this student block.", "danger")
            return redirect(url_for('student_database_index'))

    # Fetch active students in the specified grade and section
    students_in_block_query = (
        select(User)
        .join(User.role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade == grade,
            User.section == section
        )
        .options(joinedload(User.role)) # Eager load role for student info
        .order_by(User.full_name.asc())
    )
    students = db.session.scalars(students_in_block_query).all()

    if not students:
        flash(f"No active students found for Grade {grade}, Section {section}. This block might be empty or incorrectly specified.", "info")
        # Still render the page to show the message, or redirect
        # return redirect(url_for('student_database_index')) 

    return render_template(
        "Database/students/student_block.html", # Correct template path
        students=students,
        grade=grade,
        section=section,
        title=f"Students: Grade {grade} - Section {section} - Nexus"
    )

@app.route("/database/export_block/<string:grade>/<string:section>")
@login_required
@role_required("hr_ceo", "system_admin")
def export_block(grade, section):
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade == grade,
            User.section == section
        )
        .order_by(User.username)
    ).all()

    if not students:
        flash(f"No students to export for Grade {grade}, Section {section}.", "warning")
        return redirect(request.referrer or url_for("student_database_block", grade=grade, section=section))

    output = io.StringIO()
    writer = csv.writer(output)

    # CSV Header (Matches User model attributes and template output)
    writer.writerow([
        "ID", "USERNAME", "FULL_NAME", "FIRST_NAME", "LAST_NAME", "EMAIL", "GRADE", "SECTION",
        "DATE_OF_BIRTH", "GENDER", "PHONE", "ADDRESS", "IS_ACTIVE", "CREATED_AT", "LAST_LOGIN",
        "IS_LEADER", "IS_TC_MEMBER" # Added these relevant flags
    ])

    for student in students:
        writer.writerow([
            student.id,
            student.username or "",
            student.full_name or "",
            student.first_name or "",
            student.last_name or "",
            student.email or "",
            student.grade or "",
            student.section or "",
            student.date_of_birth.strftime('%Y-%m-%d') if student.date_of_birth else "",
            student.gender or "", # This was student.gender in your User model from app.py
            student.phone or "",
            student.address or "",
            "True" if student.is_active else "False",
            student.created_at.strftime('%Y-%m-%d %H:%M:%S') if student.created_at else "",
            student.last_login.strftime('%Y-%m-%d %H:%M:%S') if student.last_login else "",
            "True" if student.is_leader else "False",
            "True" if student.is_tc_member else "False"
        ])

    csv_data = output.getvalue()
    response = make_response(csv_data)
    export_filename = f"students_{grade}_{section}_export_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.csv"
    response.headers["Content-Disposition"] = f"attachment; filename={export_filename}"
    response.headers["Content-Type"] = "text/csv"

    app.logger.info(f"User {current_user.username} exported student data for Grade {grade}, Section {section}.")
    return response
# --- Behavior Record Management (HR/CEO, System Admin, School Executive) ---
# manage_student_behavior and view_student_behavior routes are defined in Part 6/7

# In Part 7, replace the entire `view_student_behavior_records` route and its subsequent behavior record routes with the following:

# --- Student Behavior Records (Universal View, Refined Recording/Editing/Deletion) ---

@app.route("/student/<int:user_id>/behavior_records")
@login_required
# No role_required here; the internal can_view_behavior_records helper
# will handle granular access based on the 'all can view' rule.
def view_student_behavior_records(user_id):
    """
    Allows authorized users to view a student's behavior records.
    Permissions handled by the `can_view_behavior_records` helper.
    """
    student = db.session.get(User, user_id)
    if not student or not student.is_active or (student.role and student.role.name.lower() != 'student'):
        abort(404, description="Student not found or is inactive.")

    # Check permission using the helper function (all authenticated users can view)
    if not can_view_behavior_records(current_user, student):
        flash("You do not have permission to view these behavior records.", "danger")
        app.logger.warning(f"Unauthorized view of behavior records for student {user_id} by user {current_user.id}.")
        return redirect(url_for('role_redirect'))

    # Fetch behavior records for the student, newest first
    records = db.session.scalars(
        select(BehaviorRecord)
        .where(BehaviorRecord.student_id == user_id)
        .options(joinedload(BehaviorRecord.recorded_by)) # Eager load who recorded it
        .order_by(BehaviorRecord.date.desc(), BehaviorRecord.id.desc())
    ).all()

    # Determine if the current user can add a record for this student
    can_add_record = current_user.is_authenticated and \
                     current_user.role and \
                     current_user.role.name.lower() in [
                         "teacher", "librarian", "talent_club", "hr_ceo",
                         "system_admin", "school_executive", "government", "parent"
                     ]

    # These flags will be used in the template to conditionally show/hide buttons for each record
    # based on the fine-grained permissions.
    # Note: `can_edit_any_record` and `can_delete_any_record` are global role permissions for the current user.
    # `can_edit_this_record` and `can_delete_this_record` will be per-record in the template.
    can_edit_any_record = current_user.role and current_user.role.name.lower() in ['hr_ceo', 'system_admin', 'school_executive']
    can_delete_any_record = current_user.role and current_user.role.name.lower() in ['hr_ceo', 'system_admin', 'school_executive']

    return render_template(
        "behavior/view_student_records.html",
        student=student,
        records=records,
        can_add_record=can_add_record,
        can_edit_any_record=can_edit_any_record,   # For UI logic for top-level roles
        can_delete_any_record=can_delete_any_record, # For UI logic for top-level roles
        title=f"{student.full_name}'s Behavior Records"
    )

@app.route("/student/<int:student_id>/behavior_records/add", methods=["GET", "POST"])
@login_required
# Ensure all roles that can record behavior are listed. Parent was added.
@role_required(
    "teacher", "librarian", "talent_club", "hr_ceo",
    "system_admin", "school_executive", "government", "parent" 
)
def add_behavior_record(student_id):
    student = db.get_or_404(User, student_id, description="Student not found.")
    if not student.role or student.role.name.lower() != 'student':
        flash("Cannot add behavior record: Target user is not a student.", "warning")
        return redirect(request.referrer or url_for('student_database_index')) # Or appropriate redirect

    form = BehaviorRecordForm() # Your BehaviorRecordForm

    if form.validate_on_submit():
        try:
            new_record = BehaviorRecord(
                student_id=student.id,
                recorded_by_id=current_user.id, # The logged-in user is the recorder
                date=datetime.now(timezone.utc), # Or allow form to set date if needed
                behavior_type=form.behavior_type.data,
                description=form.description.data.strip(),
                severity=form.severity.data,
                resolution=form.resolution.data.strip() if form.resolution.data else None,
                is_resolved=form.is_resolved.data,
            )
            db.session.add(new_record)
            db.session.commit()

            # notify_student_and_parents helper (from app.py Part 3) should be called
            notify_student_and_parents(student, new_record)

            flash(f"Behavior record for {student.full_name or student.username} added successfully.", "success")
            app.logger.info(f"User {current_user.username} added behavior record ID {new_record.id} for student {student.id}.")
            return redirect(url_for("view_student_behavior_records", user_id=student.id))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error adding behavior record for student {student.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while adding the record. Please try again.", "danger")
            
    return render_template(
        "behavior/add_edit_record.html", # Your template for adding/editing
        form=form,
        student=student,
        is_edit=False, # Flag for template to know it's "Add" mode
        title=f"Add Behavior Record for {student.full_name or student.username} - Nexus"
    )

@app.route("/behavior_records/edit/<int:record_id>", methods=["GET", "POST"])
@login_required
# Roles that can potentially edit (permission check inside)
@role_required(
    "teacher", "librarian", "talent_club", "hr_ceo",
    "system_admin", "school_executive", "government", "parent"
)
def edit_behavior_record(record_id):
    record = db.get_or_404(BehaviorRecord, record_id, description="Behavior record not found.")
    student = record.student # Get student for context and redirection

    # --- Permission Check ---
    admin_editor_roles = ['hr_ceo', 'system_admin', 'school_executive'] # Roles that can edit ANY record
    is_global_admin_editor = current_user.role and current_user.role.name.lower() in admin_editor_roles
    is_original_recorder = (record.recorded_by_id == current_user.id)

    if not (is_global_admin_editor or is_original_recorder):
        flash("You do not have permission to edit this behavior record.", "danger")
        app.logger.warning(f"Unauthorized edit attempt on behavior record {record_id} by user {current_user.username}.")
        return redirect(url_for("view_student_behavior_records", user_id=student.id))

    form = BehaviorRecordForm(obj=record) # Populate form with existing data

    if form.validate_on_submit():
        try:
            record.behavior_type = form.behavior_type.data
            record.description = form.description.data.strip()
            record.severity = form.severity.data
            record.resolution = form.resolution.data.strip() if form.resolution.data else None
            record.is_resolved = form.is_resolved.data
            # record.date could be made editable too if needed, or keep original record date
            # record.updated_at = datetime.now(timezone.utc) # If you track updates

            db.session.commit()
            flash(f"Behavior record ID {record.id} updated successfully.", "success")
            app.logger.info(f"User {current_user.username} edited behavior record ID {record.id} for student {student.id}.")
            return redirect(url_for("view_student_behavior_records", user_id=student.id))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing behavior record ID {record.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
            
    return render_template(
        "behavior/add_edit_record.html",
        form=form,
        student=student,
        record=record, # Pass record for context if template needs its ID etc.
        is_edit=True,  # Flag for template
        title=f"Edit Behavior Record for {student.full_name or student.username} - Nexus"
    )

@app.route("/behavior_records/delete/<int:record_id>", methods=["POST"]) # Should strictly be POST
@login_required
@role_required(
    "teacher", "librarian", "talent_club", "hr_ceo",
    "system_admin", "school_executive", "government", "parent"
)
def delete_behavior_record(record_id):
    record = db.get_or_404(BehaviorRecord, record_id, description="Behavior record not found.")
    student_id_for_redirect = record.student_id # Store before potential deletion

    # --- Permission Check ---
    admin_deleter_roles = ['hr_ceo', 'system_admin', 'school_executive']
    is_global_admin_deleter = current_user.role and current_user.role.name.lower() in admin_deleter_roles
    is_original_recorder = (record.recorded_by_id == current_user.id)

    if not (is_global_admin_deleter or is_original_recorder):
        flash("You do not have permission to delete this behavior record.", "danger")
        app.logger.warning(f"Unauthorized delete attempt on behavior record {record_id} by user {current_user.username}.")
        return redirect(url_for("view_student_behavior_records", user_id=student_id_for_redirect))

    try:
        db.session.delete(record)
        db.session.commit()
        flash(f"Behavior record ID {record_id} deleted successfully.", "success")
        app.logger.info(f"User {current_user.username} deleted behavior record ID {record_id} for student {student_id_for_redirect}.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting behavior record ID {record_id} by {current_user.username}: {e}", exc_info=True)
        flash("An error occurred while deleting the record. Please try again.", "danger")
        
    return redirect(url_for("view_student_behavior_records", user_id=student_id_for_redirect))

# In PART 8 START: HR/CEO & System Admin Management Features

# Add a new asset
# Locate this existing route in PART 8
@app.route("/assets/add", methods=["GET", "POST"])
@login_required
# The role_required decorator handles the base roles.
# Specific leader checks are done inside the route.
@role_required("hr_ceo", "system_admin", "teacher", "librarian", "student", "talent_club")
def add_asset():
    form = AddAssetForm() # Your AddAssetForm definition
    current_user_role_name = current_user.role.name.lower()

    # --- Permission check for student/talent_club roles needing leader status ---
    if current_user_role_name == "student" and not current_user.is_leader:
        flash("Only student leaders can add assets.", "danger")
        abort(403)
    if current_user_role_name == "talent_club" and not current_user.is_tc_leader: # Assuming system-wide TC Leader
        flash("Only Talent Club leaders can add assets.", "danger")
        abort(403)

    if form.validate_on_submit():
        final_category_id = None
        final_lab_id = None
        location_desc_to_save = form.location_description.data.strip() if form.location_description.data else None

        try:
            # --- Role-based Auto-Assignment Logic ---
            # (This logic was detailed in your original app.py Part 8. Ensure it's correctly adapted here)
            if current_user_role_name == "student" and current_user.is_leader:
                if not current_user.grade or not current_user.section:
                    flash("Your student profile (grade/section) is incomplete. Cannot determine classroom for asset.", "danger")
                    return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus")
                
                classroom_name = f"Grade {current_user.grade} Section {current_user.section} Classroom"
                classroom_lab = db.session.scalar(select(Lab).filter_by(name=classroom_name))
                if not classroom_lab: # Create if not exists
                    classroom_lab = Lab(name=classroom_name)
                    db.session.add(classroom_lab)
                    db.session.flush() # Get ID
                final_lab_id = classroom_lab.id
                
                classroom_category = db.session.scalar(select(AssetCategory).filter_by(name="Classroom Assets"))
                if not classroom_category: # Create if not exists
                    classroom_category = AssetCategory(name="Classroom Assets", description="Assets primarily used in classrooms.")
                    db.session.add(classroom_category)
                    db.session.flush() # Get ID
                final_category_id = classroom_category.id
                location_desc_to_save = classroom_name # Override user input for student leader

            elif current_user_role_name == "teacher":
                final_lab_id = current_user.lab_id # Teacher's assigned lab by default
                if form.suggested_lab_id.data and form.suggested_lab_id.data != 0:
                    final_lab_id = form.suggested_lab_id.data
                
                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                else: # Default for teachers if not specified
                    lab_eq_cat = db.session.scalar(select(AssetCategory).filter_by(name="Lab Equipment"))
                    if lab_eq_cat: final_category_id = lab_eq_cat.id
                    else: # Fallback or error
                        flash("Default 'Lab Equipment' category not found. Please select a category or contact admin.", "warning")
                        # return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus") # Optionally halt

            elif current_user_role_name == "librarian":
                library_lab = db.session.scalar(select(Lab).filter_by(name="Main Library"))
                if not library_lab: # Create if not exists
                    library_lab = Lab(name="Main Library")
                    db.session.add(library_lab); db.session.flush()
                final_lab_id = library_lab.id
                location_desc_to_save = "Main Library"

                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                else: # Default for librarians
                    books_cat = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
                    if books_cat: final_category_id = books_cat.id
                    else: flash("Default 'Books' category not found.", "warning")

            elif current_user_role_name == "talent_club" and current_user.is_tc_leader:
                tc_hq_lab = db.session.scalar(select(Lab).filter_by(name="Talent Club HQ"))
                if not tc_hq_lab: # Create if not exists
                    tc_hq_lab = Lab(name="Talent Club HQ"); db.session.add(tc_hq_lab); db.session.flush()
                final_lab_id = tc_hq_lab.id
                location_desc_to_save = "Talent Club HQ"

                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                else: # Default for TC Leaders
                    tc_gear_cat = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
                    if tc_gear_cat: final_category_id = tc_gear_cat.id
                    else: flash("Default 'Talent Club Gear' category not found.", "warning")
            
            elif current_user_role_name in ["hr_ceo", "system_admin"]:
                # HR/Admin use the form's direct suggestion if provided, otherwise it can be None
                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                if form.suggested_lab_id.data and form.suggested_lab_id.data != 0:
                    final_lab_id = form.suggested_lab_id.data
            else: # Should not happen due to @role_required and leader checks
                flash("Unauthorized asset addition attempt.", "danger")
                abort(403)

            # --- Create Asset ---
            new_asset = Asset(
                name=form.name.data.strip(),
                description=form.description.data.strip() if form.description.data else None,
                quantity=form.quantity.data,
                purchase_cost=form.purchase_cost.data if form.purchase_cost.data is not None else None,
                condition=form.condition.data,
                is_consumable=form.is_consumable.data,
                expiry_date=form.expiry_date.data if form.is_consumable.data and form.expiry_date.data else None,
                last_maintenance_date=form.last_maintenance_date.data,
                added_by_user_id=current_user.id,
                category_id=final_category_id, # Can be None if not determined/selected
                lab_id=final_lab_id,           # Can be None
                location_description=location_desc_to_save,
                status="Pending Review" # All new assets start as pending
            )
            db.session.add(new_asset)
            db.session.commit()

            notify_hr_ceo_new_asset(new_asset) # Ensure this helper is correctly implemented

            flash(f"Asset '{new_asset.name}' added successfully and is now pending review.", "success")
            app.logger.info(f"User {current_user.username} added asset '{new_asset.name}' (ID: {new_asset.id}).")
            return redirect(url_for("my_assets"))

        except IntegrityError as e: # E.g. if asset name had a unique constraint
            db.session.rollback()
            app.logger.error(f"IntegrityError adding asset by {current_user.username}: {e}", exc_info=True)
            flash("Error: An asset with similar identifying information might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error adding asset by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while adding the asset. Please try again.", "danger")

    return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus")
# Add this new route in PART 8, near other asset management routes
@app.route("/assets/<int:asset_id>/delete", methods=["POST"])
@login_required
# Only HR/CEO, System Admin, and relevant leaders can delete assets
@role_required("hr_ceo", "system_admin", "student", "talent_club")
def delete_asset(asset_id):
    """Deletes an asset from the system."""
    asset = db.get_or_404(Asset, asset_id)

    current_user_role_name = current_user.role.name.lower()

    # --- Fine-grained permission check for deletion ---
    # HR/CEO and System Admin can delete any asset.
    is_global_admin = current_user_role_name in ["hr_ceo", "system_admin"]

    # Student leaders can only delete assets they added AND are in their designated classroom lab/category
    is_student_leader_authorized = (
        current_user_role_name == "student" and
        current_user.is_leader and
        asset.added_by_user_id == current_user.id and # Must be the one who added it
        asset.lab and current_user.grade and current_user.section and # Check if they have a lab and grade/section
        asset.lab.name == f"Grade {current_user.grade} Section {current_user.section} Classroom" # Must be in their classroom lab
    )

    # Talent Club leaders can only delete assets they added AND are in the Talent Club HQ lab/category
    is_tc_leader_authorized = (
        current_user_role_name == "talent_club" and
        current_user.is_tc_leader and
        asset.added_by_user_id == current_user.id and # Must be the one who added it
        asset.lab and asset.lab.name == "Talent Club HQ" # Must be in the Talent Club HQ lab
    )

    # Teachers and Librarians are NOT granted deletion permission here.
    # This aligns with the "only leaders can add/delete" for student/TC,
    # while teachers/librarians can add but not delete (HR/CEO handles deletion for them).

    if not (is_global_admin or is_student_leader_authorized or is_tc_leader_authorized):
        flash("You do not have permission to delete this asset.", "danger")
        app.logger.warning(
            f"Unauthorized delete attempt: User {current_user.username} (ID: {current_user.id}, Role: {current_user_role_name}, Leader: {current_user.is_leader}, TC Leader: {current_user.is_tc_leader}) "
            f"tried to delete asset ID {asset.id} (Added by: {asset.added_by_user_id}, Lab: {asset.lab.name if asset.lab else 'N/A'})."
        )
        abort(403)

    try:
        db.session.delete(asset)
        db.session.commit()
        flash(f"Asset '{asset.name}' deleted successfully.", "success")
        app.logger.info(f"User {current_user.username} (ID: {current_user.id}) deleted asset '{asset.name}' (ID: {asset.id}).")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting asset ID {asset.id} by {current_user.username} (ID: {current_user.id}): {e}", exc_info=True)
        flash("An error occurred while deleting the asset. Please try again.", "danger")

    # Redirect to appropriate asset list
    return redirect(url_for("my_assets")) # Or list_all_assets

# Add this new route, potentially in PART 8 or a new "Asset Views" section
@app.route("/assets/all")
@login_required # All authenticated users can view this
def list_all_assets():
    """Displays a list of all assets visible to the current user, with basic filtering."""
    # Query for all active assets
    # We can add filters based on query parameters (e.g., category, status, lab)
    # For universal view, let's include assets that are "available", "pending review", "under maintenance"
    # but exclude "retired", "lost". HR/CEO can see all.

    # Fetch basic filter parameters from the request query string
    category_filter = request.args.get('category', 'all').strip()
    status_filter = request.args.get('status', 'available_active').strip() # New status filter options
    lab_filter = request.args.get('lab', 'all').strip()
    search_query = request.args.get('search', '').strip()
    page = request.args.get('page', 1, type=int)
    per_page = 20 # Number of assets per page

    assets_query = select(Asset).options(
        joinedload(Asset.category), # Eager load category
        joinedload(Asset.lab),     # Eager load lab
        joinedload(Asset.added_by_user) # Eager load who added it
    )

    # Apply role-based visibility to the query (HR/CEO sees everything)
    if current_user.role.name.lower() not in ['hr_ceo', 'system_admin']:
        # Non-HR/CEO/System Admin users might only see 'Available', 'Under Maintenance', 'Needs Repair' etc.
        # but not 'Pending Review' (unless they added it) or 'Retired', 'Lost' unless they have specific permission.
        # For simplicity, let's define what IS generally visible.
        assets_query = assets_query.where(
            Asset.status.in_(['Available', 'Under Maintenance', 'Needs Repair', 'CheckedOut'])
            # Optionally: only show assets they have a direct connection to, e.g. for student leaders, only assets in their classroom
            # For this route, the requirement is "every one can view".
            # The `my_assets` route (if you implement it specifically for different roles) would be for personalized views.
        )
    else: # HR/CEO, System Admin
        # They see all assets, including 'Pending Review', 'Retired', 'Lost'
        pass


    # Apply Category Filter
    if category_filter != 'all':
        category_obj = db.session.scalar(select(AssetCategory).filter_by(name=category_filter))
        if category_obj:
            assets_query = assets_query.where(Asset.category_id == category_obj.id)
        else:
            flash(f"Invalid category filter: {category_filter}", "warning")
            category_filter = 'all' # Reset to all


    # Apply Status Filter
    if status_filter == 'available_active':
        # Assets that are available for use or actively in use/maintenance
        assets_query = assets_query.where(
            Asset.status.in_(['Available', 'CheckedOut', 'Under Maintenance', 'Needs Repair'])
        )
    elif status_filter == 'pending_review':
        assets_query = assets_query.where(Asset.status == 'Pending Review')
    elif status_filter == 'retired_lost':
        assets_query = assets_query.where(Asset.status.in_(['Retired', 'Lost']))
    # 'all' status filter is covered by the base query (or hr_ceo/system_admin above)

    # Apply Lab Filter
    if lab_filter != 'all':
        lab_obj = db.session.scalar(select(Lab).filter_by(name=lab_filter))
        if lab_obj:
            assets_query = assets_query.where(Asset.lab_id == lab_obj.id)
        else:
            flash(f"Invalid lab filter: {lab_filter}", "warning")
            lab_filter = 'all' # Reset to all

    # Apply Search Query
    if search_query:
        assets_query = assets_query.where(
            or_(
                Asset.name.ilike(f'%{search_query}%'),
                Asset.description.ilike(f'%{search_query}%'),
                Asset.location_description.ilike(f'%{search_query}%')
            )
        )

    # Order assets for display
    assets_query = assets_query.order_by(Asset.name.asc())

    # Paginate the results
    paginated_assets = db.paginate(assets_query, page=page, per_page=per_page, error_out=False)

    # Get all categories and labs for filter dropdowns
    all_categories = db.session.scalars(select(AssetCategory).order_by(AssetCategory.name)).all()
    all_labs = db.session.scalars(select(Lab).order_by(Lab.name)).all()


    return render_template("assets/all_assets.html",
                           paginated_assets=paginated_assets,
                           all_categories=all_categories,
                           all_labs=all_labs,
                           category_filter=category_filter,
                           status_filter=status_filter,
                           lab_filter=lab_filter,
                           search_query=search_query,
                           title="All School Assets")

# Example my_assets (if you have one, modify it like this)
@app.route("/my_assets")
@login_required
def my_assets():
    """Displays assets added by the current user."""
    user_added_assets = db.session.scalars(
        select(Asset)
        .where(Asset.added_by_user_id == current_user.id)
        .order_by(Asset.name.asc())
    ).all()
    # You might also want to show books checked out, etc., here depending on role.
    return render_template("assets/my_assets.html", assets=user_added_assets, title="My Added Assets")

# Route for reporting an issue for a specific asset (clicking  next to a listed asset)
@app.route("/asset/<int:asset_id>/report", methods=["GET", "POST"])
@login_required
# Roles who can report on a specific asset (assuming they can view it)
@role_required("hr_ceo", "system_admin", "teacher", "librarian", "talent_club", "student")
def report_asset_specific(asset_id):
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")
    form = ReportAssetForm() # Your ReportAssetForm definition

    if form.validate_on_submit():
        try:
            new_report = AssetReport(
                asset_id=asset.id, # Link to the specific asset
                reported_by_id=current_user.id,
                damage_description=form.damage_description.data.strip(),
                date_of_damage=form.date_of_damage.data, # WTForms converts to date object or None
                quantity_damaged=form.quantity_damaged.data,
                status="Pending", # New reports default to Pending
                report_date=datetime.now(timezone.utc)
            )
            db.session.add(new_report)
            db.session.commit() # Commit to get report ID for notification

            notify_hr_ceo_new_report(new_report) # Ensure this helper is correctly implemented

            flash(f"Issue reported successfully for asset '{asset.name}'. An administrator will review it.", "success")
            app.logger.info(f"User {current_user.username} reported issue for asset ID {asset.id} (Report ID: {new_report.id}).")
            
            # Redirect back to where they came from, or a sensible default
            # If they came from all_assets or my_assets, request.referrer would be good.
            # If direct link, maybe redirect to asset detail or user's dashboard.
            return redirect(request.referrer or url_for('list_all_assets'))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error submitting specific asset report for asset ID {asset.id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while submitting the report. Please try again.", "danger")
            # Re-render the form with errors, form data is preserved by WTForms
            
    # For GET request or if form validation failed on POST
    return render_template("assets/report_asset_specific.html", 
                           form=form, 
                           asset=asset, 
                           title=f"Report Issue for: {asset.name} - Nexus")
# Route for a general asset report (clicking  next to 'Add Assets')
# This route handles reports that are not initially linked to a specific asset ID.
@app.route("/report/general", methods=["GET", "POST"])
@login_required
# Roles who can submit a general report
@role_required("hr_ceo", "system_admin", "teacher", "librarian", "talent_club", "student")
def report_asset_general():
    form = ReportAssetForm() # Your ReportAssetForm definition

    if form.validate_on_submit():
        try:
            # Get the user-provided asset description if they filled it in the template
            user_provided_asset_name_desc = request.form.get('asset_name_description', '').strip()
            
            full_damage_description = form.damage_description.data.strip()
            if user_provided_asset_name_desc:
                # Prepend it to the main damage description for context
                full_damage_description = f"Reported Item (User Described): {user_provided_asset_name_desc}\n\nIssue Details:\n{full_damage_description}"

            new_report = AssetReport(
                asset_id=None, # General report, not linked to a specific asset initially
                reported_by_id=current_user.id,
                damage_description=full_damage_description, # Save combined description
                date_of_damage=form.date_of_damage.data,
                quantity_damaged=form.quantity_damaged.data,
                status="Pending",
                report_date=datetime.now(timezone.utc)
            )
            db.session.add(new_report)
            db.session.commit()

            notify_hr_ceo_new_report(new_report) # Ensure this helper is correctly implemented

            flash("General issue report submitted successfully. An administrator will review it.", "success")
            app.logger.info(f"User {current_user.username} submitted a general asset report (Report ID: {new_report.id}).")
            
            # Redirect to a relevant page, e.g., user's dashboard or a "my reports" page if it exists
            return redirect(url_for(f"{current_user.role.name.lower()}_dashboard"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error submitting general asset report by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while submitting the general report. Please try again.", "danger")
            # Re-render form with errors

    # For GET request or if form validation failed on POST
    return render_template("assets/report_asset_general.html", 
                           form=form, 
                           title="Report General Asset Issue - Nexus")

# --- HR/CEO Specific Asset Management Routes ---

# List assets pending review (for HR/CEO & System Admin)
@app.route("/hr_ceo/assets/pending")
@login_required
@role_required("hr_ceo", "system_admin")
def list_pending_assets():
    pending_assets = db.session.scalars(
        select(Asset)
        .options(
            joinedload(Asset.added_by_user).joinedload(User.role), # Load user and their role
            joinedload(Asset.category), 
            joinedload(Asset.lab)
        )
        .where(Asset.status == "Pending Review")
        .order_by(Asset.created_at.asc()) # Show oldest pending first
    ).all()

    return render_template("hr_ceo/pending_assets.html",
                           pending_assets=pending_assets,
                           title="Assets Pending Review - Nexus")
# Edit/Review a specific asset (for HR/CEO & System Admin)
@app.route("/assets/<int:asset_id>/edit", methods=["GET", "POST"]) # Ensure path is correct
@login_required
@role_required("hr_ceo", "system_admin") # Only these roles can edit full asset details
def edit_asset(asset_id):
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")
    # EditAssetForm is defined in your app.py or forms.py
    form = EditAssetForm(obj=asset) # Pre-populate form with existing asset data on GET

    if form.validate_on_submit():
        try:
            old_status = asset.status # Store old status for notification logic

            # Update asset fields from form data
            asset.name = form.name.data.strip()
            asset.description = form.description.data.strip() if form.description.data else None
            asset.quantity = form.quantity.data
            asset.purchase_cost = form.purchase_cost.data if form.purchase_cost.data is not None else None
            
            # Ensure category_id is handled correctly (it's required in the form)
            if form.category_id.data and form.category_id.data != 0: # Assuming 0 might be a "no selection" placeholder if form allows
                asset.category_id = form.category_id.data
            else: # This case should ideally be caught by form.category_id.validators=[DataRequired()]
                flash("Asset category is required.", "danger")
                return render_template("assets/edit_asset.html", form=form, asset=asset, title=f"Edit Asset: {asset.name} - Nexus")

            asset.status = form.status.data
            asset.condition = form.condition.data
            asset.is_consumable = form.is_consumable.data
            
            if asset.is_consumable and form.expiry_date.data:
                asset.expiry_date = form.expiry_date.data
            elif not asset.is_consumable:
                asset.expiry_date = None # Clear expiry if not consumable

            asset.last_maintenance_date = form.last_maintenance_date.data
            
            asset.lab_id = form.lab_id.data if form.lab_id.data and form.lab_id.data != 0 else None
            asset.location_description = form.location_description.data.strip() if form.location_description.data else None
            
            # Asset.updated_at should be handled by onupdate in the model if defined,
            # otherwise, set it manually:
            # asset.last_updated_at = datetime.now(timezone.utc)


            db.session.commit()

            # Notification logic: Notify original adder if status changed from "Pending Review"
            if old_status == "Pending Review" and asset.status != "Pending Review" and asset.added_by_user:
                if asset.added_by_user.is_active:
                    try:
                        message_content = f"Your submitted asset '{asset.name}' (ID: {asset.id}) has been reviewed. New status: '{asset.status}'."
                        # Link to a viewable page for the user, not necessarily the edit page
                        link_url = url_for('my_assets', _external=True) # Or a specific asset view if available for them
                        
                        # Ensure is_notification_allowed is checked
                        if is_notification_allowed(current_user, asset.added_by_user):
                            notification = Notification(
                                sender_id=current_user.id,
                                receiver_id=asset.added_by_user_id,
                                content=message_content,
                                link_url=link_url,
                                timestamp=datetime.now(timezone.utc),
                                notification_type='asset_status_change' # Add a specific type
                            )
                            db.session.add(notification)
                            db.session.commit() # Commit notification separately
                            app.logger.info(f"Notified user {asset.added_by_user_id} about asset {asset.id} status change to '{asset.status}'.")
                    except Exception as notify_e:
                        db.session.rollback() # Rollback only notification part
                        app.logger.error(f"Error sending asset status change notification to {asset.added_by_user_id}: {notify_e}", exc_info=True)
            
            flash(f"Asset '{asset.name}' updated successfully. Status is now '{asset.status}'.", "success")
            app.logger.info(f"User {current_user.username} edited asset ID {asset.id}.")

            if asset.status == "Pending Review":
                return redirect(url_for("list_pending_assets"))
            else:
                return redirect(url_for("list_all_assets")) # Or back to where they came from

        except IntegrityError:
            db.session.rollback()
            flash("Error: Could not update asset. A similar asset might already exist or there was a data conflict.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing asset ID {asset.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the asset. Please try again.", "danger")

    return render_template("assets/edit_asset.html", 
                           form=form, 
                           asset=asset, 
                           title=f"Edit Asset: {asset.name} - Nexus")

# List all asset reports (for HR/CEO & System Admin)
@app.route("/hr_ceo/reports")
@login_required
@role_required("hr_ceo", "system_admin")
def list_asset_reports():
    # Add pagination and filtering later if needed
    reports_query = (
        select(AssetReport)
        .options(
            joinedload(AssetReport.asset).joinedload(Asset.category), # Load asset and its category
            joinedload(AssetReport.reporter).joinedload(User.role),   # Load reporter and their role
            joinedload(AssetReport.resolver).joinedload(User.role)    # Load resolver and their role
        )
        .order_by(
            # Custom order for status: Pending, In Progress, then others, then Resolved/Rejected
            case(
                (AssetReport.status == 'Pending', 1),
                (AssetReport.status == 'In Progress', 2),
                (AssetReport.status == 'Resolved', 4),
                (AssetReport.status == 'Rejected', 5),
                else_=3
            ).asc(),
            AssetReport.report_date.desc()
        )
    )
    reports = db.session.scalars(reports_query).all()

    return render_template("hr_ceo/list_reports.html",
                           reports=reports,
                           title="All Asset Reports - Nexus")
@app.route("/hr_ceo/report/<int:report_id>/resolve", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def resolve_asset_report(report_id):
    report = db.get_or_404(AssetReport, report_id, description="Asset report not found.")
    # Ensure related asset, reporter, resolver are loaded for display in template if needed
    # The query in list_asset_reports already does this, but direct access might not.
    # For simplicity, assume they are accessible via report.asset, report.reporter etc.
    # Or load them explicitly:
    # report = db.session.query(AssetReport).options(joinedload...)...get()

    form = ResolveReportForm(obj=report) # Pre-populate with existing data

    # Logic for potentially linking a general report to an asset (if form.link_to_asset_id exists)
    # This was commented out in the template; if implementing, handle it here.
    # if not report.asset_id and hasattr(form, 'link_to_asset_id'):
    #     # Populate choices for form.link_to_asset_id
    #     form.link_to_asset_id.choices = [(0, '--- Select Asset to Link (Optional) ---')] + \
    #                                     [(a.id, f"{a.name} (ID: {a.id})") for a in db.session.scalars(select(Asset).order_by(Asset.name)).all()]


    if form.validate_on_submit():
        try:
            old_status = report.status

            report.status = form.status.data
            report.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None

            # Handle asset linking for general reports if implemented
            # if not report.asset_id and hasattr(form, 'link_to_asset_id') and form.link_to_asset_id.data and form.link_to_asset_id.data != 0:
            #    report.asset_id = form.link_to_asset_id.data

            if report.status in ["Resolved", "Rejected"] and old_status not in ["Resolved", "Rejected"]:
                report.resolved_by_id = current_user.id
                report.resolved_date = datetime.now(timezone.utc)
            elif report.status not in ["Resolved", "Rejected"] and old_status in ["Resolved", "Rejected"]:
                report.resolved_by_id = None
                report.resolved_date = None
            
            # Update related asset's status/condition if report is "Resolved"
            if report.asset and report.status == "Resolved" and old_status != "Resolved":
                asset_to_update = report.asset
                if asset_to_update.status in ["Needs Repair", "Under Maintenance", "Lost"]: # Or other problematic statuses
                    asset_to_update.status = "Available"
                    # Optionally, update condition if relevant
                    if asset_to_update.condition in ["Poor", "Needs Repair", "Broken"]:
                        asset_to_update.condition = "Good" # Or "Fair"
                app.logger.info(f"Asset ID {asset_to_update.id} status/condition updated due to resolved report {report.id}.")

            db.session.commit()

            notify_reporter_report_update(report) # Ensure this helper is correctly implemented

            flash(f"Report ID {report.id} status updated to '{report.status}'.", "success")
            app.logger.info(f"User {current_user.username} updated report ID {report.id} to status '{report.status}'.")
            return redirect(url_for("list_asset_reports"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error resolving report ID {report.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the report. Please try again.", "danger")

    # For GET, pass the report (and its asset) and form to the template
    return render_template("hr_ceo/resolve_report.html", 
                           form=form, 
                           report=report, 
                           asset=report.asset, # Pass asset explicitly if needed by template beyond report.asset
                           title=f"Resolve Report ID: {report.id} - Nexus")
# Route for HR/CEO to manage asset categories (list, add form)
@app.route("/hr_ceo/asset_categories")
@login_required
@role_required("hr_ceo", "system_admin")
def manage_asset_categories():
    # Fetch all asset categories, ordered by name
    # Eager load assets count if your model has a direct count or efficient way
    # For simplicity, template uses category.assets.count() which might do N+1 if not careful.
    # Consider adding a count property or subquery if performance becomes an issue for many categories.
    categories = db.session.scalars(
        select(AssetCategory).order_by(AssetCategory.name.asc())
        # .options(selectinload(AssetCategory.assets)) # If you want to iterate assets in template for count, but .count() is usually better
    ).all()
    
    add_form = AddCategoryForm() # Your AddCategoryForm definition

    return render_template("hr_ceo/manage_categories.html",
                           categories=categories,
                           add_form=add_form, # Pass the form for adding new categories
                           title="Manage Asset Categories - Nexus")
# Add new category (POST only)
@app.route("/hr_ceo/asset_categories/add", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def add_asset_category():
    # This route now primarily handles the POST from the manage_asset_categories page's form
    add_form = AddCategoryForm() # Instantiate the form to validate against
    
    if add_form.validate_on_submit():
        try:
            new_category_name = add_form.name.data.strip()
            # Check for existing category with the same name (case-insensitive)
            existing_category = db.session.scalar(
                select(AssetCategory).filter(func.lower(AssetCategory.name) == func.lower(new_category_name))
            )
            if existing_category:
                flash(f"Asset category '{new_category_name}' already exists.", "danger")
            else:
                new_category = AssetCategory(
                    name=new_category_name,
                    description=add_form.description.data.strip() if add_form.description.data else None
                )
                db.session.add(new_category)
                db.session.commit()
                flash(f"Asset category '{new_category.name}' added successfully.", "success")
                app.logger.info(f"User {current_user.username} added asset category '{new_category.name}'.")
        except IntegrityError: # Should be caught by the name check above, but as a fallback
            db.session.rollback()
            flash("Asset category with this name already exists or another database error occurred.", "danger")
            app.logger.warning(f"IntegrityError while adding asset category: {add_form.name.data} by {current_user.username}.")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error adding asset category by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while adding the category. Please try again.", "danger")
    else:
        # If form validation fails (e.g., name is empty)
        for field, errors in add_form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(add_form, field).label.text}: {error}", "danger")
                
    return redirect(url_for("manage_asset_categories")) # Always redirect back
# Edit category (GET and POST)
@app.route("/hr_ceo/asset_category/<int:category_id>/edit", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def edit_asset_category(category_id):
    category = db.get_or_404(AssetCategory, category_id, description="Asset category not found.")
    # EditCategoryForm is defined in your app.py or forms.py
    form = EditCategoryForm(obj=category) # Pre-populate with existing data on GET

    if form.validate_on_submit():
        try:
            new_name = form.name.data.strip()
            # Check if new name conflicts with another existing category (case-insensitive)
            existing_category_with_new_name = db.session.scalar(
                select(AssetCategory).filter(
                    AssetCategory.id != category.id, # Exclude the current category being edited
                    func.lower(AssetCategory.name) == func.lower(new_name)
                )
            )
            if existing_category_with_new_name:
                flash(f"Another asset category named '{new_name}' already exists.", "danger")
            else:
                category.name = new_name
                category.description = form.description.data.strip() if form.description.data else None
                # category.updated_at = datetime.now(timezone.utc) # If you have an updated_at field
                db.session.commit()
                flash(f"Asset category '{category.name}' updated successfully.", "success")
                app.logger.info(f"User {current_user.username} edited asset category ID {category.id} to '{category.name}'.")
                return redirect(url_for("manage_asset_categories"))
        except IntegrityError: # Fallback, should be caught by name check
            db.session.rollback()
            flash(f"Update failed. A category named '{form.name.data.strip()}' might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing asset category ID {category_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while updating the category. Please try again.", "danger")
            
    # For GET request or if form validation failed on POST
    return render_template("hr_ceo/edit_category.html", 
                           form=form, 
                           category=category, 
                           title=f"Edit Category: {category.name} - Nexus")
# Delete category (POST only, with safety checks)
@app.route("/hr_ceo/asset_category/<int:category_id>/delete", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def delete_asset_category(category_id):
    category = db.get_or_404(AssetCategory, category_id, description="Asset category not found.")

    # Check dependencies: assets and channels
    # Assuming 'assets' and 'channels' are the correct relationship names on AssetCategory model
    asset_count = category.assets.count() if hasattr(category, 'assets') else \
                  db.session.scalar(select(func.count(Asset.id)).where(Asset.category_id == category.id)) or 0
    
    # The original SocialCategory model (and its relationship to Channel) was used for channels
    # If AssetCategory is also used by Channel (which it was in some of your model snippets), check that too.
    # Based on frontend, AssetCategory does not link to Channel, but SocialCategory does.
    # Let's assume AssetCategory ONLY links to Asset for this check.
    # If Channel can also link to AssetCategory, this check needs to be updated:
    # channel_count = category.channels.count() if hasattr(category, 'channels') else \
    #                 db.session.scalar(select(func.count(Channel.id)).where(Channel.category_id == category.id)) or 0
    # For now, assuming channels use SocialCategory, not AssetCategory.

    if asset_count > 0:
        flash(f"Cannot delete category '{category.name}' because {asset_count} asset(s) are still assigned to it. Please reassign them first.", "danger")
        app.logger.warning(f"Attempted to delete asset category ID {category_id} ('{category.name}') with {asset_count} linked assets.")
    # elif channel_count > 0: # If channels could use AssetCategory
    #     flash(f"Cannot delete category '{category.name}' because {channel_count} social channel(s) are still using it.", "danger")
    else:
        try:
            db.session.delete(category)
            db.session.commit()
            flash(f"Asset category '{category.name}' deleted successfully.", "success")
            app.logger.info(f"User {current_user.username} deleted asset category ID {category.id} ('{category.name}').")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error deleting asset category ID {category_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while deleting the category. Please try again.", "danger")

    return redirect(url_for("manage_asset_categories"))


# --- HR Student Leader Management ---
@app.route("/hr_ceo/manage_student_leaders", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin") # Allow System Admin
def manage_student_leaders():
    """Displays student leaders and allows assigning students to leaders or toggling leader status."""

    # This part handles the POST request for assigning students to a leader.
    # We instantiate the form here for both GET/POST, ensuring it's available for re-rendering on POST failure.
    # The current_leaders argument will be populated for the GET request logic later.
    form = AssignLeaderForm()

    if form.validate_on_submit(): # If the 'Assign Students' form was submitted and valid
        selected_leader_id = form.leader.data
        selected_leader = db.session.get(User, selected_leader_id)

        # Basic validation for the selected leader from the dropdown
        if (
            not selected_leader
            or not selected_leader.is_leader # Must be marked as a leader to be assigned followers
            or selected_leader.role.name.lower() != "student"
            or not selected_leader.is_active
        ):
            flash(
                "Invalid leader selected for assignment. Please select an active student leader.",
                "danger",
            )
        # Ensure the selected leader has a grade and section, which is crucial for section leadership
        elif not selected_leader.grade or not selected_leader.section:
             flash(f"The selected leader ({selected_leader.full_name or selected_leader.username}) does not have a grade or section assigned and cannot be used to lead a section.", "danger")
        else:
            # Get the list of student IDs from the checkboxes submitted in the template
            # Assumes checkbox names are "students_to_assign" and values are student.id
            selected_student_ids_str = request.form.getlist("students_to_assign")
            selected_student_ids = [int(sid) for sid in selected_student_ids_str if sid.isdigit()]

            if not selected_student_ids:
                flash("No students selected to assign to the leader.", "warning")
            else:
                assigned_count = 0
                skipped_count = 0
                try:
                    # Fetch the students who were selected to be assigned, ensuring they are active students
                    students_to_update_stmt = (
                        select(User)
                        .join(Role)
                        .where(
                            User.id.in_(selected_student_ids),
                            Role.name == "student",
                            User.is_active == True
                        )
                    )
                    students_to_update = db.session.scalars(students_to_update_stmt).all()

                    for student in students_to_update:
                        # Crucial check: Only assign students if they are in the *same* grade and section as the leader
                        if (student.id != selected_leader.id and # Cannot assign the leader to follow themselves
                            student.grade == selected_leader.grade and
                            student.section == selected_leader.section):
                            student.leader_id = selected_leader.id # Update the student's leader_id
                            assigned_count += 1
                        else:
                            skipped_count += 1
                            if student.id == selected_leader.id:
                                flash(f"Skipped {student.full_name or student.username}: Cannot assign a leader to follow themselves.", "warning")
                            elif student.grade != selected_leader.grade or student.section != selected_leader.section:
                                flash(f"Skipped {student.full_name or student.username}: Student is in a different grade/section ({student.grade}-{student.section}) than the selected leader ({selected_leader.grade}-{selected_leader.section}).", "warning")


                    if assigned_count > 0:
                        db.session.commit() # Commit the updates
                        flash(
                            f"{assigned_count} student(s) successfully assigned to leader {selected_leader.full_name or selected_leader.username}.",
                            "success",
                        )
                        app.logger.info(
                            f"{assigned_count} students assigned to leader {selected_leader.username} by {current_user.username}"
                        )
                    if skipped_count > 0:
                        # Only show this general message if specific ones were shown above
                        flash(
                            f"{skipped_count} student(s) were skipped (check messages above for reasons).",
                            "info",
                        )

                    # Redirect back to the manage leaders page to see updated assignments
                    return redirect(url_for("manage_student_leaders"))
                except Exception as e:
                    db.session.rollback() # Rollback if any database operation failed
                    app.logger.error(
                        f"Error assigning students to leader {selected_leader.username}: {e}", exc_info=True
                    )
                    flash("An unexpected error occurred while assigning students. Please try again.", "danger")

    # --- Handle GET request or failed POST (if POST failed, form will retain data) ---
    # Fetch all active students with their grade/section, ordered for display
    # Eager load their leader if available (the User object pointed to by leader_id)
    all_students_stmt = (
        select(User)
        .join(Role)
        .where(Role.name == "student", User.is_active == True)
        .options(joinedload(User.leader)) # Eager load the leader object for each student
        .order_by(User.grade, User.section, User.full_name) # Sort for logical grouping
    )
    all_students = db.session.scalars(all_students_stmt).all()

    # Students currently marked as leaders (is_leader=True) and have grade/section defined
    current_leaders = [s for s in all_students if s.is_leader and s.grade and s.section]

    # Re-instantiate form here to ensure choices are fresh for GET request, or on POST re-render.
    # This must be done *after* `current_leaders` is determined.
    form = AssignLeaderForm(current_leaders=current_leaders) # Populate dropdown for leader assignment

    # Group students by grade and section for easier display in the template
    # `defaultdict` is perfect for this, default value is a dictionary with three lists/slots
    students_by_grade_section = defaultdict(lambda: {'leader': None, 'unassigned_students': [], 'followers': []})

    for s in all_students:
        # Create a tuple key for grade and section, handling cases where they might be None
        key = (s.grade or "N/A_Grade", s.section or "N/A_Section")

        if s.is_leader:
            # This student is a designated leader for their section
            students_by_grade_section[key]['leader'] = s
            # A leader's own leader_id should logically be None. If not, it's a data anomaly.
            if s.leader_id is not None:
                app.logger.warning(f"Leader {s.username} (G:{s.grade}, S:{s.section}) has a non-None leader_id ({s.leader_id}). This should be cleared for data consistency, but the system continues.")
        else:
            # This student is not a leader themselves
            # Check if their `leader_id` points to the designated leader for their section
            current_section_leader = students_by_grade_section[key]['leader'] # Already populated if leader was processed

            if current_section_leader and s.leader_id == current_section_leader.id:
                # Student is correctly assigned to the leader of their section
                students_by_grade_section[key]['followers'].append(s)
            else:
                # Student is not a leader, and is either unassigned or assigned to an incorrect/non-existent leader
                students_by_grade_section[key]['unassigned_students'].append(s)

    # Sort the top-level keys (grade-section tuples)
    sorted_grade_section_keys = sorted(students_by_grade_section.keys())
    
    # Create a new ordered dictionary to store the sorted data, with inner lists also sorted
    sorted_students_by_grade_section = {}
    for key in sorted_grade_section_keys:
        block_data = students_by_grade_section[key]
        # Sort unassigned students alphabetically by full name
        block_data['unassigned_students'] = sorted(block_data['unassigned_students'], key=lambda stu: stu.full_name or stu.username)
        # Sort followers alphabetically by full name
        block_data['followers'] = sorted(block_data['followers'], key=lambda stu: stu.full_name or stu.username)
        sorted_students_by_grade_section[key] = block_data


    return render_template(
        "hr_ceo/student_leaders.html",
        form=form, # Pass the AssignLeader form (used for the leader dropdown and its POST validation)
        students_by_grade_section=sorted_students_by_grade_section, # Grouped students for display and checkboxes
        current_leaders=current_leaders, # Still useful for a quick list of leaders (e.g., in a sidebar)
        title="Manage Student Leaders & Assignments",
    )

# Route to toggle the is_leader status of a single student (POST only)
@app.route("/hr_ceo/toggle_leader_status/<int:student_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin") # Allow System Admin
def toggle_student_leader_status(student_id):
    """Toggles the 'is_leader' status for a specific student, enforcing one leader per grade-section."""
    student = db.session.get(User, student_id)

    # Validate that the user exists, is a student, and is active
    if not student or student.role.name.lower() != "student" or not student.is_active:
        flash("User not found, is not a student, or is inactive.", "danger")
        return redirect(request.referrer or url_for("manage_student_leaders"))

    # Ensure the student has a grade and section assigned
    if not student.grade or not student.section:
        flash(f"Student {student.full_name or student.username} must have a grade and section assigned before being promoted/demoted as a section leader.", "danger")
        return redirect(request.referrer or url_for("manage_student_leaders"))

    try:
        action_message = ""
        if student.is_leader:
            # --- Demoting a leader ---
            student.is_leader = False
            # Also, unset the `leader_id` for any students who were following this demoted leader
            # This ensures orphaned leader_ids are cleared.
            db.session.query(User).filter(User.leader_id == student.id).update({User.leader_id: None}, synchronize_session=False)

            action_message = f"{student.full_name or student.username} is no longer the leader for Grade {student.grade}, Section {student.section}."
            app.logger.info(
                f"HR/CEO {current_user.username} (ID: {current_user.id}) demoted student {student.username} (ID: {student.id}) from leader status for G:{student.grade} S:{student.section}."
            )
        else:
            # --- Promoting a leader ---
            # Check if there's already a leader for this student's grade and section
            existing_leader = db.session.scalar(
                select(User)
                .where(
                    User.grade == student.grade,
                    User.section == student.section,
                    User.is_leader == True, # Look for an existing leader flag
                    User.id != student.id, # Exclude the current student in case of self-promotion scenario
                    User.is_active == True # Only active leaders
                )
                .join(Role).filter(Role.name == 'student') # Ensure it's a student leader
            )

            if existing_leader:
                flash(f"A leader ({existing_leader.full_name or existing_leader.username}) already exists for Grade {student.grade}, Section {student.section}. Please demote them first.", "danger")
                return redirect(request.referrer or url_for("manage_student_leaders"))

            # No existing leader found for this section, proceed with promotion
            student.is_leader = True
            student.leader_id = None # A leader does not follow anyone

            action_message = f"{student.full_name or student.username} is now the leader for Grade {student.grade}, Section {student.section}."
            app.logger.info(
                f"HR/CEO {current_user.username} (ID: {current_user.id}) promoted student {student.username} (ID: {student.id}) to leader status for G:{student.grade} S:{student.section}."
            )

            # Assign this new leader to ALL other active students in the same grade and section
            # Exclude the new leader themselves.
            db.session.query(User).filter(
                User.grade == student.grade,
                User.section == student.section,
                User.id != student.id, # Exclude the new leader
                User.is_active == True,
                User.role_id == student.role_id # Ensure they are students
            ).update({User.leader_id: student.id}, synchronize_session=False)

        db.session.commit() # Commit the change to the student's is_leader status and potentially followers' leader_id
        flash(action_message, "success")

    except Exception as e:
        db.session.rollback() # Rollback on error
        app.logger.error(
            f"Error toggling leader status for student {student_id} ({student.username}) by {current_user.username}: {e}", exc_info=True
        )
        flash(
            "An error occurred while updating leader status. Please try again.",
            "danger",
        )

    # Redirect back to the manage leaders page
    return redirect(request.referrer or url_for("manage_student_leaders"))
# --- PART 8 END: HR/CEO & System Admin Management Features ---

# --- PART 9 START: Book Checkout & Management ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Asset, AssetCategory, BookCheckout, BorrowedAsset are defined.
# - Forms: BookCheckoutForm is defined.
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, joinedload, etc.), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify, paginate), and other Python imports (datetime, timezone, date) are available.
@app.route("/books/checkout", methods=["GET", "POST"])
@login_required
@role_required("librarian", "student")
def checkout_book():
    is_librarian = current_user.role.name.lower() == "librarian"
    form = BookCheckoutForm()
    if request.method == 'GET' and is_librarian:
        user_id_to_prefill = request.args.get('user_id_prefill', type=int)
        if user_id_to_prefill and hasattr(form, 'user_id'):
            if form.user_id.choices and any(user_id_to_prefill == choice[0] for choice in form.user_id.choices):
                form.user_id.data = user_id_to_prefill
    if form.validate_on_submit():
        asset_id_to_checkout = form.asset_id.data
        due_date_from_form = form.due_date.data
        user_to_checkout_for_id = current_user.id
        if is_librarian:
            if form.user_id.data and form.user_id.data != 0:
                user_to_checkout_for_id = form.user_id.data
            else:
                flash("Librarians must select a user to checkout the book for.", "danger")
                return render_template("books/checkout_book.html",
                                            form=form,
                                            is_librarian=is_librarian,
                                            title="Checkout Book - Nexus")
        asset = db.session.get(Asset, asset_id_to_checkout)
        user_for_checkout = db.session.get(User, user_to_checkout_for_id)
        if not asset or not user_for_checkout or not user_for_checkout.is_active:
            flash("Invalid book or user selected, or user is inactive.", "danger")
        elif asset.quantity < 1:
            flash(f"Book '{asset.name}' is currently out of stock.", "danger")
        elif asset.status != "Available":
            flash(f"Book '{asset.name}' is not currently available for checkout (Status: {asset.status}).", "warning")
        else:
            existing_checkout = db.session.scalar(
                select(BookCheckout).where(
                    BookCheckout.user_id == user_for_checkout.id,
                    BookCheckout.asset_id == asset.id,
                    BookCheckout.returned == False
                )
            )
            if existing_checkout:
                flash(f"{user_for_checkout.full_name or user_for_checkout.username} already has '{asset.name}' checked out.", "warning")
            else:
                try:
                    new_checkout = BookCheckout(
                        user_id=user_for_checkout.id,
                        asset_id=asset.id,
                        checkout_date=datetime.now(timezone.utc).date(),
                        due_date=due_date_from_form,
                        returned=False
                    )
                    asset.quantity -= 1
                    if asset.quantity == 0 and asset.status == "Available":
                        asset.status = "CheckedOut"
                    db.session.add(new_checkout)
                    db.session.commit()
                    flash(f"Book '{asset.name}' checked out successfully to {user_for_checkout.full_name or user_for_checkout.username}. Due: {due_date_from_form.strftime('%Y-%m-%d')}.", "success")
                    app.logger.info(f"Book ID {asset.id} checked out to user ID {user_for_checkout.id} by {current_user.username}. Due: {due_date_from_form}.")
                    if is_librarian:
                        return redirect(url_for("list_checkouts"))
                    else:
                        return redirect(url_for("view_library"))
                except Exception as e:
                    db.session.rollback()
                    flash(f"Error checking out book: {str(e)}", "danger")
                    app.logger.error(f"Checkout failed for book ID {asset.id} by user ID {user_for_checkout.id}: {str(e)}")
    return render_template("books/checkout_book.html",
                                form=form,
                                is_librarian=is_librarian,
                                title="Checkout Book/Asset - Nexus")
                           
@app.route("/books/return/<int:checkout_id>", methods=["POST"])
@login_required
@role_required("librarian") # Only librarians can mark books as returned via this direct route
def return_book(checkout_id):
    checkout_record = db.get_or_404(BookCheckout, checkout_id, description="Checkout record not found.")

    if checkout_record.returned:
        flash(f"Book '{checkout_record.asset.name if checkout_record.asset else 'Unknown Book'}' was already marked as returned on {checkout_record.return_date.strftime('%Y-%m-%d') if checkout_record.return_date else 'N/A'}.", "info")
    else:
        try:
            checkout_record.returned = True
            checkout_record.return_date = datetime.now(timezone.utc).date()

            asset = checkout_record.asset
            if asset: # Ensure asset exists
                asset.quantity += 1
                # If asset was 'CheckedOut' (meaning it was likely out of stock due to this checkout)
                # and now has quantity, set it back to 'Available'.
                # Don't change if it was 'Under Maintenance', 'Lost', etc.
                if asset.status == "CheckedOut" and asset.quantity > 0:
                    asset.status = "Available"
                elif asset.status is None and asset.quantity > 0: # If status was never set
                     asset.status = "Available"

            db.session.commit()
            flash(f"Book '{asset.name if asset else 'Unknown Book'}' marked as returned successfully.", "success")
            app.logger.info(f"Book checkout ID {checkout_id} (Asset: {asset.id if asset else 'N/A'}) marked returned by {current_user.username}.")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error returning book for checkout ID {checkout_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while marking the book as returned. Please try again.", "danger")

    # Redirect back to where the librarian was, or a default list
    return redirect(request.referrer or url_for("list_checkouts"))
@app.route("/books/checkouts")
@login_required
@role_required("librarian")
def list_checkouts():
    page = request.args.get("page", 1, type=int)
    per_page = 15 
    status_filter = request.args.get("status", "active", type=str).lower()
    search_query = request.args.get("search", "", type=str).strip()
    today_date = datetime.now(timezone.utc).date()

    query = select(BookCheckout).options(
        joinedload(BookCheckout.asset).joinedload(Asset.category), # Load asset and its category
        joinedload(BookCheckout.user).joinedload(User.role)       # Load user and their role
    )

    if status_filter == 'active':
        query = query.where(BookCheckout.returned == False)
        query = query.order_by(BookCheckout.due_date.asc()) # Overdue first
    elif status_filter == 'overdue':
        query = query.where(BookCheckout.returned == False, BookCheckout.due_date < today_date)
        query = query.order_by(BookCheckout.due_date.asc())
    elif status_filter == 'returned':
        query = query.where(BookCheckout.returned == True)
        query = query.order_by(BookCheckout.return_date.desc()) # Newest returns first
    else: # 'all'
        query = query.order_by(BookCheckout.returned.asc(), BookCheckout.checkout_date.desc()) # Active first, then newest checkouts

    if search_query:
        search_term = f"%{search_query}%"
        # Ensure you join User and Asset if they are not default joined by the relationships
        # The options(joinedload(...)) above should make them available for filtering.
        query = query.join(BookCheckout.user).join(BookCheckout.asset).where(
            or_(
                User.full_name.ilike(search_term),
                User.username.ilike(search_term),
                Asset.name.ilike(search_term)
            )
        )
    
    # Important: Re-apply order_by if search joins changed the primary table in query construction
    # For simplicity, the initial order_by might still work, but complex joins can affect it.
    # If ordering is lost after search, re-apply a default order or the status-specific order.

    checkouts_paginated = db.paginate(query, page=page, per_page=per_page, error_out=False)

    return render_template(
        "librarian/list_checkouts.html",
        checkouts_paginated=checkouts_paginated,
        status_filter=status_filter,
        search_query=search_query,
        title="Manage Book Checkouts - Nexus"
    )

# --- PART 9 END: Book Checkout & Management ---

# --- PART 10 START: Chat and Contacts ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Message are defined.
# - Helpers: is_chat_allowed (defined in Part 3), get_allowed_roles (defined in Part 3), get_unread_message_count (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: CHAT_PERMISSIONS, VALID_ROLES dictionaries (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_), Flask imports (abort, flash, redirect, url_for, request, render_template, jsonify).
# - Other Python imports (datetime, timezone).

# get_chat_messages helper is defined here, as it's specific to chat routes

# --- (Place with other API/AJAX routes, or in a new section for Chat # In app.py
# --- (Previous app code) ---
#


# =================================================================
# GEMINI 3 PRO: PHASE 1.1a - API for Club Request Handling
# =================================================================
# =================================================================
# GEMINI 3 PRO: PHASE 1.1c/d - API for Comments & Likes
# =================================================================

# =================================================================
# GEMINI 3 PRO: PHASE 1.3 - Flask-Assets Configuration
# =================================================================
from flask_assets import Environment, Bundle

assets = Environment(app)

# Define the JavaScript bundle.
# 'module' type is critical for using import/export syntax.
js_bundle = Bundle(
    'js/app.js',  # Our main entrypoint
    # Add other vendor scripts here if needed, e.g., 'vendor/chart.js'
    filters='jsmin',  # Minify in production
    output='gen/app.%(version)s.js',
    extra={'type': 'module'} # CRITICAL for modern JS
)

# Register the bundle with a name.
assets.register('app_js', js_bundle)


def get_comment_form():
    return CommentForm()

@app.context_processor
def inject_utility_processor():
    return dict(get_comment_form=get_comment_form)

# =================================================================
# GEMINI 3 PRO: PHASE 2.2 - Broadcasting Backend Events
# =================================================================

@app.route('/api/post/<int:post_id>/comment', methods=['POST'])
@login_required
def submit_comment_api(post_id):
    """ AUGMENTED: Submits a comment and broadcasts the event. """
    post = Post.query.get_or_404(post_id)
    form = CommentForm()
    
    if form.validate_on_submit():
        comment = Comment(content=form.content.data, author_id=current_user.id, post_id=post.id)
        db.session.add(comment)
        if post.author_id != current_user.id:
            db.session.add(Notification(user_id=post.author_id, message=f"{current_user.first_name} commented on your post."))
        db.session.commit()

        rendered_comment_html = render_template('social/partials/_social_comment_item.html', comment=comment)
        
        # --- BROADCAST LOGIC ---
        # We emit an event to a "room" specific to this post.
        # Any client viewing this post will be in this room.
        socketio.emit('new_comment', {
            'post_id': post_id,
            'comment_html': rendered_comment_html,
            'new_comment_count': post.comments.count()
        }, room=f'post-{post_id}')
        
        # The original AJAX request still gets its direct response.
        return jsonify({'success': True, 'comment_html': rendered_comment_html, 'new_comment_count': post.comments.count()})
    else:
        return jsonify({'success': False, 'errors': form.errors}), 400

# --- NEW SOCKETIO EVENT HANDLERS ---
@socketio.on('connect')
def handle_connect():
    """ Handles a new client connection. """
    print(f'Client connected: {request.sid}')

@socketio.on('connect')
def handle_global_connect(): # Renamed to avoid conflict if other 'connect' handlers exist
    # This can be a generic connect handler or specific to a namespace if you use them.
    # request.sid is the unique session ID for the client.
    app.logger.info(f'Socket.IO Client connected: {request.sid}')
    # No need to emit anything back by default unless you have specific connection ACK logic.

@socketio.on('disconnect')
def handle_global_disconnect(): # Renamed for clarity
    app.logger.info(f'Socket.IO Client disconnected: {request.sid}')
    # Any cleanup related to this specific SID leaving rooms can be done here,
    # though Flask-SocketIO often handles room cleanup automatically on disconnect.

@socketio.on('join_post_room') # Matches client emit event name
def handle_join_global_post_room(data): # data is the dict { 'post_id': postId }
    post_id = data.get('post_id')
    if post_id:
        room_name = f'global_post-{post_id}'
        join_room(room_name)
        app.logger.info(f'Client {request.sid} joined room: {room_name}')
        # Optionally, you could emit a confirmation back to the joining client
        # emit('joined_room_ack', {'room': room_name}, room=request.sid)
    else:
        app.logger.warning(f"Client {request.sid} tried to join_post_room without post_id.")

@socketio.on('leave_post_room') # Matches client emit event name
def handle_leave_global_post_room(data):
    post_id = data.get('post_id')
    if post_id:
        room_name = f'global_post-{post_id}'
        leave_room(room_name)
        app.logger.info(f'Client {request.sid} left room: {room_name}')
        # Optionally, emit confirmation
        # emit('left_room_ack', {'room': room_name}, room=request.sid)
    else:
        app.logger.warning(f"Client {request.sid} tried to leave_post_room without post_id.")

# --- END SOCKETIO EVENT HANDLERS ---

@socketio.on('join_post_room')
def handle_join_post_room(data):
    """ Client requests to join a room to receive updates for a specific post. """
    post_id = data.get('post_id')
    if post_id:
        join_room(f'post-{post_id}')
        print(f'Client {request.sid} joined room post-{post_id}')

@socketio.on('leave_post_room')
def handle_leave_post_room(data):
    """ Client leaves a room (e.g., navigates away from the page). """
    post_id = data.get('post_id')
    if post_id:
        leave_room(f'post-{post_id}')
        print(f'Client {request.sid} left room post-{post_id}')

@app.route('/api/post/<int:post_id>/like', methods=['POST'])
@login_required
def toggle_like_api(post_id):
    """
    Toggles a like on a post asynchronously.
    """
    post = Post.query.get_or_404(post_id)
    existing_like = Like.query.filter_by(user_id=current_user.id, post_id=post.id).first()

    if existing_like:
        # User has liked it, so unlike it.
        db.session.delete(existing_like)
        user_liked = False
    else:
        # User has not liked it, so like it.
        new_like = Like(user_id=current_user.id, post_id=post.id)
        db.session.add(new_like)
        user_liked = True

    db.session.commit()

    return jsonify({
        'success': True,
        'new_like_count': post.likes.count(),
        'user_liked': user_liked
    })
@app.route('/club/request/<int:request_id>/handle', methods=['POST'])
@login_required
def handle_club_request(request_id):
    """
    Handles approving or declining a 'JOIN_CLUB' request.
    This is an API endpoint designed to be called via Fetch from the frontend.
    """
    join_request = Request.query.get_or_404(request_id)
    action = request.form.get('action')

    if join_request.request_type != 'JOIN_CLUB':
        return jsonify({'success': False, 'error': 'Invalid request type.'}), 400

    club = join_request.talent_club
    # --- Permission Check: Only the club leader can handle requests. ---
    if not club.is_leader(current_user):
        return jsonify({'success': False, 'error': 'You do not have permission to perform this action.'}), 403

    if action == 'approve':
        join_request.status = 'APPROVED'
        # Create a new membership for the requesting user.
        new_membership = TalentClubMembership(user_id=join_request.sender_id, club_id=club.id, role='Member')
        db.session.add(new_membership)
        
        # Create a notification for the user who was accepted.
        approval_notification = Notification(
            user_id=join_request.sender_id,
            message=f"Your request to join '{club.name}' has been approved!"
        )
        db.session.add(approval_notification)
        flash(f"{join_request.sender.first_name} has been added to the club.", "success")
        
    elif action == 'decline':
        join_request.status = 'DECLINED'
        # Create a notification for the user who was declined.
        rejection_notification = Notification(
            user_id=join_request.sender_id,
            message=f"Your request to join '{club.name}' has been declined."
        )
        db.session.add(rejection_notification)
        flash(f"{join_request.sender.first_name}'s request has been declined.", "info")
    else:
        return jsonify({'success': False, 'error': 'Invalid action.'}), 400

    db.session.commit()
    return redirect(url_for('inbox'))

# --- PART X START: Talent Club Features ---
#
# Find and replace this API search route. It is now corrected to specifically query
# based on the `is_tc_member` flag, which is what you wanted.
# This endpoint is what your JavaScript user picker (e.g., TomSelect) should be calling.
@app.route("/talent_club/api/members/search")
@login_required
@tc_member_required # Ensures the person doing the searching is a TC member
def api_search_tc_members():
    """
    AJAX endpoint to search for active Talent Club members for mentioning in proposals.
    --- THIS IS THE CORRECTED VERSION ---
    It correctly queries users based on the `is_tc_member` flag, not their role.
    """
    search_query = request.args.get('q', '').strip()
    if not search_query or len(search_query) < 2:
        return jsonify([])

    try:
        # CORRECTED QUERY: Specifically selects users where is_tc_member is True.
        # This will include all students who opted in.
        results_query = (
            select(User).where(
                User.is_tc_member == True,
                User.is_active == True,
                User.id != current_user.id, # Don't let user mention themselves
                or_( # Search by username or full name
                    User.username.ilike(f'%{search_query}%'),
                    User.full_name.ilike(f'%{search_query}%')
                )
            ).options(joinedload(User.role)).order_by(User.full_name).limit(15)
        )

        results = db.session.scalars(results_query).all()
        # Format for the JavaScript user picker (e.g., TomSelect)
        return jsonify([{
            'id': u.id,
            'text': f"{u.full_name or u.username} ({u.role.name.replace('_',' ').title() if u.role else 'TC Member'})"
        } for u in results])
    except Exception as e:
        app.logger.error(f"Error searching TC members for mention: {e}", exc_info=True)
        return jsonify([]), 500


# Now, find and replace the `create_talent_club_proposal` route.
# The validation logic within it has been confirmed to be correct.
@app.route("/talent_club/configuration/new_club_proposal", methods=["GET", "POST"])
@login_required
@tc_member_required
def create_talent_club_proposal():
    form = CreateTalentClubProposalForm() # Your form definition

    if form.validate_on_submit():
        proposal_file_obj = None

        if form.proposal_file.data and form.proposal_file.data.filename:
            try:
                uploaded_file_obj = save_uploaded_file(form.proposal_file.data)
                if not uploaded_file_obj:
                    # Error flashed by helper
                    return render_template("talent_club/config_new_proposal.html", form=form, title="Submit Club Proposal - Nexus TC")
                proposal_file_obj = uploaded_file_obj
            except Exception as e:
                app.logger.error(f"Error processing proposal file for user {current_user.id}: {e}", exc_info=True)
                flash("An error occurred uploading the proposal document.", "danger")
                return render_template("talent_club/config_new_proposal.html", form=form, title="Submit Club Proposal - Nexus TC")

        # --- THIS VALIDATION IS NOW CORRECT AND CONSISTENT WITH THE API ---
        # It ensures that even if the frontend sends incorrect IDs, the backend only
        # accepts users who have `is_tc_member = True`.
        mentioned_member_ids_str = request.form.get('mentioned_member_ids_hidden', '')
        mentioned_member_ids = [int(uid) for uid in mentioned_member_ids_str.split(',') if uid.isdigit()]

        valid_mentioned_users = []
        if mentioned_member_ids:
            # CORRECTED VALIDATION LOGIC
            valid_mentioned_users_query = (
                select(User).where(
                    User.id.in_(mentioned_member_ids),
                    User.id != current_user.id, # Exclude self
                    User.is_tc_member == True,   # <-- CRITICAL CHECK: Use the boolean flag
                    User.is_active == True
                )
            )
            valid_mentioned_users = db.session.scalars(valid_mentioned_users_query).all()

        MIN_MENTIONED_MEMBERS = 5 # Define your minimum
        if len(valid_mentioned_users) < MIN_MENTIONED_MEMBERS:
            flash(f"You must successfully mention at least {MIN_MENTIONED_MEMBERS} other active Talent Club members. You selected {len(valid_mentioned_users)} valid members.", "danger")
            if proposal_file_obj and proposal_file_obj.filepath:
                try: os.remove(os.path.join(app.config['UPLOAD_FOLDER'], os.path.basename(proposal_file_obj.filepath)))
                except: pass
            # Pass all_tc_members again for the re-rendered template's picker
            all_tc_members = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True, User.id != current_user.id)).all()
            return render_template("talent_club/config_new_proposal.html", form=form, title="Submit Club Proposal - Nexus TC", all_tc_members=all_tc_members)
        
        # --- (The rest of the `create_talent_club_proposal` function remains the same) ---
        # --- It will now correctly use `valid_mentioned_users` list ---
        try:
            new_proposal = TalentClubProposal(
                creator_id=current_user.id,
                name=form.name.data.strip(),
                description=form.description.data.strip(),
                social_category_id=form.social_category_id.data,
                proposal_file_id=proposal_file_obj.id if proposal_file_obj else None,
                status='pending_leader_review',
                created_at=datetime.now(timezone.utc)
            )
            if proposal_file_obj:
                db.session.add(proposal_file_obj)

            db.session.add(new_proposal)
            db.session.flush()

            mention_entries_for_notification = []
            for user_to_mention in valid_mentioned_users:
                mention = TalentClubMention(
                    proposal_id=new_proposal.id,
                    user_id=user_to_mention.id,
                    status='pending'
                )
                db.session.add(mention)
                mention_entries_for_notification.append(mention)

            db.session.commit()
            app.logger.info(f"User {current_user.username} submitted TC Proposal ID {new_proposal.id} mentioning {len(valid_mentioned_users)} users.")

            # Notifications (remains the same)
            # 1. To Mentioned Members
            notification_content_mention = f"You've been mentioned in a new Talent Club proposal for '{new_proposal.name}' by {current_user.full_name or current_user.username}. Your response is requested."
            for mention_record in mention_entries_for_notification:
                link_url_mention = url_for('view_tc_proposal_mention', mention_id=mention_record.id, _external=True)
                notify_tc_member(
                    receiver_user=mention_record.user,
                    sender_user=current_user,
                    content=notification_content_mention,
                    notification_type='tc_proposal_mention_invite',
                    related_object_id=mention_record.id,
                    link_url=link_url_mention
                )

            # 2. To TC Leader
            tc_leader = db.session.scalar(select(User).where(User.is_tc_leader == True, User.is_active == True))
            if tc_leader:
                notification_content_leader = f"New TC Proposal '{new_proposal.name}' submitted by {current_user.full_name or current_user.username} is awaiting your review."
                link_url_leader = url_for('review_tc_proposal', proposal_id=new_proposal.id, _external=True)
                notify_tc_member(
                    receiver_user=tc_leader,
                    sender_user=current_user,
                    content=notification_content_leader,
                    notification_type='tc_proposal_for_review',
                    related_object_id=new_proposal.id,
                    link_url=link_url_leader
                )
            
            flash(f"Your proposal for '{new_proposal.name}' has been submitted and mentioned members notified!", "success")
            return redirect(url_for("my_talent_club_proposals"))
        except Exception as e:
            # (Exception handling logic remains the same)
            db.session.rollback()
            # ...
            flash("An unexpected error occurred. Please try again.", "danger")
    
    all_tc_members = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True, User.id != current_user.id)).all()
    return render_template("talent_club/config_new_proposal.html",
                           form=form,
                           all_tc_members=all_tc_members, # Pass for TomSelect if not purely AJAX
                           title="Propose New Talent Club - Nexus TC")
#
# --- (Rest of app code) ---
#
        
@app.route("/chat/api/messages/<int:other_user_id>/new")
@login_required
def ajax_get_new_chat_messages(other_user_id):
    if other_user_id == current_user.id:
        return jsonify({"messages": [], "latest_timestamp": int(datetime.now(timezone.utc).timestamp() * 1000)}), 200

    since_ms_str = request.args.get("since")
    if not since_ms_str:
        return jsonify({"error": "Missing 'since' timestamp."}), 400
        
    try:
        since_ms = int(since_ms_str)
        # Add a small buffer (e.g., 1 second) to avoid re-fetching the exact last message due to millisecond precision
        since_time = datetime.fromtimestamp((since_ms / 1000.0) + 0.001, tz=timezone.utc) 
    except (ValueError, TypeError):
        app.logger.warning(f"AJAX Chat: Invalid 'since' timestamp '{since_ms_str}' for user {current_user.username} polling {other_user_id}.")
        return jsonify({"error": "Invalid timestamp format."}), 400

    # Fetch new messages FROM other_user_id TO current_user_id
    # AND messages FROM current_user_id TO other_user_id (if sent from another client/tab)
    new_messages_query = (
        select(Message)
        .where(
            Message.timestamp > since_time, # Key condition
            or_(
                (Message.sender_id == current_user.id) & (Message.receiver_id == other_user_id),
                (Message.sender_id == other_user_id) & (Message.receiver_id == current_user.id)
            )
        )
        .options(joinedload(Message.sender).joinedload(User.role)) # Eager load sender for client-side rendering
        .order_by(Message.timestamp.asc()) # Send in chronological order
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data = []
    latest_ts_in_batch = since_ms

    # Mark newly fetched messages FROM other_user_id as read
    unread_ids_to_mark_on_poll = []

    for msg in new_messages_list:
        messages_data.append({
            "id": msg.id,
            "sender_id": msg.sender_id,
            "sender": { # Essential for JS to render the message correctly
                "full_name": msg.sender.full_name if msg.sender else "Unknown",
                "username": msg.sender.username if msg.sender else "unknown",
                "profile_photo_url": msg.sender.profile_photo_url if msg.sender else None
            },
            "receiver_id": msg.receiver_id,
            "content": msg.content,
            "timestamp": msg.timestamp.isoformat() + "Z", # ISO format for JS
            "is_read": msg.is_read # Reflect current read status
        })
        
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms
        
        # If message is from the other user and current user is receiver, mark it read
        if msg.sender_id == other_user_id and msg.receiver_id == current_user.id and not msg.is_read:
            unread_ids_to_mark_on_poll.append(msg.id)

    if unread_ids_to_mark_on_poll:
        try:
            db.session.query(Message).filter(
                Message.id.in_(unread_ids_to_mark_on_poll)
            ).update({Message.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(f"AJAX Chat: Marked {len(unread_ids_to_mark_on_poll)} polled messages as read for user {current_user.username} from {other_user_id}.")
            # Update is_read status in the data being sent to client
            for msg_data in messages_data:
                if msg_data["id"] in unread_ids_to_mark_on_poll:
                    msg_data["is_read"] = True
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"AJAX Chat: Error marking polled messages read for user {current_user.id} from {other_user_id}: {e}", exc_info=True)

    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0)
    
    return jsonify({
        "messages": messages_data,
        "latest_timestamp": final_latest_timestamp # Crucial for client's next poll 'since'
    }), 200

def get_chat_messages(user1_id, user2_id, limit=50):
    """Fetches chat messages between two users, ordered by timestamp."""
    # Ensure app context for DB access if called outside a request context
    with app.app_context():
        # Use `or_` to filter messages where either user is the sender or receiver
        # and the other user is the corresponding receiver or sender.
        return db.session.scalars(
            select(Message)
            .where(
                ((Message.sender_id == user1_id) & (Message.receiver_id == user2_id))
                | ((Message.sender_id == user2_id) & (Message.receiver_id == user1_id))
            )
            .order_by(Message.timestamp.asc())  # Show oldest first for chat flow
            .limit(
                limit
            )  # Limit messages to prevent overload, implement pagination later if needed
        ).all()

# is_chat_allowed helper (defined in Part 3) is used below
@app.route("/chat/user/<int:target_user_id>", methods=["GET", "POST"])
@login_required
def universal_chat(target_user_id):
    if target_user_id == current_user.id:
        flash("You cannot chat with yourself.", "warning")
        return redirect(url_for("contacts_list"))

    target_user = db.session.get(User, target_user_id)
    if not target_user or not target_user.is_active or not target_user.role:
        abort(404, description="The user you are trying to chat with does not exist, is inactive, or has no role.")

    # Permission check using is_chat_allowed helper (from app.py Part 3/Phase J)
    if not is_chat_allowed(current_user, target_user):
        flash(f"You do not have permission to chat with {target_user.full_name or target_user.username}.", "danger")
        return redirect(url_for("contacts_list"))

    if request.method == "POST": # This will now be primarily for AJAX message sending
        # Expecting JSON data from chat.js
        if not request.is_json:
            return jsonify({"success": False, "error": "Invalid request format. JSON expected."}), 400
        
        data = request.get_json()
        content = data.get("message", "").strip()

        if not content:
            return jsonify({"success": False, "error": "Cannot send an empty message."}), 400
        if len(content) > 2000:
            return jsonify({"success": False, "error": "Message is too long (max 2000 characters)."}), 400

        try:
            msg = Message(
                sender_id=current_user.id,
                receiver_id=target_user.id,
                sender_role=current_user.role.name,
                receiver_role=target_user.role.name,
                content=content,
                timestamp=datetime.now(timezone.utc),
                is_read=False 
            )
            db.session.add(msg)
            db.session.commit() # Commit to get msg.id and accurate timestamp

            app.logger.info(f"AJAX: Message ID {msg.id} sent from {current_user.username} to {target_user.username}.")
            
            # Prepare message data to send back (for client-side rendering)
            # Ensure sender details are included for the _chat_message_item.html partial if rendered client-side
            message_data_for_client = {
                "id": msg.id,
                "sender_id": msg.sender_id,
                "sender": { # Frontend JS will use this to construct the sender display
                    "full_name": current_user.full_name,
                    "username": current_user.username,
                    "profile_photo_url": current_user.profile_photo_url
                },
                "receiver_id": msg.receiver_id, # Though not directly used by item, good to have
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat() + "Z", # ISO format for JS Date parsing
                "is_read": msg.is_read # Will be false
            }
            
            # Optional: If you want to render the HTML snippet on the server for AJAX response
            # rendered_message_html = render_template(
            #     "partials/_chat_message_item.html",
            #     message=msg, # Pass the Message object itself
            #     current_user_id=current_user.id
            # )

            return jsonify({
                "success": True, 
                "message": "Message sent!", 
                "message_data": message_data_for_client
                # "message_html": rendered_message_html # If sending HTML
            }), 201 # 201 Created
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"AJAX: Error sending message from {current_user.id} to {target_user.id}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Server error sending message."}), 500

    # --- GET Request Logic ---
    # Fetch initial messages (e.g., last 50, newest at the bottom due to template's column-reverse)
    # The template expects messages sorted oldest first if it prepends them,
    # or newest first if it appends them at the top of a reversed container.
    # The current chat.js appends to top of a column-reverse div, so messages should be oldest first.
    initial_messages_query = (
        db.select(Message)
        .where(
            or_(
                (Message.sender_id == current_user.id) & (Message.receiver_id == target_user.id),
                (Message.sender_id == target_user.id) & (Message.receiver_id == current_user.id)
            )
        )
        .options(joinedload(Message.sender).joinedload(User.role)) # Eager load sender and their role
        .order_by(Message.timestamp.asc()) # Oldest first for appending to a reversed container
        .limit(50) # Load initial batch
    )
    messages = db.session.scalars(initial_messages_query).all()

    # Mark messages received FROM target_user in THIS batch as read
    unread_ids_in_batch_to_mark = [
        m.id for m in messages if m.sender_id == target_user.id and not m.is_read
    ]
    if unread_ids_in_batch_to_mark:
        try:
            db.session.query(Message).filter(
                Message.id.in_(unread_ids_in_batch_to_mark)
            ).update({Message.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(f"Marked {len(unread_ids_in_batch_to_mark)} messages as read from user {target_user.username} upon opening chat with {current_user.username}.")
            # Update objects in 'messages' list to reflect read status for immediate display
            for m in messages:
                if m.id in unread_ids_in_batch_to_mark:
                    m.is_read = True # This won't persist if not committed, but good for template
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error marking messages read in chat between {current_user.id} and {target_user.id}: {e}", exc_info=True)

    return render_template(
        "chat/universal_chat.html",
        target_user=target_user,
        messages=messages, # Pass initial messages
        title=f"Chat with {target_user.full_name or target_user.username} - Nexus"
    )

@app.route("/contacts")
@login_required
def contacts_list():
    """
    Displays an organized contacts list based on user role and permissions.
    - Non-student/teacher roles are listed first.
    - Teachers are grouped by the grade/section they teach.
    - Students are grouped into "TC Members" and "Other Students" blocks.
    - All visibility is controlled by the current user's chat permissions.
    """
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for('role_redirect'))

    # The permission helper is the single source of truth for what can be displayed.
    allowed_role_names = get_allowed_chat_roles('send_to', current_user)

    # --- Initialize data structures to pass to the template ---
    other_contacts_by_role = defaultdict(list)
    teachers_by_grade_section = defaultdict(list)
    tc_student_blocks = []
    non_tc_student_blocks = []
    contact_unread_counts = {}

    # --- 1. Fetch Staff Contacts (Non-Teacher, Non-Student) ---
    other_role_names = [r for r in allowed_role_names if r not in ['student', 'teacher']]
    if other_role_names:
        other_contacts_query = select(User).join(Role).where(
            User.id != current_user.id, User.is_active == True, Role.name.in_(other_role_names)
        ).options(joinedload(User.role)).order_by(Role.name, User.full_name)
        
        other_contacts_results = db.session.scalars(other_contacts_query).all()
        for contact in other_contacts_results:
            other_contacts_by_role[contact.role.name.replace('_', ' ').title()].append(contact)

    # --- 2. Fetch and Classify Teachers by Grade/Section ---
    if 'teacher' in allowed_role_names:
        # Get all active teachers and their profiles
        all_teachers = db.session.scalars(
            select(User).where(User.role.has(name='teacher'), User.is_active==True)
            .options(joinedload(User.teacher_profiles))
        ).all()
        
        added_teachers = defaultdict(set) # To prevent adding a teacher multiple times to the same block
        for teacher in all_teachers:
            for profile in teacher.teacher_profiles:
                if profile.grade and profile.section:
                    key = (profile.grade, profile.section)
                    if teacher.id not in added_teachers[key]:
                        teachers_by_grade_section[key].append(teacher)
                        added_teachers[key].add(teacher.id)

    # --- 3. Fetch Student Blocks (TC and Non-TC) ---
    if 'student' in allowed_role_names:
        base_student_query = select(
            User.grade, User.section, func.count(User.id).label('student_count')
        ).join(Role).where(
            Role.name == 'student', User.is_active == True, User.id != current_user.id,
            User.grade.isnot(None), User.grade != '',
            User.section.isnot(None), User.section != ''
        )
        
        # Query for TC Member blocks
        tc_query = base_student_query.where(User.is_tc_member == True).group_by(User.grade, User.section).order_by(User.grade, User.section)
        tc_student_blocks = db.session.execute(tc_query).all()

        # Query for Non-TC Member blocks
        non_tc_query = base_student_query.where(User.is_tc_member == False).group_by(User.grade, User.section).order_by(User.grade, User.section)
        non_tc_student_blocks = db.session.execute(non_tc_query).all()

    # --- 4. Get Unread Counts (for individual contacts shown, i.e., staff) ---
    all_individual_contacts = [c for role_list in other_contacts_by_role.values() for c in role_list]
    if all_individual_contacts:
        contact_ids = [c.id for c in all_individual_contacts]
        unread_counts_raw = db.session.execute(
            select(Message.sender_id, func.count(Message.id)).where(
                Message.receiver_id == current_user.id, Message.is_read == False, Message.sender_id.in_(contact_ids)
            ).group_by(Message.sender_id)
        ).all()
        contact_unread_counts = dict(unread_counts_raw)
        
    # Sort teacher blocks for consistent display
    sorted_teacher_blocks = sorted(teachers_by_grade_section.items())

    return render_template(
        "chat/contacts_list.html",
        other_contacts_by_role=other_contacts_by_role,
        sorted_teacher_blocks=sorted_teacher_blocks,
        tc_student_blocks=tc_student_blocks,
        non_tc_student_blocks=non_tc_student_blocks,
        contact_unread_counts=contact_unread_counts,
        allowed_role_names=allowed_role_names, # Pass for template-side permission checks
        title="My Chat Contacts"
    )

@app.route('/contacts/section/<grade>/<section>')
@login_required
def contacts_by_section(grade, section):
    """
    Displays the list of students for a specific grade and section.
    Accepts a 'tc_only' flag to filter for Talent Club members.
    """
    allowed_role_names = get_allowed_chat_roles('send_to', current_user)
    if 'student' not in allowed_role_names:
        flash("You do not have permission to view student contacts.", "danger")
        abort(403)

    # Check the flag from the URL to determine which group to show
    show_tc_only = request.args.get('tc_only') == 'true'

    # Base query for students in this specific section
    students_query = select(User).join(Role).where(
        User.id != current_user.id,
        User.is_active == True,
        Role.name == 'student',
        User.grade == grade,
        User.section == section
    )

    # Apply the TC member filter based on the flag
    if show_tc_only:
        students_query = students_query.where(User.is_tc_member == True)
        title = f"TC Members: Grade {grade} - Section {section}"
    else:
        students_query = students_query.where(User.is_tc_member == False)
        title = f"Other Students: Grade {grade} - Section {section}"
    
    students_in_section = db.session.scalars(students_query.order_by(User.full_name.asc())).all()
    
    # Get unread counts specifically for the displayed students
    contact_unread_counts = {}
    if students_in_section:
        student_ids = [s.id for s in students_in_section]
        unread_counts_raw = db.session.execute(
            select(Message.sender_id, func.count(Message.id))
            .where(
                Message.receiver_id == current_user.id,
                Message.is_read == False,
                Message.sender_id.in_(student_ids)
            ).group_by(Message.sender_id)
        ).all()
        contact_unread_counts = dict(unread_counts_raw)

    return render_template(
        "chat/contacts_section.html",
        students=students_in_section,
        contact_unread_counts=contact_unread_counts,
        title=title
    )
    
@app.route("/contacts_by_role/<string:display_role_filter>")
@login_required
def contacts_by_role_filter(display_role_filter):
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for('role_redirect'))

    allowed_chat_send_to_roles = get_allowed_chat_roles('send_to', current_user)
    display_role_filter_lower = display_role_filter.lower()
    valid_role_names_lower = [r[0].lower() for r in current_app.config.get('VALID_ROLES', [])]

    if display_role_filter_lower != 'all' and display_role_filter_lower not in valid_role_names_lower:
        flash(f"Invalid role filter: {display_role_filter}", "warning")
        return redirect(url_for('contacts_list'))

    contacts_query = (
        select(User)
        .join(User.role)
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name.in_(allowed_chat_send_to_roles)
        )
    )

    if display_role_filter_lower != 'all':
        if display_role_filter_lower in allowed_chat_send_to_roles:
            contacts_query = contacts_query.where(func.lower(Role.name) == display_role_filter_lower)
        else: # User requested a role they aren't allowed to chat with based on their 'send_to'
            flash(f"You do not have permission to initiate chats with users in the '{display_role_filter}' role.", "warning")
            contacts = [] # Override query to return empty
            # To prevent further processing if contacts is empty:
            contact_unread_counts = {}
            all_roles_for_filter = current_app.config.get('VALID_ROLES', [])
            return render_template(
                "chat/contacts_list.html",
                contacts=contacts,
                contact_unread_counts=contact_unread_counts,
                all_roles=all_roles_for_filter,
                title=f"{display_role_filter.replace('_', ' ').title()} Contacts - Nexus",
                selected_role_filter=display_role_filter
            )
    
    contacts = db.session.scalars(contacts_query.order_by(User.full_name.asc())).all()
    
    contact_unread_counts = {}
    if contacts:
        for contact in contacts:
            count = db.session.scalar(
                select(func.count(Message.id))
                .where(Message.sender_id == contact.id, Message.receiver_id == current_user.id, Message.is_read == False)
            )
            if count and count > 0: contact_unread_counts[contact.id] = count
            
    all_roles_for_filter = current_app.config.get('VALID_ROLES', [])

    return render_template(
        "chat/contacts_list.html",
        contacts=contacts,
        contact_unread_counts=contact_unread_counts,
        all_roles=all_roles_for_filter,
        title=f"{display_role_filter.replace('_', ' ').title()} Contacts - Nexus",
        selected_role_filter=display_role_filter
    )
# --- PART 10 END: Chat and Contacts ---    
# --- PART 11 START: Notifications ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Notification are defined.
# - Forms: NotificationForm is defined (in Part 4).
# - Helpers: get_unread_notifications_count (defined in Part 3), get_allowed_roles (defined in Part 3), can_send (defined in Part 3), can_receive (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: NOTIFICATION_PERMISSIONS dictionary (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_, literal, case), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, uuid, secure_filename, os).

@app.route("/notifications")
@login_required
def view_notifications():
    # Fetch notifications, unread first, then newest
    notifications_query = (
        select(Notification)
        .where(Notification.receiver_id == current_user.id)
        .options(joinedload(Notification.sender)) # Eager load sender for display
        .order_by(Notification.is_read.asc(), Notification.timestamp.desc())
    )
    notifications = db.session.scalars(notifications_query).all()

    # Mark these specific fetched notifications as read if they are unread
    unread_ids_to_mark = [n.id for n in notifications if not n.is_read]
    if unread_ids_to_mark:
        try:
            db.session.query(Notification).filter(
                Notification.id.in_(unread_ids_to_mark),
                Notification.receiver_id == current_user.id # Safety check
            ).update({Notification.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(f"Marked {len(unread_ids_to_mark)} notifications as read for user {current_user.username} upon viewing /notifications page.")
            # Update the is_read status on the objects we are about to pass to the template
            for n in notifications:
                if n.id in unread_ids_to_mark:
                    n.is_read = True
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error marking notifications as read for user {current_user.id} on /notifications view: {e}", exc_info=True)
            flash("Could not update notification read status.", "warning")
            
    return render_template("notifications/view.html", 
                           notifications=notifications, 
                           title="My Notifications - Nexus")

@app.route("/notifications/contacts_for_sending")
@login_required
def notification_contacts_for_sending():
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for('role_redirect'))

    # Uses get_allowed_notification_roles (which calls get_allowed_roles_helper)
    # This helper should be defined as per your original app.py Part 3/4 or my Phase J adjustments.
    allowed_receiver_role_names = get_allowed_notification_roles('send_to', current_user)

    contacts_query = (
        select(User)
        .join(User.role) # Assuming User.role relationship
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name.in_(allowed_receiver_role_names)
        )
        .options(joinedload(User.role)) # Eager load role for display
        .order_by(Role.name.asc(), User.full_name.asc())
    )
    contacts = db.session.scalars(contacts_query).all()
    
    # all_roles is used by the template for potential filtering UI, ensure it's available
    # VALID_ROLES should be defined globally or in app.config as per app.py Part 4 or my Phase J
    all_roles_for_filter = current_app.config.get('VALID_ROLES', [])


    return render_template(
        "notifications/contacts_for_sending.html",
        contacts=contacts,
        all_roles=all_roles_for_filter, # Pass for potential filter UI
        title="Send Notification - Select Recipient - Nexus",
        selected_role_filter='all' # For filter UI state if implemented
    )
# Optional route to filter notification contacts by role - similar to chat contacts
# @app.route("/notifications/contacts_for_sending/by_role/<string:display_role_filter>")
# @login_required
# def notification_contacts_for_sending_by_role_filter(display_role_filter):
#      # Logic similar to contacts_by_role_filter, but using notification permissions
#      pass
@app.route("/notifications/send_to/<int:receiver_id>", methods=["GET", "POST"])
@login_required
def send_notification_to_user(receiver_id):
    receiver = db.get_or_404(User, receiver_id, description="Recipient not found.")
    if not receiver.is_active or not receiver.role:
        flash("Cannot send notification: Recipient is inactive or has no role.", "warning")
        return redirect(url_for("notification_contacts_for_sending"))

    # Permission check using is_notification_allowed helper from app.py Part 3/Phase J
    if not is_notification_allowed(current_user, receiver):
        flash(f"You do not have permission to send notifications to {receiver.full_name or receiver.username}.", "danger")
        return redirect(url_for("notification_contacts_for_sending"))

    form = NotificationForm() # Your NotificationForm definition

    if form.validate_on_submit():
        try:
            notification = Notification(
                sender_id=current_user.id,
                receiver_id=receiver.id,
                content=form.content.data.strip(),
                # link_url = form.link_url.data.strip() if hasattr(form, 'link_url') and form.link_url.data else None, # If form has link_url
                timestamp=datetime.now(timezone.utc),
                is_read=False,
                notification_type='manual_general' # A type for manually sent notifications
            )
            db.session.add(notification)
            db.session.commit()
            flash(f"Notification sent successfully to {receiver.full_name or receiver.username}!", "success")
            app.logger.info(f"Notification ID {notification.id} sent from {current_user.username} to {receiver.username}.")
            return redirect(url_for("view_notifications"))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error sending notification from {current_user.username} to {receiver.username}: {e}", exc_info=True)
            flash("Failed to send notification due to a server error. Please try again.", "danger")
            # Re-render form with errors

    return render_template(
        "notifications/send_form.html",
        form=form,
        receiver=receiver,
        title=f"Send Notification to {receiver.full_name or receiver.username} - Nexus"
    )

# Add AJAX endpoints for managing notification status (Mark as read, Check for new)

# --- (Place with other API/AJAX routes, or in a new section for Notification API) ---

@app.route("/notifications/mark-all-read", methods=["POST"])
@login_required
def ajax_mark_all_notifications_read():
    try:
        updated_count_result = db.session.execute(
            db.update(Notification).where(
                Notification.receiver_id == current_user.id,
                Notification.is_read == False
            ).values(is_read=True)
        )
        db.session.commit()
        updated_count = updated_count_result.rowcount

        app.logger.info(f"AJAX: Marked {updated_count} notifications as read for user {current_user.username}.")
        return jsonify({
            "success": True,
            "message": f"{updated_count} notification(s) marked as read.",
            "updated_count": updated_count # JS can use this to update UI if needed
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"AJAX: Error marking all notifications read for user {current_user.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error marking notifications."}), 500

@app.route("/notifications/mark-read/<int:notification_id>", methods=["POST"])
@login_required
def ajax_mark_notification_read(notification_id):
    try:
        notification = db.session.get(Notification, notification_id)
        if not notification:
            return jsonify({"success": False, "error": "Notification not found."}), 404
        if notification.receiver_id != current_user.id:
            return jsonify({"success": False, "error": "Unauthorized."}), 403

        if not notification.is_read:
            notification.is_read = True
            db.session.commit()
            app.logger.info(f"AJAX: Marked notification {notification_id} as read for user {current_user.username}.")
        
        # Get current total unread count to send back
        current_total_unread = get_unread_notifications_count(current_user.id)

        return jsonify({
            "success": True, 
            "message": "Notification marked as read.", 
            "notification_id": notification_id,
            "total_unread_count": current_total_unread
            }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"AJAX: Error marking notification {notification_id} read for user {current_user.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/notifications/check-new")
@login_required
def ajax_check_new_notifications():
    since_ms_str = request.args.get("since")
    if not since_ms_str:
        # If no 'since', return current total unread and current server time, no new messages
        current_total_unread = get_unread_notifications_count(current_user.id)
        return jsonify({
            "newNotificationsHTML": [], # HTML snippets for new notifications
            "new_notification_data": [], # Raw data for new notifications
            "count": 0,
            "latestTimestamp": int(datetime.now(timezone.utc).timestamp() * 1000),
            "totalUnreadCount": current_total_unread
        }), 200
        
    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp(since_ms / 1000.0, tz=timezone.utc)
    except (ValueError, TypeError):
        app.logger.warning(f"AJAX: Invalid 'since' timestamp '{since_ms_str}' for user {current_user.username}.")
        return jsonify({"success": False, "error": "Invalid timestamp format."}), 400

    new_notifications_query = (
        select(Notification)
        .where(
            Notification.receiver_id == current_user.id,
            Notification.timestamp > since_time
        )
        .options(joinedload(Notification.sender)) # Eager load sender for template
        .order_by(Notification.timestamp.desc()) # Newest first
    )
    new_notifications_list = db.session.scalars(new_notifications_query).all()

    rendered_html_snippets = []
    new_notification_data_list = [] # For potential non-HTML updates

    latest_ts_in_batch = since_ms # Start with the 'since' timestamp

    for n in new_notifications_list:
        # Render each new notification item using the partial
        # Ensure `humanize_time_diff` is available to templates
        html_snippet = render_template("partials/_notification_item.html", notification=n)
        rendered_html_snippets.append(html_snippet)
        
        # Also prepare raw data if JS needs it for more complex updates
        new_notification_data_list.append({
            "id": n.id,
            "content": n.content,
            "link_url": n.link_url,
            "timestamp_iso": n.timestamp.isoformat(),
            "sender_name": n.sender.full_name or n.sender.username if n.sender else "System",
            "is_read": n.is_read, # Should be false for new ones
            "notification_type": n.notification_type
        })
        
        # Update latest timestamp from this batch
        notification_ts_ms = int(n.timestamp.timestamp() * 1000)
        if notification_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = notification_ts_ms
            
    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_notifications_list else 0)
    
    # Get current total unread count to send back for accurate badge update
    current_total_unread = get_unread_notifications_count(current_user.id)

    return jsonify({
        "newNotificationsHTML": rendered_html_snippets, # Pass rendered HTML
        "new_notification_data": new_notification_data_list, # Pass raw data
        "count": len(new_notifications_list),
        "latestTimestamp": final_latest_timestamp, # Crucial for next poll
        "totalUnreadCount": current_total_unread # For accurate badge update
    }), 200

@app.route("/notifications/mark-all-read", methods=["POST"])
@login_required # User must be logged in
def mark_all_notifications_read():
    """Mark all unread notifications as read for the current user (AJAX endpoint)."""
    try:
        # Use a bulk update for efficiency to mark all unread notifications for the current user as read
        updated_count = db.session.query(Notification).filter(
            Notification.receiver_id == current_user.id, # Only affect current user's notifications
            Notification.is_read == False # Only update those that are currently unread
        ).update(
            {Notification.is_read: True}, # Set is_read to True
            synchronize_session=False # Required for bulk updates outside standard ORM session sync
        )
        db.session.commit() # Commit the bulk update

        app.logger.info(f"Marked {updated_count} notifications as read for user {current_user.username} (ID: {current_user.id}) via mark-all-read endpoint.")

        # Return a JSON response indicating success and the number of notifications updated
        return jsonify({
            "success": True,
            "message": f"Marked {updated_count} notifications as read",
            "updated_count": updated_count
        }), 200 # 200 OK success status code

    except Exception as e:
        db.session.rollback() # Rollback the transaction on error
        app.logger.error(f"Error marking all notifications as read for user {current_user.id}: {e}", exc_info=True)
        # Return a JSON response indicating failure
        return jsonify({
            "success": False,
            "error": "Failed to mark notifications as read due to a server error."
        }), 500 # 500 Internal Server Error status code


@app.route("/notifications/mark-read/<int:notification_id>", methods=["POST"])
@login_required # User must be logged in
def mark_notification_read(notification_id):
    """Mark a specific notification as read (AJAX endpoint)."""
    try:
        # Fetch the specific notification by ID
        notification = db.session.get(Notification, notification_id)

        # Check if notification exists and belongs to the current user
        if not notification:
            app.logger.warning(f"Mark read attempt failed for non-existent notification ID {notification_id} by user {current_user.id}.")
            return jsonify({
                "success": False,
                "error": "Notification not found"
            }), 404 # 404 Not Found

        # Security check: Ensure the notification belongs to the currently logged-in user
        if notification.receiver_id != current_user.id:
            app.logger.warning(f"Unauthorized mark read attempt: User {current_user.id} tried to mark notification {notification_id} belonging to user {notification.receiver_id}.")
            return jsonify({
                "success": False,
                "error": "Unauthorized access to notification"
            }), 403 # 403 Forbidden

        # Only update the notification if it's currently unread
        if not notification.is_read:
            notification.is_read = True # Mark as read
            db.session.commit() # Commit the change
            app.logger.info(f"Marked notification {notification_id} as read for user {current_user.username} (ID: {current_user.id}).")
            # Return success JSON response
            return jsonify({
                "success": True,
                "message": "Notification marked as read",
                "notification_id": notification_id
            }), 200 # 200 OK
        else:
             # Notification was already read, return success but indicate no change was needed
             app.logger.debug(f"Notification {notification_id} was already read for user {current_user.id}.")
             return jsonify({
                "success": True,
                "message": "Notification was already read",
                "notification_id": notification_id
            }), 200


    except Exception as e:
        db.session.rollback() # Rollback on error
        app.logger.error(f"Error marking notification {notification_id} as read for user {current_user.id}: {e}", exc_info=True)
        # Return JSON response indicating failure
        return jsonify({
            "success": False,
            "error": "Failed to mark notification as read due to a server error."
        }), 500 # 500 Internal Server Error


@app.route("/notifications/check-new")
@login_required # User must be logged in to check for new notifications
def check_new_notifications():
    """
    Checks for new notifications received by the current user since a given timestamp (AJAX endpoint for polling).
    Expected query parameter: `since` (timestamp in milliseconds since epoch).
    """
    try:
        # Get the 'since' timestamp from query arguments
        since_ms = request.args.get("since", type=int)

        # Validate the input timestamp
        if since_ms is None or since_ms < 0:
             app.logger.warning(f"Invalid or missing 'since' timestamp ({since_ms}) from user {current_user.id}. Returning empty new notifications.")
             # Return current time and an empty list
             return jsonify({
                "newNotifications": [],
                "count": 0,
                "latestTimestamp": int(datetime.now(timezone.utc).timestamp() * 1000)
            }), 200 # 200 OK

        # Convert milliseconds timestamp to datetime object (UTC)
        # Handle potential errors during conversion (e.g., excessively large timestamp)
        try:
            since_time = datetime.fromtimestamp(since_ms / 1000.0, tz=timezone.utc)
        except (ValueError, OverflowError):
             app.logger.warning(f"Invalid 'since' timestamp value {since_ms} from user {current_user.id}. Conversion error. Returning empty new notifications.")
             # Return current time and an empty list
             return jsonify({
                "newNotifications": [],
                "count": 0,
                "latestTimestamp": int(datetime.now(timezone.utc).timestamp() * 1000)
            }), 200


        # Query for new notifications received by the current user since the provided timestamp
        # Order by timestamp descending (newest first)
        new_notifications = db.session.scalars(Notification.query.filter(
            Notification.receiver_id == current_user.id, # For the current user
            Notification.timestamp > since_time # Notifications created AFTER the 'since' timestamp
        ).order_by(Notification.timestamp.desc())).all()


        # Prepare HTML snippets for the new notifications for display on the client side
        html_snippets = []
        for n in new_notifications:
             try:
                 # Render a small HTML snippet for each new notification using a partial template
                 # Assume a template file like `partials/notification_item.html` exists for rendering a single notification
                 html_snippets.append(render_template("partials/notification_item.html", notification=n))
             except Exception as render_e:
                 app.logger.error(f"Error rendering notification item {n.id} for user {current_user.id}: {render_e}", exc_info=True)
                 # Optionally include a placeholder error message in the snippet list

        # Get the current server timestamp (in milliseconds) to send back to the client
        # The client will use this for the 'since' parameter in the next polling request.
        current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)


        # Return a JSON response containing the new notifications' HTML, count, and the latest server timestamp
        return jsonify({
            "newNotifications": html_snippets, # List of rendered HTML strings
            "count": len(new_notifications), # Number of new notifications fetched
            "latestTimestamp": current_server_timestamp_ms # Server timestamp for next poll
        }), 200 # 200 OK success status code

    except Exception as e:
        # Log any unexpected errors during the check
        app.logger.error(f"Error checking new notifications for user {current_user.id}: {e}", exc_info=True)
        # Return a JSON response indicating failure
        return jsonify({
            "success": False,
            "error": "Failed to fetch new notifications due to a server error."
        }), 500 # 500 Internal Server Error status code

# Notification settings route - needs implementation based on user model fields (e.g., email_notifications, push_notifications)
# This route is likely part of the universal settings page (Part 13) or a dedicated notifications settings page.
@app.route("/notifications/settings", methods=["GET", "POST"])
@login_required # User must be logged in to change settings
def notification_settings():
    """Allows the current user to manage their notification preferences."""
    # This route is typically accessed as a GET to display the current settings
    # and a POST to save updated settings.

    # This requires notification preference columns on the User model (added in Part 2's User model update).
    # Example: email_notifications, push_notifications, notification_sound, etc.

    # A dedicated form for notification settings (`NotificationSettingsForm`) could be defined in Part 4,
    # or these settings could be integrated into the `UniversalSettingsForm` (Part 13).
    # If using a dedicated form:
    # form = NotificationSettingsForm(obj=current_user) # Populate form fields from current_user object

    if request.method == "POST":
        # Handle saving the notification settings from the submitted data.
        # The data might come from a standard form POST or an AJAX JSON request.

        # --- Option 1: Handle data directly from request.form (if using a standard form) ---
        # Assuming form fields like 'email_notifications', 'push_notifications' exist in request.form
        # try:
        #     # Update user attributes based on form data (checkboxes submit 'on' or are missing)
        #     current_user.email_notifications = 'email_notifications' in request.form
        #     current_user.push_notifications = 'push_notifications' in request.form # If column exists
        #     current_user.notification_sound = 'notification_sound' in request.form # If column exists
        #     # Add updates for other notification settings...

        #     db.session.commit() # Save changes
        #     flash("Notification settings saved successfully!", "success")
        #     app.logger.info(f"Notification settings updated for user {current_user.id} via POST.")
        #     # Redirect back to the settings page (GET method)
        #     return redirect(url_for('notification_settings'))

        # except Exception as e:
        #     db.session.rollback()
        #     app.logger.error(f"Error updating notification settings for user {current_user.id} via POST: {e}", exc_info=True)
        #     flash("Failed to save notification settings due to a server error.", "danger")
        #     # Re-render the page with error message - might need to fetch current settings again if not using a form object
        #     # If using a form: return render_template("notifications/settings.html", form=form, title="Notification Settings")
        #     # If not using a form: render the page directly and flash message is shown
        #     return render_template("notifications/settings.html", title="Notification Settings")


        # --- Option 2: Handle data from JSON request (if using AJAX save) ---
        if request.is_json:
            try:
                data = request.get_json() # Get JSON data from the request body

                # Update user attributes based on JSON data keys
                # Accessing data using .get() with a default handles missing keys gracefully
                # Assuming keys like 'email_notifications', 'push_notifications', 'notification_sound' etc.
                # Values expected: boolean (True/False)
                if 'email_notifications' in data: # Check if the key exists in the JSON
                    current_user.email_notifications = bool(data['email_notifications']) # Ensure boolean type
                # Add updates for other notification settings if they exist on the User model:
                # if 'push_notifications' in data:
                #      current_user.push_notifications = bool(data['push_notifications'])
                # if 'notification_sound' in data:
                #      current_user.notification_sound = bool(data['notification_sound'])
                # ... etc. for other notification settings columns ...


                db.session.commit() # Save changes to the database

                app.logger.info(f"Notification settings updated for user {current_user.id} via AJAX.")
                # Return a JSON response indicating success
                return jsonify({"success": True, "message": "Notification settings saved."}), 200 # 200 OK

            except Exception as e:
                db.session.rollback() # Rollback on error
                app.logger.error(f"Error updating notification settings for user {current_user.id} via AJAX: {e}", exc_info=True)
                # Return a JSON response indicating failure
                return jsonify({"success": False, "message": "Failed to save notification settings."}), 500 # 500 Internal Server Error

        else: # Handle cases where POST is not JSON (and not a standard form, if Option 1 is commented out)
            flash("Invalid request format for saving notification settings.", "danger")
            # Redirect back or re-render the page
            return redirect(url_for('notification_settings')) # Redirect back on error


    # --- Handle GET request (displaying the notification settings page) ---
    # Render the settings page template.
    # If using a dedicated form, pass it: return render_template("notifications/settings.html", form=form, title="Notification Settings")
    # If reading settings directly from the current_user object in the template:
    return render_template("notifications/settings.html", title="Notification Settings")


# --- PART 11 END: Notifications ---

# --- Group Routes ---
@app.route("/social/groups")
@login_required
def social_group_list():
    # Fetch groups current user is a member of (any role)
    my_groups_query = (
        select(SocialGroup)
        .join(SocialGroupMember)
        .where(
            SocialGroupMember.user_id == current_user.id,
            SocialGroup.is_active == True # Only active groups
        )
        .options(
            joinedload(SocialGroup.owner) # Eager load owner for display
            # REMOVED: joinedload(SocialGroup.members) 
        )
        .order_by(SocialGroup.name.asc())
    )
    my_groups = db.session.scalars(my_groups_query).all()
    
    return render_template("social/groups/list.html",
                           my_groups=my_groups,
                           title="My Social Groups - Nexus")
# Route to discover groups (optional - similar to channels, but groups are often private)
# This would typically list public groups or groups where membership is open/requestable.
# @app.route("/social/groups/discovery")
# @login_required
# def social_group_discovery():
#      # Query for public groups or groups user can join
#      pass
@app.route("/social/groups/<int:group_id>") # Add methods=['GET'] if it only handles GET for now (POST is separate)
@login_required
def view_social_group(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    if not group.is_active:
        flash(f"Group '{group.name}' is currently not active.", "warning")
        return redirect(url_for('social_group_list'))

    user_group_role = current_user.get_group_role(group) # Helper from User model
    if not user_group_role: # Not a member
        # For groups, usually only members can view. Adjust if public groups are a feature.
        flash(f"You must be a member of '{group.name}' to view its content.", "warning")
        return redirect(url_for('social_group_list')) # Or a group discovery page
        
    # Fetch initial messages (e.g., paginated)
    # Assuming column-reverse, so fetch oldest first if prepending via JS later, or newest if initial load shows latest
    messages_query = (
        select(GroupMessage)
        .where(GroupMessage.group_id == group.id)
        .options(
            joinedload(GroupMessage.author).joinedload(User.role), 
            joinedload(GroupMessage.file)
        )
        .order_by(GroupMessage.timestamp.asc()) # Oldest first for typical chat display append
        .limit(50) # Initial batch
    )
    messages = db.session.scalars(messages_query).all()
    
    # Form for creating new messages in this group
    post_form = PostContentForm() # Your PostContentForm for message input

    return render_template("social/groups/view_group.html",
                           group=group,
                           messages=messages,
                           # pagination=pagination, # If messages are paginated
                           post_form=post_form,
                           user_group_role=user_group_role, # e.g., 'owner', 'admin', 'member'
                           title=f"{group.name} - Group Chat - Nexus")
# Route to redirect for viewing a specific message (e.g., from a notification link)
@app.route("/social/messages/<int:message_id>/view")
@login_required
def view_social_group_message_redirect(message_id):
    """Redirects to the group page containing a specific message."""
    message = db.get_or_404(GroupMessage, message_id)

    # Before redirecting, check if the user has permission to view the group where this message is located
    if not current_user.is_group_member(message.group): # Uses User model helper
         flash("You do not have permission to view this message.", "danger")
         return redirect(url_for("social_group_list")) # Redirect to group list or similar safe page

    # Redirect to the group page. Use an anchor if the frontend chat UI supports it.
    # The anchor helps the page scroll to the specific message if the template is set up for it.
    return redirect(url_for("view_social_group", group_id=message.group_id, _anchor=f"message-{message.id}"))
    
@app.route("/social/groups/<int:group_id>/create_message", methods=["POST"])
@login_required
def create_group_message(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    if not group.is_active:
        return jsonify({"success": False, "error": "This group is not active."}), 403

    user_group_role = current_user.get_group_role(group)
    if not user_group_role: # Must be a member to post
        return jsonify({"success": False, "error": "You must be a member to send messages in this group."}), 403

    # Assume PostContentForm for validation consistency
    form = PostContentForm(request.form) 
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Message content or a file must be provided."}), 400
    if form.content.data and not form.content.validate(form):
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage) # Reusing helper
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed."}), 400
        except Exception as e:
            app.logger.error(f"Error processing file for group message by {current_user.username}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Error processing file."}), 500
            
    try:
        new_message = GroupMessage( # Ensure GroupMessage model is imported
            group_id=group.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_message)
        db.session.commit()

        app.logger.info(f"User {current_user.username} sent message ID {new_message.id} in group {group.id}.")

        # Prepare message data for client-side rendering using _chat_message_item.html
        # The _chat_message_item.html expects a 'message' object with 'sender', 'content', 'timestamp'
        message_data_for_client = {
            "id": new_message.id,
            "sender_id": new_message.author_id, # Correct field
            "sender": {
                "full_name": current_user.full_name,
                "username": current_user.username,
                "profile_photo_url": current_user.profile_photo_url
            },
            "content": new_message.content,
            "timestamp": new_message.timestamp.isoformat() + "Z",
            # Include file info if any, for the _chat_message_item to render (if it handles files)
            "file": {
                "id": uploaded_file_obj.id,
                "original_filename": uploaded_file_obj.original_filename,
                "mimetype": uploaded_file_obj.mimetype,
                "size": uploaded_file_obj.size,
                "download_url": url_for('download_social_file', file_id=uploaded_file_obj.id) # Assuming this route exists
            } if uploaded_file_obj else None
        }
        # OR render HTML on server
        # message_for_render = db.session.query(GroupMessage).options(...).get(new_message.id)
        # post_html = render_template("partials/_chat_message_item.html", message=message_for_render, current_user_id=current_user.id)


        return jsonify({
            "success": True, 
            "message": "Message sent!",
            # "post_html": post_html, # If rendering HTML snippet on server
            "post_data": message_data_for_client # If rendering on client
        }), 201

    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath: # Cleanup
            try: os.remove(os.path.join(current_app.static_folder, uploaded_file_obj.filepath))
            except: pass
        app.logger.error(f"Error creating group message in group {group.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error sending message."}), 500

# --- Channel and Group Creation/Management Routes ---
@app.route("/social/api/groups/<int:group_id>/messages/new")
@login_required
def ajax_get_new_group_messages(group_id):
    group = db.get_or_404(SocialGroup, group_id)
    if not current_user.is_group_member(group): # User.is_group_member helper
        return jsonify({"error": "Access denied."}), 403

    since_ms_str = request.args.get("since")
    if not since_ms_str: return jsonify({"error": "Missing 'since' timestamp."}), 400
        
    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp((since_ms / 1000.0) + 0.001, tz=timezone.utc)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid timestamp format."}), 400

    new_messages_query = (
        select(GroupMessage)
        .where(
            GroupMessage.group_id == group_id,
            GroupMessage.timestamp > since_time
        )
        .options(joinedload(GroupMessage.author).joinedload(User.role), joinedload(GroupMessage.file))
        .order_by(GroupMessage.timestamp.asc())
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data_for_client = []
    latest_ts_in_batch = since_ms
    for msg in new_messages_list:
        # Prepare data similarly to create_group_message response
        messages_data_for_client.append({
            "id": msg.id,
            "sender_id": msg.author_id,
            "sender": {
                "full_name": msg.author.full_name if msg.author else "Unknown",
                "username": msg.author.username if msg.author else "unknown",
                "profile_photo_url": msg.author.profile_photo_url if msg.author else None
            },
            "content": msg.content,
            "timestamp": msg.timestamp.isoformat() + "Z",
            "file": {
                "id": msg.file.id,
                "original_filename": msg.file.original_filename,
                "mimetype": msg.file.mimetype,
                "size": msg.file.size,
                "download_url": url_for('download_social_file', file_id=msg.file.id)
            } if msg.file else None
        })
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms
            
    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0)

    return jsonify({
        "messages": messages_data_for_client, # Send structured data
        "latest_timestamp": final_latest_timestamp
    }), 200
# Note: create_social_channel and create_social_group routes were already generated in Part 8 accidentally.
# I will regenerate them here for completeness of Part 12, assuming they were not included in previous parts.
# If they WERE included in Part 8, you should remove the duplicates.

# Helper function to save profile photos (separate from general file uploads)
# Assuming this helper was intended for Part 12 and is defined here.
# --- (Place with other helper functions, ensure secure_filename, os, uuid are imported) ---
# from werkzeug.utils import secure_filename
# import os
# import uuid
# from flask import current_app, flash # Ensure current_app and flash are available

# Define UPLOAD_PHOTO_FOLDER at the top level of your app.py, after app initialization
# if not already defined in a more central config place.
# UPLOAD_PHOTO_FOLDER = os.path.join(app.root_path, 'static', 'uploads', 'profile_photos')
# app.config['UPLOAD_PHOTO_FOLDER'] = UPLOAD_PHOTO_FOLDER 
# It's better if app.config['UPLOAD_PHOTO_FOLDER'] is set during app configuration.

def save_profile_photo(file_storage):
    """Saves an uploaded profile photo securely and returns its relative path for DB storage."""
    if not file_storage or not file_storage.filename:
        # This case should ideally be caught by FileField validators if field is required
        return None

    # Ensure the target upload folder exists
    # It's better to ensure this once at app startup or use app.config
    upload_folder = current_app.config.get('UPLOAD_PHOTO_FOLDER', os.path.join(current_app.root_path, 'static', 'uploads', 'profile_photos'))
    os.makedirs(upload_folder, exist_ok=True)

    # Allowed extensions for photos
    ALLOWED_PHOTO_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file_storage.filename)
    
    file_ext = filename.rsplit('.', 1)[1].lower() if '.' in filename else ''
    if file_ext not in ALLOWED_PHOTO_EXTENSIONS:
        flash(f"Invalid file type for profile photo: '{file_ext}'. Allowed: {', '.join(ALLOWED_PHOTO_EXTENSIONS)}.", "danger")
        app.logger.warning(f"Profile photo upload rejected for user {current_user.id if current_user.is_authenticated else 'Unknown'}: Invalid extension '{file_ext}'.")
        return None # Indicate failure

    # Check file size (example: 2MB limit)
    # FilePond might handle this client-side, but server-side check is crucial.
    MAX_PHOTO_SIZE = current_app.config.get('MAX_PROFILE_PHOTO_SIZE_MB', 2) * 1024 * 1024 # e.g., 2MB
    file_storage.seek(0, os.SEEK_END)
    file_length = file_storage.tell()
    file_storage.seek(0) # Reset cursor
    if file_length > MAX_PHOTO_SIZE:
        flash(f"Profile photo exceeds maximum size of {MAX_PHOTO_SIZE / (1024*1024):.0f}MB.", "danger")
        app.logger.warning(f"Profile photo upload rejected for user {current_user.id if current_user.is_authenticated else 'Unknown'}: File too large ({file_length} bytes).")
        return None # Indicate failure

    # Generate a unique filename using UUID to prevent collisions and obscure original name
    unique_filename = str(uuid.uuid4()) + '.' + file_ext
    save_path_full = os.path.join(upload_folder, unique_filename)

    try:
        file_storage.save(save_path_full)
        app.logger.info(f"Profile photo '{unique_filename}' saved to '{save_path_full}' for user {current_user.id if current_user.is_authenticated else 'Unknown'}.")
        # Return the path relative to the 'static' folder for use in url_for()
        # e.g., uploads/profile_photos/unique_filename.jpg
        # This assumes your UPLOAD_PHOTO_FOLDER is under 'static'.
        # Adjust if your static file serving or UPLOAD_PHOTO_FOLDER structure is different.
        # The path stored in User.profile_photo_url should be relative from 'static'.
        # Example: if app.root_path is /srv/app, and upload_folder is /srv/app/static/uploads/profile_photos
        # then relative_path should be uploads/profile_photos/unique_filename.jpg
        
        # Construct the relative path from the 'static' folder correctly
        static_folder_path = os.path.join(current_app.root_path, 'static')
        relative_path = os.path.relpath(save_path_full, static_folder_path)
        # On Windows, relpath might use backslashes; convert to forward slashes for URLs
        return relative_path.replace(os.sep, '/')

    except Exception as e:
        app.logger.error(f"Error saving profile photo '{unique_filename}': {e}", exc_info=True)
        flash("An error occurred while saving the profile photo. Please try again.", "danger")
        # Optionally, attempt to clean up if file was partially saved
        if os.path.exists(save_path_full):
            try:
                os.remove(save_path_full)
            except Exception as cleanup_e:
                app.logger.error(f"Failed to cleanup partially saved photo {save_path_full}: {cleanup_e}")
        return None # Indicate failure

# START MODIFICATION (create_social_channel route)
@app.route("/social/create_channel", methods=["GET", "POST"])
@login_required
# Define who can create channels (e.g., teachers, hr_ceo, system_admin)
@role_required("hr_ceo", "system_admin", "teacher") 
def create_social_channel():
    form = CreateChannelForm() # CreateChannelForm from app.py Part 4
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        profile_photo_relative_path = None
        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                # save_profile_photo helper should be suitable for channel photos too,
                # or create a save_channel_photo variant if paths/sizes differ.
                profile_photo_relative_path = save_profile_photo(form.profile_photo.data)
                if not profile_photo_relative_path:
                    # Error flashed by helper
                    return render_template("social/channels/create_channel.html", form=form, title="Create New Channel - Nexus")
            except Exception as e:
                app.logger.error(f"Error saving channel profile photo for user {current_user.id}: {e}", exc_info=True)
                flash("An unexpected error occurred while uploading the profile photo.", "danger")
                return render_template("social/channels/create_channel.html", form=form, title="Create New Channel - Nexus")
        
        try:
            # Check for existing channel name (case-insensitive)
            existing_channel = db.session.scalar(
                select(Channel).filter(func.lower(Channel.name) == func.lower(form.name.data.strip()))
            )
            if existing_channel:
                form.name.errors.append("A channel with this name already exists.")
                # Cleanup uploaded photo if name conflict
                if profile_photo_relative_path:
                    try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                    except: pass
                return render_template("social/channels/create_channel.html", form=form, title="Create New Channel - Nexus")

            new_channel = Channel(
                name=form.name.data.strip(),
                bio=form.bio.data.strip() if form.bio.data else None,
                profile_photo_url=profile_photo_relative_path,
                owner_id=current_user.id,
                social_category_id=form.social_category_id.data,
                type=form.channel_type.data, # 'public' or 'private'
                allow_comments=form.allow_comments.data,
                allow_reactions=form.allow_reactions.data,
                created_at=datetime.now(timezone.utc),
                is_active=True # New channels are active
            )
            db.session.add(new_channel)
            db.session.commit() # Commit to get new_channel.id

            # Automatically subscribe the owner
            owner_subscription = ChannelSubscriber(
                channel_id=new_channel.id,
                user_id=current_user.id,
                role='owner', # Owner role in the channel
                subscribed_at=datetime.now(timezone.utc)
            )
            db.session.add(owner_subscription)
            db.session.commit()

            flash(f"Channel '{new_channel.name}' created successfully!", "success")
            app.logger.info(f"User {current_user.username} created channel '{new_channel.name}' (ID: {new_channel.id}).")
            return redirect(url_for("view_social_channel", channel_id=new_channel.id))

        except IntegrityError: # Should be caught by name check, but as fallback
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup photo if DB error
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            flash("A channel with this name already exists or another database error occurred.", "danger")
        except Exception as e:
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup photo
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            app.logger.error(f"Error creating channel by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
            
    return render_template("social/channels/create_channel.html", 
                           form=form, 
                           title="Create New Channel - Nexus")

@app.route("/social/channels/<int:channel_id>/posts") # GET request
@login_required
def get_channel_posts_paginated(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    # Permission check (same as view_social_channel)
    user_channel_role = current_user.get_channel_role(channel)
    if channel.type == 'private' and not user_channel_role:
        return jsonify({"success": False, "error": "Access denied to private channel."}), 403

    page = request.args.get('page', 1, type=int)
    per_page_posts = 10 # Should match the initial load in view_social_channel

    posts_query = (
        select(ChannelPost)
        .where(ChannelPost.channel_id == channel.id)
        .options(
            joinedload(ChannelPost.author).joinedload(User.role), 
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments).joinedload(ChannelComment.author),
            joinedload(ChannelPost.reactions)
        )
        .order_by(ChannelPost.timestamp.desc())
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts_on_page = pagination.items

    posts_html = ""
    if posts_on_page:
        # Create a temporary list of rendered post items
        rendered_posts_list = []
        for post_item in posts_on_page:
            rendered_posts_list.append(
                render_template("partials/_social_post_item.html", 
                                post=post_item, 
                                current_user=current_user)
            )
        posts_html = "".join(rendered_posts_list) # Join all rendered HTML strings

    return jsonify({
        "success": True,
        "posts_html": posts_html, # The rendered HTML for the posts
        "has_next_page": pagination.has_next,
        "next_page_num": pagination.next_num if pagination.has_next else None,
        "current_page": pagination.page
    })

@app.route("/social/channels/<int:channel_id>/subscribe", methods=["POST"])
@login_required
def ajax_subscribe_channel(channel_id): # Renamed to indicate AJAX
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    if current_user.is_channel_member(channel):
        return jsonify({"success": False, "error": "You are already a member/subscriber."}), 400

    if channel.type != 'public': # For now, only direct subscribe to public
        return jsonify({"success": False, "error": "This is a private channel. Subscription by invite/approval only."}), 403
        
    try:
        new_subscriber = ChannelSubscriber(
            channel_id=channel.id,
            user_id=current_user.id,
            role='subscriber',
            subscribed_at=datetime.now(timezone.utc)
        )
        db.session.add(new_subscriber)
        db.session.commit()
        
        new_subscriber_count = channel.subscribers.count() # Recalculate count
        app.logger.info(f"User {current_user.username} AJAX subscribed to channel {channel.id}.")
        return jsonify({
            "success": True, 
            "message": f"Successfully subscribed to '{channel.name}'.",
            "new_subscriber_count": new_subscriber_count
        }), 200
    except IntegrityError: # Should be caught by first check, but safety
        db.session.rollback()
        return jsonify({"success": False, "error": "Already subscribed (Integrity)."}), 400
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error AJAX subscribing user {current_user.id} to channel {channel.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error during subscription."}), 500

@app.route("/social/channels/<int:channel_id>/unsubscribe", methods=["POST"])
@login_required
def ajax_unsubscribe_channel(channel_id): # Renamed for AJAX
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    subscriber_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(channel_id=channel.id, user_id=current_user.id)
    )

    if not subscriber_entry:
        return jsonify({"success": False, "error": "You are not subscribed to this channel."}), 400

    if subscriber_entry.role == 'owner':
        owner_count = db.session.scalar(
            select(func.count(ChannelSubscriber.user_id))
            .where(ChannelSubscriber.channel_id == channel.id, ChannelSubscriber.role == 'owner')
        ) or 0
        if owner_count <= 1:
            return jsonify({"success": False, "error": "You are the only owner. Transfer ownership before leaving."}), 403
            
    try:
        db.session.delete(subscriber_entry)
        db.session.commit()
        new_subscriber_count = channel.subscribers.count()
        app.logger.info(f"User {current_user.username} AJAX unsubscribed from channel {channel.id}.")
        return jsonify({
            "success": True, 
            "message": f"Successfully unsubscribed from '{channel.name}'.",
            "new_subscriber_count": new_subscriber_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error AJAX unsubscribing user {current_user.id} from channel {channel.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error during unsubscription."}), 500

@app.route("/social/channels/posts/<int:post_id>/react", methods=["POST"])
@login_required
def react_channel_post(post_id):
    post = db.get_or_404(ChannelPost, post_id, description="Post not found.")
    channel = post.channel

    if not channel.is_active or (not channel.allow_reactions and not current_user.get_channel_role(channel) in ['owner','admin']):
        return jsonify({"success": False, "error": "Reactions are disabled for this post or channel."}), 403

    if not current_user.is_channel_member(channel):
        return jsonify({"success": False, "error": "You must be a channel subscriber to react."}), 403

    data = request.get_json()
    emoji = data.get("emoji", "").strip()

    if not emoji: # Basic validation, can be more specific
        return jsonify({"success": False, "error": "Emoji is required."}), 400
    
    # For simplicity, allowing only a few known emojis. Expand as needed.
    ALLOWED_REACTION_EMOJIS = ["", "", "", "", "", ""]
    if emoji not in ALLOWED_REACTION_EMOJIS:
        return jsonify({"success": False, "error": "Invalid reaction emoji."}), 400

    try:
        existing_reaction = db.session.scalar(
            select(ChannelReaction).where(
                ChannelReaction.post_id == post.id,
                ChannelReaction.user_id == current_user.id,
                ChannelReaction.emoji == emoji # Check if user already reacted with this specific emoji
            )
        )

        user_reacted_with_this_emoji = False
        if existing_reaction:
            db.session.delete(existing_reaction)
            action_message = "Reaction removed."
            user_reacted_with_this_emoji = False
        else:
            # Optional: If user has another reaction, remove it before adding new one (single reaction per user per post)
            # current_user_any_reaction = db.session.scalar(
            #     select(ChannelReaction).where(ChannelReaction.post_id == post.id, ChannelReaction.user_id == current_user.id)
            # )
            # if current_user_any_reaction:
            #     db.session.delete(current_user_any_reaction)
            
            new_reaction = ChannelReaction(
                post_id=post.id,
                user_id=current_user.id,
                emoji=emoji,
                created_at=datetime.now(timezone.utc)
            )
            db.session.add(new_reaction)
            action_message = "Reaction added."
            user_reacted_with_this_emoji = True
        
        db.session.commit()

        # Get updated count for this specific emoji
        new_count_for_emoji = db.session.scalar(
            select(func.count(ChannelReaction.id)).where(
                ChannelReaction.post_id == post.id,
                ChannelReaction.emoji == emoji
            )
        ) or 0
        
        app.logger.info(f"User {current_user.username} {action_message.lower()} emoji '{emoji}' on channel post {post.id}.")
        return jsonify({
            "success": True, 
            "message": action_message,
            "emoji": emoji, # Send back the emoji for UI update
            "new_count": new_count_for_emoji,
            "user_reacted": user_reacted_with_this_emoji # True if added, False if removed
        }), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error reacting to channel post {post.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error processing reaction."}), 500
                           
@app.route("/social/channels/posts/<int:post_id>/comment", methods=["POST"])
@login_required
def add_channel_post_comment(post_id):
    post = db.get_or_404(ChannelPost, post_id, description="Post not found.")
    channel = post.channel # Get the channel from the post

    if not channel.is_active or (not channel.allow_comments and not current_user.get_channel_role(channel) in ['owner','admin']):
        return jsonify({"success": False, "error": "Comments are disabled for this post or channel."}), 403

    # Permission to comment (basic: any subscriber if channel allows comments)
    if not current_user.is_channel_member(channel): # Assumes User.is_channel_member helper
        return jsonify({"success": False, "error": "You must be a channel subscriber to comment."}), 403

    data = request.get_json()
    content = data.get("content", "").strip()

    if not content:
        return jsonify({"success": False, "error": "Comment content cannot be empty."}), 400
    if len(content) > 500: # Max comment length
        return jsonify({"success": False, "error": "Comment is too long (max 500 characters)."}), 400

    try:
        new_comment = ChannelComment(
            post_id=post.id,
            author_id=current_user.id,
            content=content,
            timestamp=datetime.now(timezone.utc)
        )
        db.session.add(new_comment)
        db.session.commit()
        app.logger.info(f"User {current_user.username} added comment ID {new_comment.id} to channel post {post.id}.")

        # Eager load author for rendering the partial
        comment_for_render = db.session.query(ChannelComment).options(
            joinedload(ChannelComment.author).joinedload(User.role)
        ).get(new_comment.id)

        comment_html = render_template("partials/_social_comment_item.html", 
                                       comment=comment_for_render, 
                                       current_user=current_user,
                                       post=post) # Pass post if partial needs it for context

        return jsonify({
            "success": True, 
            "message": "Comment posted!", 
            "comment_html": comment_html
        }), 201
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error adding comment to channel post {post.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error posting comment."}), 500

@app.route("/social/channels/posts/<int:post_id>/comments/<int:comment_id>/delete", methods=["POST"])
@login_required
def delete_channel_post_comment(post_id, comment_id):
    comment = db.get_or_404(ChannelComment, comment_id, description="Comment not found.")
    post = comment.post # Assumes comment.post relationship
    if not post or post.id != post_id:
        return jsonify({"success": False, "error": "Comment does not belong to this post."}), 400
    
    channel = post.channel

    # Permission to delete comment: comment author OR channel owner/admin OR post author
    is_comment_author = (comment.author_id == current_user.id)
    is_post_author = (post.author_id == current_user.id)
    user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner_or_admin = user_channel_role in ['owner', 'admin']

    if not (is_comment_author or is_post_author or is_channel_owner_or_admin):
        return jsonify({"success": False, "error": "You do not have permission to delete this comment."}), 403

    try:
        db.session.delete(comment)
        db.session.commit()
        app.logger.info(f"User {current_user.username} deleted comment ID {comment.id} from channel post {post.id}.")
        return jsonify({"success": True, "message": "Comment deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting comment {comment.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error deleting comment."}), 500

@app.route("/social/channels/<int:channel_id>/create_post", methods=["POST"])
@login_required
def create_channel_post(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    if not channel.is_active:
        return jsonify({"success": False, "error": "This channel is not active."}), 403

    # Permission to post (owner, admin, or if channel allows all subscribers - basic for now)
    user_channel_role = current_user.get_channel_role(channel) # Helper from User model
    is_owner = (channel.owner_id == current_user.id)
    is_admin_in_channel = (user_channel_role == 'admin')
    
    # Basic permission: Owner or Admin of the channel can post.
    # Future: Add channel.allow_all_subscribers_to_post setting check
    can_post = is_owner or is_admin_in_channel 
    if not can_post:
        return jsonify({"success": False, "error": "You do not have permission to post in this channel."}), 403

    # Use PostContentForm for validation (text OR file)
    # The form fields are 'content' and 'attached_file'
    form = PostContentForm(request.form) # Pass request.form for text fields
    # File data is in request.files, not request.form for WTForms FileField
    # Manually assign file data to form field if needed for form validation,
    # or handle file separately after text validation.

    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name) # Get by field name

    # Validate: content OR file is required
    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Post content or a file must be provided."}), 400

    # Validate text content length if present
    if form.content.data and not form.content.validate(form): # Trigger validation for content
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    # Handle file upload if present
    if file_storage and file_storage.filename:
        try:
            # save_uploaded_file should return a File DB object (uncommitted) or None
            uploaded_file_obj = save_uploaded_file(file_storage) # Your helper from app.py Part 3/12
            if not uploaded_file_obj:
                # Error (e.g. file type/size) should be flashed by helper, or return specific error here
                return jsonify({"success": False, "error": "File upload failed. Check file type or size."}), 400
        except Exception as e:
            app.logger.error(f"Error processing uploaded file for channel post by {current_user.username}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Error processing uploaded file."}), 500
            
    try:
        new_post = ChannelPost(
            channel_id=channel.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj: # If file was uploaded, add it to session with post
            db.session.add(uploaded_file_obj) 
            
        db.session.add(new_post)
        db.session.commit() # Commits post and file object if new

        app.logger.info(f"User {current_user.username} created post ID {new_post.id} in channel {channel.id}.")

        # Eagerly load necessary relationships for rendering the partial
        # This ensures that when render_template is called, all data is available
        post_for_render = db.session.query(ChannelPost).options(
            joinedload(ChannelPost.author).joinedload(User.role),
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments), # For count
            joinedload(ChannelPost.reactions) # For count
        ).get(new_post.id)


        # Render the HTML for the new post item
        post_html = render_template("partials/_social_post_item.html", 
                                    post=post_for_render, 
                                    current_user=current_user) # Pass current_user if partial needs it

        return jsonify({
            "success": True, 
            "message": "Post created successfully!",
            "post_html": post_html,
            # Optionally send structured post_data if client-side rendering is preferred sometimes
            # "post_data": { ... serialized post data ... }
        }), 201 # 201 Created

    except Exception as e:
        db.session.rollback()
        # If a file was uploaded but DB commit failed, it's good practice to delete the orphaned file
        if uploaded_file_obj and uploaded_file_obj.filepath:
            try:
                full_file_path = os.path.join(current_app.static_folder, uploaded_file_obj.filepath)
                if os.path.exists(full_file_path):
                    os.remove(full_file_path)
                    app.logger.info(f"Cleaned up orphaned file: {uploaded_file_obj.filepath}")
            except Exception as cleanup_e:
                app.logger.error(f"Error cleaning up orphaned file {uploaded_file_obj.filepath}: {cleanup_e}")
        
        app.logger.error(f"Error creating channel post in channel {channel.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error creating post."}), 500

@app.route("/social/channels/<int:channel_id>") # Add methods=['GET'] if it only handles GET for now
@login_required
def view_social_channel(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    if not channel.is_active:
        flash(f"Channel '{channel.name}' is currently not active.", "warning")
        return redirect(url_for('social_channel_list'))

    # Permission to view: Public channels are viewable by all logged-in users.
    # Private channels require membership (or ownership/admin).
    user_channel_role = current_user.get_channel_role(channel) # Helper from User model
    is_owner = (channel.owner_id == current_user.id)
    is_admin = (user_channel_role == 'admin')
    is_subscribed_member = (user_channel_role is not None) # Any role means they are a subscriber

    if channel.type == 'private' and not is_subscribed_member:
        flash(f"'{channel.name}' is a private channel. You must be a subscriber to view its content.", "warning")
        return redirect(url_for('social_channel_discover'))
        
    # Fetch initial posts (e.g., paginated)
    page = request.args.get('page', 1, type=int)
    per_page_posts = 10 # Number of posts per page load
    
    posts_query = (
        select(ChannelPost)
        .where(ChannelPost.channel_id == channel.id)
        .options(
            joinedload(ChannelPost.author).joinedload(User.role), 
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments).joinedload(ChannelComment.author), # Load comments and their authors
            joinedload(ChannelPost.reactions) # Load reactions
        )
        .order_by(ChannelPost.timestamp.desc()) # Newest posts first
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts = pagination.items
    
    # Form for creating new posts in this channel
    post_form = PostContentForm() # Your PostContentForm for creating posts

    # Determine if current user can post (owner, admin, or if channel settings allow subscribers - future enhancement)
    can_post_in_channel = is_owner or is_admin # Basic permission for now
    # More advanced: if channel.allow_all_subscribers_to_post and is_subscribed_member: can_post_in_channel = True

    return render_template("social/channels/view_channel.html",
                           channel=channel,
                           posts=posts,
                           pagination=pagination, # Pass pagination object for "Load More"
                           post_form=post_form,
                           is_owner=is_owner,
                           is_admin=is_admin,
                           is_subscribed=is_subscribed_member,
                           can_post_in_channel=can_post_in_channel,
                           title=f"{channel.name} - Channel - Nexus")

@app.route("/social/channels")
@login_required
def social_channel_list():
    # Fetch channels current user owns
    my_owned_channels_query = (
        select(Channel)
        .where(Channel.owner_id == current_user.id, Channel.is_active == True)
        .options(joinedload(Channel.social_category), joinedload(Channel.owner)) # Eager load for card
        .order_by(Channel.name.asc())
    )
    my_owned_channels = db.session.scalars(my_owned_channels_query).all()

    # Fetch channels current user is subscribed to (but does not own)
    my_subscribed_channels_query = (
        select(ChannelSubscriber)
        .join(Channel) # Join to Channel table
        .where(
            ChannelSubscriber.user_id == current_user.id,
            Channel.owner_id != current_user.id, # Exclude owned channels from this list
            Channel.is_active == True
        )
        .options(joinedload(ChannelSubscriber.channel).joinedload(Channel.social_category),
                 joinedload(ChannelSubscriber.channel).joinedload(Channel.owner)) # Eager load for card
        .order_by(Channel.name.asc())
    )
    my_subscribed_channels = db.session.scalars(my_subscribed_channels_query).all()
    
    return render_template("social/channels/list.html",
                           my_owned_channels=my_owned_channels,
                           my_subscribed_channels=my_subscribed_channels,
                           title="My Channels - Nexus")

# END MODIFICATION (create_social_channel route)
@app.route("/social/create_group", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin", "teacher") # Define who can create groups
def create_social_group():
    form = CreateGroupForm() # Your CreateGroupForm from app.py Part 4

    if form.validate_on_submit():
        profile_photo_relative_path = None
        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                profile_photo_relative_path = save_profile_photo(form.profile_photo.data) # Reusing helper
                if not profile_photo_relative_path:
                    return render_template("social/groups/create_group.html", form=form, title="Create New Group - Nexus")
            except Exception as e:
                app.logger.error(f"Error saving group profile photo for group by user {current_user.id}: {e}", exc_info=True)
                flash("An unexpected error occurred while uploading the profile photo.", "danger")
                return render_template("social/groups/create_group.html", form=form, title="Create New Group - Nexus")

        try:
            # Check for existing group name (case-insensitive)
            existing_group = db.session.scalar(
                select(SocialGroup).filter(func.lower(SocialGroup.name) == func.lower(form.name.data.strip()))
            )
            if existing_group:
                form.name.errors.append("A group with this name already exists.")
                if profile_photo_relative_path: # Cleanup
                    try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                    except: pass
                return render_template("social/groups/create_group.html", form=form, title="Create New Group - Nexus")

            new_group = SocialGroup(
                name=form.name.data.strip(),
                description=form.bio.data.strip() if form.bio.data else None, # Form uses 'bio'
                profile_photo_url=profile_photo_relative_path,
                owner_id=current_user.id,
                is_active=True
                # Group type (public/private) if added to model and form
            )
            db.session.add(new_group)
            db.session.commit() # Commit to get new_group.id

            # Automatically make the owner a member
            owner_membership = SocialGroupMember(
                group_id=new_group.id,
                user_id=current_user.id,
                role='owner',
                joined_at=datetime.now(timezone.utc)
            )
            db.session.add(owner_membership)
            db.session.commit()

            flash(f"Group '{new_group.name}' created successfully!", "success")
            app.logger.info(f"User {current_user.username} created group '{new_group.name}' (ID: {new_group.id}).")
            return redirect(url_for("view_social_group", group_id=new_group.id))

        except IntegrityError: # Fallback
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            flash("A group with this name already exists or another database error occurred.", "danger")
        except Exception as e:
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            app.logger.error(f"Error creating group by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
            
    return render_template("social/groups/create_group.html", 
                           form=form, 
                           title="Create New Social Group - Nexus")
# START MODIFICATION (edit_social_channel route)
@app.route("/social/channels/<int:channel_id>/edit", methods=["GET", "POST"])
@login_required
def edit_social_channel(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    
    # Authorization: Owner, channel admin, or system-level admin (hr_ceo, system_admin)
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (channel.owner_id == current_user.id or user_channel_role == 'admin' or is_global_admin):
        flash("You do not have permission to edit this channel.", "danger")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    form = EditChannelForm(obj=channel) # Pre-populate with channel data on GET
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        old_profile_photo_relative_path = channel.profile_photo_url
        new_profile_photo_relative_path = None

        if form.profile_photo.data and form.profile_photo.data.filename: # Check if new photo uploaded
            try:
                saved_relative_path = save_profile_photo(form.profile_photo.data)
                if saved_relative_path:
                    new_profile_photo_relative_path = saved_relative_path
                else: # Error flashed by save_profile_photo
                    return render_template("social/channels/edit_channel.html", form=form, channel=channel, title=f"Edit Channel: {channel.name} - Nexus")
            except Exception as e:
                app.logger.error(f"Error processing channel photo upload for channel {channel_id}: {e}", exc_info=True)
                flash("An error occurred with the photo upload.", "danger")
                return render_template("social/channels/edit_channel.html", form=form, channel=channel, title=f"Edit Channel: {channel.name} - Nexus")

        try:
            # Check for name conflict if name changed
            new_name = form.name.data.strip()
            if new_name.lower() != channel.name.lower():
                existing_channel_with_new_name = db.session.scalar(
                    select(Channel).filter(
                        Channel.id != channel.id,
                        func.lower(Channel.name) == func.lower(new_name)
                    )
                )
                if existing_channel_with_new_name:
                    form.name.errors.append("Another channel with this name already exists.")
                    # Cleanup newly uploaded photo if name conflict
                    if new_profile_photo_relative_path and old_profile_photo_relative_path != new_profile_photo_relative_path:
                        try: os.remove(os.path.join(current_app.static_folder, new_profile_photo_relative_path))
                        except: pass
                    return render_template("social/channels/edit_channel.html", form=form, channel=channel, title=f"Edit Channel: {channel.name} - Nexus")
            
            channel.name = new_name
            channel.bio = form.bio.data.strip() if form.bio.data else None
            channel.social_category_id = form.social_category_id.data
            channel.allow_comments = form.allow_comments.data
            channel.allow_reactions = form.allow_reactions.data
            # channel.type is not typically editable after creation, but if it is:
            # channel.type = form.channel_type.data # Assuming channel_type is on EditChannelForm

            if new_profile_photo_relative_path:
                channel.profile_photo_url = new_profile_photo_relative_path
            
            # channel.updated_at = datetime.now(timezone.utc) # If you have an updated_at field

            db.session.commit()

            # Delete old photo if new one was successfully saved and different
            if new_profile_photo_relative_path and old_profile_photo_relative_path and \
               old_profile_photo_relative_path != new_profile_photo_relative_path and \
               not old_profile_photo_relative_path.startswith('img/placeholders/'):
                old_photo_full_path = os.path.join(current_app.static_folder, old_profile_photo_relative_path)
                if os.path.exists(old_photo_full_path):
                    try:
                        os.remove(old_photo_full_path)
                        app.logger.info(f"Deleted old channel photo: {old_profile_photo_relative_path} for channel {channel.id}")
                    except Exception as e:
                        app.logger.error(f"Error deleting old channel photo {old_profile_photo_relative_path}: {e}")

            flash(f"Channel '{channel.name}' updated successfully!", "success")
            app.logger.info(f"User {current_user.username} edited channel ID {channel.id}.")
            return redirect(url_for("view_social_channel", channel_id=channel.id))

        except IntegrityError: # Fallback if name check fails due to race condition
            db.session.rollback()
            flash("Update failed. A channel with the new name might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing channel {channel.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the channel.", "danger")

    return render_template("social/channels/edit_channel.html", 
                           form=form, 
                           channel=channel, 
                           title=f"Edit Channel: {channel.name} - Nexus")
@app.route("/social/groups/<int:group_id>/edit", methods=["GET", "POST"])
@login_required
def edit_social_group(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (group.owner_id == current_user.id or user_group_role == 'admin' or is_global_admin):
        flash("You do not have permission to edit this group.", "danger")
        return redirect(url_for("view_social_group", group_id=group.id))

    form = EditGroupForm(obj=group) # Your EditGroupForm

    if form.validate_on_submit():
        old_profile_photo_relative_path = group.profile_photo_url
        new_profile_photo_relative_path = None

        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                saved_relative_path = save_profile_photo(form.profile_photo.data)
                if saved_relative_path: new_profile_photo_relative_path = saved_relative_path
                else: return render_template("social/groups/edit_group.html", form=form, group=group, title=f"Edit Group: {group.name} - Nexus")
            except Exception as e:
                app.logger.error(f"Error saving updated group photo for group {group_id}: {e}", exc_info=True)
                flash("Error uploading group photo.", "danger")
                return render_template("social/groups/edit_group.html", form=form, group=group, title=f"Edit Group: {group.name} - Nexus")
        
        try:
            new_name = form.name.data.strip()
            if new_name.lower() != group.name.lower():
                existing_group_with_new_name = db.session.scalar(
                    select(SocialGroup).filter(SocialGroup.id != group.id, func.lower(SocialGroup.name) == func.lower(new_name))
                )
                if existing_group_with_new_name:
                    form.name.errors.append("Another group with this name already exists.")
                    if new_profile_photo_relative_path: # Cleanup
                        try: os.remove(os.path.join(current_app.static_folder, new_profile_photo_relative_path))
                        except: pass
                    return render_template("social/groups/edit_group.html", form=form, group=group, title=f"Edit Group: {group.name} - Nexus")
            
            group.name = new_name
            group.description = form.bio.data.strip() if form.bio.data else None # Form field is 'bio'
            if new_profile_photo_relative_path:
                group.profile_photo_url = new_profile_photo_relative_path
            
            # group.is_active = form.is_active.data # If you add is_active to EditGroupForm
            # group.updated_at = datetime.now(timezone.utc)

            db.session.commit()

            if new_profile_photo_relative_path and old_profile_photo_relative_path and \
               old_profile_photo_relative_path != new_profile_photo_relative_path and \
               not old_profile_photo_relative_path.startswith('img/placeholders/'):
                try: os.remove(os.path.join(current_app.static_folder, old_profile_photo_relative_path))
                except Exception as e: app.logger.error(f"Error deleting old group photo {old_profile_photo_relative_path}: {e}")

            flash(f"Group '{group.name}' updated successfully!", "success")
            return redirect(url_for("view_social_group", group_id=group.id))
        except IntegrityError: # Fallback
            db.session.rollback()
            flash("Update failed. A group with this name might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing group {group.id}: {e}", exc_info=True)
            flash("An unexpected error occurred.", "danger")
            
    return render_template("social/groups/edit_group.html", 
                           form=form, 
                           group=group, 
                           title=f"Edit Group: {group.name} - Nexus")

@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_user_id>/update_role", methods=["POST"])
@login_required
def ajax_update_channel_subscriber_role(channel_id, subscriber_user_id):
    channel = db.get_or_404(Channel, channel_id)
    subscriber_to_update = db.get_or_404(User, subscriber_user_id, description="Subscriber user not found.")
    
    subscription_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(channel_id=channel.id, user_id=subscriber_user_id)
    )
    if not subscription_entry:
        return jsonify({"success": False, "error": "User is not subscribed to this channel."}), 404

    # Authorization: Current user must be channel owner, or channel admin (and not targeting owner), or global admin
    current_user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner = (channel.owner_id == current_user.id)
    is_current_user_channel_admin = (current_user_channel_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    can_manage = False
    if is_global_admin or is_channel_owner:
        can_manage = True
    elif is_current_user_channel_admin and subscription_entry.role != 'owner': # Admin cannot change owner's role
        can_manage = True
    
    if not can_manage:
        return jsonify({"success": False, "error": "You do not have permission to change this subscriber's role."}), 403

    if subscriber_user_id == current_user.id: # Prevent user from changing their own role via this AJAX
        return jsonify({"success": False, "error": "You cannot change your own role here."}), 403
    if channel.owner_id == subscriber_user_id and not is_channel_owner: # Only owner can change owner role (though usually done via transfer)
         return jsonify({"success": False, "error": "Only the channel owner can modify the owner role."}), 403


    data = request.get_json()
    new_role = data.get('role', '').strip().lower()
    valid_roles = ['admin', 'subscriber'] # Owner role typically set on creation or via "transfer ownership"
    
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role '{new_role}'. Valid roles are 'admin', 'subscriber'."}), 400

    old_role = subscription_entry.role
    if old_role == new_role:
        return jsonify({"success": True, "message": "Role is already set to this value."}), 200

    try:
        subscription_entry.role = new_role
        db.session.commit()
        app.logger.info(f"User {current_user.username} updated role of user {subscriber_user_id} in channel {channel_id} to '{new_role}'.")
        return jsonify({
            "success": True, 
            "message": f"Role for {subscriber_to_update.full_name or subscriber_to_update.username} updated to {new_role.title()}.",
            "user_id": subscriber_user_id,
            "new_role": new_role
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating channel subscriber role for user {subscriber_user_id} in channel {channel_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error updating role.", "previous_role": old_role}), 500


@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_user_id>/remove", methods=["POST"])
@login_required
def ajax_remove_channel_subscriber(channel_id, subscriber_user_id):
    channel = db.get_or_404(Channel, channel_id)
    # subscriber_user_to_remove = db.get_or_404(User, subscriber_user_id) # Not needed if we just delete the entry
    
    subscription_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(channel_id=channel.id, user_id=subscriber_user_id)
    )
    if not subscription_entry:
        return jsonify({"success": True, "message": "User was not subscribed or already removed."}), 200 # Idempotent

    # Authorization (similar to update_role but with different nuances for removal)
    current_user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner = (channel.owner_id == current_user.id)
    is_current_user_channel_admin = (current_user_channel_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if subscriber_user_id == channel.owner_id: # Cannot remove the owner directly
        return jsonify({"success": False, "error": "Channel owner cannot be removed. Transfer ownership first."}), 403
    if subscriber_user_id == current_user.id: # User should use "Unsubscribe" action, not be removed by self here
        return jsonify({"success": False, "error": "Use the 'Unsubscribe' option to leave the channel."}), 403

    can_remove = False
    if is_global_admin or is_channel_owner:
        can_remove = True
    elif is_current_user_channel_admin and subscription_entry.role == 'subscriber': # Admin can remove subscribers
        can_remove = True
        
    if not can_remove:
        return jsonify({"success": False, "error": "You do not have permission to remove this subscriber."}), 403

    try:
        subscriber_name_for_log = subscription_entry.user.full_name or subscription_entry.user.username
        db.session.delete(subscription_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} removed subscriber {subscriber_user_id} ({subscriber_name_for_log}) from channel {channel.id}.")
        
        # Get updated subscriber count for UI update
        new_subscriber_count = channel.subscribers.count()

        return jsonify({
            "success": True, 
            "message": f"{subscriber_name_for_log} removed from channel.",
            "user_id": subscriber_user_id,
            "new_subscriber_count": new_subscriber_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing subscriber {subscriber_user_id} from channel {channel_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error removing subscriber."}), 500
# Route to view and manage channel subscribers
@app.route("/social/channels/<int:channel_id>/manage_subscribers")
@login_required
def manage_channel_subscribers(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    # Authorization: Owner, channel admin, or system-level admin
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (channel.owner_id == current_user.id or user_channel_role == 'admin' or is_global_admin):
        flash("You do not have permission to manage subscribers for this channel.", "danger")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    subscribers_query = (
        select(ChannelSubscriber)
        .where(ChannelSubscriber.channel_id == channel.id)
        .join(ChannelSubscriber.user) # Explicit join to User for ordering by User.full_name
        .options(
            joinedload(ChannelSubscriber.user).joinedload(User.role) # Load user and their global role
        )
        .order_by(
            case( # Custom order for channel roles
                (ChannelSubscriber.role == 'owner', 1),
                (ChannelSubscriber.role == 'admin', 2),
                (ChannelSubscriber.role == 'subscriber', 3),
                else_=4
            ).asc(),
            User.full_name.asc()
        )
    )
    subscribers = db.session.scalars(subscribers_query).all()
    
    return render_template("social/channels/manage_subscribers.html",
                           channel=channel,
                           subscribers=subscribers,
                           user_channel_role=user_channel_role, # Current user's role in this channel
                           title=f"Manage Subscribers - {channel.name} - Nexus")

# Endpoint to change a subscriber's role (AJAX or POST)
@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_id>/update_role", methods=["POST"])
@login_required
def update_channel_subscriber_role(channel_id, subscriber_id):
    """Updates the role of a channel subscriber (Owner/Admin/SysAdmin/HR only)."""
    channel = db.get_or_404(Channel, channel_id)
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, subscriber_id)) # Get the specific association object

    if not subscriber_entry:
         return jsonify({"success": False, "error": "Subscriber not found in this channel"}), 404

    # Check authorization: User must be owner, admin in the channel, or SysAdmin/HR/CEO
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_channel_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to change subscriber role in channel {channel_id}: User {current_user.id} (Role: {user_channel_role})")
        return jsonify({"success": False, "error": "You do not have permission to change roles"}), 403

    # Get the new role from the request (assuming JSON body with key 'role')
    if not request.is_json:
         return jsonify({"success": False, "error": "Invalid request format"}), 400

    data = request.get_json()
    new_role = data.get('role', '').strip().lower()

    # Validate the requested new role
    valid_roles = ['owner', 'admin', 'subscriber']
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role '{new_role}' provided. Valid roles are: {', '.join(valid_roles)}"}), 400

    # Additional authorization checks:
    # - Owner can set/unset any role (including other admins, but maybe not demote self?)
    # - Admin can set/unset 'subscriber' and 'admin', but NOT 'owner'.
    # - Global admin can do anything (handled by initial is_authorized)

    if not is_global_admin: # Apply specific channel role restrictions
         if user_channel_role != 'owner' and new_role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can assign the 'owner' role"}), 403
         if user_channel_role != 'owner' and subscriber_entry.role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can demote the current owner"}), 403
         if user_channel_role == 'admin' and new_role == 'owner':
              return jsonify({"success": False, "error": "Admins cannot assign the 'owner' role"}), 403
         # Prevent demoting self if you are the *last* owner? Or just prevent demoting self at all?
         # Let's prevent changing your own role here for safety.
         if subscriber_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot change your own role via this endpoint"}), 403 # Needs a separate 'leave channel' / 'transfer ownership' flow

    # Prevent setting the same role again (optional optimization)
    if subscriber_entry.role.lower() == new_role:
         return jsonify({"success": True, "message": f"Role is already '{new_role}'"}), 200


    try:
        # Update the subscriber's role
        subscriber_entry.role = new_role
        db.session.commit()
        app.logger.info(f"Channel {channel_id}: User {current_user.username} (ID: {current_user.id}) changed role of user {subscriber_id} to '{new_role}'.")

        return jsonify({
            "success": True,
            "message": f"Role updated to '{new_role}'",
            "user_id": subscriber_id,
            "new_role": new_role
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating subscriber role in channel {channel_id} for user {subscriber_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to update role"}), 500


# Endpoint to remove a subscriber (AJAX or POST)
@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_id>/remove", methods=["POST"])
@login_required
def remove_channel_subscriber(channel_id, subscriber_id):
    """Removes a subscriber from a channel (Owner/Admin/SysAdmin/HR only)."""
    channel = db.get_or_404(Channel, channel_id)
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, subscriber_id)) # Get the specific association object

    if not subscriber_entry:
         return jsonify({"success": True, "message": "User is not a subscriber (already removed?)"}), 200 # Already gone

    # Check authorization: User must be owner, admin in the channel, or SysAdmin/HR/CEO
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_channel_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to remove subscriber {subscriber_id} from channel {channel_id}: User {current_user.id} (Role: {user_channel_role})")
        return jsonify({"success": False, "error": "You do not have permission to remove subscribers"}), 403

    # Additional authorization checks:
    # - Owner can remove anyone except perhaps themselves (needs separate leave flow)
    # - Admin can remove 'subscriber' role, but NOT 'admin' or 'owner' roles.
    # - Global admin can remove anyone.

    if not is_global_admin:
         if subscriber_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot remove yourself via this endpoint (use leave channel)"}), 403 # Needs separate leave flow
         if user_channel_role == 'admin' and subscriber_entry.role in ['owner', 'admin']:
              return jsonify({"success": False, "error": "Admins cannot remove other admins or owners"}), 403

    # Prevent removing the last owner? This requires more complex logic.
    # For V1, allow removing owner, but the channel might become unmanageable without a new owner.
    # A better flow would be 'transfer ownership' before the owner leaves/is removed.


    try:
        db.session.delete(subscriber_entry) # Delete the association object
        db.session.commit()
        app.logger.info(f"Channel {channel_id}: User {current_user.username} (ID: {current_user.id}) removed user {subscriber_id} (was role: {subscriber_entry.role}).")

        return jsonify({
            "success": True,
            "message": "User removed from channel",
            "user_id": subscriber_id
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing subscriber {subscriber_id} from channel {channel_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to remove user from channel"}), 500


# Endpoint for a user to subscribe to a channel (if public or open)
# This would require a mechanism for public channels or join requests for private ones.
# For V1, let's assume only public channels are joinable via this route, or only owners can add members.
# If membership is invite-only or public-joinable, this route needs to check that.
@app.route("/social/channels/<int:channel_id>/subscribe", methods=["POST"])
@login_required
def subscribe_channel(channel_id):
    """Allows a user to subscribe to a channel (if public or allowed)."""
    channel = db.get_or_404(Channel, channel_id)

    # Check if user is already a member/subscriber
    if current_user.is_channel_member(channel):
        flash("You are already a member of this channel.", "info")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    # Check if channel is public or requires an invite/request
    # For V1, let's assume only public channels are open for self-subscription via this route.
    # Private channels require an owner/admin to add the member (handled in manage_subscribers or separate invite flow).
    if channel.type != 'public':
         flash("This is a private channel. You cannot subscribe directly.", "warning")
         # Redirect to discovery or back to channel view
         return redirect(url_for("social_channel_discovery")) # Or view_social_channel


    try:
        # Create a new subscriber entry with default 'subscriber' role
        new_subscriber = ChannelSubscriber(
            channel_id=channel.id,
            user_id=current_user.id,
            role='subscriber', # Default role for self-subscription
            subscribed_at=datetime.now(timezone.utc)
        )
        db.session.add(new_subscriber)
        db.session.commit()

        flash(f"Successfully subscribed to channel '{channel.name}'.", "success")
        app.logger.info(f"User {current_user.username} subscribed to channel {channel.id}.")
        # Redirect to the channel view page
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    except IntegrityError:
         db.session.rollback()
         # Should be caught by the initial check, but good safety net
         flash("You are already a member of this channel.", "info")
         return redirect(url_for("view_social_channel", channel_id=channel.id))
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error subscribing user {current_user.id} to channel {channel.id}: {e}", exc_info=True)
        flash("An error occurred while subscribing to the channel. Please try again.", "danger")
        return redirect(url_for("social_channel_discovery"))


# Endpoint for a user to unsubscribe from a channel (if not the last owner)
@app.route("/social/channels/<int:channel_id>/unsubscribe", methods=["POST"])
@login_required
def unsubscribe_channel(channel_id):
    """Allows a user to unsubscribe from a channel."""
    channel = db.get_or_404(Channel, channel_id)

    # Fetch the subscriber entry for the current user in this channel
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, current_user.id))

    if not subscriber_entry:
        flash("You are not a member of this channel.", "warning")
        return redirect(url_for("social_channel_discovery")) # Redirect to discovery

    # Prevent the *last* owner from unsubscribing (unless ownership is transferred)
    if subscriber_entry.role == 'owner':
         # Check if this is the only owner left
         owner_count = db.session.scalar(
             select(func.count(ChannelSubscriber.user_id))
             .where(
                 ChannelSubscriber.channel_id == channel.id,
                 ChannelSubscriber.role == 'owner'
             )
         ) or 0 # Use scalar and default 0

         if owner_count <= 1: # If this user is the only owner or one of the last owners
              flash("You are the only owner of this channel. Transfer ownership before leaving.", "danger")
              # Redirect back to channel management page (or view page)
              return redirect(url_for("view_social_channel", channel_id=channel.id)) # Or manage_channel_subscribers


    try:
        db.session.delete(subscriber_entry) # Delete the association object
        db.session.commit()

        flash(f"Successfully unsubscribed from channel '{channel.name}'.", "success")
        app.logger.info(f"User {current_user.username} unsubscribed from channel {channel.id}.")
        # Redirect to channel discovery or user's dashboard
        return redirect(url_for("social_channel_discovery"))

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error unsubscribing user {current_user.id} from channel {channel.id}: {e}", exc_info=True)
        flash("An error occurred while unsubscribing from the channel. Please try again.", "danger")
        # Redirect back to the channel view page on error
        return redirect(url_for("view_social_channel", channel_id=channel.id))

@app.route("/social/channels/discover")
@login_required
def social_channel_discover():
    page = request.args.get('page', 1, type=int)
    per_page = 12 # Number of channels per page for card view
    search_query_param = request.args.get('search_query', '', type=str).strip() # Renamed to avoid conflict
    category_id_filter = request.args.get('category_id', '', type=str) # String from form, convert to int if not empty

    query = (
        select(Channel)
        .where(Channel.type == 'public', Channel.is_active == True) # Only public and active
        .options(
            joinedload(Channel.social_category), 
            joinedload(Channel.owner)
            # REMOVED: joinedload(Channel.subscribers) # This was causing the error
        ) 
    )

    if search_query_param: # Use the renamed variable
        search_term = f"%{search_query_param}%"
        query = query.where(or_(Channel.name.ilike(search_term), Channel.bio.ilike(search_term)))

    selected_category_id_int = None
    if category_id_filter and category_id_filter.isdigit():
        selected_category_id_int = int(category_id_filter)
        query = query.where(Channel.social_category_id == selected_category_id_int)

    query = query.order_by(Channel.name.asc())
    # Line 9794 from the traceback
    pagination = db.paginate(query, page=page, per_page=per_page, error_out=False) 
    discoverable_channels = pagination.items
    
    all_social_categories = db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all()

    # Determine subscription status for displayed channels
    channel_statuses = {}
    if discoverable_channels:
        channel_ids = [c.id for c in discoverable_channels]
        # Fetch subscriptions for the current user for these specific channels
        subscriptions = db.session.scalars(
            select(ChannelSubscriber)
            .where(ChannelSubscriber.user_id == current_user.id, ChannelSubscriber.channel_id.in_(channel_ids))
        ).all()
        subscribed_channel_ids = {s.channel_id for s in subscriptions}
        
        for ch in discoverable_channels:
            channel_statuses[ch.id] = {
                'is_subscribed': ch.id in subscribed_channel_ids,
                'is_owner': ch.owner_id == current_user.id
            }

    return render_template("social/channels/discover.html",
                           discoverable_channels=discoverable_channels,
                           all_social_categories=all_social_categories,
                           pagination=pagination,
                           search_query=search_query_param, # Pass renamed variable
                           selected_category_id=selected_category_id_int, 
                           channel_statuses=channel_statuses,
                           title="Discover Channels - Nexus")
                           
# Route to view and manage group members (Owner/Admin)
@app.route("/social/groups/<int:group_id>/manage_members")
@login_required
def manage_group_members(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (group.owner_id == current_user.id or user_group_role == 'admin' or is_global_admin):
        flash("You do not have permission to manage members for this group.", "danger")
        return redirect(url_for("view_social_group", group_id=group.id))

    members_query = (
        select(SocialGroupMember)
        .where(SocialGroupMember.group_id == group.id)
        .join(SocialGroupMember.user)
        .options(joinedload(SocialGroupMember.user).joinedload(User.role))
        .order_by(
            case(
                (SocialGroupMember.role == 'owner', 1),
                (SocialGroupMember.role == 'admin', 2),
                (SocialGroupMember.role == 'member', 3),
                else_=4
            ).asc(),
            User.full_name.asc()
        )
    )
    members = db.session.scalars(members_query).all()
    
    return render_template("social/groups/manage_members.html",
                           group=group,
                           members=members,
                           user_group_role=user_group_role, # Current user's role in this group
                           title=f"Manage Members - {group.name} - Nexus")

@app.route("/social/groups/<int:group_id>/members/<int:member_user_id>/update_role", methods=["POST"])
@login_required
def ajax_update_group_member_role(group_id, member_user_id):
    group = db.get_or_404(SocialGroup, group_id)
    member_to_update = db.get_or_404(User, member_user_id, description="Member user not found.")
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=member_user_id)
    )
    if not membership_entry:
        return jsonify({"success": False, "error": "User is not a member of this group."}), 404

    # Authorization (similar to channel role update)
    current_user_group_role = current_user.get_group_role(group)
    is_group_owner = (group.owner_id == current_user.id)
    is_current_user_group_admin = (current_user_group_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    can_manage = False
    if is_global_admin or is_group_owner:
        can_manage = True
    elif is_current_user_group_admin and membership_entry.role != 'owner':
        can_manage = True
    
    if not can_manage:
        return jsonify({"success": False, "error": "Permission denied to change role."}), 403
    if member_user_id == current_user.id:
        return jsonify({"success": False, "error": "Cannot change your own role."}), 403
    if group.owner_id == member_user_id and not is_group_owner :
         return jsonify({"success": False, "error": "Only group owner can modify owner role."}), 403


    data = request.get_json()
    new_role = data.get('role', '').strip().lower()
    valid_roles = ['admin', 'member'] # Owner usually by transfer
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role. Valid: {', '.join(valid_roles)}."}), 400
    
    old_role = membership_entry.role
    if old_role == new_role:
        return jsonify({"success": True, "message": "Role is already set."}), 200

    try:
        membership_entry.role = new_role
        db.session.commit()
        app.logger.info(f"User {current_user.username} updated role of user {member_user_id} in group {group_id} to '{new_role}'.")
        return jsonify({
            "success": True, 
            "message": f"Role for {member_to_update.full_name or member_to_update.username} updated to {new_role.title()}.",
            "user_id": member_user_id, "new_role": new_role
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating group member role for {member_user_id} in group {group_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error.", "previous_role": old_role}), 500

@app.route("/social/groups/<int:group_id>/members/<int:member_user_id>/remove", methods=["POST"])
@login_required
def ajax_remove_group_member(group_id, member_user_id):
    group = db.get_or_404(SocialGroup, group_id)
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=member_user_id)
    )
    if not membership_entry:
        return jsonify({"success": True, "message": "User not a member or already removed."}), 200

    # Authorization (similar to channel member removal)
    current_user_group_role = current_user.get_group_role(group)
    is_group_owner = (group.owner_id == current_user.id)
    is_current_user_group_admin = (current_user_group_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if member_user_id == group.owner_id:
        return jsonify({"success": False, "error": "Group owner cannot be removed. Transfer ownership first."}), 403
    if member_user_id == current_user.id:
        return jsonify({"success": False, "error": "Use 'Leave Group' option."}), 403

    can_remove = False
    if is_global_admin or is_group_owner:
        can_remove = True
    elif is_current_user_group_admin and membership_entry.role == 'member':
        can_remove = True
        
    if not can_remove:
        return jsonify({"success": False, "error": "Permission denied to remove member."}), 403

    try:
        member_name_for_log = membership_entry.user.full_name or membership_entry.user.username
        db.session.delete(membership_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} removed member {member_user_id} ({member_name_for_log}) from group {group.id}.")
        new_member_count = group.members.count()
        return jsonify({
            "success": True, "message": f"{member_name_for_log} removed from group.",
            "user_id": member_user_id, "new_member_count": new_member_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing member {member_user_id} from group {group_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/social/groups/<int:group_id>/leave", methods=["POST"])
@login_required
def ajax_leave_social_group(group_id): # Renamed for AJAX
    group = db.get_or_404(SocialGroup, group_id)
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=current_user.id)
    )
    if not membership_entry:
        return jsonify({"success": False, "error": "You are not a member of this group."}), 400

    if membership_entry.role == 'owner':
        owner_count = db.session.scalar(
            select(func.count(SocialGroupMember.user_id)).where(SocialGroupMember.group_id == group.id, SocialGroupMember.role == 'owner')
        ) or 0
        if owner_count <= 1:
            return jsonify({"success": False, "error": "You are the only owner. Transfer ownership before leaving."}), 403
            
    try:
        db.session.delete(membership_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} left group {group.id}.")
        return jsonify({
            "success": True, 
            "message": f"Successfully left group '{group.name}'.",
            "redirect_url": url_for('social_group_list') # Client-side can use this
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} leaving group {group.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error leaving group."}), 500


@app.route("/social/groups/<int:group_id>/members/<int:member_id>/update_role", methods=["POST"])
@login_required
def update_group_member_role(group_id, member_id):
    """Updates the role of a group member (Owner/Admin/SysAdmin/HR only)."""
    group = db.get_or_404(SocialGroup, group_id)
    member_entry = db.session.get(SocialGroupMember, (group_id, member_id)) # Get the specific association object

    if not member_entry:
         return jsonify({"success": False, "error": "Member not found in this group"}), 404

    # Check authorization: User must be owner, admin in the group, or SysAdmin/HR/CEO
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_group_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to change member role in group {group_id}: User {current_user.id} (Role: {user_group_role})")
        return jsonify({"success": False, "error": "You do not have permission to change roles"}), 403

    # Get the new role from the request (assuming JSON body with key 'role')
    if not request.is_json:
         return jsonify({"success": False, "error": "Invalid request format"}), 400

    data = request.get_json()
    new_role = data.get('role', '').strip().lower()

    # Validate the requested new role
    valid_roles = ['owner', 'admin', 'member']
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role '{new_role}' provided. Valid roles are: {', '.join(valid_roles)}"}), 400

    # Additional authorization checks:
    # - Owner can set/unset any role
    # - Admin can set/unset 'member' and 'admin', but NOT 'owner'.
    # - Global admin can do anything.

    if not is_global_admin: # Apply specific group role restrictions
         if user_group_role != 'owner' and new_role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can assign the 'owner' role"}), 403
         if user_group_role != 'owner' and member_entry.role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can demote the current owner"}), 403
         if user_group_role == 'admin' and new_role == 'owner':
              return jsonify({"success": False, "error": "Admins cannot assign the 'owner' role"}), 403
         # Prevent changing your own role via this endpoint.
         if member_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot change your own role via this endpoint"}), 403 # Needs a separate 'leave group' / 'transfer ownership' flow


    # Prevent setting the same role again (optional optimization)
    if member_entry.role.lower() == new_role:
         return jsonify({"success": True, "message": f"Role is already '{new_role}'"}), 200


    try:
        # Update the member's role
        member_entry.role = new_role
        db.session.commit()
        app.logger.info(f"Group {group_id}: User {current_user.username} (ID: {current_user.id}) changed role of user {member_id} to '{new_role}'.")

        return jsonify({
            "success": True,
            "message": f"Role updated to '{new_role}'",
            "user_id": member_id,
            "new_role": new_role
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating member role in group {group_id} for user {member_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to update role"}), 500


# Endpoint to remove a member (AJAX or POST)
@app.route("/social/groups/<int:group_id>/members/<int:member_id>/remove", methods=["POST"])
@login_required
def remove_group_member(group_id, member_id):
    """Removes a member from a group (Owner/Admin/SysAdmin/HR only)."""
    group = db.get_or_404(SocialGroup, group_id)
    member_entry = db.session.get(SocialGroupMember, (group_id, member_id)) # Get the specific association object

    if not member_entry:
         return jsonify({"success": True, "message": "User is not a member (already removed?)"}), 200 # Already gone

    # Check authorization: User must be owner, admin in the group, or SysAdmin/HR/CEO
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_group_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to remove member {member_id} from group {group_id}: User {current_user.id} (Role: {user_group_role})")
        return jsonify({"success": False, "error": "You do not have permission to remove members"}), 403

    # Additional authorization checks:
    # - Owner can remove anyone except perhaps themselves (needs separate leave flow)
    # - Admin can remove 'member' role, but NOT 'admin' or 'owner' roles.
    # - Global admin can remove anyone.

    if not is_global_admin:
         if member_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot remove yourself via this endpoint (use leave group)"}), 403 # Needs separate leave flow
         if user_group_role == 'admin' and member_entry.role in ['owner', 'admin']:
              return jsonify({"success": False, "error": "Admins cannot remove other admins or owners"}), 403

    # Prevent removing the last owner? This requires more complex logic.
    # For V1, allow removing owner, but the group might become unmanageable without a new owner.
    # A better flow would be 'transfer ownership' before the owner leaves/is removed.


    try:
        db.session.delete(member_entry) # Delete the association object
        db.session.commit()
        app.logger.info(f"Group {group_id}: User {current_user.username} (ID: {current_user.id}) removed user {member_id} (was role: {member_entry.role}).")

        return jsonify({
            "success": True,
            "message": "User removed from group",
            "user_id": member_id
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing member {member_id} from group {group_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to remove user from group"}), 500

# --- ADD THESE API ROUTES (e.g., towards the end of app.py, before error handlers or main execution block) ---
# --- API v1: Global Engagement Core ---

# Helper function for API error responses (optional, but good practice)
def api_error_response(status_code, message):
    response = jsonify({'error': message, 'success': False})
    response.status_code = status_code
    return response

# === Global Post Endpoints ===

@app.route("/api/v1/global_posts", methods=["POST"])
@login_required
def create_global_post():
    """
    Creates a new global post.
    Accessible by all authenticated roles.
    """
    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")

    data = request.get_json()
    content = data.get("content", "").strip()
    file_id_from_request = data.get("file_id") # Assuming file is uploaded separately and ID is provided
    visibility = data.get("visibility", "public").strip().lower()
    allow_comments = data.get("allow_comments", True)
    allow_likes = data.get("allow_likes", True)
    # shared_post_id = data.get("shared_post_id") # For future repost feature

    if not content and not file_id_from_request:
        return api_error_response(400, "Post content or a file_id must be provided.")
    if len(content) > 10000: # Arbitrary max length for post content
        return api_error_response(400, "Post content is too long.")
    if visibility not in ['public']: # Initially, only 'public' is fully supported
        # Future: add 'connections_only', 'private' with appropriate logic
        return api_error_response(400, "Invalid visibility setting. Currently only 'public' is supported.")

    # Validate file_id if provided
    linked_file = None
    if file_id_from_request:
        try:
            file_id_int = int(file_id_from_request)
            # Check if file exists and belongs to the current user, or is publicly usable
            # For now, assume file_id is valid and was uploaded by current_user via a separate endpoint or process
            linked_file = db.session.get(File, file_id_int)
            if not linked_file:
                return api_error_response(400, f"File with ID {file_id_int} not found.")
            # Optional: Check if file is already attached to another post type to prevent re-use conflicts
            # if linked_file.channel_post or linked_file.group_message or linked_file.global_post_attachment:
            #     return api_error_response(400, f"File ID {file_id_int} is already in use.")

        except ValueError:
            return api_error_response(400, "Invalid file_id format.")

    try:
        new_post = GlobalPost(
            author_id=current_user.id,
            content=content if content else None,
            file_id=linked_file.id if linked_file else None,
            visibility=visibility,
            allow_comments=bool(allow_comments),
            allow_likes=bool(allow_likes),
            timestamp=datetime.now(timezone.utc)
            # shared_post_id=shared_post_id # For future
        )
        db.session.add(new_post)
        db.session.commit()

        app.logger.info(f"User {current_user.username} created GlobalPost ID {new_post.id}.")
        
        # Prepare response data (can be more detailed)
        post_data = {
            "id": new_post.id,
            "author_id": new_post.author_id,
            "content": new_post.content,
            "file_id": new_post.file_id,
            "timestamp": new_post.timestamp.isoformat() + "Z",
            "visibility": new_post.visibility,
            "allow_comments": new_post.allow_comments,
            "allow_likes": new_post.allow_likes,
            "comment_count": 0, # Initial
            "like_count": 0,    # Initial
            "author": { # Include basic author info
                "id": current_user.id,
                "username": current_user.username,
                "full_name": current_user.full_name,
                "profile_photo_url": current_user.profile_photo_url
            }
            # "file_details": { ... } if file was attached
        }
        # TODO: Emit SocketIO event for new_global_post (Phase 4.3)

        return jsonify({"success": True, "post": post_data}), 201

    except IntegrityError as e: # E.g. if file_id unique constraint violated
        db.session.rollback()
        app.logger.error(f"IntegrityError creating GlobalPost for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(409, "Conflict creating post, possibly due to file re-use.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error creating GlobalPost for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error creating post.")


@app.route("/api/v1/global_posts", methods=["GET"])
@login_required # All authenticated users can view public posts
def get_global_posts():
    """
    Retrieves a paginated list of global posts.
    Initial version: Fetches all 'public' posts.
    """
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int) # Default 10 posts per page
    author_id_filter = request.args.get('author_id', type=int)

    if per_page > 50: # Max per_page limit
        per_page = 50

    query = db.select(GlobalPost).where(GlobalPost.visibility == 'public') # Only public for now

    if author_id_filter:
        query = query.where(GlobalPost.author_id == author_id_filter)

    query = query.options(
        joinedload(GlobalPost.author).options(joinedload(User.role)), # Eager load author and their role
        joinedload(GlobalPost.attached_file) # Eager load attached file details
        # Comments and Likes counts will be added dynamically or via subquery for performance
    ).order_by(GlobalPost.timestamp.desc())

    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        posts_list = pagination.items
        
        result_posts = []
        for post in posts_list:
            # Efficiently get comment and like counts for each post
            comment_count = db.session.scalar(
                db.select(func.count(GlobalComment.id)).where(GlobalComment.post_id == post.id)
            ) or 0
            like_count = db.session.scalar(
                db.select(func.count(GlobalLike.id)).where(GlobalLike.post_id == post.id)
            ) or 0
            
            # Check if current user liked this post
            current_user_liked = False
            if current_user.is_authenticated:
                current_user_liked = db.session.query(
                    db.exists().where(GlobalLike.post_id == post.id, GlobalLike.user_id == current_user.id)
                ).scalar()

            post_data = {
                "id": post.id,
                "author_id": post.author_id,
                "content": post.content,
                "timestamp": post.timestamp.isoformat() + "Z",
                "is_edited": post.is_edited,
                "visibility": post.visibility,
                "allow_comments": post.allow_comments,
                "allow_likes": post.allow_likes,
                "comment_count": comment_count,
                "like_count": like_count,
                "current_user_liked": current_user_liked,
                "author": {
                    "id": post.author.id,
                    "username": post.author.username,
                    "full_name": post.author.full_name,
                    "profile_photo_url": post.author.profile_photo_url,
                    "role": post.author.role.name if post.author.role else None
                },
                "file": {
                    "id": post.attached_file.id,
                    "filename": post.attached_file.filename, # Server-side filename
                    "original_filename": post.attached_file.original_filename,
                    "mimetype": post.attached_file.mimetype,
                    "size": post.attached_file.size,
                    "download_url": post.attached_file.get_download_url()
                } if post.attached_file else None,
                "share_url": post.get_share_url()
            }
            result_posts.append(post_data)

        return jsonify({
            "success": True,
            "posts": result_posts,
            "pagination": {
                "page": pagination.page,
                "per_page": pagination.per_page,
                "total_pages": pagination.pages,
                "total_items": pagination.total,
                "has_next": pagination.has_next,
                "has_prev": pagination.has_prev
            }
        }), 200

    except Exception as e:
        app.logger.error(f"Error retrieving GlobalPosts: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving posts.")

@app.route("/api/v1/global_posts/<int:post_id>/comments", methods=["POST"])
@login_required
def create_global_comment(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    if not post.allow_comments:
        return api_error_response(403, "Comments are disabled for this post.")

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")
    
    data = request.get_json()
    content = data.get("content", "").strip()
    parent_comment_id = data.get("parent_comment_id")

    if not content:
        return api_error_response(400, "Comment content cannot be empty.")
    if len(content) > 2000:
        return api_error_response(400, "Comment is too long.")

    parent_comment = None
    if parent_comment_id:
        try:
            parent_id_int = int(parent_comment_id)
            parent_comment = db.session.get(GlobalComment, parent_id_int)
            if not parent_comment or parent_comment.post_id != post.id:
                return api_error_response(400, "Invalid parent comment ID.")
        except ValueError:
            return api_error_response(400, "Invalid parent_comment_id format.")
            
    try:
        new_comment = GlobalComment(
            post_id=post.id,
            author_id=current_user.id,
            content=content,
            parent_comment_id=parent_comment.id if parent_comment else None,
            timestamp=datetime.now(timezone.utc)
        )
        db.session.add(new_comment)
        db.session.commit() # Commit to get ID and persisted state

        app.logger.info(f"User {current_user.username} created GlobalComment ID {new_comment.id} on GlobalPost ID {post.id}.")

        # --- SOCKETIO EMIT ---
        # Prepare data for the socket event.
        # The client-side (socket-client.js) expects 'comment_html'.
        # For this, we need to render the comment item HTML.
        # Ensure the partial template `partials/_global_comment_item.html` exists and is correctly designed.
        # It will need the `new_comment` object (with its author loaded) and `current_user`.
        
        # Eagerly load author for the template
        comment_for_render = db.session.query(GlobalComment).options(
            joinedload(GlobalComment.author).joinedload(User.role)
        ).get(new_comment.id)

        rendered_comment_html = render_template(
            "partials/_global_comment_item.html", # ASSUMING THIS PARTIAL EXISTS or create it
            comment=comment_for_render,
            current_user=current_user # Pass current_user if partial needs it (e.g. for edit/delete buttons)
        )
        
        new_total_comment_count = db.session.scalar(
            db.select(func.count(GlobalComment.id)).where(GlobalComment.post_id == post.id)
        ) or 0

        socketio.emit('new_comment', {
            'post_id': post.id,
            'comment_html': rendered_comment_html,
            'new_comment_count': new_total_comment_count
        }, room=f'global_post-{post.id}')
        app.logger.info(f"SocketIO 'new_comment' emitted for GlobalPost ID {post.id}.")
        # --- END SOCKETIO EMIT ---

        # AJAX response data (original part of the function)
        comment_data_for_ajax_response = {
            "id": new_comment.id, "post_id": new_comment.post_id, "author_id": new_comment.author_id,
            "parent_comment_id": new_comment.parent_comment_id, "content": new_comment.content,
            "timestamp": new_comment.timestamp.isoformat() + "Z", "is_edited": new_comment.is_edited,
            "author": {
                "id": current_user.id, "username": current_user.username,
                "full_name": current_user.full_name, "profile_photo_url": current_user.profile_photo_url
            }
        }

        return jsonify({
            "success": True, 
            "comment": comment_data_for_ajax_response, # For the user who submitted
            "post_comment_count": new_total_comment_count
            }), 201

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error creating GlobalComment for user {current_user.id} on post {post.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error creating comment.")

@app.route("/api/v1/global_posts/<int:post_id>/like", methods=["POST"])
@login_required
def toggle_global_post_like(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    if not post.allow_likes:
        return api_error_response(403, "Likes are disabled for this post.")

    try:
        existing_like = db.session.scalar(
            db.select(GlobalLike).where(
                GlobalLike.post_id == post.id,
                GlobalLike.user_id == current_user.id
            )
        )

        user_liked_action = False
        if existing_like:
            db.session.delete(existing_like)
            app.logger.info(f"User {current_user.username} unliked GlobalPost ID {post.id}.")
            user_liked_action = False
        else:
            new_like = GlobalLike(
                post_id=post.id,
                user_id=current_user.id,
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(new_like)
            app.logger.info(f"User {current_user.username} liked GlobalPost ID {post.id}.")
            user_liked_action = True

        db.session.commit()
        
        new_like_count = db.session.scalar(
            db.select(func.count(GlobalLike.id)).where(GlobalLike.post_id == post.id)
        ) or 0

        # --- SOCKETIO EMIT ---
        socketio.emit('like_update', {
            'post_id': post.id,
            'new_like_count': new_like_count
            # Client-side handles 'user_liked' state based on AJAX response, not socket for this one.
            # Socket is for broad count update to all viewers.
        }, room=f'global_post-{post.id}')
        app.logger.info(f"SocketIO 'like_update' emitted for GlobalPost ID {post.id}.")
        # --- END SOCKETIO EMIT ---

        return jsonify({
            "success": True,
            "liked": user_liked_action, # For the user who initiated the action
            "like_count": new_like_count
        }), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error toggling like for user {current_user.id} on post {post.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error processing like.")
        
# --- END API v1: Global Engagement Core --

# --- CONTINUE ADDING TO API v1: Global Engagement Core section in app.py ---

# === Global Post Endpoints (Continued) ===

@app.route("/api/v1/global_posts/<int:post_id>", methods=["GET"])
@login_required
def get_global_post_detail(post_id):
    """Retrieves a single global post with details."""
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    if post.visibility != 'public':
        # Basic check: if not public, only author or admin can view directly.
        # More complex visibility (e.g., connections_only) would require further checks.
        if not (current_user.is_authenticated and (post.author_id == current_user.id or current_user.role.name in ['system_admin', 'hr_ceo'])):
            return api_error_response(403, "You do not have permission to view this post.")

    try:
        comment_count = db.session.scalar(
            db.select(func.count(GlobalComment.id)).where(GlobalComment.post_id == post.id)
        ) or 0
        like_count = db.session.scalar(
            db.select(func.count(GlobalLike.id)).where(GlobalLike.post_id == post.id)
        ) or 0
        current_user_liked = db.session.query(
            db.exists().where(GlobalLike.post_id == post.id, GlobalLike.user_id == current_user.id)
        ).scalar() if current_user.is_authenticated else False

        post_data = {
            "id": post.id, "author_id": post.author_id, "content": post.content,
            "timestamp": post.timestamp.isoformat() + "Z", "is_edited": post.is_edited,
            "visibility": post.visibility, "allow_comments": post.allow_comments,
            "allow_likes": post.allow_likes, "comment_count": comment_count,
            "like_count": like_count, "current_user_liked": current_user_liked,
            "author": {
                "id": post.author.id, "username": post.author.username,
                "full_name": post.author.full_name, "profile_photo_url": post.author.profile_photo_url,
                "role": post.author.role.name if post.author.role else None
            },
            "file": {
                "id": post.attached_file.id, "original_filename": post.attached_file.original_filename,
                "mimetype": post.attached_file.mimetype, "size": post.attached_file.size,
                "download_url": post.attached_file.get_download_url()
            } if post.attached_file else None,
            "share_url": post.get_share_url()
        }
        return jsonify({"success": True, "post": post_data}), 200
    except Exception as e:
        app.logger.error(f"Error retrieving GlobalPost ID {post_id}: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving post details.")

@app.route("/api/v1/global_posts/<int:post_id>", methods=["PUT"])
@login_required
def update_global_post(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")

    # Authorization: Only author or admin can edit
    if not (post.author_id == current_user.id or current_user.role.name in ['system_admin', 'hr_ceo']):
        return api_error_response(403, "You do not have permission to edit this post.")

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")
    
    data = request.get_json()
    content = data.get("content", "").strip()
    # file_id cannot be updated here; file attachment is on creation or via separate endpoint if needed.
    visibility = data.get("visibility", post.visibility).strip().lower() # Keep current if not provided
    allow_comments = data.get("allow_comments", post.allow_comments)
    allow_likes = data.get("allow_likes", post.allow_likes)

    if not content and not post.file_id: # If no file was ever attached, content is required
        return api_error_response(400, "Post content cannot be empty if no file is attached.")
    if len(content) > 10000:
        return api_error_response(400, "Post content is too long.")
    if visibility not in ['public']: # Expand when other visibilities are supported
        return api_error_response(400, "Invalid visibility setting.")

    try:
        post.content = content if content else post.content # Allow clearing content if file exists
        post.visibility = visibility
        post.allow_comments = bool(allow_comments)
        post.allow_likes = bool(allow_likes)
        post.is_edited = True
        # post.timestamp = datetime.now(timezone.utc) # Optionally update timestamp on edit

        db.session.commit()
        app.logger.info(f"User {current_user.username} updated GlobalPost ID {post.id}.")
        # Return updated post data (similar to get_global_post_detail)
        # For brevity, returning a simple success message. Consider returning full updated object.
        return jsonify({"success": True, "message": "Post updated successfully.", "post_id": post.id}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating GlobalPost ID {post.id} by user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error updating post.")


@app.route("/api/v1/global_posts/<int:post_id>", methods=["DELETE"])
@login_required
def delete_global_post(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")

    # Authorization: Only author or admin can delete
    if not (post.author_id == current_user.id or current_user.role.name in ['system_admin', 'hr_ceo']):
        return api_error_response(403, "You do not have permission to delete this post.")

    try:
        # Cascading delete should handle comments and likes.
        # The file linked via file_id is set to NULL due to ondelete='SET NULL', so it's not deleted from File table.
        # Actual file system cleanup for orphaned files would be a separate process or handled by File model logic.
        file_to_potentially_delete = post.attached_file # Get File object before deleting post

        db.session.delete(post)
        db.session.commit()
        
        # If the File was uniquely attached to this GlobalPost and should be deleted:
        if file_to_potentially_delete:
            # Check if this file is ONLY referenced by the deleted GlobalPost
            # (This requires checking other relationships on the File model)
            # For now, let's assume if a GlobalPost had a file, its File record should be deleted.
            # This is a simplification; a robust system might check if the File is used elsewhere.
            try:
                other_references = False
                if file_to_potentially_delete.channel_post or \
                   file_to_potentially_delete.group_message or \
                   file_to_potentially_delete.talent_club_feed_post or \
                   file_to_potentially_delete.talent_club_community_message or \
                   file_to_potentially_delete.talent_club_proposal_file: # Add other file usages
                    other_references = True
                
                if not other_references:
                    app.logger.info(f"Preparing to delete File record ID {file_to_potentially_delete.id} as it was only linked to deleted GlobalPost {post_id}.")
                    # First, delete the physical file
                    if file_to_potentially_delete.filepath:
                        full_file_path = os.path.join(current_app.static_folder, file_to_potentially_delete.filepath) # Assuming path relative to static
                        if os.path.exists(full_file_path):
                            os.remove(full_file_path)
                            app.logger.info(f"Deleted physical file: {full_file_path}")
                    # Then, delete the File DB record
                    db.session.delete(file_to_potentially_delete)
                    db.session.commit()
                    app.logger.info(f"Deleted File DB record ID {file_to_potentially_delete.id}.")
                else:
                    app.logger.info(f"File ID {file_to_potentially_delete.id} is referenced elsewhere, not deleting File record or physical file.")

            except Exception as file_delete_exc:
                db.session.rollback() # Rollback file deletion part if it fails
                app.logger.error(f"Error during associated file deletion for GlobalPost {post_id}: {file_delete_exc}", exc_info=True)
                # Post is already deleted, so this is a secondary error.

        app.logger.info(f"User {current_user.username} deleted GlobalPost ID {post_id}.")
        # TODO: Emit SocketIO event for global_post_deleted (Phase 4.3 enhancement or here)
        # socketio.emit('global_post_deleted', {'post_id': post_id}, room=f'global_post-{post_id}')
        # socketio.emit('global_post_deleted_from_feed', {'post_id': post_id}, room='global_feed') # If general feed room exists
        
        return jsonify({"success": True, "message": "Post deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting GlobalPost ID {post_id} by user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error deleting post.")


# === Global Comment Endpoints (Continued) ===

@app.route("/api/v1/global_posts/<int:post_id>/comments", methods=["GET"])
@login_required
def get_global_post_comments(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    # Add visibility check for post if necessary before showing comments

    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    if per_page > 50: per_page = 50

    # Query for top-level comments (parent_comment_id is None)
    # Threaded replies would be fetched client-side or via a separate endpoint per comment.
    query = (
        db.select(GlobalComment)
        .where(GlobalComment.post_id == post.id, GlobalComment.parent_comment_id.is_(None))
        .options(
            joinedload(GlobalComment.author).joinedload(User.role),
            joinedload(GlobalComment.replies).options( # Eager load replies and their authors
                joinedload(GlobalComment.author).joinedload(User.role)
            ) 
        )
        .order_by(GlobalComment.timestamp.asc()) # Oldest first for chronological display
    )

    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        comments_list = pagination.items
        
        result_comments = []
        for comment in comments_list:
            # Recursively format replies (basic example, can be optimized)
            def format_replies(comment_obj):
                replies_data = []
                # Access loaded replies directly if lazy='dynamic' is not used or if loaded via options
                # If replies is lazy='dynamic', use .all() or further query.
                # Assuming replies are loaded via joinedload as above.
                for reply in comment_obj.replies: # This should iterate over loaded replies if joinedload was effective
                    replies_data.append({
                        "id": reply.id, "post_id": reply.post_id, "author_id": reply.author_id,
                        "parent_comment_id": reply.parent_comment_id, "content": reply.content,
                        "timestamp": reply.timestamp.isoformat() + "Z", "is_edited": reply.is_edited,
                        "author": {
                            "id": reply.author.id, "username": reply.author.username,
                            "full_name": reply.author.full_name, "profile_photo_url": reply.author.profile_photo_url
                        },
                        "replies": format_replies(reply) # Recursive call for nested replies
                    })
                return replies_data

            comment_data = {
                "id": comment.id, "post_id": comment.post_id, "author_id": comment.author_id,
                "parent_comment_id": comment.parent_comment_id, "content": comment.content,
                "timestamp": comment.timestamp.isoformat() + "Z", "is_edited": comment.is_edited,
                "author": {
                    "id": comment.author.id, "username": comment.author.username,
                    "full_name": comment.author.full_name, "profile_photo_url": comment.author.profile_photo_url,
                    "role": comment.author.role.name if comment.author.role else None
                },
                "replies": format_replies(comment) # Add formatted replies
                # "reply_count": db.session.scalar(db.select(func.count(GlobalComment.id)).where(GlobalComment.parent_comment_id == comment.id)) or 0
            }
            result_comments.append(comment_data)
            
        return jsonify({
            "success": True, "comments": result_comments,
            "pagination": {
                "page": pagination.page, "per_page": pagination.per_page,
                "total_pages": pagination.pages, "total_items": pagination.total,
                "has_next": pagination.has_next, "has_prev": pagination.has_prev
            }
        }), 200
    except Exception as e:
        app.logger.error(f"Error retrieving comments for GlobalPost ID {post_id}: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving comments.")


@app.route("/api/v1/global_comments/<int:comment_id>", methods=["PUT"])
@login_required
def update_global_comment(comment_id):
    comment = db.session.get(GlobalComment, comment_id)
    if not comment:
        return api_error_response(404, "Comment not found.")

    # Authorization: Only author or admin can edit
    if not (comment.author_id == current_user.id or current_user.role.name in ['system_admin', 'hr_ceo']):
        return api_error_response(403, "You do not have permission to edit this comment.")

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")
    
    data = request.get_json()
    content = data.get("content", "").strip()

    if not content:
        return api_error_response(400, "Comment content cannot be empty.")
    if len(content) > 2000:
        return api_error_response(400, "Comment is too long.")
    
    try:
        comment.content = content
        comment.is_edited = True
        # comment.timestamp = datetime.now(timezone.utc) # Optionally update timestamp
        db.session.commit()
        app.logger.info(f"User {current_user.username} updated GlobalComment ID {comment.id}.")
        # TODO: Emit SocketIO event for comment_updated
        return jsonify({"success": True, "message": "Comment updated successfully.", "comment_id": comment.id}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating GlobalComment ID {comment.id} by user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error updating comment.")


@app.route("/api/v1/global_comments/<int:comment_id>", methods=["DELETE"])
@login_required
def delete_global_comment(comment_id):
    comment = db.session.get(GlobalComment, comment_id)
    if not comment:
        return api_error_response(404, "Comment not found.")

    post = comment.post # Get the parent post for authorization checks

    # Authorization: Comment author, Post author, or Admin
    can_delete = (
        comment.author_id == current_user.id or
        (post and post.author_id == current_user.id) or
        current_user.role.name in ['system_admin', 'hr_ceo']
    )
    if not can_delete:
        return api_error_response(403, "You do not have permission to delete this comment.")

    try:
        post_id_for_socket = comment.post_id # Get before deleting comment
        db.session.delete(comment) # Cascade delete should handle replies
        db.session.commit()
        app.logger.info(f"User {current_user.username} deleted GlobalComment ID {comment.id}.")
        
        # Get new total comment count for the post
        new_total_comment_count = db.session.scalar(
            db.select(func.count(GlobalComment.id)).where(GlobalComment.post_id == post_id_for_socket)
        ) or 0
        
        # TODO: Emit SocketIO event for comment_deleted
        # socketio.emit('global_comment_deleted', {'post_id': post_id_for_socket, 'comment_id': comment_id, 'post_comment_count': new_total_comment_count}, room=f'global_post-{post_id_for_socket}')
        
        return jsonify({
            "success": True, 
            "message": "Comment deleted successfully.",
            "post_comment_count": new_total_comment_count
            }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting GlobalComment ID {comment.id} by user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error deleting comment.")

# === Global Like Endpoints (Continued) ===

@app.route("/api/v1/global_posts/<int:post_id>/likes", methods=["GET"])
@login_required
def get_global_post_likers(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        return api_error_response(404, "Post not found.")
    # Add visibility check for post if necessary

    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int) # More likers might be shown
    if per_page > 100: per_page = 100

    query = (
        db.select(User)
        .join(GlobalLike, GlobalLike.user_id == User.id)
        .where(GlobalLike.post_id == post.id)
        .options(joinedload(User.role))
        .order_by(GlobalLike.timestamp.desc()) # Newest likes first
    )
    
    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        likers_list = pagination.items
        
        result_likers = [{
            "id": user.id, "username": user.username, "full_name": user.full_name,
            "profile_photo_url": user.profile_photo_url,
            "role": user.role.name if user.role else None
        } for user in likers_list]
            
        return jsonify({
            "success": True, "likers": result_likers,
            "pagination": {
                "page": pagination.page, "per_page": pagination.per_page,
                "total_pages": pagination.pages, "total_items": pagination.total,
                "has_next": pagination.has_next, "has_prev": pagination.has_prev
            }
        }), 200
    except Exception as e:
        app.logger.error(f"Error retrieving likers for GlobalPost ID {post_id}: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving likers.")

# === Placeholder for Global Post Share URL Redirect ===
@app.route("/global_posts/<int:post_id>/view") 
# No login_required here if posts can be shared publicly, but content access will be checked
def view_global_post_redirect(post_id):
    post = db.session.get(GlobalPost, post_id)
    if not post:
        abort(404, description="Shared post not found.")
    
    # Check post visibility before redirecting to a frontend view
    if post.visibility != 'public':
        if not current_user.is_authenticated:
            flash("Please log in to view this content.", "warning")
            return redirect(url_for('login', next=request.url))
        # Further checks if not public (e.g., author, admin, connections for future)
        if not (post.author_id == current_user.id or current_user.role.name in ['system_admin', 'hr_ceo']):
            flash("You do not have permission to view this post.", "warning")
            abort(403)
            
    # Redirect to a frontend route that displays this post.
    # This frontend route would then use the API /api/v1/global_posts/{post_id} to fetch details.
    # Example: frontend_url = f"/app/feed?post={post.id}" # Or similar client-side routing
    # For now, a simple placeholder redirect that might not work without a frontend page.
    # A better solution is for the frontend to handle /app/feed?post=ID directly.
    # This backend route is just for sharing a link that gets processed.
    flash(f"Viewing shared post: {post.content[:50]}..." if post.content else f"Viewing shared media post ID {post.id}", "info")
    # This would typically redirect to a frontend page that loads the post details via API.
    # For now, let's assume there's a generic 'feed' page on the frontend that can handle a post_id query param.
    return redirect(url_for('social_feed_placeholder', highlight_post_id=post.id)) # Assuming a general feed page

# A placeholder for a generic feed page, if you create one.
@app.route("/feed") # Example placeholder
@login_required
def social_feed_placeholder():
    # This page would ideally fetch posts from /api/v1/global_posts
    # and highlight a specific post if highlight_post_id is in request.args
    highlight_post_id = request.args.get('highlight_post_id')
    return render_template("social/global_feed_placeholder.html", 
                           title="Global Feed", 
                           highlight_post_id=highlight_post_id)

# --- END API v1: Global Engagement Core ---
# --- ADD TO API v1 section in app.py (or new API section) ---

@app.route("/api/v1/me/channels/view", methods=["GET"])
@login_required
def get_my_channels_view_api():
    filter_type = request.args.get('filter_type', 'active').lower() # 'all', 'pinned', 'active', 'archived'
    user_category_id_filter_str = request.args.get('category_id')
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    if per_page > 50: per_page = 50

    # Base query: Channels user is subscribed to or owns
    base_query = (
        db.select(Channel)
        .outerjoin(UserChannelPreference, 
                   and_(UserChannelPreference.channel_id == Channel.id, 
                        UserChannelPreference.user_id == current_user.id))
        .join(ChannelSubscriber, 
              and_(ChannelSubscriber.channel_id == Channel.id, 
                   ChannelSubscriber.user_id == current_user.id)) # Ensures user is subscribed
        .where(Channel.is_active == True) # Only active channels
        .options(
            joinedload(Channel.social_category),
            joinedload(Channel.owner),
            # Load the specific preference for *this* user directly with the channel
            # This subqueryload approach is often more efficient for one-to-one or one-to-many (filtered to one)
            selectinload(Channel.user_preferences.and_(UserChannelPreference.user_id == current_user.id))
        )
    )
    
    # Apply filters based on UserChannelPreference
    if filter_type == 'pinned':
        base_query = base_query.where(UserChannelPreference.is_pinned == True).order_by(UserChannelPreference.pinned_order.asc().nulls_last(), Channel.name.asc())
    elif filter_type == 'archived':
        base_query = base_query.where(UserChannelPreference.is_archived == True).order_by(UserChannelPreference.last_accessed_at.desc().nulls_last(), Channel.name.asc())
    elif filter_type == 'active': # Default: not archived, not hidden (if hidden is a separate flag)
        base_query = base_query.where(
            or_(UserChannelPreference.is_archived.is_(None), UserChannelPreference.is_archived == False),
            or_(UserChannelPreference.is_hidden.is_(None), UserChannelPreference.is_hidden == False) # if is_hidden implemented
        ).order_by(UserChannelPreference.is_pinned.desc(), UserChannelPreference.pinned_order.asc().nulls_last(), Channel.name.asc()) # Pinned first
    else: # 'all' (includes archived, hidden, etc. - maybe for a management view)
        base_query = base_query.order_by(Channel.name.asc())

    # Filter by user's custom category
    unlocked_category_ids = session.get('unlocked_channel_category_ids', set())
    selected_user_category = None
    if user_category_id_filter_str:
        try:
            user_category_id_filter = int(user_category_id_filter_str)
            selected_user_category = db.session.get(UserChannelCategory, user_category_id_filter)
            if not selected_user_category or selected_user_category.user_id != current_user.id:
                return api_error_response(404, "Custom category not found or not yours.")
            
            # If category is locked and not in session's unlocked list, deny access to its content
            if selected_user_category.security_type and selected_user_category.security_type != 'none' and selected_user_category.id not in unlocked_category_ids:
                return jsonify({
                    "success": True, "channels": [], "pagination": {"page":1, "per_page":per_page, "total_pages":0, "total_items":0},
                    "category_locked": True, "category_id": selected_user_category.id, "category_name": selected_user_category.name
                }), 200 # Return success but indicate category is locked

            base_query = base_query.where(UserChannelPreference.user_category_id == user_category_id_filter)
        except ValueError:
            return api_error_response(400, "Invalid category_id format.")

    try:
        pagination = db.paginate(base_query, page=page, per_page=per_page, error_out=False)
        channels_list = pagination.items
        
        results = []
        for ch in channels_list:
            # User preferences for this channel (should be loaded by selectinload or available via ch.user_preferences.first())
            pref = next((p for p in ch.user_preferences if p.user_id == current_user.id), None) # Get specific pref
            
            # Subscriber count (can be expensive if not careful, consider denormalization or approximate count)
            # For now, direct count from relationship if ChannelSubscriber is loaded for channel.
            # subscriber_count = ch.subscribers.count() # If 'subscribers' is a dynamic relationship
            # For performance, a subquery in the main query or a separate count query might be better for list views.
            # This can be simplified if `ch.subscribers` is configured to be a scalar count.
            
            results.append({
                "id": ch.id, "name": ch.name, "bio": ch.bio, 
                "profile_photo_url": ch.profile_photo_url,
                "type": ch.type, "owner_id": ch.owner_id,
                "owner_name": ch.owner.full_name or ch.owner.username if ch.owner else "N/A",
                "social_category_name": ch.social_category.name if ch.social_category else "Uncategorized",
                "allow_comments": ch.allow_comments, "allow_reactions": ch.allow_reactions,
                # "subscriber_count": subscriber_count, # Add if efficiently obtainable
                "user_preference": {
                    "is_pinned": pref.is_pinned if pref else False,
                    "pinned_order": pref.pinned_order if pref and pref.is_pinned else None,
                    "is_archived": pref.is_archived if pref else False,
                    "is_hidden": pref.is_hidden if pref else False, # If using
                    "user_category_id": pref.user_category_id if pref else None,
                    "last_accessed_at": pref.last_accessed_at.isoformat() + "Z" if pref and pref.last_accessed_at else None
                }
            })
        
        return jsonify({
            "success": True, "channels": results,
            "pagination": {"page": pagination.page, "per_page": pagination.per_page, "total_pages": pagination.pages, "total_items": pagination.total, "has_next": pagination.has_next, "has_prev": pagination.has_prev},
            "category_locked": False # Default if not specifically filtering by a locked category
        }), 200

    except Exception as e:
        app.logger.error(f"Error retrieving personalized channel list for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving channel list.")

# --- END Channel Command & Control API Endpoints ---
# --- Channel Command & Control API Endpoints ---

# Helper to get or create UserChannelPreference
def get_or_create_channel_preference(user_id, channel_id):
    preference = db.session.get(UserChannelPreference, (user_id, channel_id))
    if not preference:
        # Ensure channel exists before creating preference
        channel = db.session.get(Channel, channel_id)
        if not channel:
            return None # Or raise an error
        # User must be subscribed or own the channel to have preferences for it
        # This check assumes ChannelSubscriber link exists and user.is_channel_member or owner check
        # For simplicity here, we assume if they are trying to set a pref, they have some relation.
        # Robust check: if not (current_user.id == channel.owner_id or current_user.is_channel_member(channel)): return None
        
        preference = UserChannelPreference(user_id=user_id, channel_id=channel_id)
        db.session.add(preference)
    return preference

# === Channel Preference API Endpoints ===

@app.route("/api/v1/users/me/channel_preferences/<int:channel_id>/pin", methods=["POST"])
@login_required
def pin_channel_api(channel_id):
    preference = get_or_create_channel_preference(current_user.id, channel_id)
    if not preference:
        return api_error_response(404, "Channel not found or preference cannot be created.")

    data = request.get_json() if request.is_json else {}
    new_order = data.get("order") # Optional: for explicit ordering by user

    try:
        preference.is_pinned = True
        if new_order is not None:
            try:
                preference.pinned_order = int(new_order)
            except ValueError:
                return api_error_response(400, "Invalid 'order' value for pinning.")
        # If order not provided, could auto-assign to end or handle in frontend
        
        # Simple re-ordering logic if new_order is provided (can be more complex)
        # If setting a pinned_order, ensure other pinned items are adjusted if needed.
        # For now, assume client handles visual order and backend stores user's explicit intent.
        
        db.session.commit()
        app.logger.info(f"User {current_user.username} pinned Channel ID {channel_id}.")
        return jsonify({"success": True, "message": "Channel pinned.", "channel_id": channel_id, "is_pinned": True, "pinned_order": preference.pinned_order}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error pinning channel {channel_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error pinning channel.")

@app.route("/api/v1/users/me/channel_preferences/<int:channel_id>/pin", methods=["DELETE"])
@login_required
def unpin_channel_api(channel_id):
    preference = db.session.get(UserChannelPreference, (current_user.id, channel_id))
    if not preference or not preference.is_pinned:
        return api_error_response(404, "Channel not pinned or preference not found.")
    try:
        preference.is_pinned = False
        preference.pinned_order = None # Clear order when unpinned
        db.session.commit()
        app.logger.info(f"User {current_user.username} unpinned Channel ID {channel_id}.")
        return jsonify({"success": True, "message": "Channel unpinned.", "channel_id": channel_id, "is_pinned": False}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error unpinning channel {channel_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error unpinning channel.")

@app.route("/api/v1/users/me/channel_preferences/<int:channel_id>/archive", methods=["POST"])
@login_required
def archive_channel_api(channel_id):
    preference = get_or_create_channel_preference(current_user.id, channel_id)
    if not preference:
        return api_error_response(404, "Channel not found or preference cannot be created.")
    try:
        preference.is_archived = True
        preference.is_hidden = False # Archiving might override simple hiding
        preference.is_pinned = False # Cannot be pinned and archived
        preference.pinned_order = None
        db.session.commit()
        app.logger.info(f"User {current_user.username} archived Channel ID {channel_id}.")
        return jsonify({"success": True, "message": "Channel archived.", "channel_id": channel_id, "is_archived": True}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error archiving channel {channel_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error archiving channel.")

@app.route("/api/v1/users/me/channel_preferences/<int:channel_id>/archive", methods=["DELETE"])
@login_required
def unarchive_channel_api(channel_id):
    preference = db.session.get(UserChannelPreference, (current_user.id, channel_id))
    if not preference or not preference.is_archived:
        return api_error_response(404, "Channel not archived or preference not found.")
    try:
        preference.is_archived = False
        db.session.commit()
        app.logger.info(f"User {current_user.username} unarchived Channel ID {channel_id}.")
        return jsonify({"success": True, "message": "Channel unarchived.", "channel_id": channel_id, "is_archived": False}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error unarchiving channel {channel_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error unarchiving channel.")

# Implement /hide and /unhide similarly if their behavior is distinct from archive.
# For now, assuming archive is the primary "remove from active list" mechanism.

@app.route("/api/v1/users/me/channel_preferences/<int:channel_id>/assign_category", methods=["PUT"])
@login_required
def assign_channel_to_category_api(channel_id):
    preference = get_or_create_channel_preference(current_user.id, channel_id)
    if not preference:
        return api_error_response(404, "Channel not found or preference cannot be created.")

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")
    data = request.get_json()
    user_category_id = data.get("user_category_id") # Can be null to unassign

    try:
        if user_category_id is not None:
            try:
                user_category_id = int(user_category_id)
                # Verify category exists and belongs to current user
                category = db.session.get(UserChannelCategory, user_category_id)
                if not category or category.user_id != current_user.id:
                    return api_error_response(404, "Custom category not found or does not belong to you.")
                preference.user_category_id = category.id
            except ValueError:
                 return api_error_response(400, "Invalid user_category_id format.")
        else: # Unassign
            preference.user_category_id = None
        
        db.session.commit()
        app.logger.info(f"User {current_user.username} assigned Channel ID {channel_id} to Category ID {preference.user_category_id}.")
        return jsonify({"success": True, "message": "Channel category assignment updated.", "channel_id": channel_id, "user_category_id": preference.user_category_id}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error assigning channel {channel_id} to category for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error assigning category.")

# === User-Defined Channel Category API Endpoints ===

@app.route("/api/v1/users/me/channel_categories", methods=["POST"])
@login_required
def create_user_channel_category_api():
    if not request.is_json: return api_error_response(400, "JSON expected.")
    data = request.get_json()
    name = data.get("name", "").strip()
    order = data.get("order", 0)
    security_type = data.get("security_type", "none").strip().lower()
    security_payload = data.get("security_payload") # Plain PIN or pattern string

    if not name: return api_error_response(400, "Category name is required.")
    if len(name) > 100: return api_error_response(400, "Category name is too long.")
    
    valid_security_types = ['none', 'pin_code', 'pattern'] # 'pattern' is conceptual for now
    if security_type not in valid_security_types:
        return api_error_response(400, f"Invalid security_type. Allowed: {', '.join(valid_security_types)}")
    if security_type != 'none' and not security_payload:
        return api_error_response(400, "security_payload is required for secured categories.")

    try:
        new_category = UserChannelCategory(
            user_id=current_user.id,
            name=name,
            order=int(order),
            security_type=security_type if security_type != 'none' else None
        )
        if new_category.security_type:
            new_category.set_security_payload(security_payload) # Hashes the payload
        
        db.session.add(new_category)
        db.session.commit()
        app.logger.info(f"User {current_user.username} created Channel Category '{name}' (ID: {new_category.id}).")
        
        category_data = {
            "id": new_category.id, "name": new_category.name, "order": new_category.order,
            "security_type": new_category.security_type, 
            "channel_count": 0 # Initial count
        }
        return jsonify({"success": True, "message": "Category created.", "category": category_data}), 201
    except IntegrityError:
        db.session.rollback()
        return api_error_response(409, f"A category named '{name}' already exists.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error creating channel category for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error creating category.")

@app.route("/api/v1/users/me/channel_categories", methods=["GET"])
@login_required
def get_user_channel_categories_api():
    categories_query = (
        db.select(UserChannelCategory)
        .where(UserChannelCategory.user_id == current_user.id)
        .order_by(UserChannelCategory.order.asc(), UserChannelCategory.name.asc())
    )
    categories = db.session.scalars(categories_query).all()
    
    results = []
    for cat in categories:
        # Efficiently count channels in this category for this user
        channel_count = db.session.scalar(
            db.select(func.count(UserChannelPreference.channel_id))
            .where(UserChannelPreference.user_category_id == cat.id, UserChannelPreference.user_id == current_user.id) # Ensure it's for this user's preferences
        ) or 0
        results.append({
            "id": cat.id, "name": cat.name, "order": cat.order,
            "security_type": cat.security_type, # DO NOT return security_payload_hash
            "is_locked": bool(cat.security_type and cat.security_type != 'none'), # Simple locked status
            "channel_count": channel_count,
            "_metadata": cat._metadata
        })
    return jsonify({"success": True, "categories": results}), 200

# PUT and DELETE for categories, and POST for /unlock would follow similar patterns.
# The /unlock endpoint needs careful session management for the "unlocked" state.

@app.route("/api/v1/users/me/channel_categories/<int:category_id>", methods=["PUT"])
@login_required
def update_user_channel_category_api(category_id):
    category = db.session.get(UserChannelCategory, category_id)
    if not category or category.user_id != current_user.id:
        return api_error_response(404, "Category not found or not yours.")

    if not request.is_json: return api_error_response(400, "JSON expected.")
    data = request.get_json()
    
    try:
        if "name" in data:
            name = data["name"].strip()
            if not name: return api_error_response(400, "Category name cannot be empty.")
            if len(name) > 100: return api_error_response(400, "Category name is too long.")
            # Check for name conflict if changed
            if name.lower() != category.name.lower():
                existing = db.session.scalar(db.select(UserChannelCategory).where(UserChannelCategory.user_id == current_user.id, func.lower(UserChannelCategory.name) == name.lower(), UserChannelCategory.id != category.id))
                if existing: return api_error_response(409, f"A category named '{name}' already exists.")
            category.name = name
        
        if "order" in data: category.order = int(data["order"])
        
        if "security_type" in data:
            security_type = data["security_type"].strip().lower() if data["security_type"] else 'none'
            security_payload = data.get("security_payload") # New PIN/Pattern
            
            valid_security_types = ['none', 'pin_code', 'pattern']
            if security_type not in valid_security_types:
                return api_error_response(400, "Invalid security_type.")

            if security_type != 'none' and not security_payload:
                # If changing to a secure type, payload is required
                if category.security_type is None or category.security_type == 'none': # Only if was not secure before or changing type
                     return api_error_response(400, "security_payload is required to set a new secured category type.")
                # If just updating name/order of an already secured category, payload is not required to change
            
            category.security_type = security_type if security_type != 'none' else None
            if security_payload: # If a new payload is provided, hash and set it
                category.set_security_payload(security_payload)
            elif security_type == 'none': # If changing to 'none', clear hash
                category.security_payload_hash = None
        
        if "_metadata" in data: category._metadata = data["_metadata"] # Allow updating metadata

        db.session.commit()
        app.logger.info(f"User {current_user.username} updated Channel Category ID {category.id}.")
        # Return updated category data
        updated_category_data = {
            "id": category.id, "name": category.name, "order": category.order,
            "security_type": category.security_type, "is_locked": bool(category.security_type),
            "channel_count": category.channel_assignments.count(), "_metadata": category._metadata
        }
        return jsonify({"success": True, "message": "Category updated.", "category": updated_category_data}), 200
    except ValueError:
        return api_error_response(400, "Invalid data format (e.g., for order).")
    except IntegrityError: # Name conflict
        db.session.rollback()
        return api_error_response(409, "Category name already exists.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating channel category {category_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error updating category.")


@app.route("/api/v1/users/me/channel_categories/<int:category_id>", methods=["DELETE"])
@login_required
def delete_user_channel_category_api(category_id):
    category = db.session.get(UserChannelCategory, category_id)
    if not category or category.user_id != current_user.id:
        return api_error_response(404, "Category not found or not yours.")
    try:
        # Unassign channels from this category before deleting category
        UserChannelPreference.query.filter_by(user_category_id=category.id, user_id=current_user.id).update({"user_category_id": None})
        
        db.session.delete(category)
        db.session.commit()
        app.logger.info(f"User {current_user.username} deleted Channel Category ID {category.id} ('{category.name}').")
        return jsonify({"success": True, "message": "Category deleted."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting channel category {category_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error deleting category.")

@app.route("/api/v1/users/me/channel_categories/<int:category_id>/unlock", methods=["POST"])
@login_required
def unlock_user_channel_category_api(category_id):
    category = db.session.get(UserChannelCategory, category_id)
    if not category or category.user_id != current_user.id:
        return api_error_response(404, "Category not found or not yours.")
    if not category.security_type or category.security_type == 'none':
        return jsonify({"success": True, "message": "Category is not locked."}), 200 # Not an error

    if not request.is_json: return api_error_response(400, "JSON expected.")
    data = request.get_json()
    security_payload_attempt = data.get("security_payload")

    if not security_payload_attempt:
        return api_error_response(400, "Security payload (PIN/pattern data) is required to unlock.")

    if category.check_security_payload(security_payload_attempt):
        # Set session variable to mark category as unlocked for a limited time
        unlocked_cats = session.get('unlocked_channel_category_ids', set())
        unlocked_cats.add(category.id)
        session['unlocked_channel_category_ids'] = unlocked_cats
        # Set an expiration for this "unlocked" status if desired, e.g., by also storing a timestamp
        # session['unlocked_channel_category_expiry'] = datetime.now(timezone.utc) + timedelta(minutes=15)
        app.logger.info(f"User {current_user.username} unlocked Channel Category ID {category.id}.")
        return jsonify({"success": True, "message": "Category unlocked.", "category_id": category.id}), 200
    else:
        # Optional: Implement attempt counter and temporary lockout for security
        app.logger.warning(f"User {current_user.username} failed to unlock Channel Category ID {category.id}.")
        return api_error_response(401, "Incorrect PIN or pattern.")

# --- END Channel Command & Control API Endpoints ---

def can_user_view_item(user, item_type, item_id):
    """
    Checks if the given user has permission to view the specified item.
    This is a simplified placeholder and needs to be fully implemented
    based on your application's specific visibility and permission rules for each item_type.
    """
    if not user or not user.is_authenticated: # Should be caught by @login_required but good check
        return False

    # Fetch the item first
    item = None
    if item_type == 'GlobalPost':
        item = db.session.get(GlobalPost, item_id)
        if item: return item.visibility == 'public' or item.author_id == user.id # or admin
    elif item_type == 'ChannelPost':
        item = db.session.get(ChannelPost, item_id)
        if item and item.channel: return user.is_channel_member(item.channel) # Example permission
    elif item_type == 'GroupMessage':
        item = db.session.get(GroupMessage, item_id)
        if item and item.group: return user.is_group_member(item.group) # Example permission
    elif item_type == 'DirectMessage': # Assuming 'Message' model for DMs
        item = db.session.get(Message, item_id)
        if item: return item.sender_id == user.id or item.receiver_id == user.id
    elif item_type == 'TalentClubFeedPost':
        item = db.session.get(TalentClubFeedPost, item_id)
        if item and item.feed and item.feed.talent_club:
            # TC members can view active club feeds. More granular checks might be needed.
            return item.feed.talent_club.is_active and user.is_tc_member
    elif item_type == 'TalentClubCommunityMessage':
        item = db.session.get(TalentClubCommunityMessage, item_id)
        if item: return user.is_tc_member # TC Community is for all TC members
    # ... Add checks for other item_types ...
    
    if not item:
        app.logger.warning(f"Permission check: Item {item_type} ID {item_id} not found for user {user.id}.")
        return False # Item doesn't exist
        
    app.logger.debug(f"Permission check for user {user.id} on {item_type} ID {item_id}: Granted (basic check).")
    return True # Default to true if item exists but no specific check implemented yet, needs refinement.


# Helper for API to get item details for hydrated saved list (expand with all supported item_types)
def get_item_summary_for_saved_list(item_type, item_id, requesting_user):
    """
    Fetches a summary of an item for the saved items list.
    Includes permission check before returning details.
    """
    details = {
        "type": item_type, "id": item_id, "title": "Item not found or access denied", 
        "snippet": "", "url": None, "author_name": None, "author_id": None, 
        "timestamp": None, "thumbnail_url": None, "item_exists": False
    }

    if not can_user_view_item(requesting_user, item_type, item_id):
        return details # Return default "access denied" structure

    details["item_exists"] = True # Item exists and user can view it

    # --- GlobalPost ---
    if item_type == 'GlobalPost':
        post = db.session.get(GlobalPost, item_id)
        if post:
            details["title"] = (post.content[:70] + '...' if post.content and len(post.content) > 70 else post.content) or \
                               (f"Media Post by {post.author.full_name or post.author.username}" if post.author else "Media Post")
            details["snippet"] = (post.content[:150] + '...' if post.content and len(post.content) > 150 else post.content) or \
                                 (f"File: {post.attached_file.original_filename}" if post.attached_file else "Global Post")
            details["url"] = post.get_share_url()
            if post.author:
                details["author_name"] = post.author.full_name or post.author.username
                details["author_id"] = post.author.id
            details["timestamp"] = post.timestamp.isoformat() + "Z" if post.timestamp else None
            if post.attached_file and post.attached_file.mimetype and post.attached_file.mimetype.startswith('image/'):
                details["thumbnail_url"] = url_for('static', filename=post.attached_file.filepath) # Assuming filepath is relative to static

    # --- ChannelPost ---
    elif item_type == 'ChannelPost':
        post = db.session.get(ChannelPost, item_id)
        if post:
            details["title"] = (f"Post in '{post.channel.name}': " + (post.content[:50] + '...' if post.content and len(post.content) > 50 else post.content)) or \
                               f"Media Post in '{post.channel.name}'"
            details["snippet"] = (post.content[:150] + '...' if post.content and len(post.content) > 150 else post.content) or \
                                 (f"File: {post.file.original_filename}" if post.file else "Channel Post")
            details["url"] = post.get_share_url()
            if post.author:
                details["author_name"] = post.author.full_name or post.author.username
                details["author_id"] = post.author.id
            details["timestamp"] = post.timestamp.isoformat() + "Z" if post.timestamp else None
            if post.file and post.file.mimetype and post.file.mimetype.startswith('image/'):
                details["thumbnail_url"] = url_for('static', filename=post.file.filepath)

    # --- GroupMessage ---
    elif item_type == 'GroupMessage':
        msg = db.session.get(GroupMessage, item_id)
        if msg:
            details["title"] = (f"Message in '{msg.group.name}': " + (msg.content[:50] + '...' if msg.content and len(msg.content) > 50 else msg.content)) or \
                               f"Media Message in '{msg.group.name}'"
            details["snippet"] = (msg.content[:150] + '...' if msg.content and len(msg.content) > 150 else msg.content) or \
                                 (f"File: {msg.file.original_filename}" if msg.file else "Group Message")
            details["url"] = msg.get_share_url()
            if msg.author:
                details["author_name"] = msg.author.full_name or msg.author.username
                details["author_id"] = msg.author.id
            details["timestamp"] = msg.timestamp.isoformat() + "Z" if msg.timestamp else None
            if msg.file and msg.file.mimetype and msg.file.mimetype.startswith('image/'):
                details["thumbnail_url"] = url_for('static', filename=msg.file.filepath)
    
    # --- DirectMessage (Message model) ---
    elif item_type == 'DirectMessage':
        msg = db.session.get(Message, item_id) # Assuming Message is your DM model
        if msg:
            other_user = msg.sender if msg.receiver_id == requesting_user.id else msg.receiver
            details["title"] = f"DM with {other_user.full_name or other_user.username}: " + \
                               (msg.content[:50] + '...' if msg.content and len(msg.content) > 50 else msg.content)
            details["snippet"] = msg.content[:150] + '...' if msg.content and len(msg.content) > 150 else msg.content
            # URL for DMs might point to the chat interface with that user
            details["url"] = url_for('universal_chat', target_user_id=other_user.id)
            if msg.sender: # The actual sender of this specific message
                details["author_name"] = msg.sender.full_name or msg.sender.username
                details["author_id"] = msg.sender.id
            details["timestamp"] = msg.timestamp.isoformat() + "Z" if msg.timestamp else None

    # --- TalentClubFeedPost ---
    elif item_type == 'TalentClubFeedPost':
        post = db.session.get(TalentClubFeedPost, item_id)
        if post and post.feed and post.feed.talent_club:
            club_name = post.feed.talent_club.name
            details["title"] = (f"Post in TC '{club_name}': " + (post.content[:50] + '...' if post.content and len(post.content) > 50 else post.content)) or \
                               f"Media Post in TC '{club_name}'"
            details["snippet"] = (post.content[:150] + '...' if post.content and len(post.content) > 150 else post.content) or \
                                 (f"File: {post.file.original_filename}" if post.file else "TC Feed Post")
            details["url"] = url_for('view_talent_club_feed', club_id=post.feed.talent_club_id, _anchor=f'tc_feed_post-{post.id}')
            if post.author:
                details["author_name"] = post.author.full_name or post.author.username
                details["author_id"] = post.author.id
            details["timestamp"] = post.timestamp.isoformat() + "Z" if post.timestamp else None
            if post.file and post.file.mimetype and post.file.mimetype.startswith('image/'):
                details["thumbnail_url"] = url_for('static', filename=post.file.filepath)

    # --- TalentClubCommunityMessage ---
    elif item_type == 'TalentClubCommunityMessage':
        msg = db.session.get(TalentClubCommunityMessage, item_id)
        if msg and msg.community:
            details["title"] = (f"Message in '{msg.community.name}': " + (msg.content[:50] + '...' if msg.content and len(msg.content) > 50 else msg.content)) or \
                               f"Media Message in '{msg.community.name}'"
            details["snippet"] = (msg.content[:150] + '...' if msg.content and len(msg.content) > 150 else msg.content) or \
                                 (f"File: {msg.file.original_filename}" if msg.file else "TC Community Message")
            details["url"] = url_for('view_tc_community_messages', _anchor=f'tcc_message-{msg.id}')
            if msg.author:
                details["author_name"] = msg.author.full_name or msg.author.username
                details["author_id"] = msg.author.id
            details["timestamp"] = msg.timestamp.isoformat() + "Z" if msg.timestamp else None
            if msg.file and msg.file.mimetype and msg.file.mimetype.startswith('image/'):
                details["thumbnail_url"] = url_for('static', filename=msg.file.filepath)
                
    # Add more elif blocks for other item_types as they become saveable

    return details


@app.route("/api/v1/saved_items", methods=["POST"])
@login_required
def save_item_api(): # Renamed from save_item to avoid conflict if a non-api route exists
    if not request.is_json: 
        return api_error_response(400, "Invalid request format: JSON expected.")
    data = request.get_json()
    item_type = data.get("item_type")
    item_id_from_req = data.get("item_id") # Keep as string initially for parsing
    notes = data.get("notes")

    if not item_type or item_id_from_req is None:
        return api_error_response(400, "item_type and item_id are required.")
    
    # Define allowed item types based on your models
    # This list should be exhaustive for all saveable content types.
    allowed_item_types = [
        'GlobalPost', 'ChannelPost', 'GroupMessage', 'DirectMessage', 
        'TalentClubFeedPost', 'TalentClubCommunityMessage'
        # Add 'UserTask', 'Request', etc. if they become saveable
    ]
    if item_type not in allowed_item_types:
        return api_error_response(400, f"Invalid item_type. Allowed types: {', '.join(allowed_item_types)}")

    try:
        item_id = int(item_id_from_req)
    except ValueError:
        return api_error_response(400, "Invalid item_id format: Must be an integer.")

    # CRITICAL: Verify the item exists and the current user has permission to view it.
    if not can_user_view_item(current_user, item_type, item_id):
        app.logger.warning(f"User {current_user.id} attempt to save unviewable item: {item_type} ID {item_id}.")
        return api_error_response(404, "Item not found or you do not have permission to view it, so it cannot be saved.")

    try:
        new_saved_item = UserSavedItem(
            user_id=current_user.id,
            item_type=item_type,
            item_id=item_id,
            notes=notes.strip() if notes else None,
            saved_at=datetime.now(timezone.utc)
        )
        db.session.add(new_saved_item)
        db.session.commit()
        app.logger.info(f"User {current_user.username} saved item: Type '{item_type}', ID {item_id}.")
        
        # Return data for the new saved item entry itself
        saved_item_data = {
            "id": new_saved_item.id, 
            "item_type": new_saved_item.item_type, 
            "item_id": new_saved_item.item_id, 
            "notes": new_saved_item.notes, 
            "saved_at": new_saved_item.saved_at.isoformat() + "Z"
        }
        return jsonify({"success": True, "message": "Item saved successfully.", "saved_item": saved_item_data}), 201
    except IntegrityError: # Handles the UniqueConstraint _user_saved_item_uc
        db.session.rollback()
        app.logger.info(f"User {current_user.username} attempt to save already saved item: Type '{item_type}', ID {item_id}.")
        return api_error_response(409, "This item is already in your saved list.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error saving item (Type '{item_type}', ID {item_id}) for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error occurred while saving the item.")

@app.route("/api/v1/saved_items", methods=["GET"]) # Using query params for item identification
@login_required
def get_saved_items_api(): # Renamed
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 15, type=int)
    if per_page > 50: per_page = 50 # Max limit
    
    item_type_filter_req = request.args.get('item_type_filter')
    sort_by_req = request.args.get('sort_by', 'saved_at_desc') # Default sort

    query = db.select(UserSavedItem).where(UserSavedItem.user_id == current_user.id)
    
    if item_type_filter_req:
        query = query.where(UserSavedItem.item_type == item_type_filter_req)
    
    if sort_by_req == 'saved_at_desc':
        query = query.order_by(UserSavedItem.saved_at.desc())
    elif sort_by_req == 'saved_at_asc':
        query = query.order_by(UserSavedItem.saved_at.asc())
    elif sort_by_req == 'item_type_asc':
        query = query.order_by(UserSavedItem.item_type.asc(), UserSavedItem.saved_at.desc())
    else: # Default if invalid sort_by
        query = query.order_by(UserSavedItem.saved_at.desc())
        
    try:
        pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
        saved_items_raw_list = pagination.items
        
        hydrated_results = []
        for si_raw_item in saved_items_raw_list:
            # Use the refined helper that includes permission check
            item_content_details = get_item_summary_for_saved_list(si_raw_item.item_type, si_raw_item.item_id, current_user)
            
            hydrated_results.append({
                "saved_item_id": si_raw_item.id, # ID of the UserSavedItem record itself
                "item_type": si_raw_item.item_type,
                "item_id": si_raw_item.item_id, # ID of the actual content (GlobalPost, Message, etc.)
                "saved_at": si_raw_item.saved_at.isoformat() + "Z",
                "notes": si_raw_item.notes,
                "content_details": item_content_details # This is the hydrated part from the helper
            })

        return jsonify({
            "success": True, 
            "saved_items": hydrated_results,
            "pagination": {
                "page": pagination.page, "per_page": pagination.per_page,
                "total_pages": pagination.pages, "total_items": pagination.total,
                "has_next": pagination.has_next, "has_prev": pagination.has_prev
            }
        }), 200
    except Exception as e:
        app.logger.error(f"Error retrieving saved items for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error retrieving saved items.")


@app.route("/api/v1/saved_items", methods=["DELETE"]) # Using query params for item identification
@login_required
def unsave_item_api(): # Renamed
    item_type = request.args.get("item_type")
    item_id_str = request.args.get("item_id")

    if not item_type or not item_id_str:
        return api_error_response(400, "item_type and item_id query parameters are required.")
    try:
        item_id = int(item_id_str)
    except ValueError:
        return api_error_response(400, "Invalid item_id format: Must be an integer.")

    try:
        saved_item_to_delete = db.session.scalar(
            db.select(UserSavedItem).where(
                UserSavedItem.user_id == current_user.id,
                UserSavedItem.item_type == item_type,
                UserSavedItem.item_id == item_id
            )
        )
        if not saved_item_to_delete:
            return api_error_response(404, "This item is not in your saved list or was already unsaved.")
        
        saved_item_id_for_response = saved_item_to_delete.id # Get UserSavedItem.id for response consistency
        db.session.delete(saved_item_to_delete)
        db.session.commit()
        app.logger.info(f"User {current_user.username} unsaved item: Type '{item_type}', ID {item_id} (UserSavedItem ID: {saved_item_id_for_response}).")
        return jsonify({
            "success": True, 
            "message": "Item removed from your saved list.",
            "unsaved_item_details": { # Send back identifiers for client to update UI
                "saved_item_id": saved_item_id_for_response, # The ID of the UserSavedItem row
                "item_type": item_type,
                "item_id": item_id
            }
            }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error unsaving item (Type '{item_type}', ID {item_id}) for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error occurred while unsaving the item.")

@app.route("/api/v1/saved_items/<int:saved_item_id>", methods=["PUT"])
@login_required
def update_saved_item_notes_api(saved_item_id): # Renamed
    saved_item = db.session.get(UserSavedItem, saved_item_id)
    if not saved_item or saved_item.user_id != current_user.id:
        return api_error_response(404, "Saved item not found or you do not have permission to edit it.")

    if not request.is_json:
        return api_error_response(400, "Invalid request format: JSON expected.")
    
    data = request.get_json()
    notes = data.get("notes") # Allow empty string to clear notes, or null
    # custom_tags = data.get("custom_tags") # For future tag editing

    if notes is not None and len(notes.strip()) > 1000: # Max length for notes
        return api_error_response(400, "Notes are too long (max 1000 characters).")

    try:
        saved_item.notes = notes.strip() if notes is not None else None
        # if custom_tags is not None: saved_item.custom_tags = custom_tags # For future
        
        db.session.commit()
        app.logger.info(f"User {current_user.username} updated notes for UserSavedItem ID {saved_item_id}.")
        
        updated_item_data = {
            "id": saved_item.id, 
            "item_type": saved_item.item_type, 
            "item_id": saved_item.item_id, 
            "notes": saved_item.notes, 
            "saved_at": saved_item.saved_at.isoformat() + "Z",
            "custom_tags": saved_item.custom_tags 
        }
        return jsonify({"success": True, "message": "Saved item updated.", "saved_item": updated_item_data}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating UserSavedItem ID {saved_item_id} for user {current_user.id}: {e}", exc_info=True)
        return api_error_response(500, "Server error updating saved item.")

# --- END Content Curation API Endpoints ---

# Endpoint for a user to leave a group (if not the last owner)
@app.route("/social/groups/<int:group_id>/leave", methods=["POST"])
@login_required
def leave_social_group(group_id):
    """Allows a user to leave a group."""
    group = db.get_or_404(SocialGroup, group_id)

    # Fetch the member entry for the current user in this group
    member_entry = db.session.get(SocialGroupMember, (group_id, current_user.id))

    if not member_entry:
        flash("You are not a member of this group.", "warning")
        return redirect(url_for("social_group_list")) # Redirect to group list

    # Prevent the *last* owner from leaving (unless ownership is transferred)
    if member_entry.role == 'owner':
         # Check if this is the only owner left
         owner_count = db.session.scalar(
             select(func.count(SocialGroupMember.user_id))
             .where(
                 SocialGroupMember.group_id == group.id,
                 SocialGroupMember.role == 'owner'
             )
         ) or 0

         if owner_count <= 1: # If this user is the only owner or one of the last owners
              flash("You are the only owner of this group. Transfer ownership before leaving.", "danger")
              # Redirect back to group management page (or view page)
              return redirect(url_for("view_social_group", group_id=group.id)) # Or manage_group_members


    try:
        db.session.delete(member_entry) # Delete the association object
        db.session.commit()

        flash(f"Successfully left group '{group.name}'.", "success")
        app.logger.info(f"User {current_user.username} left group {group.id}.")
        # Redirect to group list
        return redirect(url_for("social_group_list"))

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error leaving group {group.id} by {current_user.id}: {e}", exc_info=True)
        flash("An error occurred while leaving the group. Please try again.", "danger")
        # Redirect back to the group view page on error
        return redirect(url_for("view_social_group", group_id=group.id))


# --- PART 12 END: Social Media Features ---

# --- PART 13 START: Settings ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User are defined with settings columns (e.g., age, sex, profile_photo_url, etc.).
# - Forms: UniversalSettingsForm is defined.
# - Decorators: login_required, role_required are defined.
# - Helpers: save_profile_photo (defined in Part 12) is used for profile photo uploads.
# - SQLAlchemy imports (select, func), Flask imports (abort, flash, redirect, url_for, request, render_template, jsonify), and other Python imports (datetime, timezone, os).

# Universal Settings Page
@app.route("/settings", methods=["GET", "POST"])
@login_required
def settings():
    # UniversalSettingsForm should be defined in your app.py or imported.
    # It should include fields like: full_name, username, email, age, sex,
    # and critically for this step: profile_photo (as FileField)
    # The 'profile_photo_url' field in the form (StringField) from previous phases can be removed
    # if direct file upload is now the primary method via 'profile_photo' FileField.
    
    # Ensure UniversalSettingsForm in your app.py has:
    # profile_photo = FileField("Update Profile Photo", 
    # validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!')])

    form = UniversalSettingsForm(
        obj=current_user,  # Pre-populate with current user's data
        original_username=current_user.username, # For unique username validation
        original_email=current_user.email      # For unique email validation
    )
    
    # Manually set the display-only TC member status for the form, if the field exists
    if hasattr(form, 'is_tc_member_display'):
        form.is_tc_member_display.data = current_user.is_tc_member

    if form.validate_on_submit():
        old_profile_photo_relative_path = current_user.profile_photo_url
        new_profile_photo_relative_path = None

        # --- Handle Profile Photo Upload ---
        # Check if the 'profile_photo' FileField in the form has data
        if form.profile_photo.data and form.profile_photo.data.filename:
            file_storage = form.profile_photo.data # This is a FileStorage object
            try:
                # Call your save_profile_photo helper
                saved_relative_path = save_profile_photo(file_storage)
                if saved_relative_path:
                    new_profile_photo_relative_path = saved_relative_path
                    app.logger.info(f"New profile photo uploaded for user {current_user.username}: {new_profile_photo_relative_path}")
                else:
                    # save_profile_photo should flash its own error, but we can add a general one
                    # If photo save failed, we might not want to proceed with other updates,
                    # or save other updates but not the photo. For now, we'll proceed with other updates.
                    flash("Profile photo update failed, but other settings might be saved.", "warning")
            except Exception as e:
                app.logger.error(f"Critical error processing profile photo for user {current_user.id}: {e}", exc_info=True)
                flash("A critical error occurred with the photo upload. Other settings were not saved.", "danger")
                return render_template("settings.html", form=form, title="My Settings - Nexus")


        # --- Update User Object ---
        try:
            current_user.full_name = form.full_name.data.strip()
            # Update first_name and last_name based on full_name
            name_parts = current_user.full_name.split(' ', 1)
            current_user.first_name = name_parts[0]
            current_user.last_name = name_parts[1] if len(name_parts) > 1 else None

            # Username and Email uniqueness is handled by form validators
            current_user.username = form.username.data.strip()
            current_user.email = form.email.data.strip() if form.email.data else None
            
            current_user.age = form.age.data
            current_user.sex = form.sex.data if form.sex.data else None # Handle empty select

            if new_profile_photo_relative_path:
                current_user.profile_photo_url = new_profile_photo_relative_path
            # If no new photo was uploaded, current_user.profile_photo_url remains unchanged.

            # Example for other settings if they were on UniversalSettingsForm:
            # if hasattr(form, 'theme') and hasattr(current_user, 'theme'):
            #     current_user.theme = form.theme.data
            # if hasattr(form, 'email_notifications') and hasattr(current_user, 'email_notifications'):
            #     current_user.email_notifications = form.email_notifications.data

            db.session.commit()

            # If a new photo was successfully saved and DB committed, delete the old one (if different)
            if new_profile_photo_relative_path and old_profile_photo_relative_path and \
               old_profile_photo_relative_path != new_profile_photo_relative_path and \
               not old_profile_photo_relative_path.startswith('img/placeholders/'): # Don't delete default placeholders
                
                old_photo_full_path = os.path.join(current_app.static_folder, old_profile_photo_relative_path)
                if os.path.exists(old_photo_full_path):
                    try:
                        os.remove(old_photo_full_path)
                        app.logger.info(f"Deleted old profile photo: {old_profile_photo_relative_path} for user {current_user.username}")
                    except Exception as e:
                        app.logger.error(f"Error deleting old profile photo {old_profile_photo_relative_path}: {e}")
            
            flash("Your settings have been updated successfully!", "success")
            app.logger.info(f"User {current_user.username} (ID: {current_user.id}) updated their settings.")
            return redirect(url_for("settings")) # Redirect to refresh the page with new data

        except IntegrityError: # Should be caught by form validators ideally
            db.session.rollback()
            app.logger.warning(f"Settings update for user {current_user.username} failed: IntegrityError (username/email).")
            # Form validators (validate_username, validate_email in UniversalSettingsForm) should add errors to form.
            # If they are not present on the form, add a generic flash message.
            if not form.username.errors and not form.email.errors:
                 flash("Update failed. The username or email may already be in use.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error updating settings for user {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while saving your settings. Please try again.", "danger")

    # For GET request or if form validation failed on POST
    # The form object (with data and errors) is passed to the template.
    return render_template("settings.html", form=form, title="My Settings - Nexus")

# --- PART 13 END: Settings ---

# --- PART Y START: Task System Features ---
# In app.py, replace the POST handling logic inside the create_task route

@app.route("/tasks/create", methods=["GET", "POST"])
@login_required
def create_task():
    if current_user.role.name.lower() not in TASK_CREATOR_ROLES:
        flash("You do not have permission to create tasks.", "danger")
        abort(403)

    form = CreateTaskForm() # We still use this for the main task fields

    if form.validate_on_submit():
        # --- NEW: Parse the unified assignee data ---
        assignees_data_str = request.form.get('assignees_data', '')
        if not assignees_data_str:
            flash("Please assign the task to at least one user, role, or class.", "danger")
            return render_template("tasks/create.html", form=form, title="Create New Task")

        individual_user_ids = []
        selected_roles = []
        selected_grade_sections = []

        # Parse the "type:id,type:id,..." string
        for item in assignees_data_str.split(','):
            try:
                item_type, item_id = item.split(':', 1)
                if item_type == 'user':
                    individual_user_ids.append(int(item_id))
                elif item_type == 'role':
                    selected_roles.append(item_id)
                elif item_type == 'grade_section':
                    selected_grade_sections.append(item_id)
            except (ValueError, IndexError):
                app.logger.warning(f"Could not parse assignee item: '{item}'")
                continue # Skip malformed items

        # --- Process Task Creation and Assignment (Same logic as before, now with parsed data) ---
        try:
            new_task = Task(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                due_date=form.due_date.data,
                urgency=form.urgency.data,
                created_by=current_user
            )
            # Add to session so it gets an ID before being passed to helpers
            db.session.add(new_task)

            assigned_count_total = 0

            if individual_user_ids:
                assigned_count_total += assign_task_to_users(new_task, individual_user_ids, current_user)

            if selected_roles:
                for role_name in selected_roles:
                    assigned_count_total += assign_task_to_role(new_task, role_name, current_user)

            if selected_grade_sections:
                for grade_section_str in selected_grade_sections:
                    try:
                        grade, section = grade_section_str.split('-', 1)
                        assigned_count_total += assign_task_to_grade_section(new_task, grade, section, current_user)
                    except ValueError:
                        app.logger.error(f"Invalid grade-section string in assignment: {grade_section_str}")
                        flash(f"Skipped invalid class assignment: {grade_section_str}.", "warning")
            
            # NOTE: The helper functions (assign_task_to_...) commit internally. 
            # This is not ideal for a single transaction. A better long-term solution
            # would be to have them only add to the session and have a single commit here.
            # But for now, this works with your existing helpers.
            # If the helpers didn't commit, you would uncomment the next line:
            # db.session.commit()

            if assigned_count_total > 0:
                flash(f"Task '{new_task.title}' created and assigned to {assigned_count_total} user(s)/group(s) successfully!", "success")
                app.logger.info(f"Task ID {new_task.id} created and assigned by {current_user.username}.")
                return redirect(url_for("my_assigned_tasks"))
            else:
                db.session.rollback() # Rollback the new_task if no one was assigned
                flash("No valid assignees were found for the selection. Task not created.", "warning")
                return render_template("tasks/create.html", form=form, title="Create New Task")

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating/assigning task by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while creating the task. Please try again.", "danger")

    # For GET request or validation failure
    return render_template("tasks/create.html", form=form, title="Create New Task")

@app.route("/tasks/api/assignees/search")
@login_required
def api_search_assignees():
    """
    Powerful AJAX endpoint to search for all types of assignees for a task:
    - Individual Users
    - Roles (e.g., 'teacher', 'librarian')
    - Grade/Sections (e.g., 'Grade 9, Section A')
    """
    search_query = request.args.get('q', '').strip()
    if not search_query or len(search_query) < 2:
        return jsonify([]) # Return empty list if query is too short

    results = []

    # 1. Search for Individual Users
    user_query = (
        select(User)
        .where(
            User.is_active == True,
            # Exclude roles that cannot be assigned tasks, e.g., system_admin
            User.role.has(Role.name.notin_(['system_admin'])),
            or_(
                User.username.ilike(f'%{search_query}%'),
                User.full_name.ilike(f'%{search_query}%')
            )
        )
        .options(joinedload(User.role))
        .order_by(User.full_name)
        .limit(10)
    )
    found_users = db.session.scalars(user_query).all()
    for user in found_users:
        results.append({
            "group": "Users",
            "type": "user",
            "id": user.id,
            "text": f"{user.full_name} ({user.role.name.replace('_',' ').title()})",
            "subtext": user.username
        })

    # 2. Search for Roles
    assignable_roles = get_assignable_roles() # Your helper function
    matching_roles = [r for r in assignable_roles if search_query.lower() in r.lower()]
    for role_name in matching_roles:
        results.append({
            "group": "Roles",
            "type": "role",
            "id": role_name,
            "text": f"All {role_name.replace('_',' ').title()}s",
            "subtext": "Assign to entire role"
        })
    
    # 3. Search for Grade/Sections
    assignable_sections = get_assignable_grade_sections() # Your helper function
    # Search by grade number or section letter
    matching_sections = [
        (g, s) for g, s in assignable_sections
        if search_query.lower() in g.lower() or search_query.lower() in s.lower()
    ]
    for grade, section in matching_sections:
        # The ID for a grade/section will be a composite string like "9-A"
        composite_id = f"{grade}-{section}"
        results.append({
            "group": "Classes",
            "type": "grade_section",
            "id": composite_id,
            "text": f"Grade {grade}, Section {section}",
            "subtext": "Assign to all students in this class"
        })

    return jsonify(results)

@app.route("/tasks/api/users/search") # AJAX Endpoint for User Search Picker
@login_required # User must be logged in
def api_search_users():
    """Provides a list of assignable users based on a search query (for JS picker)."""
    search_query = request.args.get('q', '').strip()
    if not search_query or len(search_query) < 2: # Require minimum 2 characters
        return jsonify([]) # Return empty list if query too short

    try:
        # Get users who are eligible to be assigned tasks (reuse helper logic)
        # The helper already excludes System Admins by default
        assignable_users_query = select(User).where(User.is_active == True) # Start with active users
        # Exclude Task Creator roles from being assigned? Or just System Admin?
        # Let's exclude System Admins based on the helper
        system_admin_role = db.session.scalar(select(Role).filter_by(name='system_admin'))
        if system_admin_role:
             assignable_users_query = assignable_users_query.where(User.role != system_admin_role)

        # Filter by search query (case-insensitive on username or full_name)
        assignable_users_query = assignable_users_query.where(
            or_(
                User.username.ilike(f'%{search_query}%'),
                User.full_name.ilike(f'%{search_query}%')
            )
        )

        # Order results and limit
        results = db.session.scalars(assignable_users_query.order_by(User.full_name).limit(20)).all() # Limit results

        # Format results for JSON response
        formatted_results = [{
            'id': user.id,
            'text': f"{user.full_name} ({user.username})", # Format for display in picker
            'role': user.role.name if user.role else 'N/A'
        } for user in results]

        return jsonify(formatted_results)

    except Exception as e:
        app.logger.error(f"Error searching users for task assignment picker by user {current_user.id}: {e}", exc_info=True)
        return jsonify({"error": "Failed to search users"}), 500

# Around line 10540 in your app.py
@app.route("/tasks/my_tasks")
@login_required
def my_tasks():
    """Lists tasks assigned to the current user."""
    # Fetch UserTask entries assigned *to* the current user
    my_tasks_list = db.session.scalars(
        select(UserTask)
        .join(UserTask.task)  # <<< --- ADD THIS JOIN
        .where(UserTask.user_id == current_user.id)
        # Eager load the Task and the creator of the Task (keep this)
        .options(joinedload(UserTask.task).joinedload(Task.created_by))
        # Order by status (Open first), then urgency (High first), then assigned_at (oldest first)
        .order_by(
            # Custom order for statuses: Open, In Progress, Delayed, Rejected, Completed, Accepted, Review Rejected
             case(
                {
                    'Open': 1,
                    'In Progress': 2,
                    'Delayed (Pending Review)': 3,
                    'Rejected (Pending Review)': 4,
                    'Completed (Pending Review)': 5,
                    'Review Rejected': 6, # Tasks rejected by reviewer need action again
                    'Accepted': 7 # Final state
                },
                value=UserTask.status # Order by this mapping
            ),
            Task.urgency.desc(),  # <<< --- CHANGE THIS LINE TO REFER TO THE Task MODEL
            UserTask.assigned_at.asc() # Order by assignment date ascending
        )
    ).all()

    # Filter tasks that are still 'Open', 'In Progress', 'Delayed', 'Rejected', 'Review Rejected' for the "My Tasks" list
    # 'Completed (Pending Review)' should also be listed under My Tasks until reviewed.
    # 'Accepted' tasks are considered done for the user and might be filtered out of the primary "My Tasks" view.
    # 'Review Rejected' tasks are effectively sent back, so they should remain in the "My Tasks" view.

    actionable_statuses = [
        'Open',
        'In Progress',
        'Completed (Pending Review)',
        'Delayed (Pending Review)',
        'Rejected (Pending Review)',
        'Review Rejected'
    ]
    my_actionable_tasks = [ut for ut in my_tasks_list if ut.status in actionable_statuses]
    # You might want a separate list for 'Accepted' tasks or view them via history.

    return render_template(
        "tasks/my_tasks.html",
        my_tasks=my_actionable_tasks,
        title="My Tasks"
    )

@app.route("/tasks/user_task/<int:user_task_id>/view") # View detail of a specific UserTask instance
@login_required
def view_user_task(user_task_id):
    """Displays details of a specific task assignment for the assigned user."""
    user_task = db.get_or_404(UserTask, user_task_id)

    # Check if the user task is assigned to the current user OR if the current user is the task creator or an admin
    is_assigned_user = (user_task.user_id == current_user.id)
    is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False # Ensure task exists
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if not is_assigned_user and not is_task_creator and not is_global_admin:
         flash("You do not have permission to view this task assignment.", "danger")
         app.logger.warning(f"Unauthorized view of UserTask {user_task_id} by user {current_user.id}. Assigned: {user_task.user_id}, Creator: {user_task.task.created_by_id if user_task.task else 'N/A'}.")
         abort(403) # Forbidden

    # Fetch history for this specific UserTask instance
    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc()) # Oldest first
    ).all()

    # Determine if the assigned user can update status
    can_update_status = is_assigned_user and user_task.status in ['Open', 'In Progress', 'Review Rejected', 'Delayed (Pending Review)', 'Rejected (Pending Review)'] # Can update if not in a final state or awaiting creator review

    # Determine if the creator can review this status
    can_review_status = is_task_creator and user_task.status in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)'] # Can review if status is pending review

    # Instantiate forms if needed (will be rendered conditionally in template)
    update_form = UpdateUserTaskStatusForm() if can_update_status else None
    review_form = ReviewUserTaskForm() if can_review_status else None

    # If it's a GET request and user can update, pre-populate update form with current notes if any
    if request.method == 'GET' and can_update_status and user_task.completion_notes:
         update_form.completion_notes.data = user_task.completion_notes

    # If it's a GET request and creator can review, pre-populate review form with current reviewer_notes if any
    if request.method == 'GET' and can_review_status and user_task.reviewer_notes:
         review_form.reviewer_notes.data = user_task.reviewer_notes


    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=user_task.task, # Pass the related task object
        history_records=history_records,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=update_form, # Pass the form instance if available
        review_form=review_form, # Pass the form instance if available
        title=f"Task: {user_task.task.title}"
    )


@app.route("/tasks/user_task/<int:user_task_id>/update_status", methods=["POST"])
@login_required
def update_user_task_status(user_task_id):
    """Handles status updates submitted by the assigned user."""
    user_task = db.get_or_404(UserTask, user_task_id)

    # Check authorization: Must be the assigned user
    if user_task.user_id != current_user.id:
        flash("You do not have permission to update this task.", "danger")
        app.logger.warning(f"Unauthorized status update attempt for UserTask {user_task_id} by user {current_user.id}. Assigned: {user_task.user_id}.")
        abort(403)

    # Check if status can be updated (not in a final state like 'Accepted' or 'Review Rejected' or already pending review)
    # Allowing updates if 'Open', 'In Progress', or 'Review Rejected' (sent back)
    if user_task.status not in ['Open', 'In Progress', 'Review Rejected']:
        flash(f"Cannot update status from '{user_task.status}'.", "warning")
        return redirect(url_for('view_user_task', user_task_id=user_task.id))


    form = UpdateUserTaskStatusForm()

    if form.validate_on_submit():
        old_status = user_task.status
        new_status = form.status.data # Get the new status from the form
        completion_notes = form.completion_notes.data.strip() if form.completion_notes.data else None

        # Additional check: Ensure the submitted status is valid for this endpoint flow
        valid_update_statuses = ['In Progress', 'Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']
        if new_status not in valid_update_statuses:
             flash("Invalid status update submitted.", "danger")
             app.logger.warning(f"User {current_user.id} submitted invalid status '{new_status}' for UserTask {user_task_id}.")
             return redirect(url_for('view_user_task', user_task_id=user_task.id)) # Redirect back


        try:
            user_task.status = new_status
            user_task.completion_notes = completion_notes
            user_task.last_status_update_at = datetime.now(timezone.utc)
            user_task.reviewed_by_id = None # Clear previous reviewer/notes on new user update
            user_task.reviewer_notes = None

            # Log history
            log_user_task_history(user_task, current_user, old_status, new_status, 'Status Update', completion_notes)

            db.session.commit() # Commit update and history

            # Notify the task creator about the status update
            notify_user_task_status_update(user_task)

            flash("Task status updated successfully!", "success")
            app.logger.info(f"UserTask {user_task_id} status updated to '{new_status}' by user {current_user.id}.")
            return redirect(url_for('view_user_task', user_task_id=user_task.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error updating status for UserTask {user_task_id} by user {current_user.id}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating task status. Please try again.", "danger")
            # Re-render or redirect back
            return redirect(url_for('view_user_task', user_task_id=user_task.id))


    # If form validation fails (e.g., notes missing for Delayed/Rejected)
    flash("Failed to update status. Please check notes.", "warning")
    # Re-render the view page, passing the form with errors. Need to fetch data again.
    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc())
    ).all()
    can_update_status = user_task.status not in ['Accepted', 'Review Rejected'] # Re-evaluate permission
    can_review_status = user_task.status in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']

    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=user_task.task,
        history_records=history_records,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=form, # Pass the form with errors
        review_form=ReviewUserTaskForm() if can_review_status else None, # Pass new review form if applicable
        title=f"Task: {user_task.task.title}"
    )


@app.route("/tasks/user_task/<int:user_task_id>/review", methods=["POST"])
@login_required
def review_user_task(user_task_id):
    """Handles review of a user's task status update by the task creator."""
    user_task = db.get_or_404(UserTask, user_task_id)

    # Check authorization: Must be the task creator or a global admin
    is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if not is_task_creator and not is_global_admin:
         flash("You do not have permission to review this task.", "danger")
         app.logger.warning(f"Unauthorized review attempt for UserTask {user_task_id} by user {current_user.id}. Creator: {user_task.task.created_by_id if user_task.task else 'N/A'}.")
         abort(403)

    # Check if status is pending review
    if user_task.status not in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']:
        flash(f"This task status ('{user_task.status}') is not pending review.", "warning")
        return redirect(url_for('view_user_task', user_task_id=user_task.id))


    form = ReviewUserTaskForm()

    if form.validate_on_submit():
        old_status = user_task.status
        review_outcome = form.review_outcome.data # 'Accepted' or 'Review Rejected'
        reviewer_notes = form.reviewer_notes.data.strip() if form.reviewer_notes.data else None

        # Additional check for outcome validity
        valid_outcomes = ['Accepted', 'Review Rejected']
        if review_outcome not in valid_outcomes:
             flash("Invalid review outcome submitted.", "danger")
             app.logger.warning(f"User {current_user.id} submitted invalid review outcome '{review_outcome}' for UserTask {user_task_id}.")
             return redirect(url_for('view_user_task', user_task_id=user_task.id)) # Redirect back


        try:
            user_task.reviewer_notes = reviewer_notes
            user_task.reviewed_by = current_user
            user_task.reviewed_at = datetime.now(timezone.utc)

            action = '' # To be logged in history
            if review_outcome == 'Accepted':
                user_task.status = 'Accepted'
                action = 'Review Accepted'
                flash("Task status update accepted.", "success")
            elif review_outcome == 'Review Rejected':
                user_task.status = 'Open' # Reset status for the assigned user to try again
                action = 'Review Rejected'
                flash("Task status update rejected. Status reset to 'Open'.", "warning")

            # Log history
            log_user_task_history(user_task, current_user, old_status, user_task.status, action, reviewer_notes)

            db.session.commit() # Commit update and history

            # Notify the assigned user about the review result
            notify_user_task_review_result(user_task)

            app.logger.info(f"UserTask {user_task_id} review outcome '{review_outcome}' by creator/reviewer {current_user.id}. New status: '{user_task.status}'.")
            # Redirect back to the creator's view of the overall task
            return redirect(url_for('view_assigned_task_detail', task_id=user_task.task_id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error reviewing UserTask {user_task_id} by {current_user.id}: {e}", exc_info=True)
            flash("An unexpected error occurred while processing the review. Please try again.", "danger")
            # Re-render or redirect back
            return redirect(url_for('view_user_task', user_task_id=user_task.id))


    # If form validation fails (e.g., notes missing for Review Rejected)
    flash("Failed to submit review. Please check notes.", "warning")
    # Re-render the view page, passing the form with errors. Need to fetch data again.
    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc())
    ).all()
    can_update_status = user_task.status not in ['Accepted', 'Review Rejected']
    can_review_status = user_task.status in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']

    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=user_task.task,
        history_records=history_records,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=UpdateUserTaskStatusForm() if can_update_status else None,
        review_form=form, # Pass the review form with errors
        title=f"Task: {user_task.task.title}"
    )


@app.route("/tasks/my_assigned_tasks")
@login_required
def my_assigned_tasks():
    """Lists tasks created by the current user for their review/management."""
    # Check if current user's role is in the list of roles allowed to create tasks
    if current_user.role.name.lower() not in TASK_CREATOR_ROLES:
        flash("You do not have permission to view tasks you assigned.", "danger")
        app.logger.warning(f"Unauthorized view of assigned tasks list by user {current_user.username} (Role: {current_user.role.name}).")
        abort(403)

    # Fetch tasks created by the current user
    my_created_tasks = db.session.scalars(
        select(Task)
        .where(Task.created_by_id == current_user.id)
        .order_by(Task.created_at.desc()) # Newest first
    ).all()

    # For each task, get counts of UserTask assignments by status
    task_status_counts = {}
    for task in my_created_tasks:
         status_counts = db.session.execute(
             select(UserTask.status, func.count(UserTask.id))
             .where(UserTask.task_id == task.id)
             .group_by(UserTask.status)
         ).all()
         task_status_counts[task.id] = dict(status_counts) # Store as a dictionary per task

    return render_template(
        "tasks/my_assigned_tasks.html",
        my_created_tasks=my_created_tasks,
        task_status_counts=task_status_counts, # Pass the counts
        title="Tasks I Assigned"
    )


@app.route("/tasks/my_assigned_tasks/<int:task_id>")
@login_required
def view_assigned_task_detail(task_id):
    """Displays details and all user assignments for a task created by the current user."""
    task = db.get_or_404(Task, task_id)

    # Check authorization: Must be the task creator or a global admin
    is_task_creator = (task.created_by_id == current_user.id)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if not is_task_creator and not is_global_admin:
         flash("You do not have permission to view details for this task.", "danger")
         app.logger.warning(f"Unauthorized view of assigned task detail {task_id} by user {current_user.id}. Creator: {task.created_by_id}.")
         abort(403)

    # Fetch all UserTask assignments for this task
    user_assignments = db.session.scalars(
        select(UserTask)
        .where(UserTask.task_id == task.id)
        # Eager load the assigned user and their role
        .options(joinedload(UserTask.user).joinedload(User.role))
        # Order assignments by status (pending review first), then assigned user name
        .order_by(
            case(
                {
                    'Completed (Pending Review)': 1,
                    'Delayed (Pending Review)': 2,
                    'Rejected (Pending Review)': 3
                },
                value=UserTask.status,
                else_=4 # All other statuses after pending review
            ),
            User.full_name.asc()
        )
    ).all()

    # Determine counts of assignments by status for a summary
    status_counts = defaultdict(int)
    for assignment in user_assignments:
        status_counts[assignment.status] += 1


    return render_template(
        "tasks/my_assigned_tasks_detail.html",
        task=task,
        user_assignments=user_assignments,
        status_counts=dict(status_counts), # Convert back to dict for template
        title=f"Assigned Task: {task.title}"
    )



# @app.route("/tasks/all") # Optional Admin View (Placeholder)
# @login_required
# @role_required("system_admin", "hr_ceo")
# def list_all_tasks_admin():
#     """Admin view to list all tasks in the system."""
#     # Implement query for all Task objects, possibly with pagination and filtering
#     all_tasks = db.session.scalars(
#          select(Task)
#          .options(joinedload(Task.created_by))
#          .order_by(Task.created_at.desc())
#     ).all()
#     # Render template...
#     pass

# @app.route("/tasks/user_task/<int:user_task_id>/history") # Optional history detail
# @login_required
# def view_user_task_history(user_task_id):
#     """Displays the history of a specific user's task assignment."""
#     user_task = db.get_or_404(UserTask, user_task_id)
#     # Check permissions (assigned user, creator, or admin)
#     is_assigned_user = (user_task.user_id == current_user.id)
#     is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False
#     is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
#
#     if not is_assigned_user and not is_task_creator and not is_global_admin:
#          flash("You do not have permission to view this task assignment history.", "danger")
#          abort(403)
#
#     history_records = db.session.scalars(
#         select(TaskHistory)
#         .where(TaskHistory.user_task_id == user_task.id)
#         .options(joinedload(TaskHistory.changed_by))
#         .order_by(TaskHistory.timestamp.asc())
#     ).all()
#
#     # Render template...
#     pass

# --- PART Y END: Task System Features ---

# --- PART 14 START: Analytics (Placeholder/Basic) ---

# --- (Place with other Analytics or API routes) ---

@app.route("/analytics/attendance")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive") # Roles that can access this data
def analytics_attendance_data():
    try:
        today = datetime.now(timezone.utc).date()
        
        # Counts of attendance statuses for today
        # Ensure Attendance model and func are imported
        attendance_summary_raw = db.session.execute(
            select(Attendance.status, func.count(Attendance.id).label("count"))
            .where(Attendance.date == today)
            .group_by(Attendance.status)
        ).all() # List of Row objects [(status, count), ...]
        
        summary_dict = {row.status: row.count for row in attendance_summary_raw}

        # Calculate 'Absent (No Entry)' if needed, based on total eligible students
        total_eligible_students = db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == 'student', User.is_active == True)
        ) or 0
        
        students_with_entry_today = sum(summary_dict.values())
        absent_no_entry_count = total_eligible_students - students_with_entry_today
        
        # Prepare labels and data for Chart.js
        labels = []
        data_values = []
        
        # Order for consistency, e.g., Present, Late, Excused, Absent (from DB), Absent (No Entry)
        status_order = ['Present', 'Late', 'Excused', 'Absent']
        for status_key in status_order:
            if status_key in summary_dict:
                labels.append(status_key)
                data_values.append(summary_dict[status_key])
        
        if absent_no_entry_count > 0:
            labels.append('Absent (No Entry)')
            data_values.append(absent_no_entry_count)
        
        # If no data at all, provide empty arrays but success
        if not labels and not data_values and total_eligible_students == 0:
             labels = ["No Student Data"]
             data_values = [0]
        elif not labels and not data_values and total_eligible_students > 0 : # No attendance marked today
            labels = ["Attendance Not Marked"]
            data_values = [total_eligible_students]


        return jsonify({
            "success": True, # Indicate successful data fetch
            "labels": labels,
            "data": data_values,
            "chart_type": "doughnut", # Suggest chart type
            "title": f"Attendance Summary for {today.strftime('%Y-%m-%d')}",
            "total_eligible_students": total_eligible_students # Extra context for frontend
        }), 200

    except Exception as e:
        app.logger.error(f"Error fetching attendance analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve attendance analytics data."}), 500

@app.route("/analytics/enrollment_trends")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_enrollment_trends():
    # Placeholder: This would typically involve querying student enrollment data over time periods (e.g., per year/semester)
    # Example: Counts of new student registrations per month for the last year.
    # For now, returning static placeholder data.
    try:
        # Replace with actual query logic
        labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"] # Example labels (months)
        data_values = [20, 25, 22, 30, 28, 35] # Example data (new enrollments)
        
        if not data_values: # No data found
            labels = ["No Enrollment Trend Data"]
            data_values = [0]


        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values,
            "chart_type": "line",
            "title": "Recent Enrollment Trends"
        }), 200
    except Exception as e:
        app.logger.error(f"Error fetching enrollment trend analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve enrollment trend data."}), 500

@app.route("/analytics/graduation_rates")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_graduation_rates():
    # Placeholder: This would involve querying student status (e.g., 'graduated') over time or by cohort.
    # For now, returning static placeholder data.
    try:
        # Replace with actual query logic
        labels = ["Cohort 2020", "Cohort 2021", "Cohort 2022", "Cohort 2023"] # Example labels
        data_values = [85, 88, 90, 92] # Example data (graduation percentage)

        if not data_values:
            labels = ["No Graduation Rate Data"]
            data_values = [0]


        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values, # Percentages
            "chart_type": "bar",
            "title": "Graduation Rates by Cohort (%)"
        }), 200
    except Exception as e:
        app.logger.error(f"Error fetching graduation rate analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve graduation rate data."}), 500

@app.route("/analytics/demographics")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_demographics_data():
    try:
        # Gender distribution for active students
        # Ensure User, Role, func are imported
        demographics_raw = db.session.execute(
            select(User.gender, func.count(User.id).label("count"))
            .join(User.role) # Assuming User.role relationship
            .where(User.is_active == True, Role.name == 'student') # Focus on active students
            .group_by(User.gender)
            .order_by(User.gender.asc()) # For consistent order
        ).all() # List of Row objects [(gender, count), ...]

        summary_dict = {}
        for row in demographics_raw:
            gender_key = row.gender if row.gender and row.gender.strip() != '' else 'Not Specified'
            summary_dict[gender_key] = summary_dict.get(gender_key, 0) + row.count
            
        # Ensure all expected categories are present for consistent chart display
        # This list can be expanded or made configurable
        expected_genders = ['Male', 'Female', 'Other', 'Prefer Not to Say', 'Not Specified']
        labels = []
        data_values = []
        for gender_cat in expected_genders:
            count = summary_dict.get(gender_cat, 0)
            if count > 0 or gender_cat in summary_dict : # Only add if data exists or it's a defined category
                labels.append(gender_cat)
                data_values.append(count)
        
        if not labels : # No demographic data found
            labels = ["No Demographic Data"]
            data_values = [0]


        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values,
            "chart_type": "pie", # Suggest chart type
            "title": "Student Gender Demographics (Active)"
        }), 200

    except Exception as e:
        app.logger.error(f"Error fetching demographics analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve demographics analytics data."}), 500

@app.route("/analytics/performance")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_performance_data():
    try:
        # Average of student averages per subject
        # Ensure Mark model and func are imported
        performance_summary_raw = db.session.execute(
            select(Mark.subject, func.avg(Mark.average).label("average_score"))
            .where(Mark.average.isnot(None)) # Only consider students with a calculated average
            .group_by(Mark.subject)
            .order_by(Mark.subject.asc())
        ).all() # List of Row objects [(subject, average_score), ...]

        labels = [row.subject for row in performance_summary_raw]
        data_values = [round(row.average_score, 2) if row.average_score is not None else 0 for row in performance_summary_raw]

        if not labels: # No performance data found
            labels = ["No Performance Data"]
            data_values = [0]

        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values,
            "chart_type": "bar", # Suggest chart type
            "title": "Average Performance by Subject"
        }), 200

    except Exception as e:
        app.logger.error(f"Error fetching performance analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve performance analytics data."}), 500

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Attendance, Mark, Asset, AssetReport, etc. are defined.
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, or_), Flask imports (jsonify, request, render_template, make_response), and other Python imports (csv, io, datetime, timezone).

# --- Analytics Routes (Basic Implementations / Placeholders) ---
# These routes are for HR/CEO and System Admin roles to view basic data summaries.
# Full-featured analytics with complex calculations and filtering are beyond the scope of this V1 generation.

@app.route("/analytics/attendance")
@login_required
@role_required("hr_ceo", "system_admin") # Allow System Admin
def attendance_analytics():
    """Provides basic attendance data summary as JSON."""
    # This is a basic placeholder. Real analytics would involve filtering by date range, grade, section, etc.

    try:
        # Get counts of attendance statuses for today
        today = datetime.now(timezone.utc).date()

        attendance_summary = db.session.execute(
            select(Attendance.status, func.count(Attendance.id))
            .where(Attendance.date == today)
            .group_by(Attendance.status)
        ).all()

        # Format the results into a dictionary
        summary_dict = dict(attendance_summary)

        # Include total students count for context
        total_students_today = sum(summary_dict.values()) # Sum of students with *an* entry today

        # You might also want the total number of *eligible* students
        total_eligible_students = db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == 'student', User.is_active == True)
        ) or 0

        # Structure data for a chart/display (example format)
        labels = list(summary_dict.keys()) # Status names
        values = list(summary_dict.values()) # Counts

        # Add 'Absent' if not present in results but eligible students exist
        if 'Absent' not in labels and total_eligible_students > 0:
            # Calculate truly absent students = total eligible - those with entries today
            actual_absent = total_eligible_students - total_students_today
            if actual_absent > 0:
                 labels.append('Absent (No Entry)')
                 values.append(actual_absent)


        return jsonify({
            "labels": labels, # e.g., ['Present', 'Late', 'Absent (No Entry)']
            "data": values,  # e.g., [150, 10, 20]
            "date": today.strftime('%Y-%m-%d'),
            "total_eligible_students": total_eligible_students
        })

    except Exception as e:
        app.logger.error(f"Error fetching attendance analytics data by {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to fetch attendance data"}), 500


@app.route("/analytics/performance")
@login_required
@role_required("hr_ceo", "system_admin")
def performance_analytics():
    """Provides basic performance data summary by subject as JSON."""
    # This is a basic placeholder. Real analytics would involve filtering by grade, section, etc.

    try:
        # Get average marks per subject (using average of 'average' column in Mark model)
        performance_summary = db.session.execute(
            select(Mark.subject, func.avg(Mark.average))
            .where(Mark.average.isnot(None)) # Only include marks where average is calculated
            .group_by(Mark.subject)
            .order_by(Mark.subject)
        ).all()

        # Format the results
        summary_dict = dict(performance_summary)

        labels = list(summary_dict.keys()) # Subject names
        values = [round(v, 2) for v in summary_dict.values()] # Average scores, rounded

        return jsonify({
            "labels": labels, # e.g., ['Math', 'Science', 'History']
            "data": values   # e.g., [75.5, 82.1, 68.9]
        })

    except Exception as e:
        app.logger.error(f"Error fetching performance analytics data by {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to fetch performance data"}), 500


@app.route("/analytics/demographics")
@login_required
@role_required("hr_ceo", "system_admin")
def demographics_analytics():
    """Provides basic demographic breakdown (e.g., gender) as JSON."""
    try:
         # Get gender counts for all active users (or perhaps just students?)
         # Let's do all active users for a general demographic overview
         gender_counts = db.session.execute(
             select(User.gender, func.count(User.id))
             .where(User.is_active == True) # Only active users
             .group_by(User.gender)
             .order_by(User.gender) # Order results consistently
         ).all()

         # Format results into a dictionary, handling None/empty gender
         summary_dict = {
             (row[0] if row[0] is not None and row[0] != '' else 'Not Specified'): row[1]
             for row in gender_counts
         }

         # Ensure common gender categories are present even if count is 0
         all_genders = ['Male', 'Female', 'Other', 'Prefer Not to Say', 'Not Specified']
         final_summary = {g: summary_dict.get(g, 0) for g in all_genders}


         labels = list(final_summary.keys())
         values = list(final_summary.values())


         return jsonify({
             "labels": labels, # e.g., ['Female', 'Male', 'Not Specified', 'Other']
             "data": values   # e.g., [120, 130, 15, 5]
         })

    except Exception as e:
        app.logger.error(f"Error fetching demographics data by {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to fetch demographics data"}), 500


@app.route("/analytics/performance-comparison")
@login_required
@role_required("hr_ceo", "system_admin")
def performance_comparison():
    """Placeholder for comparing performance metrics (e.g., across grades/sections)."""
    # This route is complex and requires more specific data structure and logic.
    # Returning empty data as a placeholder.

    return jsonify({
        "labels": [],
        "average_scores": [],
        "leader_averages": [], # Example comparison metric
        "error": "Performance comparison analytics not yet implemented."
    })

# Ensure csv and io are imported at the top
# import csv
# import io

@app.route("/analytics/export/<string:export_type>") # Make sure export_type is string
@login_required
@role_required("hr_ceo", "system_admin", "school_executive") # Ensure roles are correct
def export_analytics_data(export_type):
    valid_export_types = ["attendance_summary", "performance_averages", "demographics", 
                          "enrollment_trends", "graduation_rates"] # Add new conceptual types

    if export_type not in valid_export_types:
        flash(f"Invalid export type requested: {export_type}", "danger")
        abort(404)

    output = io.StringIO()
    writer = csv.writer(output)
    filename = f"{export_type}_export_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.csv"
    
    try:
        if export_type == "attendance_summary":
            writer.writerow(["Status", "Count", "Date", "Total Eligible Students"])
            today = datetime.now(timezone.utc).date()
            attendance_summary_raw = db.session.execute(
                select(Attendance.status, func.count(Attendance.id).label("count"))
                .where(Attendance.date == today).group_by(Attendance.status)
            ).all()
            summary_dict = {row.status: row.count for row in attendance_summary_raw}
            total_eligible_students = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == 'student', User.is_active == True)) or 0
            students_with_entry_today = sum(summary_dict.values())
            absent_no_entry_count = total_eligible_students - students_with_entry_today

            for status, count in summary_dict.items():
                writer.writerow([status, count, today.strftime('%Y-%m-%d'), total_eligible_students])
            if absent_no_entry_count > 0:
                writer.writerow(['Absent (No Entry)', absent_no_entry_count, today.strftime('%Y-%m-%d'), total_eligible_students])

        elif export_type == "performance_averages":
            writer.writerow(["Subject", "Average Score"])
            performance_summary_raw = db.session.execute(
                select(Mark.subject, func.avg(Mark.average).label("average_score"))
                .where(Mark.average.isnot(None)).group_by(Mark.subject).order_by(Mark.subject.asc())
            ).all()
            for row in performance_summary_raw:
                writer.writerow([row.subject, round(row.average_score, 2) if row.average_score is not None else "N/A"])
        
        elif export_type == "demographics": # Example: Student Demographics by Gender
            writer.writerow(["Gender", "Count"])
            demographics_raw = db.session.execute(
                select(User.gender, func.count(User.id).label("count"))
                .join(Role).where(User.is_active == True, Role.name == 'student')
                .group_by(User.gender).order_by(User.gender.asc())
            ).all()
            summary_dict = {}
            for row in demographics_raw:
                gender_key = row.gender if row.gender and row.gender.strip() != '' else 'Not Specified'
                summary_dict[gender_key] = summary_dict.get(gender_key, 0) + row.count
            for gender, count in summary_dict.items():
                 writer.writerow([gender, count])

        # Add CSV generation for 'enrollment_trends' and 'graduation_rates' using their placeholder data
        elif export_type == "enrollment_trends":
            writer.writerow(["Month", "New Enrollments"])
            labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"]
            data_values = [20, 25, 22, 30, 28, 35]
            for label, value in zip(labels, data_values):
                writer.writerow([label, value])
                
        elif export_type == "graduation_rates":
            writer.writerow(["Cohort", "Graduation Rate (%)"])
            labels = ["Cohort 2020", "Cohort 2021", "Cohort 2022", "Cohort 2023"]
            data_values = [85, 88, 90, 92]
            for label, value in zip(labels, data_values):
                writer.writerow([label, value])
        else:
            # Should be caught by valid_export_types check
            flash("Unknown data type for export.", "danger")
            return redirect(request.referrer or url_for('hr_ceo_dashboard'))


        csv_data = output.getvalue()
        response = make_response(csv_data)
        response.headers["Content-Disposition"] = f"attachment; filename={filename}"
        response.headers["Content-Type"] = "text/csv"
        app.logger.info(f"User {current_user.username} exported analytics data: {export_type}.")
        return response

    except Exception as e:
        app.logger.error(f"Error generating CSV export for {export_type} by {current_user.username}: {e}", exc_info=True)
        flash(f"An error occurred while generating the {export_type} CSV export. Please try again.", "danger")
        return redirect(request.referrer or url_for('hr_ceo_dashboard')) 
# --- PART X START: Multi-Tiered Request System Features ---

# NOTE: This new part relies on:
# - Models: Request, RequestHistory, User, Role
# - Forms: CreateRequestForm, ReviewRequestForm
# - Helpers: get_request_permissions, log_request_history, notify_request_event, get_users_in_role
# - Auth: login_required, role_required

@app.route("/requests/submit", methods=["GET", "POST"])
@login_required
# Only specific roles can initiate. Student & Talent Club are checked with is_leader/is_tc_leader
@role_required("librarian", "student", "teacher", "talent_club") # These roles are checked in the route logic
def submit_request():
    """Allows authorized users (requester roles) to submit a new request."""
    form = CreateRequestForm()
    permissions = get_request_permissions(current_user)

    # Double check if the current user is authorized to create a request
    # This handles student leaders / talent club leaders by their is_leader / is_tc_leader flags
    if not permissions['can_create_request']:
        flash("You do not have permission to submit new requests.", "danger")
        app.logger.warning(f"Unauthorized request submission attempt by user {current_user.username} (Role: {current_user.role.name}).")
        abort(403) # Forbidden

    if form.validate_on_submit():
        try:
            # Determine the initial handler (HR/CEO)
            hr_ceo_role_name = REQUEST_SYSTEM_PERMISSIONS['tier_handlers'][1]
            hr_ceos = get_users_in_role(hr_ceo_role_name)
            
            if not hr_ceos:
                flash("No HR/CEO users available to handle requests. Please contact administration.", "danger")
                app.logger.error("No active HR/CEO users found when attempting to submit a new request.")
                return render_template("requests/submit.html", form=form, title="Submit New Request")

            # Assign to the first active HR/CEO for simplicity (can implement round-robin later)
            initial_handler = hr_ceos[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id,
                current_handler_id=initial_handler.id,
                status='Pending',
                tier=1, # Always starts at Tier 1
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            db.session.add(new_request)
            db.session.flush() # Flush to get request ID for history and notification

            # Log history: Initial submission
            log_request_history(new_request, current_user, None, 'Pending', 'Submitted', new_request.description)

            db.session.commit() # Commit new request and history

            # Notify the initial handler
            notify_request_event(new_request, 'Submitted', changed_by_user=current_user)

            flash("Your request has been submitted successfully and is awaiting review.", "success")
            app.logger.info(f"Request ID {new_request.id} submitted by {current_user.username} (Role: {current_user.role.name}).")
            return redirect(url_for("my_requests"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error submitting request by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while submitting your request. Please try again.", "danger")

    return render_template("requests/submit.html", form=form, title="Submit New Request")

@app.route("/requests/my_requests")
@login_required
def my_requests():
    """Lists requests submitted by the current user."""
    # Filter requests by requester_id
    requests = db.session.scalars(
        select(Request)
        .where(Request.requester_id == current_user.id)
        .options(joinedload(Request.current_handler), joinedload(Request.requester)) # Eager load handler
        .order_by(Request.last_updated_at.desc()) # Newest updates first
    ).all()

    return render_template("requests/my_requests.html", requests=requests, title="My Submitted Requests")

@app.route("/requests/<int:request_id>/view")
@login_required
def view_request_detail(request_id):
    """Displays detailed information and history for a specific request."""
    request_obj = db.get_or_404(Request, request_id)
    permissions = get_request_permissions(current_user, request_obj)

    # User must be the requester, current handler, a global admin, or last_forwarded_by
    if not permissions['is_requester_of_request'] and \
       not permissions['is_handler_for_request'] and \
       not (current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo', 'school_executive', 'government']) and \
       (request_obj.last_forwarded_by_id != current_user.id): # Allow previous forwarders to view for audit
        flash("You do not have permission to view this request.", "danger")
        app.logger.warning(f"Unauthorized view of request ID {request_id} by user {current_user.username}.")
        abort(403)

    # Fetch request history
    history_records = db.session.scalars(
        select(RequestHistory)
        .where(RequestHistory.request_id == request_id)
        .options(joinedload(RequestHistory.changed_by))
        .order_by(RequestHistory.timestamp.asc()) # Oldest first for chronological display
    ).all()

    return render_template(
        "requests/detail.html",
        request_obj=request_obj,
        history_records=history_records,
        permissions=permissions, # Pass permissions for template logic (e.g., show/hide buttons)
        title=f"Request: {request_obj.title}"
    )

@app.route("/requests/inbox")
@login_required
@role_required("hr_ceo", "school_executive", "government") # Only these roles have an inbox
def requests_inbox():
    """Lists requests currently assigned to the current user for review."""
    # Fetch requests where the current user is the current_handler and status is not final
    inbox_requests = db.session.scalars(
        select(Request)
        .where(
            Request.current_handler_id == current_user.id,
            Request.status.notin_(['Resolved', 'Denied']) # Exclude already final statuses
        )
        .options(joinedload(Request.requester)) # Eager load requester for display
        .order_by(Request.urgency.desc(), Request.created_at.asc()) # High urgency first, then oldest
    ).all()

    return render_template("requests/inbox.html", inbox_requests=inbox_requests, title="Requests Inbox")

@app.route("/requests/<int:request_id>/review", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "school_executive", "government") # Only these roles can review
def review_request(request_id):
    """Allows handlers to review and update the status of a request."""
    request_obj = db.get_or_404(Request, request_id)
    permissions = get_request_permissions(current_user, request_obj)

    # Crucial authorization check: User must be the current handler or a global admin
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin']
    if not permissions['is_handler_for_request'] and not is_global_admin:
        flash("You do not have permission to review this request.", "danger")
        app.logger.warning(f"Unauthorized review attempt of request ID {request_id} by user {current_user.username}.")
        abort(403)

    # If the request is already resolved or denied, it cannot be reviewed further by this handler
    if request_obj.status in ['Resolved', 'Denied']:
        flash(f"This request is already '{request_obj.status}' and cannot be reviewed further.", "info")
        return redirect(url_for("view_request_detail", request_id=request_id))

    # Instantiate form, dynamically populating choices based on current user's role and request's tier
    form = ReviewRequestForm(
        obj=request_obj, # Pre-populate existing notes/reason
        current_user_role_name=current_user.role.name.lower(),
        request_tier=request_obj.tier,
        request_status=request_obj.status
    )

    # Populate 'forward_to_user_id' choices if the current role can forward
    if permissions['can_forward']:
        next_role_name = REQUEST_SYSTEM_PERMISSIONS['forward_paths'].get(current_user.role.name.lower())
        if next_role_name:
            next_tier_users = get_users_in_role(next_role_name)
            form.forward_to_user_id.choices = [(0, '--- Select User to Forward To ---')] + \
                                              [(u.id, f"{u.full_name} ({u.username})") for u in next_tier_users]
        else:
            form.forward_to_user_id.choices = [(0, 'No users in next tier or no forward path')]


    if form.validate_on_submit():
        old_status = request_obj.status
        selected_action = form.status.data # This is the action chosen from the dropdown (e.g., 'Approved', 'Forward')

        try:
            # Handle 'Forward' action
            if selected_action == 'Forward':
                if not permissions['can_forward']:
                    flash("You cannot forward this request.", "danger")
                    app.logger.warning(f"User {current_user.username} attempted to forward request {request_id} without permission.")
                    return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")

                # Update current handler and tier
                request_obj.current_handler_id = form.forward_to_user_id.data
                request_obj.tier += 1
                request_obj.status = 'Pending' # Reset status to Pending for the next handler
                request_obj.last_forwarded_by_id = current_user.id
                request_obj.last_updated_at = datetime.now(timezone.utc)

                # Log history
                log_request_history(request_obj, current_user, old_status, request_obj.status, 'Forwarded', form.resolution_notes.data)

                db.session.commit()

                # Notify the new handler
                new_handler = db.session.get(User, request_obj.current_handler_id)
                notify_request_event(request_obj, 'Forwarded', changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} forwarded successfully to {new_handler.full_name or new_handler.username}.", "success")
                app.logger.info(f"Request ID {request_obj.id} forwarded by {current_user.username} to tier {request_obj.tier}.")
                return redirect(url_for("requests_inbox"))

            # Handle 'Denied' action
            elif selected_action == 'Denied':
                if not form.denial_reason.data: # Should be caught by form validation but double check
                     flash("Denial reason is required if status is 'Denied'.", "danger")
                     return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")

                request_obj.status = 'Denied'
                request_obj.denial_reason = form.denial_reason.data.strip()
                request_obj.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None
                request_obj.current_handler_id = None # No longer assigned to anyone once denied
                request_obj.last_updated_at = datetime.now(timezone.utc)

                # Log history
                log_request_history(request_obj, current_user, old_status, 'Denied', 'Denied', form.denial_reason.data)

                db.session.commit()

                # Notify the requester
                notify_request_event(request_obj, 'Denied', changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} denied.", "info")
                app.logger.info(f"Request ID {request_obj.id} denied by {current_user.username}.")
                return redirect(url_for("requests_inbox"))

            # Handle 'Resolved' action (only for HR/CEO and School Executive)
            elif selected_action == 'Resolved':
                if current_user.role.name.lower() not in REQUEST_SYSTEM_PERMISSIONS['resolver_roles']:
                    flash("You do not have permission to mark this request as 'Resolved'.", "danger")
                    return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")
                
                request_obj.status = 'Resolved'
                request_obj.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None
                request_obj.denial_reason = None # Clear if previously denied
                request_obj.current_handler_id = None # No longer assigned to anyone once resolved
                request_obj.last_updated_at = datetime.now(timezone.utc)

                # Log history
                log_request_history(request_obj, current_user, old_status, 'Resolved', 'Resolved', form.resolution_notes.data)

                db.session.commit()

                # Notify the requester
                notify_request_event(request_obj, 'Resolved', changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} successfully resolved.", "success")
                app.logger.info(f"Request ID {request_obj.id} resolved by {current_user.username}.")
                return redirect(url_for("requests_inbox"))

            # Handle 'Approved' or 'On Progress' actions
            else: # Status is 'Approved' or 'On Progress'
                request_obj.status = selected_action
                request_obj.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None
                request_obj.denial_reason = None # Clear if previously denied

                # Log history
                log_request_history(request_obj, current_user, old_status, selected_action, 'Reviewed', form.resolution_notes.data)

                db.session.commit()

                # Notify the requester about status update
                notify_request_event(request_obj, 'Status_Updated', old_status=old_status, changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} status updated to '{selected_action}'.", "success")
                app.logger.info(f"Request ID {request_obj.id} status updated to '{selected_action}' by {current_user.username}.")
                return redirect(url_for("requests_inbox"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error reviewing request ID {request_id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the request. Please try again.", "danger")

    return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")


# --- Direct Initiation Routes (HR/CEO, School Executive) ---

@app.route("/requests/hr_ceo/new_to_school_exec", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin") # System Admin can also initiate this path
def hr_ceo_initiate_request():
    """Allows HR/CEO to initiate a new request directly to School Executive."""
    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            # Determine the next handler (School Executive)
            school_exec_role_name = REQUEST_SYSTEM_PERMISSIONS['tier_handlers'][2]
            school_execs = get_users_in_role(school_exec_role_name)
            
            if not school_execs:
                flash("No School Executive users available to handle requests. Cannot initiate.", "danger")
                app.logger.error("No active School Executive users found when HR/CEO attempted to initiate a request.")
                return render_template("requests/hr_ceo_initiate.html", form=form, title="New Request to School Executive")

            # Assign to the first active School Executive for simplicity
            initial_handler = school_execs[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id, # HR/CEO is the requester
                current_handler_id=initial_handler.id,
                status='Pending', # Still pending for the next tier
                tier=2, # Starts at Tier 2
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            db.session.add(new_request)
            db.session.flush()

            # Log history: Initial submission by HR/CEO
            log_request_history(new_request, current_user, None, 'Pending', 'Submitted (HR/CEO Direct)', new_request.description)

            db.session.commit()

            # Notify the initial handler (School Executive)
            notify_request_event(new_request, 'Submitted', changed_by_user=current_user)

            flash("Your request has been submitted to School Executive successfully!", "success")
            app.logger.info(f"HR/CEO {current_user.username} initiated request ID {new_request.id} to School Executive.")
            return redirect(url_for("my_requests")) # Or requests_inbox for HR/CEO

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error HR/CEO initiating request to School Executive by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while initiating the request. Please try again.", "danger")

    return render_template("requests/hr_ceo_initiate.html", form=form, title="New Request to School Executive")


@app.route("/requests/school_exec/new_to_government", methods=["GET", "POST"])
@login_required
@role_required("school_executive", "system_admin") # System Admin can also initiate this path
def school_exec_initiate_request():
    """Allows School Executive to initiate a new request directly to Government."""
    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            # Determine the final handler (Government)
            government_role_name = REQUEST_SYSTEM_PERMISSIONS['tier_handlers'][3]
            government_users = get_users_in_role(government_role_name)
            
            if not government_users:
                flash("No Government users available to handle requests. Cannot initiate.", "danger")
                app.logger.error("No active Government users found when School Executive attempted to initiate a request.")
                return render_template("requests/school_exec_initiate.html", form=form, title="New Request to Government")

            # Assign to the first active Government user for simplicity
            initial_handler = government_users[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id, # School Executive is the requester
                current_handler_id=initial_handler.id,
                status='Pending', # Still pending for the final tier
                tier=3, # Starts at Tier 3
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            db.session.add(new_request)
            db.session.flush()

            # Log history: Initial submission by School Executive
            log_request_history(new_request, current_user, None, 'Pending', 'Submitted (School Exec Direct)', new_request.description)

            db.session.commit()

            # Notify the final handler (Government)
            notify_request_event(new_request, 'Submitted', changed_by_user=current_user)

            flash("Your request has been submitted to Government successfully!", "success")
            app.logger.info(f"School Executive {current_user.username} initiated request ID {new_request.id} to Government.")
            return redirect(url_for("my_requests")) # Or requests_inbox for School Exec

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error School Executive initiating request to Government by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while initiating the request. Please try again.", "danger")

    return render_template("requests/school_exec_initiate.html", form=form, title="New Request to Government")

# --- PART X END: Multi-Tiered Request System Features ---

# --- PART 14 END: Analytics (Placeholder/Basic) ---

# --- PART X START: Talent Club Features ---

# Decorator to require user is a Talent Club member (defined in Phase 3)
# from .helpers import tc_member_required # Ensure this import is correct if moved to helpers file
@app.route("/talent_club/member_dashboard") # Or just /talent_club/dashboard if no coordinator dashboard
@login_required
@tc_member_required # Ensures user is an active TC member
def talent_club_dashboard_member_view(): # Unique function name
    # --- Data for Stat Cards ---
    # My Club Memberships Count (active memberships in active clubs)
    my_club_memberships_count = db.session.scalar(
        select(func.count(TalentClubMembership.talent_club_id))
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True
        )
    ) or 0

    # Clubs I Follow Count (for active clubs, excluding those I'm a member of)
    membered_club_ids = db.session.scalars(
        select(TalentClubMembership.talent_club_id)
        .where(TalentClubMembership.user_id == current_user.id, TalentClubMembership.is_active == True)
    ).all()
    my_followed_clubs_count = db.session.scalar(
        select(func.count(TalentClubFollow.talent_club_id))
        .join(TalentClubFollow.club)
        .where(
            TalentClubFollow.user_id == current_user.id,
            TalentClub.is_active == True,
            TalentClub.id.notin_(membered_club_ids) # Only count follows if not a member
        )
    ) or 0
    
    # My Pending Proposals Count
    my_pending_proposals_count = db.session.scalar(
        select(func.count(TalentClubProposal.id))
        .where(
            TalentClubProposal.creator_id == current_user.id,
            TalentClubProposal.status.in_(['pending_leader_review', 'pending_members_accept'])
        )
    ) or 0

    # TC-specific Notifications Count (placeholder, uses global for now)
    # For a more specific count, filter Notification.notification_type.startswith('tc_')
    # unread_tc_notifications_count = get_unread_notifications_count(current_user.id) # Already in context

    # --- Data for "My Active Clubs (Joined)" List ---
    my_active_club_memberships = db.session.scalars(
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category) 
            # Add other eager loads for club if needed by the partial, e.g., owner for display
        )
        .order_by(TalentClub.name.asc())
        .limit(5) # Show first 5 for dashboard snippet
    ).all()

    # --- Data for "Recent Activity in My Clubs" (Conceptual) ---
    # This would require a more complex query:
    # - Get IDs of clubs user is member of.
    # - Fetch recent TalentClubFeedPost items from those clubs' feeds.
    # - Format them into the 'activity' dictionary structure expected by the partial.
    # For now, passing an empty list.
    recent_my_clubs_activity = [] 
    # Example query idea (very simplified):
    if my_active_club_memberships:
        my_club_ids = [m.talent_club_id for m in my_active_club_memberships]
        recent_posts_in_my_clubs = db.session.scalars(
            select(TalentClubFeedPost)
            .join(TalentClubFeedPost.feed)
            .where(TalentClubFeed.talent_club_id.in_(my_club_ids))
            .order_by(TalentClubFeedPost.timestamp.desc())
            .limit(5)
        ).all()
        for post in recent_posts_in_my_clubs:
            recent_my_clubs_activity.append({
                'icon': 'bi-chat-right-text-fill', 'badge_color': 'primary',
                'text': f"New post in <strong>{post.feed.talent_club.name}</strong>: \"{post.content[:30]}...\"",
                'timestamp': post.timestamp,
                'url': url_for('view_talent_club_feed', club_id=post.feed.talent_club_id, _anchor=f'tc_feed_post-{post.id}')
            })


    # --- Data for "System TC Leader Info" ---
    system_tc_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).limit(1)
    )

    return render_template(
        "talent_club/dashboard.html", # The new TC Member dashboard template
        title="My Talent Club Hub - Nexus TC",
        my_club_memberships_count=my_club_memberships_count,
        my_followed_clubs_count=my_followed_clubs_count,
        my_pending_proposals_count=my_pending_proposals_count,
        my_active_club_memberships=my_active_club_memberships,
        recent_my_clubs_activity=recent_my_clubs_activity,
        system_tc_leader=system_tc_leader
        # unread_notifications_count is from context_processor
    )

@app.route("/join_talent_club", methods=["POST"])
@login_required
@role_required("student") 
def join_talent_club():
    if current_user.is_tc_member:
        flash("You are already a Talent Club member.", "info")
        return redirect(url_for("talent_club_dashboard_member_view")) # Redirect to TC Member Dashboard

    try:
        current_user.is_tc_member = True
        # Ensure the user is added to the TC Community group
        # add_to_tc_community_group helper should be defined (from app.py Part 3 / Phase J)
        # It handles checking if already a member and commits.
        community_add_success = add_to_tc_community_group(current_user) 
        
        db.session.commit() # Commit user.is_tc_member change

        if not community_add_success:
            flash("Welcome to the Talent Club! However, there was an issue adding you to the main community group. Please contact an administrator.", "warning")
        else:
            flash("Welcome to the Talent Club! You've also been added to the TC Community group.", "success")
        
        app.logger.info(f"Student {current_user.username} (ID: {current_user.id}) opted in to Talent Club.")
        return redirect(url_for("talent_club_dashboard_member_view")) # Redirect to TC Member Dashboard

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error student {current_user.id} joining Talent Club: {e}", exc_info=True)
        flash("An error occurred while joining Talent Club. Please try again.", "danger")
        return redirect(url_for("student_dashboard")) # Back to general student dashboard
@app.route("/talent_club/clubs")
@login_required
@tc_member_required # Custom decorator from app.py Part 4 / Phase J
def my_talent_clubs():
    # Clubs user is a MEMBER of (active memberships)
    my_memberships_query = (
        select(TalentClubMembership)
        .join(TalentClubMembership.club) # Join to TalentClub for ordering and eager loading
        .where(
            TalentClubMembership.user_id == current_user.id, 
            TalentClubMembership.is_active == True, # Only active memberships
            TalentClub.is_active == True # Only for active clubs
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_memberships = db.session.scalars(my_memberships_query).all()

    # Clubs user is FOLLOWING (and is not a member of)
    # Get IDs of clubs where user is already a member
    membered_club_ids = [m.talent_club_id for m in my_memberships]

    my_follows_query = (
        select(TalentClubFollow)
        .join(TalentClubFollow.club)
        .where(
            TalentClubFollow.user_id == current_user.id,
            TalentClub.is_active == True, # Only follow active clubs
            TalentClub.id.notin_(membered_club_ids) # Exclude clubs they are already a member of
        )
        .options(
            joinedload(TalentClubFollow.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubFollow.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_follows = db.session.scalars(my_follows_query).all()

    return render_template(
        "talent_club/my_clubs.html",
        my_memberships=my_memberships, # List of TalentClubMembership objects
        my_follows=my_follows,         # List of TalentClubFollow objects
        title="My Clubs & Follows - Nexus TC"
    )
@app.route("/talent_club/discover")
@login_required
@tc_member_required
def talent_club_discover():
    page = request.args.get('page', 1, type=int)
    per_page = 12 # Clubs per page
    search_query = request.args.get('search_query', '', type=str).strip()
    category_id_filter = request.args.get('category_id', '', type=str)

    query = (
        select(TalentClub)
        .where(TalentClub.is_active == True) # Only discover active clubs
        .options(
            joinedload(TalentClub.social_category), 
            joinedload(TalentClub.owner),
            # Eager load counts using subqueries for efficiency if your SQLAlchemy version supports it well,
            # or rely on relationship.count() in template (can be N+1 if not careful).
            # For now, template uses .count() on relationships.
            joinedload(TalentClub.memberships), # To allow .memberships.count()
            joinedload(TalentClub.follows)      # To allow .follows.count()
            )
    )

    if search_query:
        search_term = f"%{search_query}%"
        query = query.where(or_(TalentClub.name.ilike(search_term), TalentClub.description.ilike(search_term)))

    selected_category_id_int = None
    if category_id_filter and category_id_filter.isdigit():
        selected_category_id_int = int(category_id_filter)
        query = query.where(TalentClub.social_category_id == selected_category_id_int)

    query = query.order_by(TalentClub.level.desc(), TalentClub.name.asc()) # Example order
    pagination_obj = db.paginate(query, page=page, per_page=per_page, error_out=False)
    discoverable_clubs = pagination_obj.items
    
    # Get SocialCategory list for the filter dropdown
    all_social_categories_for_filter = get_social_categories() # Helper from app.py Part 4 / Phase J

    # Determine current user's status (member/follower) for each displayed club
    club_statuses = {}
    if discoverable_clubs:
        club_ids = [c.id for c in discoverable_clubs]
        
        memberships = db.session.scalars(
            select(TalentClubMembership.talent_club_id) # Select only the ID
            .where(TalentClubMembership.user_id == current_user.id, 
                   TalentClubMembership.talent_club_id.in_(club_ids),
                   TalentClubMembership.is_active == True)
        ).all()
        member_of_club_ids = set(memberships)

        follows = db.session.scalars(
            select(TalentClubFollow.talent_club_id) # Select only the ID
            .where(TalentClubFollow.user_id == current_user.id, 
                   TalentClubFollow.talent_club_id.in_(club_ids))
        ).all()
        following_club_ids = set(follows)

        for club_item in discoverable_clubs:
            club_statuses[club_item.id] = {
                'is_member': club_item.id in member_of_club_ids,
                'is_following': club_item.id in following_club_ids and club_item.id not in member_of_club_ids
            }
            
    return render_template("talent_club/discover.html",
                           all_clubs=discoverable_clubs, # Renamed for template consistency
                           categories=all_social_categories_for_filter, # For filter dropdown
                           pagination=pagination_obj,
                           search_query=search_query,
                           selected_category_id=selected_category_id_int,
                           club_statuses=club_statuses,
                           title="Discover Talent Clubs - Nexus TC")
@app.route("/talent_club/discover/search") # AJAX Endpoint for real-time search
@login_required
@tc_member_required
def talent_club_search():
    """Handles real-time search for Talent Clubs by name."""
    search_query = request.args.get('q', '').strip()
    if not search_query:
        return jsonify([]) # Return empty list if no query

    # Search for active clubs whose name matches the query (case-insensitive)
    results_query = (
        select(TalentClub)
        .where(
            TalentClub.is_active == True,
            TalentClub.name.ilike(f'%{search_query}%') # Case-insensitive LIKE
        )
        .order_by(TalentClub.name)
        .limit(10) # Limit results for performance
    )
    results = db.session.scalars(results_query).all()

    # Format results for JSON response (list of dictionaries)
    formatted_results = []
    for club in results:
         # Determine if the current user is a member or follower for display in search results
         is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=club, user=current_user, is_active=True).exists())
         is_following = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user).exists())

         formatted_results.append({
             'id': club.id,
             'name': club.name,
             'profile_photo_url': club.profile_photo_url,
             'is_member': is_member,
             'is_following': is_following,
             # Add other relevant info if needed
         })

    # Return JSON response
    return jsonify(formatted_results)

@app.route("/talent_club/<int:club_id>/profile")
@login_required
@tc_member_required # Any TC member can view an active club's profile
def view_talent_club_profile(club_id):
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is no longer active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # is_member and is_following needed for UI buttons on profile
    is_member = db.session.scalar(
        select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True).exists()
    )
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id)
    )
    is_following = (follow_entry is not None) and not is_member # Don't show "following" if already a member

    # For user_status on template (determines follow/join/member button state)
    user_status = 'none'
    if is_member: user_status = 'member'
    elif is_following: user_status = 'following'
    
    receive_notifications_status = follow_entry.receive_notifications if follow_entry else False
    
    # Fetch follower and member counts (these are relationship counts on the model)
    # The template used club.follows.count() and club.memberships.filter_by(is_active=True).count()
    # For follower_count on template:
    # total_engagement = (db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0) + \
    #                    (db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0)
    # Simpler in template if relationships are loaded. The template has:
    # follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
    # Ensure club.memberships and club.follows are queryable collections or efficiently countable.

    # Fetch content snippets for profile page (e.g., last 3-5 posts of each type)
    # This requires club.feed to be loaded.
    recent_posts_snippets = []
    media_snippets = []
    file_snippets = []
    text_snippets = []

    if club.feed: # Ensure club has a feed relationship
        recent_posts_snippets_query = (
            select(TalentClubFeedPost)
            .where(TalentClubFeedPost.feed_id == club.feed.id)
            .options(joinedload(TalentClubFeedPost.file)) # Eager load file for mimetype check
            .order_by(TalentClubFeedPost.timestamp.desc())
            .limit(9) # Fetch a few more to try and get diverse types
        )
        recent_posts_snippets = db.session.scalars(recent_posts_snippets_query).all()

        for p in recent_posts_snippets:
            if p.file and p.file.mimetype and (p.file.mimetype.startswith('image/') or p.file.mimetype.startswith('video/')) and len(media_snippets) < 3:
                media_snippets.append(p)
            elif p.file and len(file_snippets) < 3 : # Not image/video but has a file
                file_snippets.append(p)
            elif p.content and len(text_snippets) < 3:
                text_snippets.append(p)
    
    return render_template(
        "talent_club/club_profile.html",
        club=club, # Pass full club object with loaded owner, social_category, feed
        user_status=user_status,
        receive_notifications_status=receive_notifications_status,
        media_snippets=media_snippets,
        file_snippets=file_snippets,
        text_snippets=text_snippets,
        title=f"Profile: {club.name} - Nexus TC"
    )
    
# Endpoint to fetch full content for the Media, Files, Texts tabs

@app.route("/talent_club/<int:club_id>/follow_club", methods=["POST"]) # Matched action in JS
@login_required
@tc_member_required
def ajax_tc_follow_club(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        return jsonify({"success": False, "error": "Club is inactive."}), 400

    is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True).exists())
    if is_member:
        return jsonify({"success": False, "error": "You are already a member."}), 400
    
    existing_follow = db.session.scalar(select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id))
    if existing_follow:
        return jsonify({"success": False, "error": "Already following."}), 400

    try:
        new_follow = TalentClubFollow(club_id=club.id, user_id=current_user.id, receive_notifications=True)
        db.session.add(new_follow)
        db.session.commit()
        app.logger.info(f"User {current_user.id} followed TC Club {club.id}.")
        # Recalculate total engagement
        member_c = db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0
        follow_c = db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0
        return jsonify({"success": True, "message": f"Now following {club.name}.", "new_total_engagement": member_c + follow_c}), 200
    except Exception as e: # Catch other errors
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} following club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/unfollow_club", methods=["POST"]) # Matched action in JS
@login_required
@tc_member_required
def ajax_tc_unfollow_club(club_id):
    club = db.get_or_404(TalentClub, club_id)
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id))
    if not follow_entry:
        return jsonify({"success": False, "error": "Not following this club."}), 400
    try:
        db.session.delete(follow_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.id} unfollowed TC Club {club.id}.")
        member_c = db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0
        follow_c = db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0
        return jsonify({"success": True, "message": f"Unfollowed {club.name}.", "new_total_engagement": member_c + follow_c}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} unfollowing club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/toggle_notifications", methods=["POST"])
@login_required
@tc_member_required
def ajax_tc_toggle_notifications(club_id):
    club = db.get_or_404(TalentClub, club_id)
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id))
    if not follow_entry:
        return jsonify({"success": False, "error": "You must be following this club to change notification settings."}), 400
    try:
        follow_entry.receive_notifications = not follow_entry.receive_notifications
        db.session.commit()
        app.logger.info(f"User {current_user.id} toggled TC notifications for club {club.id} to {follow_entry.receive_notifications}.")
        return jsonify({"success": True, "message": "Notification setting updated.", "new_status": follow_entry.receive_notifications}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} toggling TC notifications for club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500
@app.route("/talent_club/<int:club_id>/content/<string:content_type>")
@login_required
@tc_member_required
def view_talent_club_content(club_id, content_type):
    """Fetches and renders a list of content posts for a specific club by type (for tabs)."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
         return jsonify({"error": "Club is inactive"}), 404 # Or redirect on error handler

    # Validate content_type
    valid_types = ['media', 'files', 'texts', 'all']
    if content_type not in valid_types:
        abort(404, description="Invalid content type.")

    # Build query for posts in the club's feed
    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed == club.feed)
        .options(joinedload(TalentClubFeedPost.author), joinedload(TalentClubFeedPost.file))
        .order_by(TalentClubFeedPost.timestamp.desc())
    )

    # Filter by content type
    if content_type == 'media':
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(
                or_(
                    File.mimetype.like('image/%'),
                    File.mimetype.like('video/%')
                )
            )
        )
    elif content_type == 'files':
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(
                ~or_( # NOT (image OR video)
                    File.mimetype.like('image/%'),
                    File.mimetype.like('video/%')
                )
            )
        )
    elif content_type == 'texts':
        posts_query = posts_query.where(TalentClubFeedPost.content.isnot(None))

    # Execute the query (consider pagination for large feeds)
    posts = db.session.scalars(posts_query).all()

    # Render a partial template for the list of posts and return HTML
    # Assume a template like `partials/talent_club/content_list.html` exists
    # This partial template needs to handle displaying posts based on their content type.
    return render_template(
        "partials/talent_club/content_list.html",
        posts=posts,
        club=club, # Pass club for context in template (e.g., allow_comments/reactions)
        content_type=content_type # Pass type to assist template rendering
    )


@app.route("/talent_club/<int:club_id>/follow", methods=["POST"])
@login_required
@tc_member_required
def talent_club_follow(club_id):
    """Allows a TC member to follow a specific Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
         return jsonify({"success": False, "error": "Club is inactive"}), 400

    # Check if user is already a member of this club instance
    is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=club, user=current_user, is_active=True).exists())
    if is_member:
        return jsonify({"success": False, "error": "You are already a member of this club"}), 400 # Cannot follow if a member

    # Check if user is already following
    is_following = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user).exists())
    if is_following:
        return jsonify({"success": False, "error": "You are already following this club"}), 400

    try:
        # Create the follow entry
        new_follow = TalentClubFollow(
            club=club,
            user=current_user,
            followed_at=datetime.now(timezone.utc),
            receive_notifications=True # Default to receiving notifications on follow
        )
        db.session.add(new_follow)
        db.session.commit()
        app.logger.info(f"User {current_user.id} started following Talent Club {club.id}.")
        # Return updated follower count (approx) or success message
        follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
        return jsonify({"success": True, "message": f"Following {club.name}", "follower_count": follower_count}), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} following club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to follow club"}), 500

@app.route("/talent_club/<int:club_id>/unfollow", methods=["POST"])
@login_required
@tc_member_required
def talent_club_unfollow(club_id):
    """Allows a TC member to unfollow a specific Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    # Check if user is a member (cannot unfollow if a member, must leave)
    is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=club, user=current_user, is_active=True).exists())
    if is_member:
         return jsonify({"success": False, "error": "You are a member of this club, not just following. Use the 'Leave Club' option instead."}), 400

    # Find the follow entry
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user))
    if not follow_entry:
        return jsonify({"success": False, "error": "You are not following this club"}), 400 # Or already unfollowed

    try:
        db.session.delete(follow_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.id} unfollowed Talent Club {club.id}.")
        # Return updated follower count (approx) or success message
        follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
        return jsonify({"success": True, "message": f"Unfollowed {club.name}", "follower_count": follower_count}), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} unfollowing club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to unfollow club"}), 500

# Endpoint to toggle notifications for a followed club
@app.route("/talent_club/<int:club_id>/toggle_notifications", methods=["POST"])
@login_required
@tc_member_required
def talent_club_toggle_notifications(club_id):
    """Toggles notification preference for a followed Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    # Find the follow entry - must be FOLLOWING, not just a member
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user))
    if not follow_entry:
        return jsonify({"success": False, "error": "You must be following this club to change notification settings"}), 400

    try:
        # Toggle the boolean value
        follow_entry.receive_notifications = not follow_entry.receive_notifications
        db.session.commit()
        app.logger.info(f"User {current_user.id} toggled notifications for Talent Club {club.id} to {follow_entry.receive_notifications}.")
        return jsonify({"success": True, "message": "Notification setting updated", "new_status": follow_entry.receive_notifications}), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} toggling notifications for club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to update notification setting"}), 500


@app.route("/talent_club/configuration")
@login_required
@tc_member_required
def talent_club_configuration():
    """Displays the Talent Club Configuration menu for TC members."""
    # This route just renders the template with navigation options.
    return render_template("talent_club/configuration.html", title="TC Configuration")

@app.route("/talent_club/configuration/my_club_management")
@login_required
@tc_member_required
def my_talent_club_management():
    # Fetch clubs where the user is 'creator' or 'admin'
    my_manager_memberships_query = (
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
            TalentClubMembership.role.in_(['creator', 'admin'])
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_manager_memberships = db.session.scalars(my_manager_memberships_query).all()

    # Fetch clubs where the user is just a 'member'
    my_member_memberships_query = (
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
            TalentClubMembership.role == 'member'
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_member_memberships = db.session.scalars(my_member_memberships_query).all()

    return render_template(
        "talent_club/config_my_clubs.html",
        my_manager_memberships=my_manager_memberships, # List of TalentClubMembership objects
        my_member_memberships=my_member_memberships,   # List of TalentClubMembership objects
        title="My Club Involvement - Nexus TC"
    )
# Route to view/post to a specific club's feed (via linked channel logic)
@app.route("/talent_club/<int:club_id>/feed", methods=["GET"]) # POST handled by a separate AJAX endpoint
@login_required
@tc_member_required 
def view_talent_club_feed(club_id):
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is not active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # Ensure the club has a feed record created (should happen when club is created)
    if not club.feed:
        # This is an inconsistency; ideally, a feed is created with the club.
        # For robustness, create it if missing, though this indicates a setup issue.
        app.logger.warning(f"Talent Club {club.id} ('{club.name}') was missing a feed record. Creating one now.")
        new_feed = TalentClubFeed(talent_club_id=club.id)
        db.session.add(new_feed)
        db.session.commit()
        club = db.session.get(TalentClub, club_id) # Re-fetch to get the new feed relationship

    # Permission to view feed (any TC member can view an active club's feed)
    # Posting permissions are checked separately.

    # Fetch initial posts (e.g., paginated)
    page = request.args.get('page', 1, type=int)
    per_page_posts = 10 
    
    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role), 
            joinedload(TalentClubFeedPost.file),
            # Eager load comments and their authors for each post
            joinedload(TalentClubFeedPost.comments).joinedload(TalentClubFeedComment.author).joinedload(User.role),
            # Eager load reactions for each post (for counts)
            joinedload(TalentClubFeedPost.reactions) 
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts = pagination.items
    
    post_form = PostContentForm() # For creating new posts in this feed

    # Determine if current user can post in this feed
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
    )
    can_post_in_feed = False
    if user_membership:
        can_post_in_feed = TALENT_CLUB_POSTING_PERMISSIONS.get(user_membership.role.lower(), False)
    
    # Determine if current user is a manager (owner or admin of this club) for edit/delete all posts
    is_club_manager = (club.owner_id == current_user.id) or (user_membership and user_membership.role == 'admin')


    return render_template("talent_club/club_feed.html",
                           club=club,
                           posts=posts,
                           pagination=pagination,
                           post_form=post_form,
                           can_post_in_feed=can_post_in_feed,
                           is_club_manager=is_club_manager, # Pass this for admin actions on posts
                           title=f"{club.name} Feed - Nexus TC")
                          
@app.route("/talent_club/<int:club_id>/feed/posts", methods=["POST"])
@login_required
@tc_member_required
def create_talent_club_feed_post(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active or not club.feed:
        return jsonify({"success": False, "error": "Club or its feed is not active/available."}), 403

    # Check posting permissions
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
    )
    can_post = False
    if user_membership:
        can_post = TALENT_CLUB_POSTING_PERMISSIONS.get(user_membership.role.lower(), False)
    
    if not can_post:
        return jsonify({"success": False, "error": "You do not have permission to post in this club's feed."}), 403

    form = PostContentForm(request.form) # For text content
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Post content or a file must be provided."}), 400
    if form.content.data and not form.content.validate(form): # Validate text content
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage) # Reusing general helper
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed. Check type/size."}), 400
        except Exception as e:
            app.logger.error(f"Error processing file for TC feed post by {current_user.username}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Error processing uploaded file."}), 500
            
    try:
        new_post = TalentClubFeedPost( # Use TalentClubFeedPost model
            feed_id=club.feed.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_post)
        db.session.commit()

        app.logger.info(f"User {current_user.username} created TC feed post ID {new_post.id} in club {club.id}.")

        post_for_render = db.session.query(TalentClubFeedPost).options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role),
            joinedload(TalentClubFeedPost.file),
            joinedload(TalentClubFeedPost.comments), 
            joinedload(TalentClubFeedPost.reactions)
        ).get(new_post.id)

        post_html = render_template("partials/_tc_feed_post_item.html", 
                                    post=post_for_render, 
                                    current_user=current_user,
                                    club=club) # Pass club to partial for context

        # TODO: Notify club followers/members (see Phase 3 TC Proposal notification logic for example)
        # notify_tc_club_new_post(new_post, club)

        return jsonify({"success": True, "message": "Post created!", "post_html": post_html}), 201
    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath: # Cleanup
            try: os.remove(os.path.join(current_app.static_folder, uploaded_file_obj.filepath))
            except: pass
        app.logger.error(f"Error creating TC feed post in club {club.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error creating post."}), 500

@app.route("/talent_club/feed/posts/<int:post_id>/delete", methods=["POST"])
@login_required
@tc_member_required
def delete_tc_feed_post_ajax(post_id): # Renamed to avoid conflict if a GET view existed
    post = db.get_or_404(TalentClubFeedPost, post_id)
    club = post.feed.talent_club

    # Permissions: Post author, Club owner, Club admin
    is_post_author = (post.author_id == current_user.id)
    user_membership = db.session.scalar(select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True))
    is_club_owner_or_admin = (club.owner_id == current_user.id) or (user_membership and user_membership.role == 'admin')

    if not (is_post_author or is_club_owner_or_admin):
        return jsonify({"success": False, "error": "Permission denied."}), 403
        
    try:
        # If post has an associated file, delete it from filesystem (optional, handle orphans otherwise)
        if post.file:
            file_to_delete = post.file
            full_file_path = os.path.join(current_app.static_folder, file_to_delete.filepath)
            # Delete the File DB record first or after, cascade might handle it.
            # For safety, explicitly delete file record if not cascaded by post deletion.
        
        db.session.delete(post) # This should cascade to comments and reactions if model relationships are set up with cascade='all, delete-orphan'
        if post.file: # Delete File record if post deletion doesn't cascade to it
            db.session.delete(post.file) # This assumes a one-to-one from post to file

        db.session.commit()
        
        # Now delete file from disk
        if post.file and file_to_delete: # Check if file_to_delete was set
             if os.path.exists(full_file_path):
                try:
                    os.remove(full_file_path)
                    app.logger.info(f"Deleted associated file {file_to_delete.filepath} for TC post {post.id}.")
                except Exception as fe:
                    app.logger.error(f"Error deleting file {file_to_delete.filepath} for TC post {post.id}: {fe}")


        app.logger.info(f"User {current_user.username} deleted TC feed post {post.id}.")
        return jsonify({"success": True, "message": "Post deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting TC feed post {post.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/talent_club/feed/posts/<int:post_id>/react", methods=["POST"])
@login_required
@tc_member_required
def react_tc_feed_post(post_id):
    post = db.get_or_404(TalentClubFeedPost, post_id)
    club = post.feed.talent_club

    if not club.is_active or not club.feed.allow_reactions:
        # Club owner/admin might bypass this
        user_membership = db.session.scalar(select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True))
        is_manager = (club.owner_id == current_user.id) or (user_membership and user_membership.role == 'admin')
        if not is_manager:
            return jsonify({"success": False, "error": "Reactions are disabled."}), 403

    data = request.get_json()
    emoji = data.get("emoji", "").strip()
    if not emoji or emoji not in ["", "", "", "", "", ""]: # Allowed emojis
        return jsonify({"success": False, "error": "Invalid emoji."}), 400

    try:
        existing_reaction = db.session.scalar(
            select(TalentClubFeedReaction).where(
                TalentClubFeedReaction.post_id == post.id,
                TalentClubFeedReaction.user_id == current_user.id,
                TalentClubFeedReaction.emoji == emoji
            )
        )
        user_reacted_flag = False
        if existing_reaction:
            db.session.delete(existing_reaction)
            action_message = "Reaction removed."
        else:
            # Optional: If only one reaction type per user is allowed, remove their other reactions first
            # db.session.query(TalentClubFeedReaction).filter_by(post_id=post.id, user_id=current_user.id).delete()
            new_reaction = TalentClubFeedReaction(post_id=post.id, user_id=current_user.id, emoji=emoji)
            db.session.add(new_reaction)
            action_message = "Reaction added."
            user_reacted_flag = True
        db.session.commit()

        new_count = db.session.scalar(
            select(func.count(TalentClubFeedReaction.id)).where(
                TalentClubFeedReaction.post_id == post.id, TalentClubFeedReaction.emoji == emoji)
        ) or 0
        
        app.logger.info(f"User {current_user.username} {action_message} emoji '{emoji}' on TC post {post.id}.")
        return jsonify({
            "success": True, "message": action_message, "emoji": emoji,
            "new_count": new_count, "user_reacted": user_reacted_flag
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error reacting TC post {post.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/talent_club/<int:club_id>/feed/posts") # GET request
@login_required
@tc_member_required # Must be TC member to view feed posts
def get_tc_feed_posts_paginated(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active or not club.feed:
        return jsonify({"success": False, "error": "Club or feed not available."}), 404

    page = request.args.get('page', 1, type=int)
    per_page_posts = 10

    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role), 
            joinedload(TalentClubFeedPost.file),
            joinedload(TalentClubFeedPost.comments).joinedload(TalentClubFeedComment.author),
            joinedload(TalentClubFeedPost.reactions)
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts_on_page = pagination.items

    posts_html = ""
    if posts_on_page:
        rendered_posts_list = [
            render_template("partials/_tc_feed_post_item.html", post=p, current_user=current_user, club=club)
            for p in posts_on_page
        ]
        # Also render the "Load More" button if there's a next page, for JS to replace old one
        if pagination.has_next:
            next_page_trigger_html = f"""
            <div class="text-center my-4" id="loadMoreTcPostsTrigger-{club.id}">
                <button class="btn btn-outline-primary load-more-tc-posts-btn" data-club-id="{club.id}" data-current-page="{pagination.page}">
                    <span class="spinner-border spinner-border-sm d-none me-1" role="status" aria-hidden="true"></span>
                    Load More Posts
                </button>
            </div>
            """
            rendered_posts_list.append(next_page_trigger_html)

        posts_html = "".join(rendered_posts_list)


    return jsonify({
        "success": True,
        "posts_html": posts_html, # Contains posts and potentially the next load_more button
        "has_next_page": pagination.has_next
    })

 # --- ADD or VERIFY these Redirect Routes ---
 @app.route("/talent_club/feed_posts/<int:post_id>/view")
 # @login_required # Optional: if shared links can be viewed by non-logged-in users for public TC content
 def view_tc_feed_post_redirect(post_id):
     post = db.session.get(TalentClubFeedPost, post_id)
     if not post or not post.feed or not post.feed.talent_club or not post.feed.talent_club.is_active:
         abort(404, description="Talent Club feed post not found or club is inactive.")

     # Permission Check: (Simplified - e.g., all TC members can view any active TC's feed posts)
     # More granular might involve checking if club is 'public' within TC system.
     if not current_user.is_authenticated or not current_user.is_tc_member:
         flash("You must be a logged-in Talent Club member to view this content.", "warning")
         return redirect(url_for('login', next=request.url))
     
     # Redirect to the frontend page that displays the feed, with an anchor to the post
     # This assumes your 'view_talent_club_feed' route can scroll to an anchor.
     return redirect(url_for('view_talent_club_feed', club_id=post.feed.talent_club_id, _anchor=f'tc_feed_post-{post.id}'))

 # Implement similar redirect routes for TalentClubCommunityMessage
 @app.route("/talent_club/community_messages/<int:message_id>/view")
 def view_tc_community_message_redirect(message_id):
     message = db.session.get(TalentClubCommunityMessage, message_id)
     if not message or not message.community:
         abort(404, description="Talent Club community message not found.")

     if not current_user.is_authenticated or not current_user.is_tc_member: # Must be TC member
         flash("You must be a logged-in Talent Club member to view this content.", "warning")
         return redirect(url_for('login', next=request.url))
     
     # Ensure user is part of the TC Community group (should be if is_tc_member is true after initial join)
     if not is_tc_community_member(current_user): # is_tc_community_member helper
          flash("You are not part of the Talent Club community group.", "warning")
          return redirect(url_for('talent_club_dashboard_member_view'))


     return redirect(url_for('view_tc_community_messages', _anchor=f'tcc_message-{message.id}'))
 # --- END Redirect Routes ---

@app.route("/talent_club/configuration/current_leader")
@login_required
@tc_member_required # Only TC members can view this page
def view_current_tc_leader():
    current_system_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).limit(1)
    )
    active_election = get_active_tc_leader_election() # Helper from app.py Part 3 / Phase J

    candidates_for_voting = []
    user_has_voted_in_active_election = None
    can_user_vote = False
    vote_form = None

    if active_election:
        candidates_for_voting = get_tc_leader_candidates() # Helper from app.py Part 3 / Phase J (all active TC members)
        user_has_voted_in_active_election = db.session.scalar(
            select(TalentClubLeaderVote).filter_by(election_id=active_election.id, voter_id=current_user.id).limit(1)
        )
        if not user_has_voted_in_active_election: # Can vote if election is active and they haven't voted
            can_user_vote = True
            # Pass the list of candidates to the form's __init__
            vote_form = TalentClubLeaderVoteForm(candidates=candidates_for_voting)
    
    return render_template(
        "talent_club/config_current_leader.html",
        current_leader=current_system_leader,
        active_election=active_election,
        candidates=candidates_for_voting, # For display or form population
        user_vote=user_has_voted_in_active_election, # The vote object if they voted
        can_vote=can_user_vote,
        vote_form=vote_form, # Pass form if user can vote
        title="TC Leadership & Election - Nexus TC"
    )

@app.route("/talent_club/leader_vote", methods=["POST"])
@login_required
@tc_member_required # Only TC members can vote
def cast_tc_leader_vote():
    """Handles casting a vote in an active TC Leader election."""
    # Ensure user is eligible to vote (is_tc_member) - handled by decorator
    # Ensure an election is active
    active_election = get_active_tc_leader_election()
    if not active_election:
        flash("No active Talent Club Leader election is in progress.", "danger")
        return redirect(url_for("view_current_tc_leader"))

    # Ensure user hasn't already voted
    existing_vote = db.session.scalar(select(TalentClubLeaderVote).filter_by(election=active_election, voter=current_user))
    if existing_vote:
        flash("You have already voted in this election.", "warning")
        return redirect(url_for("view_current_tc_leader"))

    # Get eligible candidates to populate the form and validate submitted candidate
    candidates = get_tc_leader_candidates()
    form = TalentClubLeaderVoteForm(candidates=candidates) # Need to pass candidates to validate submitted candidate_id

    if form.validate_on_submit():
        candidate_id = form.candidate_id.data
        # Verify the selected candidate is actually one of the eligible candidates
        candidate = next((c for c in candidates if c.id == candidate_id), None)

        if not candidate:
             flash("Invalid candidate selected.", "danger")
             # Re-render the voting form page with error
             # Need to pass necessary data to re-render the template correctly
             return render_template("talent_club/config_current_leader.html",
                                    current_leader=None, # Re-fetch if needed, or pass empty
                                    active_election=active_election,
                                    candidates=candidates,
                                    user_vote=None,
                                    can_vote=True,
                                    vote_form=form, # Pass the form with errors
                                    title="Current Talent Club Leader")


        try:
            # Create the vote entry
            new_vote = TalentClubLeaderVote(
                election=active_election,
                voter=current_user,
                candidate=candidate,
                voted_at=datetime.now(timezone.utc)
            )
            db.session.add(new_vote)
            db.session.commit()

            flash("Your vote has been cast successfully!", "success")
            app.logger.info(f"User {current_user.id} voted for user {candidate.id} in election {active_election.id}.")

            # Redirect back to the leader view page
            return redirect(url_for("view_current_tc_leader"))

        except IntegrityError:
             db.session.rollback()
             flash("You have already voted in this election.", "warning") # Safety net for unique constraint
             app.logger.warning(f"IntegrityError casting vote for user {current_user.id} in election {active_election.id}.")
             return redirect(url_for("view_current_tc_leader"))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error user {current_user.id} casting vote in election {active_election.id}: {e}", exc_info=True)
            flash("An error occurred while casting your vote. Please try again.", "danger")
            return redirect(url_for("view_current_tc_leader"))

    # If form validation fails (unlikely with just select field but possible)
    flash("Invalid vote submission.", "danger")
    # Re-render the voting form page with errors
    # Need to pass necessary data to re-render the template correctly
    return render_template("talent_club/config_current_leader.html",
                           current_leader=None,
                           active_election=active_election,
                           candidates=candidates,
                           user_vote=None,
                           can_vote=True,
                           vote_form=form,
                           title="Current Talent Club Leader")
# ute for displaying mentioned member invite response page
@app.route("/talent_club/invite/<int:mention_id>") # GET request
@login_required
@tc_member_required 
def view_tc_proposal_mention(mention_id):
    mention = db.get_or_404(TalentClubMention, mention_id, description="Proposal mention not found.")

    if mention.user_id != current_user.id:
        flash("This invitation is not for you.", "danger")
        return redirect(url_for("view_notifications")) # Or TC dashboard

    # Eager load related proposal data
    proposal = db.session.scalar(
        select(TalentClubProposal)
        .where(TalentClubProposal.id == mention.proposal_id)
        .options(
            joinedload(TalentClubProposal.creator),
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file)
        )
    )
    if not proposal: # Should not happen if mention exists
        flash("Associated proposal not found.", "danger")
        return redirect(url_for("view_notifications"))

    return render_template("talent_club/invite_response.html",
                           mention=mention,
                           proposal=proposal,
                           title=f"Invitation: Join '{proposal.name}' Proposal - Nexus TC")

# Endpoint to handle accepting/declining a club proposal mention
@app.route("/talent_club/invite/<int:mention_id>/respond/<string:response_action>", methods=["POST"]) # Renamed 'response' to 'response_action'
@login_required
@tc_member_required
def respond_tc_proposal_mention(mention_id, response_action):
    mention = db.get_or_404(TalentClubMention, mention_id, description="Proposal mention not found.")
    proposal = mention.proposal # Assumes relationship is loaded or accessible

    if mention.user_id != current_user.id:
        flash("This is not your invitation to respond to.", "danger")
        abort(403)

    if response_action not in ['accept', 'decline']:
        flash("Invalid response action.", "danger")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))

    if mention.status != 'pending':
        flash(f"You have already responded to this invitation (your response: {mention.status.title()}).", "info")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))
    
    # Crucially, only allow response if the main proposal is still in a state where responses matter
    if proposal.status != 'pending_leader_review':
        flash(f"This proposal (Status: {proposal.status.replace('_',' ').title()}) is no longer awaiting member responses.", "warning")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))

    try:
        if response_action == 'accept':
            mention.status = 'accepted'
        elif response_action == 'decline':
            mention.status = 'rejected'
        mention.responded_at = datetime.now(timezone.utc)
        db.session.commit()
        
        app.logger.info(f"User {current_user.username} {mention.status} mention ID {mention.id} for proposal '{proposal.name}'.")

        # Notify proposal creator
        creator = proposal.creator
        if creator and creator.is_active and creator.id != current_user.id:
            response_text = "accepted" if mention.status == 'accepted' else "declined"
            content = f"{current_user.full_name or current_user.username} has {response_text} your invitation to join the '{proposal.name}' club proposal."
            link = url_for('review_tc_proposal', proposal_id=proposal.id, _external=True) # Link for TC Leader, or a creator view of proposal
            # Link for creator could be my_talent_club_proposals or a detail view of their own proposal
            # For now, TC Leader link is fine, creator can see status on their "My Proposals" page.

            notify_tc_member(
                receiver_user=creator,
                sender_user=current_user,
                content=content,
                notification_type='tc_mention_response_to_creator', # New distinct type
                related_object_id=mention.id, # Could link to the mention or the proposal
                link_url=link # Link to the proposal detail/review page
            )

        flash(f"Thank you! You have {mention.status.title()} the invitation for '{proposal.name}'.", "success" if mention.status == 'accepted' else "info")
        return redirect(url_for("view_notifications")) # Or back to My Proposals

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error responding to TC mention {mention_id} by {current_user.id}: {e}", exc_info=True)
        flash("An error occurred while processing your response. Please try again.", "danger")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))
# Route for viewing submitted proposals (for the creator)
@app.route("/talent_club/my_proposals")
@login_required
@tc_member_required
def my_talent_club_proposals():
    proposals_query = (
        select(TalentClubProposal)
        .where(TalentClubProposal.creator_id == current_user.id)
        .options(
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file),
            joinedload(TalentClubProposal.reviewed_by) # If displaying reviewer
            # No need to load all mentioned_members here for list view, just count
        )
        .order_by(TalentClubProposal.created_at.desc())
    )
    proposals = db.session.scalars(proposals_query).all()

    accepted_counts = {}
    for p in proposals:
        # Efficiently count accepted mentions for each proposal
        accepted_counts[p.id] = db.session.scalar(
            select(func.count(TalentClubMention.id))
            .where(TalentClubMention.proposal_id == p.id, TalentClubMention.status == 'accepted')
        ) or 0
        
    return render_template("talent_club/my_proposals.html",
                           proposals=proposals,
                           accepted_counts=accepted_counts,
                           title="My Club Proposals - Nexus TC")
                           
@app.route("/talent_club/configuration/community") # This is a navigation link from config menu
@login_required
@tc_member_required # Ensures only TC members can access this path
def talent_club_community_group():
    # get_tc_community_group() helper should be defined (from app.py Part 3 / Phase J)
    # It fetches the single TalentClubCommunity instance.
    community_group = get_tc_community_group() 
    if not community_group:
        flash("The Talent Club Community group has not been configured by an administrator yet.", "danger")
        app.logger.error("TC Community group not found in DB when navigating from config menu.")
        return redirect(url_for("talent_club_configuration"))

    # Ensure current user (who is a TC member due to @tc_member_required) is in the TalentClubCommunityMember table
    # is_tc_community_member() and add_to_tc_community_group() helpers are from app.py Part 3 / Phase J
    if not is_tc_community_member(current_user):
        add_success = add_to_tc_community_group(current_user)
        if not add_success:
            flash("Successfully joined Talent Club, but there was an issue adding you to the TC Community group chat. Please contact an administrator.", "warning")
            # Log is in helper
        else:
            flash("You've been added to the Talent Club Community group chat!", "info")
            
    # All checks passed, redirect to the actual message viewing route
    return redirect(url_for("view_tc_community_messages"))

@app.route("/talent_club/community/messages", methods=["GET"]) # POST handled by separate AJAX endpoint
@login_required
@tc_member_required
def view_tc_community_messages():
    community_group = get_tc_community_group()
    if not community_group:
        flash("Talent Club Community group is not available.", "danger")
        return redirect(url_for("talent_club_dashboard_member_view")) # Redirect to TC member dashboard

    # Double check membership (should be guaranteed by redirect from /talent_club/configuration/community)
    if not is_tc_community_member(current_user):
        flash("You are not a member of the TC Community group.", "danger")
        app.logger.warning(f"User {current_user.id} attempted direct access to TCC messages but not a member.")
        return redirect(url_for("talent_club_dashboard_member_view"))

    # Determine if user can post (not muted system-wide in TC)
    # is_currently_banned_muted helper from app.py Part 3 / Phase J
    active_restriction = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == current_user.id,
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        )
    )
    can_post_in_community = not (active_restriction and active_restriction.type == 'mute')


    # Fetch initial messages for display
    # Template uses column-reverse, so fetch oldest first if JS will prepend, or newest if template handles display order
    messages_query = (
        select(TalentClubCommunityMessage) # Your TalentClubCommunityMessage model
        .where(TalentClubCommunityMessage.community_id == community_group.id)
        .options(
            joinedload(TalentClubCommunityMessage.author).joinedload(User.role), 
            joinedload(TalentClubCommunityMessage.file)
        )
        .order_by(TalentClubCommunityMessage.timestamp.asc()) # Oldest first for chat-like display
        .limit(50) # Initial batch
    )
    messages = db.session.scalars(messages_query).all()
    
    post_form = PostContentForm() # For message input (reusing from social features)

    return render_template("talent_club/community_group.html",
                           community_group=community_group,
                           messages=messages,
                           post_form=post_form,
                           can_post_in_community=can_post_in_community,
                           title=f"{community_group.name} - Nexus TC")
@app.route("/talent_club/leaderboard")
@login_required
@tc_member_required
@cache.cached(timeout=3600)
def talent_club_leaderboard():
    leaderboard_clubs = db.session.scalars(
        select(TalentClub)
        .where(TalentClub.is_active == True)
        .options(joinedload(TalentClub.owner), joinedload(TalentClub.social_category), joinedload(TalentClub.memberships), joinedload(TalentClub.follows)) # Load for counts
        .order_by(TalentClub.level.desc(), TalentClub.warning_count.asc(), TalentClub.name.asc())
    ).all()
    
    return render_template(
        "talent_club/leaderboard.html",
        leaderboard_clubs=leaderboard_clubs,
        title="Talent Club Leaderboard - Nexus TC"
    )

# --- TC Leader Specific Routes (Requires is_tc_leader = TRUE) ---
# We need a custom decorator or check within routes for is_tc_leader

def tc_leader_required(f):
    """Decorator to restrict access to routes to the system-wide Talent Club Leader."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check if the user is the system-wide TC Leader
        if not current_user.is_tc_leader:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC Leader restricted route {request.path} but is not the leader."
            )
            flash("You must be the Talent Club Leader to access this page.", "danger")
            # Redirect them back to the main TC dashboard
            return redirect(url_for('talent_club_dashboard'))

        return f(*args, **kwargs)

    return decorated_function

# Route to view pending proposals for the TC Leader
@app.route("/talent_club/leader/proposals")
@login_required
@tc_leader_required # Custom decorator for system-wide TC Leader
def review_tc_proposals():
    pending_proposals_query = (
        select(TalentClubProposal)
        .where(TalentClubProposal.status == 'pending_leader_review')
        .options(
            joinedload(TalentClubProposal.creator),
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file) # For viewing document
            # mentioned_members are loaded per proposal below for counts and details
        )
        .order_by(TalentClubProposal.created_at.asc()) # Oldest first
    )
    pending_proposals = db.session.scalars(pending_proposals_query).all()

    proposal_mentions_details = {} # To store list of mention objects per proposal
    accepted_mention_counts = {}   # To store count of accepted mentions per proposal

    for proposal in pending_proposals:
        mentions_for_proposal = db.session.scalars(
            select(TalentClubMention)
            .where(TalentClubMention.proposal_id == proposal.id)
            .options(joinedload(TalentClubMention.user).joinedload(User.role)) # Load user and their role
        ).all()
        proposal_mentions_details[proposal.id] = mentions_for_proposal
        
        accepted_mention_counts[proposal.id] = sum(
            1 for m in mentions_for_proposal if m.status == 'accepted' and m.user_id != proposal.creator_id
        )

    return render_template(
        "talent_club/leader/review_proposals.html",
        pending_proposals=pending_proposals,
        proposal_mentions=proposal_mentions_details, # Pass the actual mention objects
        accepted_counts=accepted_mention_counts,     # Pass the calculated counts
        title="Review Club Proposals - TC Leader Admin - Nexus TC"
    )
@app.route("/talent_club/leader/proposals/<int:proposal_id>/review", methods=["GET", "POST"])
@login_required
@tc_leader_required
def review_tc_proposal(proposal_id):
    proposal = db.get_or_404(TalentClubProposal, proposal_id, description="Proposal not found.")

    if proposal.status != 'pending_leader_review':
        flash(f"This proposal (Status: {proposal.status.replace('_',' ').title()}) is no longer awaiting leader review.", "info")
        return redirect(url_for("review_tc_proposals"))

    mentions = db.session.scalars(
        select(TalentClubMention)
        .where(TalentClubMention.proposal_id == proposal.id)
        .options(joinedload(TalentClubMention.user).joinedload(User.role))
    ).all()
    
    accepted_count = sum(1 for m in mentions if m.status == 'accepted' and m.user_id != proposal.creator_id)
    MIN_REQUIRED_ACCEPTED_FOR_CLUB = 5 # Define your constant
    meets_min_members = accepted_count >= MIN_REQUIRED_ACCEPTED_FOR_CLUB

    if request.method == "POST":
        action = request.form.get('action')
        review_notes = request.form.get('review_notes', '').strip()
        
        if action not in ['accept', 'reject', 'save_notes']:
            flash("Invalid review action specified.", "danger")
            # Re-render with current data
            return render_template(
                "talent_club/leader/review_proposal_detail.html",
                proposal=proposal, mentions=mentions, accepted_count=accepted_count,
                meets_min_members=meets_min_members, title=f"Review: {proposal.name} - Nexus TC")

        try:
            proposal.leader_review_notes = review_notes if review_notes else proposal.leader_review_notes
            proposal.reviewed_by_id = current_user.id
            proposal.reviewed_at = datetime.now(timezone.utc)

            if action == 'accept':
                if not meets_min_members:
                    flash(f"Cannot accept: Proposal needs at least {MIN_REQUIRED_ACCEPTED_FOR_CLUB} accepted mentions (has {accepted_count}).", "danger")
                else:
                    proposal.status = 'accepted'
                    # --- Create TalentClub, Feed, Memberships ---
                    new_club = TalentClub(
                        name=proposal.name,
                        description=proposal.description,
                        # profile_photo_url set later via edit club profile
                        owner_id=proposal.creator_id,
                        social_category_id=proposal.social_category_id,
                        level=1, # Default start level
                        is_active=True,
                        created_at=datetime.now(timezone.utc)
                    )
                    db.session.add(new_club)
                    db.session.flush() # Get new_club.id

                    new_feed = TalentClubFeed(talent_club_id=new_club.id) # Create linked feed
                    db.session.add(new_feed)

                    # Add creator as 'creator' role member
                    creator_membership = TalentClubMembership(club_id=new_club.id, user_id=proposal.creator_id, role='creator')
                    db.session.add(creator_membership)

                    # Add accepted mentioned members as 'member' role
                    for mention in mentions:
                        if mention.status == 'accepted' and mention.user_id != proposal.creator_id:
                            member_membership = TalentClubMembership(club_id=new_club.id, user_id=mention.user_id, role='member')
                            db.session.add(member_membership)
                    
                    db.session.commit() # Commit proposal, new club, feed, memberships
                    app.logger.info(f"TC Proposal {proposal.id} accepted by {current_user.username}. New Club ID: {new_club.id}")
                    flash(f"Proposal '{proposal.name}' accepted and Talent Club created!", "success")

                    # --- Notifications for Acceptance ---
                    # 1. To Creator
                    notify_tc_member(proposal.creator, current_user, f"Your club proposal '{new_club.name}' has been APPROVED and the club is now active!",
                                     'tc_proposal_approved_creator', new_club.id, url_for('view_talent_club_feed', club_id=new_club.id, _external=True))
                    # 2. To Accepted Members
                    for mention in mentions:
                        if mention.status == 'accepted' and mention.user_id != proposal.creator_id:
                             notify_tc_member(mention.user, current_user, f"The proposal for '{new_club.name}' (which you accepted) has been approved! You are now a member.",
                                              'tc_club_membership_granted', new_club.id, url_for('view_talent_club_feed', club_id=new_club.id, _external=True))
                    return redirect(url_for("review_tc_proposals"))

            elif action == 'reject':
                proposal.status = 'rejected'
                db.session.commit()
                app.logger.info(f"TC Proposal {proposal.id} rejected by {current_user.username}.")
                flash(f"Proposal '{proposal.name}' has been rejected.", "info")
                
                # --- Notifications for Rejection ---
                # 1. To Creator
                notes_info = f" Reviewer notes: {proposal.leader_review_notes[:100]}..." if proposal.leader_review_notes else ""
                notify_tc_member(proposal.creator, current_user, f"Your club proposal '{proposal.name}' has been REJECTED.{notes_info}",
                                 'tc_proposal_rejected_creator', proposal.id, url_for('my_talent_club_proposals', _external=True)) # Link to their proposals list
                # 2. To Mentioned Members (who had accepted/pending)
                for mention in mentions:
                     if mention.status in ['accepted', 'pending'] and mention.user_id != proposal.creator_id:
                          notify_tc_member(mention.user, current_user, f"The club proposal '{proposal.name}' (that you were mentioned in) has been rejected by the TC Leader.",
                                           'tc_proposal_rejected_mention', proposal.id, url_for('view_notifications', _external=True)) # Generic link
                return redirect(url_for("review_tc_proposals"))

            elif action == 'save_notes':
                db.session.commit()
                flash("Review notes saved for this proposal.", "success")
                # Stay on the same page to continue review
                return redirect(url_for('review_tc_proposal', proposal_id=proposal.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error processing TC proposal {proposal.id} action '{action}' by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while processing the proposal.", "danger")

    # For GET request
    return render_template("talent_club/leader/review_proposal_detail.html",
                           proposal=proposal,
                           mentions=mentions,
                           accepted_count=accepted_count,
                           meets_min_members=meets_min_members,
                           title=f"Review Proposal: {proposal.name} - Nexus TC")

@app.route("/talent_club/leader/club/<int:club_id>/set_level", methods=["POST"])
@login_required
@tc_leader_required
def set_talent_club_level_action(club_id): # Renamed to avoid conflict if a GET view existed
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        flash("Cannot change level of an inactive club.", "warning")
        return redirect(url_for("manage_talent_clubs_leader"))

    form = TalentClubLevelForm(request.form) # Bind form to request data for validation

    if form.validate_on_submit(): # WTForms validation
        new_level = form.level.data
        old_level = club.level

        # Optional: Further validation if TALENT_CLUB_LEVELS is a list of allowed values
        # if new_level not in [lvl[1] if isinstance(lvl, tuple) else lvl for lvl in TALENT_CLUB_LEVELS]:
        #     flash("Invalid level selected.", "danger")
        #     return redirect(url_for("manage_talent_clubs_leader"))

        try:
            club.level = new_level
            db.session.commit()
            app.logger.info(f"TC Leader {current_user.username} set level of club {club.id} from {old_level} to {new_level}.")
            flash(f"Level for club '{club.name}' successfully updated to {new_level}.", "success")

            # --- Notification for Level Change ---
            # (Similar notification logic as in your original app.py Part X for set_talent_club_level)
            # Query members and followers who want notifications.
            # Send notification with notify_tc_member(...)
            # Example:
            # users_to_notify = get_club_members_and_followers_for_notification(club) # A helper you'd create
            # for user_to_notify in users_to_notify:
            #    notify_tc_member(user_to_notify, current_user, f"Club '{club.name}' level changed to {new_level}.", 'tc_level_change', club.id, url_for('view_talent_club_profile', club_id=club.id, _external=True))


        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error setting level for club {club.id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while updating the club level.", "danger")
    else:
        # Form validation failed
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(form, field).label.text}: {error}", "danger")
                
    return redirect(url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/club/<int:club_id>/set_level", methods=["POST"])
@login_required
@tc_leader_required
def set_talent_club_level(club_id):
    """Allows the TC Leader to set the level of a Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
         flash("Cannot change level of an inactive club.", "warning")
         return redirect(request.referrer or url_for("manage_talent_clubs_leader"))

    form = TalentClubLevelForm() # Use the level form

    if form.validate_on_submit():
        new_level = form.level.data

        # Optional validation: Ensure level is within a valid range if you have a max level
        # if new_level not in TALENT_CLUB_LEVELS and isinstance(TALENT_CLUB_LEVELS[0], int): # Check if using integer levels
        #      flash("Invalid level provided.", "danger")
        #      # Need to re-render the management page or handle AJAX error
        #      return redirect(request.referrer or url_for("manage_talent_clubs_leader")) # Redirect for simplicity

        old_level = club.level

        try:
            club.level = new_level
            db.session.commit()

            # --- Notification ---
            # Notify club members and followers (who want notifications) about level change
            members_and_followers = db.session.scalars(
                 select(User)
                 .join(TalentClubMembership, and_(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True), isouter=True) # Outer join for members
                 .join(TalentClubFollow, TalentClubFollow.talent_club_id == club.id, isouter=True) # Outer join for follows
                 .where(or_(TalentClubMembership.user_id == User.id, TalentClubFollow.user_id == User.id)) # User is in either membership or follow
                 .distinct() # Ensure distinct users
                 .where(User.is_active == True, User.id != current_user.id) # Only active, not the leader
            ).all()

            if members_and_followers:
                 notification_content = f"Talent Club '{club.name}' level changed from {old_level} to {new_level}."
                 link_url = url_for('view_talent_club_profile', club_id=club.id)

                 notifications_to_add = []
                 for user in members_and_followers:
                      # Only notify followers if their setting is True
                      if user.is_tc_member or (user.tc_follows.filter_by(club=club, receive_notifications=True).first() is not None): # Notify members, or followers with notifications on
                            try:
                                 notify = Notification(
                                     sender_id=current_user.id,
                                     receiver_id=user.id,
                                     content=notification_content,
                                     link_url=link_url,
                                     timestamp=datetime.now(timezone.utc),
                                     is_read=False,
                                     notification_type='tc_level_change', # Specific type
                                     related_object_id=club.id
                                 )
                                 notifications_to_add.append(notify)
                            except Exception as notify_e:
                                 app.logger.error(f"Error creating TC level change notification for user {user.id}: {notify_e}")

                 if notifications_to_add:
                    db.session.add_all(notifications_to_add)
                    db.session.commit()
                    app.logger.info(f"Notified {len(notifications_to_add)} users about level change for club {club.id}.")


            flash(f"Level for club '{club.name}' set to {new_level}.", "success")
            app.logger.info(f"TC Leader {current_user.id} set level of club {club.id} to {new_level}.")

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error TC Leader {current_user.id} setting level for club {club.id}: {e}", exc_info=True)
            flash("An error occurred while setting the club level. Please try again.", "danger")

    else:
         # If form validation failed (e.g., non-integer level)
         flash("Invalid level submitted.", "danger")

    # Redirect back to club management page
    return redirect(request.referrer or url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/club/<int:club_id>/warn", methods=["POST"])
@login_required
@tc_leader_required
def warn_talent_club_action(club_id): # Renamed
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        flash("Cannot issue a warning to an inactive club.", "warning")
        return redirect(url_for("manage_talent_clubs_leader"))

    form = TalentClubWarningForm(request.form) # Bind to request data

    if form.validate_on_submit():
        try:
            reason = form.reason.data.strip()
            new_warning = TalentClubWarning(
                talent_club_id=club.id,
                issued_by_id=current_user.id,
                reason=reason,
                issued_at=datetime.now(timezone.utc)
            )
            db.session.add(new_warning)
            club.warning_count += 1
            
            club_deactivated_due_to_warnings = False
            if club.level == 1 and club.warning_count >= 3:
                club.is_active = False # Soft delete
                club_deactivated_due_to_warnings = True
                app.logger.warning(f"TC Club {club.id} ('{club.name}') deactivated due to reaching 3 warnings at Level 1.")
            
            db.session.commit()
            
            flash_message = f"Warning issued to club '{club.name}'. Reason: {reason}. Warning count is now {club.warning_count}."
            if club_deactivated_due_to_warnings:
                flash_message += " The club has been deactivated due to exceeding warnings at Level 1."
            flash(flash_message, "success" if not club_deactivated_due_to_warnings else "danger")
            app.logger.info(f"TC Leader {current_user.username} issued warning to club {club.id}. Reason: {reason}. Count: {club.warning_count}.")

            # --- Notifications for Warning & Potential Deactivation ---
            # (Similar to your original app.py Part X for warn_talent_club)
            # Notify club owner, members, followers about the warning.
            # If club deactivated, send a specific "club_destroyed" notification.

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error issuing warning to club {club.id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while issuing the warning.", "danger")
    else:
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(form, field).label.text}: {error}", "danger")
                
    return redirect(url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/member_management")
@login_required
@tc_leader_required # Custom decorator for system-wide TC Leader
def manage_tc_members_leader():
    active_tc_members_query = (
        select(User)
        .where(User.is_tc_member == True, User.is_active == True)
        .options(joinedload(User.role), joinedload(User.tc_memberships).joinedload(TalentClubMembership.club)) # Load roles and club memberships
        .order_by(User.full_name.asc())
    )
    tc_members = db.session.scalars(active_tc_members_query).all()

    member_ban_status = {} # To store active TalentClubBan object or None
    if tc_members:
        member_ids = [m.id for m in tc_members]
        active_bans = db.session.scalars(
            select(TalentClubBan)
            .where(
                TalentClubBan.user_id.in_(member_ids),
                or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
            )
        ).all()
        for ban in active_bans:
            member_ban_status[ban.user_id] = ban
            
    return render_template(
        "talent_club/leader/member_management.html",
        tc_members=tc_members,
        member_ban_status=member_ban_status,
        title="Manage TC Members - TC Leader Admin - Nexus TC"
    )
    
@app.route("/talent_club/leader/member/<int:user_id>/ban_mute", methods=["GET", "POST"])
@login_required
@tc_leader_required
def ban_mute_tc_member(user_id):
    user_to_manage = db.get_or_404(User, user_id, description="User not found.")

    if not user_to_manage.is_tc_member: # Can only ban/mute current TC members
        flash(f"{user_to_manage.full_name or user_to_manage.username} is not currently a Talent Club member.", "warning")
        return redirect(url_for("manage_tc_members_leader"))
    if user_to_manage.id == current_user.id:
        flash("You cannot ban or mute yourself.", "danger")
        return redirect(url_for("manage_tc_members_leader"))

    # Fetch current active ban/mute, if any
    active_ban_object = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == user_to_manage.id,
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        ).limit(1)
    )
    
    form = TalentClubBanMuteForm() # Your form definition

    if form.validate_on_submit():
        ban_type_from_form = form.ban_type.data
        reason_from_form = form.reason.data.strip()
        duration_days_from_form = form.duration_days.data # Integer or None

        if ban_type_from_form not in TALENT_CLUB_BAN_TYPES: # TALENT_CLUB_BAN_TYPES from app.py config
            flash("Invalid action type selected.", "danger")
        else:
            try:
                # End any existing active ban/mute for this user before applying a new one
                if active_ban_object:
                    active_ban_object.expires_at = datetime.now(timezone.utc) - timedelta(seconds=1) # Expire immediately
                    db.session.add(active_ban_object) # Add to session for commit
                    app.logger.info(f"Expiring previous ban/mute ID {active_ban_object.id} for user {user_to_manage.id} before applying new one.")

                expires_at_val = None
                if duration_days_from_form is not None and duration_days_from_form > 0:
                    expires_at_val = datetime.now(timezone.utc) + timedelta(days=duration_days_from_form)

                new_ban_entry = TalentClubBan(
                    user_id=user_to_manage.id,
                    issued_by_id=current_user.id,
                    type=ban_type_from_form,
                    reason=reason_from_form,
                    issued_at=datetime.now(timezone.utc),
                    expires_at=expires_at_val
                )
                db.session.add(new_ban_entry)

                # Apply side-effects of 'ban'
                if ban_type_from_form == 'ban':
                    user_to_manage.is_tc_member = False # Revoke TC membership
                    # Remove from TC Community Group
                    community_group = get_tc_community_group()
                    if community_group:
                        community_member_entry = db.session.scalar(select(TalentClubCommunityMember).filter_by(community_id=community_group.id, user_id=user_to_manage.id))
                        if community_member_entry:
                            db.session.delete(community_member_entry)
                    # Deactivate/remove from all specific club memberships
                    db.session.query(TalentClubMembership).filter_by(user_id=user_to_manage.id).update({"is_active": False})
                    # Remove all club follows
                    db.session.query(TalentClubFollow).filter_by(user_id=user_to_manage.id).delete()
                    if user_to_manage.is_tc_leader: # If they were the system leader
                        user_to_manage.is_tc_leader = False
                        app.logger.warning(f"System TC Leader {user_to_manage.username} was banned and demoted.")
                        # TODO: Notify HR/CEO about this auto-demotion
                
                db.session.commit()
                flash(f"{user_to_manage.full_name or user_to_manage.username} has been successfully {ban_type_from_form}ned.", "success")
                app.logger.info(f"TC Leader {current_user.username} {ban_type_from_form}ned user {user_to_manage.id}. Reason: {reason_from_form}.")

                # --- Notification to the affected user ---
                notif_content = f"You have received a Talent Club system {ban_type_from_form}. Reason: {reason_from_form[:100]}..."
                if expires_at_val: notif_content += f" Expires: {expires_at_val.strftime('%Y-%m-%d %H:%M')}."
                if user_to_manage.is_active: # Only notify if user account is active
                    notify_tc_member(user_to_manage, current_user, notif_content, f'tc_system_{ban_type_from_form}', new_ban_entry.id, None)

                return redirect(url_for("manage_tc_members_leader"))
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error applying {ban_type_from_form} to user {user_id} by {current_user.username}: {e}", exc_info=True)
                flash(f"An error occurred. Could not apply {ban_type_from_form}.", "danger")
    
    # For GET request or if form validation failed
    return render_template("talent_club/leader/ban_mute_member.html",
                           user_to_manage=user_to_manage,
                           active_ban=active_ban_object, # Pass current ban object
                           form=form,
                           title=f"Apply Restriction to {user_to_manage.full_name or user_to_manage.username} - Nexus TC")

@app.route("/talent_club/api/community/<int:community_group_id>/messages/new")
@login_required
@tc_member_required
def ajax_get_new_tc_community_messages(community_group_id):
    # Verify community_group_id matches the single global one, or adapt if multiple could exist
    community_group = get_tc_community_group()
    if not community_group or community_group.id != community_group_id:
        return jsonify({"error": "Invalid community group."}), 404
    
    if not is_tc_community_member(current_user): # Should be covered by decorator
        return jsonify({"error": "Not a member."}), 403

    since_ms_str = request.args.get("since")
    if not since_ms_str: return jsonify({"error": "Missing 'since' timestamp."}), 400
        
    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp((since_ms / 1000.0) + 0.001, tz=timezone.utc)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid timestamp format."}), 400

    new_messages_query = (
        select(TalentClubCommunityMessage)
        .where(
            TalentClubCommunityMessage.community_id == community_group.id,
            TalentClubCommunityMessage.timestamp > since_time,
            TalentClubCommunityMessage.author_id != current_user.id # Don't poll own messages back immediately
        )
        .options(joinedload(TalentClubCommunityMessage.author).joinedload(User.role), 
                 joinedload(TalentClubCommunityMessage.file))
        .order_by(TalentClubCommunityMessage.timestamp.asc())
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data_for_client = []
    latest_ts_in_batch = since_ms
    for msg in new_messages_list:
        messages_data_for_client.append({
            "id": msg.id, "sender_id": msg.author_id,
            "sender": {
                "full_name": msg.author.full_name if msg.author else "N/A",
                "username": msg.author.username if msg.author else "N/A",
                "profile_photo_url": msg.author.profile_photo_url if msg.author else None
            },
            "content": msg.content, "timestamp": msg.timestamp.isoformat() + "Z",
            "file": { "id": msg.file.id, "original_filename": msg.file.original_filename,
                      "mimetype": msg.file.mimetype, "size": msg.file.size,
                      "download_url": url_for('download_social_file', file_id=msg.file.id)
                    } if msg.file else None
        })
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch: latest_ts_in_batch = msg_ts_ms
            
    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0)

    return jsonify({"messages": messages_data_for_client, "latest_timestamp": final_latest_timestamp}), 200

@app.route("/talent_club/community/create_message", methods=["POST"])
@login_required
@tc_member_required
def create_tc_community_message():
    community_group = get_tc_community_group()
    if not community_group:
        return jsonify({"success": False, "error": "TC Community group not available."}), 404

    if not is_tc_community_member(current_user): # Redundant due to @tc_member_required but good check
        return jsonify({"success": False, "error": "Not a member of TC Community."}), 403

    # Check if muted
    active_restriction = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == current_user.id,
            TalentClubBan.type == 'mute', # Specifically check for mute
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        )
    )
    if active_restriction:
        return jsonify({"success": False, "error": "You are currently muted in the Talent Club."}), 403

    form = PostContentForm(request.form)
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Message content or a file must be provided."}), 400
    if form.content.data and not form.content.validate(form):
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage)
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed."}), 400
        except Exception as e:
            return jsonify({"success": False, "error": "Error processing file."}), 500
            
    try:
        new_message = TalentClubCommunityMessage(
            community_id=community_group.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj: db.session.add(uploaded_file_obj)
        db.session.add(new_message)
        db.session.commit()

        app.logger.info(f"User {current_user.username} sent TCC Message ID {new_message.id}.")

        # Prepare data for client-side rendering via _chat_message_item.html
        message_data_for_client = {
            "id": new_message.id,
            "sender_id": new_message.author_id,
            "sender": {
                "full_name": current_user.full_name, "username": current_user.username,
                "profile_photo_url": current_user.profile_photo_url
            },
            "content": new_message.content,
            "timestamp": new_message.timestamp.isoformat() + "Z",
            "file": { # Adapt based on how _chat_message_item handles files or if a different partial is used
                "id": uploaded_file_obj.id, "original_filename": uploaded_file_obj.original_filename,
                "mimetype": uploaded_file_obj.mimetype, "size": uploaded_file_obj.size,
                "download_url": url_for('download_social_file', file_id=uploaded_file_obj.id)
            } if uploaded_file_obj else None
        }
        # Or server-render HTML:
        # msg_for_render = db.session.query(TalentClubCommunityMessage).options(...).get(new_message.id)
        # post_html = render_template("partials/_chat_message_item.html", message=msg_for_render, current_user_id=current_user.id)


        return jsonify({"success": True, "message": "Message sent!", "post_data": message_data_for_client}), 201
    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath: # Cleanup
            try: os.remove(os.path.join(current_app.static_folder, uploaded_file_obj.filepath))
            except: pass
        app.logger.error(f"Error creating TCC message by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error sending message."}), 500
# Route to remove a ban/mute (POST only)

@app.route("/talent_club/leader/member/<int:user_id>/unban_unmute", methods=["POST"])
@login_required
@tc_leader_required
def unban_unmute_tc_member(user_id):
    user_to_manage = db.get_or_404(User, user_id, description="User not found.")
    if user_to_manage.id == current_user.id:
        flash("Invalid action on self.", "danger")
        return redirect(url_for("manage_tc_members_leader"))

    active_ban = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == user_to_manage.id,
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        ).limit(1)
    )

    if not active_ban:
        flash(f"{user_to_manage.full_name or user_to_manage.username} does not have an active ban or mute.", "info")
        return redirect(url_for("manage_tc_members_leader"))

    try:
        ban_type_lifted = active_ban.type
        active_ban.expires_at = datetime.now(timezone.utc) - timedelta(seconds=1) # Expire it

        # If 'ban' was lifted, re-grant TC membership. This is a policy decision.
        # User might need to re-join clubs manually or be re-added.
        if ban_type_lifted == 'ban':
            user_to_manage.is_tc_member = True 
            # Attempt to add back to TC Community Group
            add_to_tc_community_group(user_to_manage) 
            # Note: Previous club memberships are NOT automatically restored here. User would need to rejoin or be re-added.
        
        db.session.commit()
        flash(f"The {ban_type_lifted} for {user_to_manage.full_name or user_to_manage.username} has been lifted.", "success")
        app.logger.info(f"TC Leader {current_user.username} lifted {ban_type_lifted} for user {user_id} (Ban ID: {active_ban.id}).")

        # --- Notification to the affected user ---
        if user_to_manage.is_active:
            notify_tc_member(user_to_manage, current_user, f"Your Talent Club system {ban_type_lifted} has been lifted.", f'tc_system_un{ban_type_lifted}', active_ban.id, None)
            
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error lifting {ban_type_lifted} for user {user_id} by {current_user.username}: {e}", exc_info=True)
        flash("An error occurred while removing the restriction.", "danger")

    return redirect(url_for("manage_tc_members_leader"))
# --- HR/CEO Specific Routes for TC Leader Management ---
@app.route("/hr_ceo/talent_club_leader_management")
@login_required
@role_required("hr_ceo", "system_admin")
def manage_system_tc_leader():
    current_system_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).options(joinedload(User.role))
    )
    active_election = get_active_tc_leader_election() # Helper function
    
    total_votes_in_active_election = 0
    candidate_vote_counts_dict = {}
    eligible_candidates_list = get_tc_leader_candidates() # Helper function

    if active_election:
        total_votes_in_active_election = db.session.scalar(
            select(func.count(TalentClubLeaderVote.id)).where(TalentClubLeaderVote.election_id == active_election.id)
        ) or 0
        
        # Get vote counts per candidate for the active election
        vote_counts_raw = db.session.execute(
            select(TalentClubLeaderVote.candidate_id, func.count(TalentClubLeaderVote.id).label("vote_count"))
            .where(TalentClubLeaderVote.election_id == active_election.id)
            .group_by(TalentClubLeaderVote.candidate_id)
            .order_by(desc("vote_count")) # Order by most votes
        ).all() # Returns list of Row objects
        candidate_vote_counts_dict = {row.candidate_id: row.vote_count for row in vote_counts_raw}

    past_elections_query = (
        select(TalentClubLeaderElection)
        .where(TalentClubLeaderElection.status == 'concluded')
        .options(joinedload(TalentClubLeaderElection.elected_leader)) # Load who won
        .order_by(TalentClubLeaderElection.concluded_at.desc())
        .limit(5) # Show recent past elections
    )
    past_elections = db.session.scalars(past_elections_query).all()

    return render_template(
        "hr_ceo/manage_tc_leader.html",
        current_leader=current_system_leader,
        active_election=active_election,
        total_votes_in_active_election=total_votes_in_active_election,
        candidate_vote_counts=candidate_vote_counts_dict, # Pass the dictionary
        eligible_candidates=eligible_candidates_list, # For mapping candidate IDs to names in template
        past_elections=past_elections,
        title="Manage System TC Leader - Nexus TC"
    )

@app.route("/hr_ceo/talent_club_leader/demote/<int:user_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_demote_tc_leader(user_id):
    user_to_demote = db.get_or_404(User, user_id, description="User not found.")

    if not user_to_demote.is_tc_leader:
        flash(f"{user_to_demote.full_name or user_to_demote.username} is not currently the Talent Club Leader.", "warning")
    elif user_to_demote.id == current_user.id and user_to_demote.is_tc_leader: # HR/Admin trying to demote self if they were also leader
        flash("You cannot demote yourself from the TC Leader role via this action. Assign another leader or contact support.", "danger")
    else:
        try:
            user_to_demote.is_tc_leader = False
            db.session.commit()
            flash(f"{user_to_demote.full_name or user_to_demote.username} has been successfully demoted from System Talent Club Leader.", "success")
            app.logger.info(f"User {current_user.username} demoted user {user_id} from system TC Leader.")

            # Notify the demoted user
            if user_to_demote.is_active:
                notify_tc_member( # Your helper function
                    receiver_user=user_to_demote,
                    sender_user=current_user,
                    content=f"You have been demoted from the role of System Talent Club Leader by administration.",
                    notification_type='tc_leader_demoted_by_admin', # New specific type
                    related_object_id=user_to_demote.id, # Link to the user demoted
                    link_url=url_for('view_current_tc_leader', _external=True) # Link to general TC Leader info page
                )
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error demoting TC Leader {user_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while demoting the leader. Please try again.", "danger")
            
    return redirect(request.referrer or url_for("manage_system_tc_leader"))

@app.route("/hr_ceo/talent_club_leader/initiate_election", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_initiate_tc_leader_election():
    if get_active_tc_leader_election(): # Check if one is already active
        flash("An election for Talent Club Leader is already in progress.", "warning")
        return redirect(url_for("manage_system_tc_leader"))

    if not get_tc_leader_candidates(): # Check if there are any eligible TC members
        flash("Cannot start an election: No eligible Talent Club members found to be candidates/voters.", "danger")
        return redirect(url_for("manage_system_tc_leader"))
        
    try:
        new_election = TalentClubLeaderElection(
            initiated_by_id=current_user.id,
            initiated_at=datetime.now(timezone.utc),
            status='active'
        )
        db.session.add(new_election)
        db.session.commit()
        flash("New Talent Club Leader election initiated successfully! Members can now vote.", "success")
        app.logger.info(f"User {current_user.username} initiated TC Leader Election ID {new_election.id}.")

        # Notify all active TC members (who are the voters/candidates)
        tc_members_to_notify = get_tc_leader_candidates() # Gets all active TC members
        notification_content = "A new election for System Talent Club Leader has started! Cast your vote now."
        link_url_vote = url_for('view_current_tc_leader', _external=True) # Link to voting page

        for member in tc_members_to_notify:
            if member.id != current_user.id: # Don't notify the initiator (HR/Admin)
                notify_tc_member(
                    member, current_user, notification_content,
                    'tc_election_started', new_election.id, link_url_vote
                )
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error initiating TC Leader election by {current_user.username}: {e}", exc_info=True)
        flash("An error occurred while initiating the election.", "danger")
        
    return redirect(url_for("manage_system_tc_leader"))


@app.route("/hr_ceo/talent_club_leader/conclude_election/<int:election_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_conclude_tc_leader_election(election_id):
    """Allows HR/CEO to conclude a Talent Club Leader election and declare a winner."""
    election = db.get_or_404(TalentClubLeaderElection, election_id)

    # Check if the election is active and can be concluded
    if election.status != 'active':
        flash("This election is not currently active.", "warning")
        return redirect(request.referrer or url_for("manage_system_tc_leader"))

    try:
        # Count votes per candidate
        vote_counts_query = db.session.query(
            TalentClubLeaderVote.candidate_id,
            func.count(TalentClubLeaderVote.id)
        ).filter(TalentClubLeaderVote.election_id == election.id).group_by(TalentClubLeaderVote.candidate_id).all()

        vote_counts = dict(vote_counts_query)

        elected_leader = None
        if vote_counts:
            # Find candidate(s) with the maximum votes
            max_votes = max(vote_counts.values())
            winners = [candidate_id for candidate_id, count in vote_counts.items() if count == max_votes]

            if len(winners) == 1:
                # Clear any existing TC Leader
                current_leader = db.session.scalar(select(User).where(User.is_tc_leader == True))
                if current_leader and current_leader.id != winners[0]:
                     current_leader.is_tc_leader = False
                     app.logger.info(f"Existing TC Leader {current_leader.id} demoted due to election conclusion.")

                # Set the winner as the new TC Leader
                winner_user = db.session.get(User, winners[0])
                if winner_user: # Ensure winner user exists and is active
                     if winner_user.is_active:
                          winner_user.is_tc_leader = True
                          elected_leader = winner_user
                          flash(f"Election concluded. {winner_user.full_name or winner_user.username} is the new Talent Club Leader!", "success")
                          app.logger.info(f"User {winner_user.id} elected as new TC Leader (Election {election.id}).")
                     else:
                          flash(f"Election concluded with winner ID {winners[0]}, but user is inactive. No leader assigned.", "warning")
                          app.logger.warning(f"Election {election.id} winner {winners[0]} is inactive. No leader assigned.")
                else:
                     flash(f"Election concluded with winner ID {winners[0]}, but user not found. No leader assigned.", "warning")
                     app.logger.warning(f"Election {election.id} winner {winners[0]} not found. No leader assigned.")


            else:
                # Handle tie (e.g., no leader assigned, manual HR decision needed)
                flash("Election resulted in a tie. No leader assigned via election.", "warning")
                app.logger.info(f"Election {election.id} resulted in a tie among users: {winners}. No leader assigned.")

        else:
            # No votes were cast
            flash("No votes were cast in the election. No leader assigned.", "info")
            app.logger.info(f"Election {election.id} had no votes cast.")

        # Conclude the election status and record winner (if any)
        election.status = 'concluded'
        election.concluded_at = datetime.now(timezone.utc)
        election.elected_leader = elected_leader # Link the winner user

        db.session.commit()

        # --- Notification ---
        # Notify all active TC members about election results
        eligible_candidates = get_tc_leader_candidates() # Get all TC members who *could* have voted
        notification_content = f"Talent Club Leader election concluded. Winner: {elected_leader.full_name or elected_leader.username if elected_leader else 'None'}. Check results."
        link_url = url_for('manage_system_tc_leader') # Link to the management page to see results

        notifications_to_add = []
        for member in eligible_candidates:
             if member.is_active and member.id != current_user.id:
                  try:
                       notify = Notification(
                           sender_id=current_user.id,
                           receiver_id=member.id,
                           content=notification_content,
                           link_url=link_url,
                           timestamp=datetime.now(timezone.utc),
                           is_read=False,
                           notification_type='tc_vote_result', # Specific type
                           related_object_id=election.id
                       )
                       notifications_to_add.append(notify)
                  except Exception as notify_e:
                       app.logger.error(f"Error creating TC vote result notification for user {member.id}: {notify_e}")

        if notifications_to_add:
           db.session.add_all(notifications_to_add)
           db.session.commit() # Commit notifications


    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error HR/CEO {current_user.id} concluding TC Leader election {election_id}: {e}", exc_info=True)
        flash("An error occurred while concluding the election. Please try again.", "danger")

    # Redirect back to management page
    return redirect(request.referrer or url_for("manage_system_tc_leader"))


# --- PART X END: Talent Club Features ---


# --- PART 15 START: CLI Commands, Error Handlers, and Main Execution ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, Role, AssetCategory, User models are defined.
# - password hashing functions (generate_password_hash) are available.
# - Werkzeug imports (NotFound) are available.
# - Other Python imports (click, sys, os, datetime, timezone).

import click # Import click for CLI commands
import sys # Import sys for exiting

# --- CLI Commands ---
# Use @app.cli.command() to register functions as CLI commands

# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# START MODIFICATION (create_initial CLI Command)
@app.cli.command("create-initial")
def create_initial_roles_and_categories():
    """Creates initial Role, AssetCategory, SocialCategory, and core Lab entries if they don't exist.""" # MODIFIED: Updated docstring
    with app.app_context():
        print("Creating initial roles...")
        initial_roles = ["system_admin", "hr_ceo", "school_executive", "government", "teacher", "librarian", "talent_club", "student", "parent"]
        created_roles = []
        try:
            for role_name in initial_roles:
                role = db.session.scalar(select(Role).filter_by(name=role_name))
                if not role:
                    new_role = Role(name=role_name)
                    db.session.add(new_role)
                    created_roles.append(role_name)
            db.session.commit()
            if created_roles:
                print(f"Created roles: {', '.join(created_roles)}")
            else:
                print("All initial roles already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating roles: {e}", file=sys.stderr)
            sys.exit(1)

        print("\nCreating initial asset categories...")
        # MODIFIED: Removed social media categories from this list
        initial_asset_categories = [
            "General Equipment", "IT Hardware", "Furniture", "Teaching Supplies",
            "Lab Equipment", "Library Equipment", "Books", "Talent Club Gear",
            "Office Supplies", "Sports Equipment", "Student Activities Gear",
            "Classroom Assets"
        ]
        created_asset_categories = []
        try:
            for cat_name in initial_asset_categories:
                category = db.session.scalar(select(AssetCategory).filter_by(name=cat_name))
                if not category:
                    new_category = AssetCategory(name=cat_name)
                    db.session.add(new_category)
                    created_asset_categories.append(cat_name)
            db.session.commit()
            if created_asset_categories:
                print(f"Created asset categories: {', '.join(created_asset_categories)}")
            else:
                print("All initial asset categories already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating asset categories: {e}", file=sys.stderr)
            sys.exit(1)


        # START ADDITION (SocialCategory creation)
        print("\nCreating initial social media categories...")
        initial_social_categories = [
            "Entertainment",
            "Fun",
            "Sport",
            "Education",
            "Technology",
            "Personal",
            "Social",
            "Lifestyle",
            "Innovation",
            "Relationships"
        ]
        created_social_categories = []
        try:
            for social_cat_name in initial_social_categories:
                social_category = db.session.scalar(select(SocialCategory).filter_by(name=social_cat_name))
                if not social_category:
                    new_social_category = SocialCategory(name=social_cat_name)
                    db.session.add(new_social_category)
                    created_social_categories.append(social_cat_name)
            db.session.commit()
            if created_social_categories:
                print(f"Created social categories: {', '.join(created_social_categories)}")
            else:
                print("All initial social categories already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating social categories: {e}", file=sys.stderr)
            sys.exit(1)
        # END ADDITION (SocialCategory creation)


        print("\nCreating core Lab entries...")
        # ... (core Lab entries) ...
# END MODIFICATION (create_initial CLI Command)
        # START ADDITION (Talent Club Community Group creation)
        print(f"\nCreating '{TC_COMMUNITY_GROUP_NAME}' group...")
        try:
            community_group = db.session.scalar(select(TalentClubCommunity).filter_by(name=TC_COMMUNITY_GROUP_NAME))
            if not community_group:
                new_community_group = TalentClubCommunity(name=TC_COMMUNITY_GROUP_NAME, description="Official community group for all Talent Club members.")
                db.session.add(new_community_group)
                db.session.commit()
                print(f"Created '{TC_COMMUNITY_GROUP_NAME}'.")
            else:
                print(f"'{TC_COMMUNITY_GROUP_NAME}' already exists.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating Talent Club Community group: {e}", file=sys.stderr)
            sys.exit(1)
        # END ADDITION (Talent Club Community Group creation)
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# Add these imports if not already 

# Add this near your other CLI commands

# Ensure your models are accessible: User, Role, TeacherProfile, Lab, Asset

@app.cli.command("standardize-grade-sections")
def standardize_grade_sections_command():
    """
    Standardizes grade/section data in User and TeacherProfile tables,
    and removes specific 'Grade 9, Section A/B/C' student entries.
    WARNING: This command modifies data. BACK UP YOUR DATABASE FIRST.
    """
    with app.app_context():
        print("\n--- Standardizing Grade and Section Data & Cleaning ---")
        if not click.confirm("WARNING: This command will modify database records (User, TeacherProfile, Lab) and delete some User records. Ensure you have a backup. Do you want to continue?"):
            print("Operation cancelled by user.")
            return

        # --- Step 1: Define Standardization Rules ---
        def normalize_grade(grade_str):
            if not grade_str: return None
            s = str(grade_str).strip()
            if s.lower().startswith("grade "):
                return s.split(" ", 1)[1].strip() # "Grade 9" -> "9"
            return s # Assumes it's already "9", "10" etc.

        def normalize_section(section_str):
            if not section_str: return None
            s = str(section_str).strip()
            if s.isdigit() and s.startswith("0") and len(s) > 1:
                return str(int(s)) # "01" -> "1", "09" -> "9"
            return s # "A", "1", "10" remain as is

        # --- Step 2: Remove specific 'Grade 9, Section A/B/C' student entries ---
        print("\n1. Removing specific 'Grade 9, Section A/B/C' student entries...")
        grades_to_remove_raw = ["9", "Grade 9"] # Cover both formats
        sections_to_remove = ["A", "B", "C"]
        users_to_delete_query = select(User).join(User.role).where(
            Role.name == "student",
            or_(
                User.grade.in_(grades_to_remove_raw),
                User.grade.in_([normalize_grade(g) for g in grades_to_remove_raw if normalize_grade(g)]) # Normalized check
            ),
            or_(
                User.section.in_(sections_to_remove),
                User.section.in_([normalize_section(s) for s in sections_to_remove if normalize_section(s)]) # Normalized check
            )
        )
        users_to_delete = db.session.scalars(users_to_delete_query).all()
        deleted_count = 0
        if users_to_delete:
            for user in users_to_delete:
                print(f"  - Preparing to delete student: {user.username} (ID: {user.id}), Grade: {user.grade}, Section: {user.section}")
                # Add cascading delete logic here if needed for related records (marks, attendance, etc.)
                # For simplicity, this script just deletes the user. SQLAlchemy cascades might handle some.
                db.session.delete(user)
                deleted_count += 1
            db.session.commit()
            print(f"  Successfully deleted {deleted_count} student entries for Grade 9, Sections A/B/C.")
        else:
            print("  No student entries found matching Grade 9, Sections A/B/C for deletion.")

        # --- Step 3: Standardize User (Student) Grade/Section Data ---
        print("\n2. Standardizing Grade/Section for all Users (Students)...")
        all_students = db.session.scalars(select(User).join(Role).where(Role.name == 'student')).all()
        student_updated_count = 0
        for student in all_students:
            original_grade = student.grade
            original_section = student.section
            normalized_g = normalize_grade(student.grade)
            normalized_s = normalize_section(student.section)

            changed = False
            if student.grade != normalized_g:
                student.grade = normalized_g
                changed = True
            if student.section != normalized_s:
                student.section = normalized_s
                changed = True
            
            if changed:
                print(f"  - Student {student.username}: Grade '{original_grade}'->'{normalized_g}', Section '{original_section}'->'{normalized_s}'")
                student_updated_count += 1
        if student_updated_count > 0:
            db.session.commit()
            print(f"  Standardized {student_updated_count} student records.")
        else:
            print("  No student records needed grade/section standardization.")

        # --- Step 4: Standardize TeacherProfile Grade/Section Data ---
        print("\n3. Standardizing Grade/Section for Teacher Profiles...")
        all_teacher_profiles = db.session.scalars(select(TeacherProfile)).all()
        tp_updated_count = 0
        for tp in all_teacher_profiles:
            original_grade = tp.grade
            original_section = tp.section
            normalized_g = normalize_grade(tp.grade)
            normalized_s = normalize_section(tp.section)

            changed = False
            if tp.grade != normalized_g:
                tp.grade = normalized_g
                changed = True
            if tp.section != normalized_s:
                tp.section = normalized_s
                changed = True
            
            if changed:
                teacher_name = tp.user.full_name if tp.user else f"TeacherProfile ID {tp.id}"
                print(f"  - TeacherProfile for {teacher_name}: Grade '{original_grade}'->'{normalized_g}', Section '{original_section}'->'{normalized_s}'")
                tp_updated_count += 1
        if tp_updated_count > 0:
            db.session.commit()
            print(f"  Standardized {tp_updated_count} teacher profile records.")
        else:
            print("  No teacher profile records needed grade/section standardization.")

        # --- Step 5: Standardize Lab Names (Classroom Labs) ---
        # This assumes the desired format is "Grade X Section Y Classroom" where X and Y are normalized.
        print("\n4. Standardizing Classroom Lab Names...")
        labs_to_check = db.session.scalars(select(Lab).where(Lab.name.ilike('Grade %'))).all()
        lab_updated_count = 0
        processed_lab_names = set() # To avoid processing a lab name multiple times if it appears due to other issues

        for lab in labs_to_check:
            if lab.name in processed_lab_names:
                continue
            
            parts = lab.name.split(" ")
            # Example: "Grade 9 Section A Classroom" or "Grade Grade 9 Section 01 Classroom"
            # We want "Grade <NormGrade> Section <NormSection> Classroom"
            try:
                if len(parts) >= 5 and parts[0].lower() == "grade" and parts[2].lower() == "section" and parts[4].lower() == "classroom":
                    grade_part = parts[1]
                    section_part = parts[3]

                    norm_g = normalize_grade(grade_part)
                    norm_s = normalize_section(section_part)

                    if norm_g and norm_s: # Ensure normalization was successful
                        new_lab_name = f"Grade {norm_g} Section {norm_s} Classroom"
                        if lab.name != new_lab_name:
                            # Check if a lab with the new_lab_name already exists
                            existing_target_lab = db.session.scalar(select(Lab).filter_by(name=new_lab_name))
                            if existing_target_lab and existing_target_lab.id != lab.id:
                                print(f"  - Lab '{lab.name}': Target name '{new_lab_name}' already exists (ID: {existing_target_lab.id}). Manual merge of assets might be needed.")
                                # You might want to move assets from 'lab' to 'existing_target_lab' then delete 'lab'
                                # For now, just log and skip renaming to avoid unique constraint violation.
                            else:
                                print(f"  - Lab: Renaming '{lab.name}' to '{new_lab_name}'")
                                lab.name = new_lab_name
                                lab_updated_count += 1
                        processed_lab_names.add(lab.name) # Add original name to avoid re-processing
                        if lab.name != new_lab_name:
                             processed_lab_names.add(new_lab_name) # Add new name too if changed
                    else:
                        print(f"  - Lab '{lab.name}': Could not reliably parse and normalize grade/section parts.")
                elif parts[0].lower() == "grade" and parts[1].lower() == "grade": # Handle "Grade Grade X"
                    if len(parts) >= 6 and parts[3].lower() == "section" and parts[5].lower() == "classroom":
                        grade_part = parts[2]
                        section_part = parts[4]
                        norm_g = normalize_grade(grade_part)
                        norm_s = normalize_section(section_part)
                        if norm_g and norm_s:
                            new_lab_name = f"Grade {norm_g} Section {norm_s} Classroom"
                            # ... (rest of renaming logic as above) ...
                            if lab.name != new_lab_name:
                                existing_target_lab = db.session.scalar(select(Lab).filter_by(name=new_lab_name))
                                if existing_target_lab and existing_target_lab.id != lab.id:
                                    print(f"  - Lab '{lab.name}': Target name '{new_lab_name}' already exists (ID: {existing_target_lab.id}). Manual merge of assets might be needed.")
                                else:
                                    print(f"  - Lab: Renaming '{lab.name}' to '{new_lab_name}'")
                                    lab.name = new_lab_name
                                    lab_updated_count += 1
                            processed_lab_names.add(lab.name)
                            if lab.name != new_lab_name:
                                 processed_lab_names.add(new_lab_name)
                        else:
                             print(f"  - Lab '{lab.name}': Could not reliably parse (double 'Grade').")
            except Exception as e:
                print(f"  - Error processing lab '{lab.name}': {e}")
        
        if lab_updated_count > 0:
            db.session.commit()
            print(f"  Standardized {lab_updated_count} classroom lab names.")
        else:
            print("  No classroom lab names needed standardization or could be safely standardized.")

        print("\n--- Standardization and Cleaning Complete ---")
        print("Please re-run 'flask inspect-grade-sections' to verify the changes.")

# --- CLI COMMAND TO INSPECT GRADE/SECTION DATA ---
@app.cli.command("inspect-grade-sections")
def inspect_grade_sections_command():
    """Inspects and prints distinct grade/section combinations from the database."""
    with app.app_context():
        print("\n--- Inspecting Grade and Section Data ---")

        # 1. Distinct Grade/Section combinations for active STUDENTS
        print("\n1. Distinct Grade/Section Combinations for Active Students:")
        student_blocks_query = (
            select(User.grade, User.section, func.count(User.id).label("student_count"))
            .join(User.role)
            .where(
                Role.name == "student",
                User.is_active == True,
                User.grade.isnot(None), User.grade != '',
                User.section.isnot(None), User.section != ''
            )
            .group_by(User.grade, User.section)
            .order_by(User.grade.asc(), User.section.asc())
        )
        student_blocks = db.session.execute(student_blocks_query).all()

        if student_blocks:
            for grade, section, count in student_blocks:
                print(f"  - Grade: {grade}, Section: {section} (Students: {count})")
        else:
            print("  No distinct grade/section combinations found for active students.")

        # 2. Distinct Grade/Section/Subject combinations for active TEACHERS
        print("\n2. Distinct Grade/Section/Subject Assignments for Active Teachers:")
        teacher_assignments_query = (
            select(
                User.full_name.label("teacher_name"),
                TeacherProfile.grade,
                TeacherProfile.section,
                TeacherProfile.subject,
                func.count(TeacherProfile.id).label("assignment_count") # Count profiles
            )
            .join(User.teacher_profiles) # From User to TeacherProfile
            .join(User.role) # From User to Role
            .where(
                Role.name == "teacher",
                User.is_active == True,
                TeacherProfile.grade.isnot(None), TeacherProfile.grade != '',
                TeacherProfile.section.isnot(None), TeacherProfile.section != '',
                TeacherProfile.subject.isnot(None), TeacherProfile.subject != ''
            )
            .group_by(User.full_name, TeacherProfile.grade, TeacherProfile.section, TeacherProfile.subject)
            .order_by(User.full_name.asc(), TeacherProfile.grade.asc(), TeacherProfile.section.asc(), TeacherProfile.subject.asc())
        )
        teacher_assignments = db.session.execute(teacher_assignments_query).all()

        if teacher_assignments:
            current_teacher = None
            for teacher_name, grade, section, subject, count in teacher_assignments:
                if teacher_name != current_teacher:
                    if current_teacher is not None: print("") # Newline for next teacher
                    print(f"  Teacher: {teacher_name}")
                    current_teacher = teacher_name
                print(f"    - Teaches: Grade {grade} - Section {section}, Subject: {subject} (Profiles: {count})")
        else:
            print("  No distinct grade/section/subject assignments found for active teachers.")

        # 3. Labs that look like Classrooms (based on naming convention)
        print("\n3. Labs Named Like Classrooms (e.g., for Student Leaders' assets):")
        classroom_labs_query = (
            select(Lab.name, func.count(Asset.id).label("asset_count"))
            .outerjoin(Asset, Lab.id == Asset.lab_id) # Outer join to count assets even if lab is empty
            .where(Lab.name.ilike('Grade % Section % Classroom'))
            .group_by(Lab.id, Lab.name) # Group by Lab.id as well for safety if names aren't unique (though they should be)
            .order_by(Lab.name.asc())
        )
        classroom_labs = db.session.execute(classroom_labs_query).all()
        if classroom_labs:
            for lab_name, asset_count in classroom_labs:
                print(f"  - Lab: {lab_name} (Assets linked: {asset_count})")
        else:
            print("  No labs found matching the 'Grade X Section Y Classroom' naming pattern.")

        print("\n--- Inspection Complete ---")

@app.cli.command("seed-db")
@click.argument("count", default=10)
def seed_db_command(count):
    """Seeds the database with dummy data, including specific lab/category assignments and Talent Club data.""" # Updated docstring
    with app.app_context():
        print(f"Seeding database with {count} dummy users (students, teachers, talent club) and assets...")
        try:
            # Fetch necessary roles
            student_role = db.session.scalar(select(Role).filter_by(name="student"))
            teacher_role = db.session.scalar(select(Role).filter_by(name="teacher"))
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            system_admin_role = db.session.scalar(select(Role).filter_by(name="system_admin"))
            talent_club_role = db.session.scalar(select(Role).filter_by(name="talent_club"))
            librarian_role = db.session.scalar(select(Role).filter_by(name="librarian"))

            if not all([student_role, teacher_role, hr_ceo_role, system_admin_role, talent_club_role, librarian_role]):
                print("Error: Required roles not found. Run 'flask create-initial' first.", file=sys.stderr)
                sys.exit(1)

            # Fetch necessary categories
            classroom_category = db.session.scalar(select(AssetCategory).filter_by(name="Classroom Assets"))
            lab_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="Lab Equipment"))
            books_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
            tc_gear_category = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
            general_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="General Equipment"))

            if not all([classroom_category, lab_equipment_category, books_category, tc_gear_category, general_equipment_category]):
                print("Error: Required asset categories not found. Run 'flask create-initial' first.", file=sys.stderr)
                sys.exit(1)

            # Fetch core Labs (or create if missing - create-initial should make these)
            main_library_lab = db.session.scalar(select(Lab).filter_by(name="Main Library"))
            talent_club_hq_lab = db.session.scalar(select(Lab).filter_by(name="Talent Club HQ"))
            # Create a generic Science Lab if it doesn't exist for teachers
            science_lab = db.session.scalar(select(Lab).filter_by(name="Science Lab A"))
            if not science_lab:
                science_lab = Lab(name="Science Lab A")
                db.session.add(science_lab)
                # No flush/commit here, will be committed with users later


            # Create a default admin user if one doesn't exist
            admin_user = db.session.scalar(select(User).filter_by(username="admin"))
            if not admin_user:
                 print("Creating default 'admin' user...")
                 admin_user = User(
                     username="admin",
                     email="admin@school.com",
                     full_name="System Administrator",
                     first_name="System",
                     last_name="Administrator",
                     role=system_admin_role,
                     is_active=True,
                     force_password_change=True,
                     created_at=datetime.now(timezone.utc)
                 )
                 admin_user.set_password("default_admin_password")
                 db.session.add(admin_user)
                 print("Default admin user 'admin' created with password 'default_admin_password'. PLEASE CHANGE THIS IMMEDIATELY after first login using the forced change password page.")


            # Create dummy users (mix of students, teachers, librarians, and talent_club members)
            grades = ["9", "10", "11", "12"]
            sections = ["A", "B", "C"]
            subjects = ["Math", "Science", "History", "English", "Physics", "Chemistry", "Biology"]
            genders = ["Male", "Female"]

            print("\nCreating dummy users and associated assets...")
            for i in range(count):
                role_choice = i % 4 # Now 4 categories: student, teacher, talent_club, librarian
                if role_choice == 0:
                    role = student_role
                elif role_choice == 1:
                    role = teacher_role
                elif role_choice == 2:
                    role = talent_club_role
                else: # role_choice == 3
                    role = librarian_role

                dummy_username = f"{role.name}_{i+1}".lower()
                dummy_email = f"{dummy_username}@example.com"
                dummy_full_name = f"{role.name.capitalize()} User {i+1}"
                dummy_first_name = f"{role.name.capitalize()}"
                dummy_last_name = f"User{i+1}"

                existing_user = db.session.scalar(
                    select(User).filter(
                        (User.username == dummy_username) | (User.email == dummy_email)
                    )
                )
                if existing_user:
                    print(f"Skipping user {dummy_username}: already exists.")
                    continue

                user = User(
                    username=dummy_username,
                    email=dummy_email,
                    full_name=dummy_full_name,
                    first_name=dummy_first_name,
                    last_name=dummy_last_name,
                    role=role,
                    is_active=True,
                    created_at=datetime.now(timezone.utc),
                    age=14 + i if role == student_role else 30 + i,
                    gender=genders[i % len(genders)],
                    phone=f"555-123-{1000 + i}",
                    address=f"Dummy Address {i+1}",
                    force_password_change=False,
                    is_tc_member=False, # Default False, set True below for some students
                    is_tc_leader=False # Default False, set True below for some talent_club role users
                )
                user.set_password("password")

                # --- Role-Specific Attribute Assignment and Asset Creation within the loop ---
                if role == student_role:
                    user.grade = grades[i % len(grades)]
                    user.section = sections[i % len(sections)]
                    # Dynamically create/get classroom lab for students
                    classroom_name = f"Grade {user.grade} Section {user.section} Classroom"
                    classroom_lab = db.session.scalar(select(Lab).filter_by(name=classroom_name))
                    if not classroom_lab:
                        classroom_lab = Lab(name=classroom_name)
                        db.session.add(classroom_lab)
                        db.session.flush() # Flush to get ID for newly created lab
                    # Assign student to their classroom lab (conceptual)
                    user.lab_id = classroom_lab.id

                    # Make some students leaders
                    if i % 3 == 0:
                        user.is_leader = True
                        print(f"  - User {user.username} is a Student Leader.")
                        # Add an asset for this student leader in their classroom
                        classroom_asset = Asset(
                            name=f"Classroom Projector {i}",
                            description="Projector for class use.",
                            quantity=1,
                            condition="Good",
                            added_by_user=user, # Link to the user being created
                            category=classroom_category,
                            lab=classroom_lab,
                            status="Available"
                        )
                        db.session.add(classroom_asset)
                    # Make some students TC members
                    if i % 2 == 0: # Example: Make every other student a TC member
                        user.is_tc_member = True
                        print(f"  - User {user.username} is a Talent Club Member.")
                        # Adding to community group is handled *after* the loop


                elif role == teacher_role:
                    # Assign teachers to a lab (e.g., Science Lab A)
                    # Ensure science_lab exists before assigning its ID
                    if science_lab:
                        user.lab_id = science_lab.id

                    dummy_subject = subjects[i % len(subjects)]
                    dummy_grade = grades[i % len(grades)]
                    dummy_section = sections[i % len(sections)]
                    teacher_profile = TeacherProfile(
                         user=user, # Link to the user being created
                         subject=dummy_subject,
                         grade=dummy_grade,
                         section=dummy_section,
                         salary=50000.0 + i * 1000.0
                    )
                    db.session.add(teacher_profile)

                    # Add an asset for this teacher in their lab
                    if science_lab and lab_equipment_category: # Ensure prerequisites exist
                         lab_asset = Asset(
                             name=f"Microscope {i}",
                             description="For science experiments.",
                             quantity=2,
                             condition="Good",
                             added_by_user=user, # Link to the user being created
                             category=lab_equipment_category,
                             lab=science_lab,
                             status="Available"
                         )
                         db.session.add(lab_asset)


                elif role == talent_club_role:
                    # Ensure Talent Club HQ Lab exists before assigning
                    if talent_club_hq_lab:
                         user.lab_id = talent_club_hq_lab.id

                    if i % 2 == 0:
                        user.is_tc_leader = True
                        print(f"  - User {user.username} is a Talent Club Leader.")
                        # Add an asset for this talent club leader in Talent Club HQ
                        if talent_club_hq_lab and tc_gear_category: # Ensure prerequisites exist
                             tc_asset = Asset(
                                 name=f"Stage Light {i}",
                                 description="Lighting equipment for club performances.",
                                 quantity=1,
                                 condition="Fair",
                                 added_by_user=user, # Link to the user being created
                                 category=tc_gear_category,
                                 lab=talent_club_hq_lab,
                                 status="Available"
                             )
                             db.session.add(tc_asset)


                elif role == librarian_role:
                    # Ensure Main Library Lab exists before assigning
                    if main_library_lab:
                         user.lab_id = main_library_lab.id
                    # Add a book asset for the librarian
                    if main_library_lab and books_category: # Ensure prerequisites exist
                         book_asset = Asset(
                             name=f"Math Textbook Vol {i}",
                             description="Calculus textbook.",
                             quantity=10,
                             condition="New",
                             added_by_user=user, # Link to the user being created
                             category=books_category, # Corrected typo here as well
                             lab=main_library_lab,
                             status="Available"
                         )
                         db.session.add(book_asset)

                # Add the user to the session after all specific attributes/relations are set for their role
                db.session.add(user)

            # --- Code AFTER the main user loop finishes ---

            db.session.commit() # Commit all users and assets created *within* the loop

            # Ensure TC Community group exists (should be done by create-initial, but double-check)
            community_group = get_tc_community_group()
            if not community_group:
                 print(f"Error: '{TC_COMMUNITY_GROUP_NAME}' group not found. Run 'flask create-initial' first.", file=sys.stderr)
                 sys.exit(1)


            # Add all is_tc_member students to the TC Community group
            print("\nAdding TC Members to Community Group...")
            tc_members = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True)).all()
            for member in tc_members:
                 # Use the helper which checks if they are already a member
                 add_to_tc_community_group(member)
                 # The helper commits internally, so no separate commit needed here for this loop

            # Create some dummy Talent Clubs, Feeds, Memberships, and Follows
            print("\nCreating dummy Talent Clubs...")
            tc_categories = db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all()
            if not tc_categories:
                 print("Error: No Social Categories found. Cannot create dummy Talent Clubs.", file=sys.stderr)
            else:
                 # Select some TC members to be club owners (ensure they are active and TC members)
                 tc_owners = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True).order_by(User.id).limit(3)).all() # Get 3 owners, consistent order
                 if not tc_owners:
                      print("Warning: No TC members found to be club owners. Skipping dummy club creation.")
                 else:
                      for i, owner in enumerate(tc_owners):
                          club_name = f"{owner.full_name}'s Awesome Club {i+1}"
                          # Check if club name already exists
                          existing_club = db.session.scalar(select(TalentClub).filter_by(name=club_name))
                          if existing_club:
                               print(f"Skipping club '{club_name}': already exists.")
                               continue

                          try:
                              category = tc_categories[i % len(tc_categories)]
                              new_club = TalentClub(
                                   name=club_name,
                                   description=f"A dummy club created by {owner.full_name or owner.username}.",
                                   owner=owner,
                                   social_category=category,
                                   level=(i % 5) + 1, # Levels 1-5
                                   warning_count=i % 3, # Warnings 0-2
                                   is_active=True,
                                   created_at=datetime.now(timezone.utc) - timedelta(days=i*10) # Backdate creation
                              )
                              db.session.add(new_club)
                              db.session.flush() # Flush to get club ID

                              # Create the linked feed
                              club_feed = TalentClubFeed(talent_club=new_club)
                              db.session.add(club_feed)

                              # Add owner as a member ('creator' role)
                              owner_membership = TalentClubMembership(club=new_club, user=owner, role='creator')
                              db.session.add(owner_membership)

                              # Add a few other random TC members as 'member' (ensure they are active TC members)
                              other_members = db.session.scalars(
                                   select(User)
                                   .where(User.is_tc_member == True, User.id != owner.id, User.is_active == True)
                                   .order_by(db.func.random()) # Random members
                                   .limit(5)
                              ).all()
                              for other_member in other_members:
                                   try:
                                        # Check if they are already a member of this specific club instance (unlikely but safe)
                                        is_already_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=new_club, user=other_member).exists())
                                        if not is_already_member:
                                            member_membership = TalentClubMembership(club=new_club, user=other_member, role='member')
                                            db.session.add(member_membership)
                                            # Add some dummy posts to the feed from a few members
                                            if len(new_club.feed.posts.all()) < 5: # Add a few posts per club
                                                 post_content = f"Hello from {other_member.full_name or other_member.username} in {new_club.name}!"
                                                 feed_post = TalentClubFeedPost(feed=club_feed, author=other_member, content=post_content)
                                                 db.session.add(feed_post)
                                   except IntegrityError:
                                        db.session.rollback() # Rollback only this specific membership/post add
                                        print(f"    - User {other_member.username} already member of club {new_club.name} (IntegrityError).", file=sys.stderr)
                                   except Exception as e:
                                        db.session.rollback() # Rollback only this specific membership/post add
                                        print(f"    - Error adding member {other_member.username} or post to club {new_club.name}: {e}", file=sys.stderr)


                              # Add some dummy followers (can be any active user)
                              followers = db.session.scalars(select(User).where(User.is_active == True).order_by(db.func.random()).limit(10)).all() # Any active user can follow
                              for follower in followers:
                                  # Avoid adding user if they are already a member of this specific club instance
                                  is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=new_club, user=follower).exists())
                                  # Avoid adding user if they already follow this specific club instance
                                  is_already_following = db.session.scalar(select(TalentClubFollow).filter_by(club=new_club, user=follower).exists())
                                  if not is_member and not is_already_following:
                                      try:
                                          follow_entry = TalentClubFollow(club=new_club, user=follower)
                                          db.session.add(follow_entry)
                                      except IntegrityError:
                                          db.session.rollback() # Rollback only this specific follow add
                                          print(f"    - User {follower.username} already follows club {new_club.name} (IntegrityError).", file=sys.stderr)
                                      except Exception as e:
                                          db.session.rollback() # Rollback only this specific follow add
                                          print(f"    - Error adding follower {follower.username} to club {new_club.name}: {e}", file=sys.stderr)


                              db.session.commit() # Commit the new club, feed, memberships, posts, and follows
                              print(f"Created club '{new_club.name}' (ID: {new_club.id}) with {new_club.memberships.filter_by(is_active=True).count()} members and {new_club.follows.count()} followers.")


                          except IntegrityError:
                               db.session.rollback()
                               print(f"Skipping club '{club_name}': name already exists.", file=sys.stderr)
                          except Exception as e:
                              db.session.rollback()
                              print(f"Error creating club '{club_name}': {e}", file=sys.stderr)

            # Add a few general assets by admin for testing HR/CEO view (if admin_user was created/exists)
            if admin_user and general_equipment_category: # Ensure prerequisites exist
                 print("\nCreating dummy admin assets...")
                 for i in range(3):
                     admin_asset = Asset(
                         name=f"Admin PC {i + 1}",
                         description="Office computer for staff.",
                         quantity=1,
                         condition="Good",
                         added_by_user=admin_user,
                         category=general_equipment_category,
                         lab=None, # No specific lab initially
                         status="Pending Review"
                     )
                     db.session.add(admin_asset)
                 db.session.commit() # Commit admin assets


            print("\nDatabase seeding process complete.")
            sys.exit(0) # Exit successfully

        except Exception as e:
            db.session.rollback() # Rollback everything in case of a general error
            print(f"General error during seeding: {e}", file=sys.stderr)
            sys.exit(1) # Exit with error code


# --- Error Handlers ---
# Define custom error pages for common HTTP errors

@app.errorhandler(403) # Forbidden
def forbidden_error(error):
    """Render custom 403 Forbidden page."""
    # Log the 403 error, including the user and path
    user_info = f"User {current_user.username} (ID: {current_user.id})" if current_user.is_authenticated else "Unauthenticated user"
    app.logger.warning(f"403 Forbidden: {user_info} attempted access to {request.path} from IP {request.remote_addr}")
    # Render a template specific to 403 errors
    return render_template("errors/403.html", title="Forbidden", error=error), 403

@app.errorhandler(404) # Not Found
def not_found_error(error):
    """Render custom 404 Not Found page."""
    # Log the 404 error, including the requested path and source IP
    app.logger.info(f"404 Not Found: Path {request.path} from IP {request.remote_addr}")
    # Render a template specific to 404 errors
    return render_template("errors/404.html", title="Page Not Found", error=error), 404

@app.errorhandler(500) # Internal Server Error
def internal_error(error):
    """Render custom 500 Internal Server Error page."""
    # Log the 500 error with traceback for debugging
    user_info = f"User {current_user.username} (ID: {current_user.id})" if current_user.is_authenticated else "Unauthenticated user"
    app.logger.error(f"500 Internal Server Error: {user_info} on path {request.path} from IP {request.remote_addr}", exc_info=True) # Log traceback

    # Ensure the database session is properly rolled back in case of an error
    # Flask-SQLAlchemy usually handles this, but explicit rollback in 500 handler is safer.
    db.session.rollback()
    # Render a template specific to 500 errors
    return render_template("errors/500.html", title="Server Error", error=error), 500

# Route to serve static favicon.ico if it exists in the static folder
# Browsers automatically request this, defining a route avoids 404 errors in logs.
@app.route('/favicon.ico')
def favicon():
    try:
        return send_from_directory(os.path.join(app.root_path, 'static'),
                                   'favicon.ico',
                                   mimetype='image/vnd.microsoft.icon')
    except NotFound:
         app.logger.debug("favicon.ico not found in static directory.")
         abort(404)
# --- Main Execution Block ---
# This block runs when the script is executed directly.
# It typically starts the Flask development server or the SocketIO server.

if __name__ == '__main__':
    # If you are using Flask-SocketIO, you should run the app using socketio.run()
    # in the main execution block, not app.run().
    # Ensure host and port are configured as needed.
    print("Starting SocketIO server...")
    socketio.run(app, host='127.0.0.1', port=5000, debug=app.debug)
    # For production, use a production WSGI server like Gunicorn with gevent/eventlet workers for SocketIO.

    # Example production start: gunicorn --worker-class eventlet -w 1 app:app

# --- PART 15 END ----e 

===== static/img/logo_dark.png =====
 Exif  MM *                  i       >                                                   JFIF      (ICC_PROFILE         mntrRGB XYZ             acsp                                  -                                                   	desc      trXYZ  d   gXYZ  x   bXYZ     rTRC     (gTRC     (bTRC     (wtpt     cprt     <mluc          enUS   X    s R G B                                                                                XYZ       o  8  XYZ       b    XYZ       $    para        ff    Y    
[        XYZ            -mluc          enUS        G o o g l e   I n c .   2 0 1 6 C 		



	 C "                	 d 	  !1A"Qa	2q#3BRbcdrs$%(4CDftv&'8EeuFS567TU            	 M 
   !1AQq"a2r#3BRb%5$&46SsCDT   ? |l`! I,{-RBT^52!/"G4c8wIUO)'S*-6S\"&*GJ0E\x<_P6^3Oji,oeE+ :M%/G>.-o_v!M7_*h.0Hik,AOJ$qOY4]Bz/V'}(FJv;Ri!UvZ+XjRDDUDDDDDDDDDDTg</*VUXt{P+\p^([83fg'sEmi8[J
|{-:gR	#/D  %bAkT[rRu H<c\N0ZNOgb{~`O5AtR 	k
m9ZC7y>gh[Aut5Qv$c+/%!([]jF L;9jd`& ;[&[F't
,nGUa""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""*owuj8uoI!ivx	>f+<wq P{TJ@JCyRT4:42x}*8kK\]WufW-qZFKkn0"vdsn[fZdtwsfl-uFptLRge[GAc
ee;$pA*E%XP=%U+T""UDBlhvt(U;^1JPerW=lC7U[$ KssOr7_1J42q7 _mMK6\vq=~d8W;mcviZD)LmrCD?zq> hqo,iS;_]`i5]()O """QZ_xD$X}7y?BXf^|[Y@>JV	0PiCioJyJ$hAP7Qs_> l^5U>Jl5sQN#,u<iFXn/p{srb6[rVSP 1:Gl,0K3.[}pa@!vxm/+en,'+xflpfj yq-TE(Tp5SB`"RDDUDDDDDDD_) `'xgaY`?9fVF|w=l.<fE;IeA+ ~gy_7Vm'9 W&beKhMZ!}o6^tZ{?6W*&(+.\tgpDDUY'|IEi* W 6a~&\69x{'3ehY5}ia#Vvz(s.TUqMJq	jf96U~Ld2YIMqeMF%tqbmiag\E]\'5ly;#PH:vO/<7.cFrU0~Z<,eH}I~O~iN}s
HA=U+^;;dFhf4;7S5[uzDt8/A`]m*}c $7i
r[4|Gwtx64kZ-"j,r(?h~0Ny.ulWkyKCz{/q,7v+ipo+RG}nDnD(rTB\xAuzE]+J""""""""(v6 z3obY>\xMKGiog0}+)'qJ)_$lvry/-b<=zK-J.O"Z:fgxe SS3gkS%IFmL>mD~wUeDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEBQ[RTDDUDDDDDDDDDDDDDDDDDJ""QU8N!E]Sw!(zAYf;p+N3rB6J<;-rfo@ceN
TK"V{#Db0}/P>kyU`Mb4@>p@7}\6w`bTM<G5I1*7bR[M^z[u`sQ85^]u4,7ts	/Df[>4)eeS"v_s#;$},X $I0Cy)#D" m$2DN`xnoqE<sx!\PetU[*1e^sLiMGh_6=,`0wCjv{vn)GpkOs,cck%=x!2@?Z6X
 Sd%;=P(F[:E"""Q*UlKlv*]Ygil|x,ZOxk%aiX'ullJ6:qkGw,-nN?ZIbD Wf~	G33 t=[7
)>H*"""""""""""""(VQE/i@JxE2%tDDETDDT%DDDDDDDDDDDDDDDDEuiwQE!'R
tR/8_B2(qGGTU
dRy"UE8@n<UEhDDEQ""*"""T"""UQP]cx*""""""""(TT*D>D.;DR6kQA:j.U2CC*qU[Lcp#w$&7[U#UJ%+5~9g;J]QTQUjoFnf>5m-K?60LO[~f@Ca<h.=ad3>_c7*7iw)G(F{k }8Upsw [ HZL$pFaMw1`l'YTg<){O%!	ARK7jyZak 8b'N |mKf58=sKx&Vyb's^I!Py1	abu6,>wEl9'hLq9
^:y6*>)w5`{v]CB^+Hj5RjRq(tYfsVVfRIyk/L8]^TVIi>5]/mTA 5WL7h^C =Wae6B jYdc1UtREm-**"+Q^A+vkuOJmMe?^ +uY
/9}lKok}`W4ol?U87Y)v$?-7a>jd r,oWgqWgTy_p|QUeDDDDDDDDDDE-OE+,TKRp.7:]SdkMQl`V, +XP"CT
,(7z""""+""pUQ@(q*U2wnE6("WT%uUB/oH*$+0W44
|Q+%5]+iNiS
S-"UV]tT;o"7VPD
X*"K(Q]Zi%+YK{jC  V7q25AF ((bUE)B)H'iR=UUxq)z#JdBl8Use (:BAUSpuH;E3Uu5S7<x W("QsO+S"cJRzMTS\,Xxl$woBADBl3PmRATEL[6~W)CUQs8JK~gk:NUIUIS5S<+M4J9\uM KB(*DDDDDDDENZ(.Rszo6iG!WT({tTV)Qa#Td$hl844r
%u3jmBwUb	Ne2oz@Y;EI(ErEUAFY_n^tZ'<9)|z8G~76{Anx+oAO1?r |uW{ Zz5;mYY]E0u 9SZl)'`&,crxUQ,W~r$[INyWMct]ZfzmSC6-OsGlig(voh]B0:)`)ZXx-7SaRh:&5$_nF-lYKJM;"Ra+ebiCx%4P0\w\t#CQ0]GQ!}s)VlOi.+sosyanN@[w},se a:pJ 4'a :J2.o4a7#]} JIqYphMBKSpXM)P,6xY[4AYquc?tK;)n'' k^kp-HoYy SY(f.T HZn!,97Hs[#ejg
qU,Sy_w("R.WvH5TPr~3|\dp(wB|a'5;&@6uV&Gq[x{x!h4{~>{rn1G;$COh[1M2pU0 X\-L3FbA-nC]ny:dkw6cZw`x)(fM5DVDDDDE;_o}y{Y8IxmYS1TSKGF-|nfA%l6,_^]kY@HKZ/m696jn<m<8CpuK\G5m+&X}E)97DJ=ix7+k)l`ky{V	/Z
VbKV!BJUHYN|'I^J}Mmjp,lrW<q:%,*<_ T|jp2+s^T^wmsFuiw6Rax/W:2bx]['^CGPqK,xNprovg70B~?oNgwlAj~5O=Fg}-?fg+o9+jH50iaqH,z)YWo	 2I?fe}4x\U_}^'\VU+px? S Y?6~pFq@y|jMJQqYa pvtyRZH+T{mlrBFVJx]m9VSOB#OqeET4mEp'sorM^s#plu>NJi<Om'GT@i1gFc1PF.p RWeIs`,FRI_C,QLy%o5iZ5
^.',s
pSX?:y41B*uu44p;\`kmYSe|Z}\2[cl3Um'v7C]upHE~]0)GzGww<U	jv^^XUna-4%|s^2P[ o)2)t$[Aq]_	;LlQ.y![bmeuU!92Y,8uWP<S=S83|vcDf[zGhy/ /Q	)p5qT<A_Ed \{o*(09B]3Q08jp'Xx'2 $0Oq6<SVL^wYX]nVh{4#s0UQC!u9X0(ROe$z[CUP35V5-BH+30*S4hm+[I3seE.K*Yt 6~{5ma%u'!H%YWIy6(ISVq:W:+\Hn/!G8MTPfp#zGkj{" "<6wFI]-	\j7|Me%MMe;j>0\p]mFC'YsY4vz'mant~qF3vsS/BZ3VknuUPVQkiTKR|SoEk+a{(If$|&3r8b\JailJh*<jGSQO26=(8oU-`lrH[7*rB.(vC:mRp*uQ|fziB"H"EUDP_c(T$+%.HE]ixGMekQVzRp|WFs;G.b8.. i9]ze]1! Ei9h1<O!^^Hh><uhg	6h5K|6Q~gk@?xmiLBiUl}4m+[;}m-V74f|2qwQHKr%uMmf S1QCEVLHF"rc*&)eH[7f"(XJ6RJ"4@%;F~G7{eYSQMi#juu!h}) l:(LIT7k0u+Xrzu%Y|QF{7vt3?)qfD.p+ gz`~1YB a{W9`jq%C,sIW <5-c^N>[X4|0pq-}-Xtv'AU;wcK<=	- mjj{={nI^,dm>V`>~)@`.ou9+SquX6qxb3f#	TJ S_P%X96zO}iX@ho>66pLwpT5ho1_]KT`}iJ*>K71;zRdT6aT#` Yp_(C]Z54|a:'R=]>^&4S6Kh`ejA=9=|<^`KDO,(B&<4TEz*gbOI 9DR>?+R=#(GSv+nl6y?r]8\YavJ<Bi(yrp Lq
s~Gqs.C@yTQ3\T}=O
".B}"p|#V8uk'@GEvD(BQFj_l/TC,$JphRn_&eI= |r+KJI,dDDo|$VV>6</V|.B0En9{7W*[y-0!6_w"|>9py30D{F?	dummm#b	dtbW3fHc3vk\HL yUAUc%	X|o1 QYwb3~r}K4=Gb}TY?ZY|bKQkYX5e_vuDl@[5oE2j!r$ )O[Q#dSO*(}~H""""""""""*rUEJqb j"Z[	q8`C[qVh:v(T[2P>'T2J3$uU-5jtU!]x5lwRy%:uW.bvlV/nH2b]5te<kA}(YS8umk:0FS^Vf[REz}6`]x7i_UW)</j*s?ke"[|S%/#8:wP[mal7
p`H2nj7TJMjw)<U/q$3^X8;O]iq	b ])pz82G[}=7bT2'Xz~*N_\)z(Hu!:<Ua7lg~*%Jd<euq\^]j8_n 6|Px8Qd1, P:=l/ui;,-nEJ2]Oj$n?PR
[Pzat9YJ6l Y^ |}v]?Wke:98e_T,[W| qc9 r)=!\7JO I_$lk}K; l2 rR\
?'X:5F6Eo83l1	8,?}%}6')I},vq@x<}.Eu3dy%P@cO4|v-%DU ?8Hl9Q9E[l#Zv$9"jM>]5CcHA%f++s+bxkuUc!ja+!tG0OuQ^hYJ9h ;|+`9*37O5{oj:R8rnWtXDup{O0oeJJ)l<y@g]t=`}CeBihSC*LXsp`=k-cn<b=68e%LKwvK	>WWd3m}okq8saYOx.m{!;
zTFf=(Y	Z7L.-/aj3x- YpVc\6Zg>]ISg9(WI9}xZSJhRH]4bY)S{,)4!?$zQoITx$5+ BeN{lY0nTS{G6i~<rGvwGzZ,8&`UxeK+Ky)'=\Wk!'sgoKyWtp5`/}#na I/fE4cOsMzK9I7i=Z!+v G79*-T]%X4u'~Nn9xtRVWZbA% $
l_vWmkRf\Z.,1[T2<#_lKOzOf^;a$`V9*r/E5[$Fg+H[sNb|D1kt) sQ6cZ3ozO5z
e h (E/J%S=zYUv*j3\N\jD4-H^|VO$)Gp 8+.7c=vb}#Z B,Qq8~UB_0lL[I:zWGqf1 Un@Qz#hdS"g%A*N."TUX^LV&-lT|uJ4u+dsQ ) rWuVxj6s}@uSE9\+a'l ?:/8qe;evOC 9452`?4e	(T./R~aM?*U+Hr]eIU&[I"n$0o0IZfVsTw\Nr`;S4bcao3\u9\559@IlnMue	x.YcTWp?NW:f-3pg1H|L.6cGhT }Y$R.,BZjraS/s;2Ng2n]d76`YsqJ8K#\rc@Nd-_'0HguR<C%~ p+mkflM jv-xI9}ql22,5+DJkf9$]'e5O-0\f">Vc.e/[]v< s/Oxo}}zOhRafpnB8Cm 2</8qw[&_{vbZu8@
y 4.<Ukbus33V8rd}TA;;Vvq&#O4102R<~kl4	a&"ix!ufG1C  
?Cm5.6B$X&#f+,9y\AL YjO`qfLri4+Q}"_::A1X>-:z/6{Aokz9k&X!7,6rC%pPBu&x1 $q2|6w[eS@"""*Bbq	QSm-<:Hd@^g*sG{/jP%8#5-!OVkqNKP:C-Fd9 3Y--4dd8~Z{|4si5E8|sAK/|<p1_%I+x!^B%A@CdVl
mvO% }bxX.ei?C[]S*GP3#Axw|iK6R)FMqhG3U*7)3zXPpX o.(>X0JVX~P^)"1qXyX;_HbD,?ZFo_!s,/ U' Z!K_D}]O*jE~w;""k*E(fwuj r6>kE'5*!67&.*J4u|fKR67Y%T(OU8/6 .GetWEWrR+:L7FEe0{b6u7k^FO60Uz&sYqv5 <?3a6BTH\l~;jdy fgJ?h	r@Y+H
L}-7
f#E9BFU S"`,QNqT*8i2b3<nSoAC31\O|F~IK\iTi2%S0D
L6-!%i~1Xqre1CsbI~}TCB X3S1, :$\(7
+C/f*T=k.PXIn9<xurr&}>"1]66!elhG_a|#/'
)&C1y]AuvFo+Bsr_&6CYMGT 70}
<cB?*eKo`q%a:h!}'V:z1\,aG,y#W1ez8[faeKG5?Sa|GVFH@iZ539AS,/bxqeDr UX\q2ReuM1^v# [E wN'*V/Xk-U:Yt
_kgH+ UU3D>J{e(a9TK7&TL j,lQ%<W.ttoh-x-,kcnHqsQ.{h\U7O9PWRLHUAy\DBB8{m1D!a[w3+1=s'cX| Wr%:Anfa[	4|qm!G8Gvt^EP*kTq|=5Oc#%L4sCiFl&kfh]wciY CnC|24<WBa50eR|Wnr$XxFUk_"FA"Wv#2:/}eCjLvmb{_w_K,VCiVYyjL pBV2k-^&ruBg#
V56sV&-84< :%mkm8oKU.Ezs+d*RaAuq-DR]nZGIrN9_79sfn#y?s#+Hr(U6l vL{)vYvp2XNYN.6vl,a c<z?EFrgljfvG+8d]\nz9t&yFgMl#MG% !vJZZ}x,Zj` `S4*GBm$o#o8A\ ]|^kWV!BNuVP|V\Cd@'8)8d{	55jebze!/[i?:7m|XMX\']?<>dX-=J",+xfUJE*Ro{MJXUKc6^}[IRTHNTu[[^WF_X3s:*SETNK#M9
?sLA^?O[	QYd_-y!q|X=9sr ks=R4W%\.2hJ8+Ja;p\ftz\9.W:gT:J|UV;i@ y"Jce}~sf`qpe~!/gs#!K%-|N'3~|bN3\F4dnK)b^x~Zi:6&y>a$[5^m<T5mEghqX.EejPema[llSbSui`/!^KHkHxG%u?fsba&'_uD	HM5 pOEHa~LfDx]R(jhun:9%"CL:+Qy6-VvDr0OoF#23>kxat =o{aSt-2[`A23NtZ5U+j.l'A&GGwy}<6hSpUajtG-(M h@9 QNR
YD^?%r4jHk?6\3|oS~wa*j|#2]> m8I;AC1$d#Far ul,l?5u#xI|gq\GrxUH
""mn"
UTa'B8w[^#F"hj:&4<4H{dHYT"	X^8HBt_V#HqK9+$97v,PhnKk:yj)%._$7wB*+RV`N2[jGs]iy9XYcM=LN}4ysHNa5Q_R^FMJN=8m\3
	efhsH%}x7SF^ sCd
8\)UzT"L0"s*aWiTGq/3_R ?Z0f3Ow0kn^k;<${"S&k%+[3w4Of}t<%t:1p`+:;;""dDDDDDDDDDEF|U)+\*
MbmVfLkM|LNfF96`_c.*wB{|$
){6$GgdQ"8$+I[fH*QZU/a7! }Q({%l7jbtfj[7^G[_^pz#M<Vn.ML^51 oA)f$?7&7Y2y&\qG4oP8*fVNC5qmm	9O4IbX;N"nW| 4d;2=1on{`8=DS:u-76u7.sghdLU6G6& ^k8TUP=l<-?XG`:'g(qtkKB)&3EM\<ff(U)r}xLV{CT8{u\Sdng9-s5<*XLmxR9:n
<kt2P]6o|?5t*f_U*pUO\'}4(c=CvT\	M
emZUMa"7
A6BK d%R9e:zT/	@wMR"`%i
ZU RJ ,eLhx#JvEbU,<q
e ;I+l[3;`2j.mOFhq}%
vYCZa^-t|Nc&5R:X/d>gzifssLeP]lFC8)rmG1?-.cF~Yx\EmeQTwqiEKd64#ku%!L0ptod<
h|EO$i\{W	F[`@V;GK(CdUVSgr"N2bk w|ar&iPsF~
:+Wmg.y34jBEp/aQIY9K4}&Bln{g-9/|4bAqC*$ 4gy'2)]d0fG6KN
cz{E2.:zq	:X y~[8 gi3H=M{d`z9w "6XRQ *x!%v1TK1);ok^\uP4
v7rV|64rPssTpeclYfFTV@n"$ qY~JWpc O'Z5']rsw6G'io]HgevqA 7Y&R\|QA:9rx?qhFyt
PuSfGmh'	%VQK<6EdsSr\8re4TVMe3R(R?V%3M'@ E;I!@MJoQCUy[W3<[?J;#<':gwzGp,^;xNV~A[9 6 We"&BCPz0,%TgE	w5=YfrUyHxPyJV@9ZTX))w=W,vG^K+#{/;O#8`U4^([c?!q9QYg GBl?-p x d./'+?GCXSd*X5$m TqT@{YY}U|'V
PLNPBrCWM22ciki$,'K%yj(5,MZVZ(4XD8'wZ|O5 C#wlQ$.yIsN'weMxLfgU i>6Z%v\@Ze/r {\^'N{U.5 ^jDb=3WCN6W= TTF
n,}l_cZOhAw@{:*/v
DEU,H1Yj)H)z;})@ 9{wq^;~jc)Yj@F-v'{xqL/6\<8Qb,>k;dDR .@DD@'UIkQoXi~^?s_7xhjekKQn^zC\M2:#ln*lxKOguQ:( ouQfZYYx!!-3]P@5]%Av\y<FL:{6_ W6k]MK4OoXO
8D_D,hEXcG8l1~WP_dEq/5>NQjfq1ZYN)MeU[gD[o/j?-h"m5)V pWS#]-oW
${d/$vwDEz
(_*o fd?J2[( \~zPO*V]@EC]S3E[B&&Nmmzpet}Ieu6{AggfV :
+#8\*#h5#u
^I(v{]:7.:|( |y]vMKMUTFxV<
=j9QIR7']GXFU6Zec2=crPT	iKewBd	<U(C%2;Tnp n]{&7l^NAt{Mao8!X3k*z`_'"
4+u3M3|hU)h+Mp<o89xgyW?,@H;~lJ|:TL`|?:/K|9 //,?@~OoCx)Qm?EE?{*?bch%OI2/A\9kb9<>D8XFh8UFsmJQvf*"[t6_ 6I}
vm!`#o$,~MMp>\1
)P7\JW^|B=u JTe}_a=O+vLoCx$FGQdBEF0a+LCVU;y/q[4He=8l\02 qpWW/@E83F:`DDWnLsI*+cf%L=m#z}:>!mmS!7L]\ Vkd6I	AE;p V5..u{x[jBK{_)4XRlPy+4cqq[N4U&K^?*^'t\6qdGt\r-z]s2`.auwe[P>76E,]l{CRJDxOTWM<VP}fIv,-eVo	YLi!7:sQwnv:;7lEM{	'5
s\hi<r^s^)w$evFZn^M"iuA1!v8?FQ{E;CUI9{N0r}	U,5c o,l/lCLlIS5*yj)-# MkErnHX271E'km>-VRSE3mhh,LmFvi't:N;w6PC;'UUZQko|jhLDDVy)+\rP`% S*G
3
t\;y:AjgC_I?5X<h rZWy*Gy4/Ny*p3g+Y-kpgp{1^pg7~YBdlgZnB?hj{?TDE_T"(?(*EEAV@<dgzXyzCm ) ecoxZ;7C8]Sp*A_q5i[v(#NX_d?o<V]L9cv\YUB
bU	D|RiYH3s fsK&w :MG}{65[)?0_D\z45V[1#+9Ha1$%zP1#iU3M+VX
"7#gAiA 54$9]:9lvN=Qs J#Rk0F;vDiZyrns#hl>{b4<*(fkgk0giG;qCc<!x"~
Dz;^h<#v0WesN 
>=,*t4mhh-y[KH&?q6&&Nz:^W\>Z711v`IM7lr:L4Q,\8rB7>uq&Xz-];A2x[au(5N:*VYtS3
* ,EDEU$zA|7b+qwE~)?'88Ca~a[j'w>5aVPT<x6 6&@+M)WP!&_%WP!7%\}Tgq\OKwY~"p_KUP2*5uIKm.tfSUQH86GxH#/l79d5V#Zs5e+qU7q6+T8yJPR$h$}fI sHpXUMma^rS[oO8Z6i[au^GA+<YhaUu:)p0~2xB2y^r'!*=an'cTA]% 	 !g,NxFf4{.-a(  ZQ{AXl  Tvb=Kc*jo(ff>2bY ~g~W[?l*El- V?RguDsKw8S-; aMy`GWW
#o\(zYI1-TEEo68
; lyvpW?Z)Gg#Pw,n);M R/ e} icV>?yr>7\dL#nWUZL3 5V-lYJcI s-s&g,mc]<}q{ vkH84U;ly=\5:_akY||vm,Hzp`ijeMM,0[EyWn+E#M5lU0{mUZy/,v Epj}w^aqL+IC{_*Qo(O\4T?=HwUHzch-k|Wgeki:d*XgWiJ*T#sz[ Z%8E36!osJ\Q[^
xj=U#{t\e	4S mqkJ+MM&"$kLd9[*gm^*S1Ebix#Nx|3,=,-aW-FI:2lWW/ajM=7<G _0cd 
8nm+o xmGWf3,{<o$)dhpG V !N+2~*J4PCoVj9q9o?(TXgwJ,4c}JB7_!*h	*#~
c:tlw}zUZ\!Pg\bG]?VK/mHfmty PEU,'}6cwki {15Rx^a`+^7luC[]7WP6 QIB2vQX).MJ(DTY}l*h*. A
R2G5Q-U9bjF8'AAS1-WnDlUo<;"G,]AU4RT2D0o*0IY
jq\]f4@{'0[wS(xuGhF;j +z#MJ#P(d-3;:>; Yx{2ab5-iy6}p5glQREiLYYW33Y~[$-7` :Wo]5<{E*r AB;P*h
vd$vBYTH[({V	Yl (iA_J|fnsZg<7;}%~f8d	ss]Sv;wmC 2bu`K_PZY-x4rk9b,]PkacG[Na@lhWCrl2`kpAX Q}eJ3v/qhA-H[ERZTR\)V,*I4<G7WdT<*YR:
T 5=&.od-_m'o!T0KV;eSMiPyTx;q5;7n~\R`AL0{l_/	T2Q^uB(?**=
RM@Q[Lnw/^X^%_	 ?Cuk 4'wr
FzLOM
FG~woNj05 Cm]&kBMx,~m\;1krT**=tq;NVUa.&tVcZvn83k~q dst[GGR7^2!0&e\Z=Do[6<&x1|mFf+,R;2}WZHXXKl}!bP4DB\Mp4go(q2I8lUMo^Ow[sN'IEoOYLKkS0iD8/6QUa),g
^5#\B=WCx#1YpK2BH5A).}hB ,io_~^}vF6<({QNWhh3
Z}Grj80Vj\	N/J. iq%:v.llykiN 9rZ.W2fnxUt5SRO$Ns#UzE1FVa6mb4DM#j<\JXqr'dg`N->}KzC11:()@spz8.kRQV^\oxB:|SVI,egW7t4YxkV.u 5dudm!]gx%;>I,zbxG! P.o|# 
?
Isgq\?@"ar4T<UNV9"Vq yc*_OGM$ZO.k&Mj0lak1<X&adellM4I8-X?.\Up0.p$!Cb6(t91$W@ynn5Suws=r\4p`""M8}hocXYq
l/eRC" ->YVe%p~[I-mDg6$	6Mq/S'S6dp#%*eB*MiZ."@4V
""DDEUB Tnf<8Iub3Y6;JPlKlt,H6+37< AN-5am}UG[=m\E?/lA;G5h.?J,jVz[=2	 }UKw5vjV6yJ:ZT{D_@nsume xWBhguwpm-?QZ5y]
&zMf~x>x#+AU)sDZ-pcq (#Nr6Mq\2\v=uq*X.\=0<WZZIp0+\C{t])x@nvrV=)do=N|GvpfY3u+^]P]Bvlx:_iVAfbyKp<ox5SV^Za=1u+)T`_|?XOo# yhMamlq7;rE[y]UT0T{%"XvUG;ewR%(f
7TL<y.+UNw;OkxJ-& /[,?&+=a0SS%%k8TI 6#vM*~Hhqu'.?46s1n=7l>[6<bjMxq+{-)DAFH714[ >Q,H<,V~F'}mcz?Uk,5;_J/-}AkT;HhMr#4FGm7 irz8O~ep7vzaU- z5bq}Krn)dq_g]QtS4,i>ZM@ImD5**-ZAyDDWDEBUQBEC",tEm[;ci$U&56i0Yy'LWh&2WbbH.^6]cRa0J0[r^C]Fs*em[@2RRFPY:8Bz )'Mdyv!kadj2os`fr[e4X.n7Ob@xt-@Ole,+d{4XlM;?_woRqdYi'fE6c7+N+l>ne/y>@Zdjh,2t='|
7Npms>94cus|.T*
{[U#oRy4%mJo+\f.#x y6c:X*6^?q3xV	IS\Kn>]rQ7d0vQ_Mi~em}Gr"443>x\Z=f6JN~8[OX-qG,np6jS-q!{nb;fX,P -u.#c;5 FpRmm55u0mg5'Nn4cIV8N37SRTF%7iYok-LUTG2W EE2dEFsiEYPo{![W6}'ZTo;IEy2~}cpLiq[>10y}k~<wCpy$3\KV[d>l/ n`?f.f<OpUTTTVB(?OUJwT XU@j\_v7 P[MT4ZW6 nio=sCg?wr*`"Mj +;F7`m2g;~%Lj*xF.7N]N
N~l-8O{+%NnU9+jqbt\aUKDEbtEBLw+8_d4hAtW^X6B=v/a,fv;oEa$cJNO [PbnOIrH:d^[Np2qKGj?j(~X4h[Gj;%_Z8MNETn/,W37!aq}P^;u=3qR\Q 	7KXF\Yi.x01,?,Ap&W hu9k[17 9r)1,T[ kZK#)bwZlA+XB%hoxvj6PIabe8.7Qs|:h A&{6[ L/{~^c[E^57\T|1^/]_img5-{]+c9Gkv+BkT;IuV/*BM0}
['2I[/~w0~o/wBTrJ>aC?~W$s f!N g.bR0 )th[RS~g;k\;*\::M
BTo_>s5vTrv]o {Wsso+tNWLmk#\;8nPRJ/c]=|x|vO/z.Z1mW,hY<=/25P,0 x]6XiA".$sb6B8R`F4%M7f{H#M4i&o[A=W@ {m},A$dpNyO;ay+PcX5u6%q	jas0 ~*3&l9S_w|{zjemW|\:>jh>+X+CuTQQdDDDDDEByN)bnK!ROm8(C!w=8ap+,;[gs#m#1`}oIC~Y[9<*]-H-qf~k'[7 65:1GJoLt>%pK~=2;;""eDDDDDDDDDEFsg*VEC{y3TGN	]Wo94>Pm;|?hpyR{C_u6]QopWZw\ / [*{}7V.~
x\`n`H"8{Y
rx}37(j"zzVtp_M>Z WBr$fas5enFH@oc=w*bqh 9gpGEmrRr!Z2miCM3b,t>;7|<-I&eUk )_rh<8CGhAQ6WoO|M(:T}6(6+<K/<E>}<OvGSJqT:E$[0lb[j:k\Y%fm*Yv9fFq5Ra+i~-ar~rZ|[,Yw1UH ]NMvg?h%o^:/%{z	w0b1,(WeGR *G]@ +t uqx`# Qr@6;Q0k g%2Us	aZ
%R>+S"(l:#EQ,*7P)Ek%0R),mdY@DEUPE$Qw>
%Tjq)kqfE{]_Vl Wjt{7e6<6J<6q8`kz}E2m2
b/;-]Kt'
hG@OsEbtW:!{k]dBJhTKN ;lmv+{sM6aQ<Owi2vZ,`B0toJ3rirJt$%+Y XRQ3`y+fK6mcfl^Hf!,2 W|HY^AaC%jKx!d1YsN)\I$%h>}:J]eD'yG2C}_rcs7E#pM}
6Uz;d^AxlZPeXcF=X:}+KQCgNFjZ8\OkLf~6C|ov=\:ZW8\wZd/ pw_7ii;>jw,|.'N; l<.p>
alAWQ@xw;2ZD~.6aT-^VJ88@`,:r\E>t&3Au>N4pT]{q)N@o<OTBee?_S34d1Z*\zm\1F(,kUYShp\MQLGvZVJHnu.dkCO1t7ZORln/RxK7TzYs7.`)m&fo5/]{2;sX~+^ -VagXrtX-=,9%ckOp_6Q>W** wQ^e)^z)T+HT_ja
7zk*JEj0c&-[[U.E>/dW./P(lJk5z\bWzqXmrztU<vP~{Ey$k1Gmo)CRi'a?@]hk PU 3Mu8We) V5g`O-j)SNrGS`j\&hDEbHU*9)I* k8z
OJX Uv\*E,j+r4T&wF#EOc[q4vVoZTPs_V#Mu=]w~Z}6+8
R	ai--"eNVz\Ysz|GO hZH&
m48rpY/_!iSP/-XI!%~&u-fHLGEV!rq 5h4EF)h
(E:@EBnZScZ99s|w0sOx^+)+JYwP8*%)'Hp.ne,%L?~)L`l+[JZuS)\o4T<)a/-u\6WZ|Cg-q#cwRrmbWmke&f#3x9jpuAlVDMU9[{}+z|k8i+%mbLZzf66(*%yki8XFmcA>WB4A
r3r<1]/V|Kb4=`y*"svxVz86C4lO#FQ#sdyr-+a-{b5y,h6^uEQQMWu8H	1Z%*LNl7b]'H2ED tw9C?Ee])2BVJ{-)LFFuTRq|EQP F<$VqXMXxegcx=Jc%aff=`cMs[`R/G]R;[57 We Sg-vOSG)4{M]GQL~m\+jcf\}=2;;""dDDDDDDDDDENKVDZ#$o
mN?M7}	aOJp|0k<|j#e?lyt~'~[ikKh/E1o=`4X*lQN&Q%B.g*m(,ufz9-+m{-fwsI
$ulkE\n-/1x5\usBEGKoUzYUhd+$d-w/E"A;'"AdYRd@=rXL/}>#[Y=]M]m|ju+{Nc_VglHs:sSwu*uW^:4vll5	~R~mnj6"7.hbad
uWfj8*uU'~13M75hgEk5?Rqug1hoq.NaI}8pWaZQ:Nz.J(k{	j0sn>qY'8x[M%xE5_LaS*&MT{WG%\"8<Wx7EDBf(i)EQK#VvQE HqUQZ\Q	>ATM,y*o&:qb6q9ZoLr9,Lgob94uw,gZSwy^gnq98Ut[YQi.8'7EmZ4ceNv|% BOZQ\,~E'q7A\tS~J-Z"+c7'}kbQm9JxfWnxvi",hRFj60,Sp,<SN`@Qr;2uqT1Uu3{kGUm;=acas^,e8u@]c[i<{M<zLFNZ.hBo6F_zvGQr:['\*;e,Yrb6Z-f0di>+ii Rj26 e#~QhbXyDgx$Pek`9V8F<X&Ek\[=,Qr.14sZ(@GY	B
)gvVNeRk|M$!BIo;W}FXxum^Rsna[V5c\#PG^VFKP.'= >9c}$Z;<Rjxq?HC"<n%PAEv!8g4[9zQ'qV_nj(RSsP;JqRbi?k^GvvSx]d^~{"I8`uSq_OhdsMXMkKD'rQ#nG<:,TSN)9k*OkyE]p,"v'4`LQ.nJ=sVU^.iYz%?:.s/dSii1DsFD)k8y;D+b'KeZ	po4dzT<D>*U?3]8*2!UVNInk$*|@2T{]Sm[x|&yR4i!mg[}vN)b8Q@{?:o1Yj+*dy$&&]-YF#Fs5{/U1/NI`Ph)*&`/v:G[	Qj1	0Tj=I%w|WS)VM+sC`n9HaV{Q>;lFpXvG&?UJ9mjW"3NL46ZY9uXgyUxoR)(e%ds2Ucb_\!m@ct,n;q];FUY VV?JgXkEiN<\\iuL:c%V\s;PtQtuqr1*sUkW0?c;#3uTxsc,FKWA&
zWnj.^Y{<<.kn"Cn+y
GUT\f8N49gY-+
5hS3?l8~*WjBoF)gHKUqOCE~5:\6*fJF%_>N2OZp|/	R+DBnh+m;b *}Oh~j]!hYs{q<aOXjR:lV}	To~eIm+f0sS[@o}XO#Nr?RW qQ|']~"*+Y;,2J xM=q_1E'1	hFhGA$.Jdv|Z3^'[bp#PGBTiysxlYOp~G<Fut/#OwW-1!]N>CiP1Vy5i; RDVRHjf_tNi ZKTnP8+3.DQ|4UTQV&kMR>yI_,tvj"oX`W]O,\4>+%b~g, cQu[
1H+a SqA|Z9)CYWn	6DCRuHEK.b4X5&!su
rYVvM9o}cEQFzCK#M^PjTG	PcE+ DJ \K%dgl Eq4R?k K3SH0SZ@\~\AbDOnKTAfwxic8<?ub1E5h.S%dA+mErKu^O""+DDDDDDDDDDTQS8kE	l/an4ox7%B^7T1)fA#_u;lsrt^+6CWc+e;dUF?\*qO*%^DDDR*e}3{KH<)/nK]xAF;4"'{/,4p+{|y(Gf(O,nkltPn[>{P=Bn dPJ `"\n,8vav
P.jn Qmr-q=|Oko#usyI?n\H
-}&u]PwQf#xhjj?pmfK^{1KEh\gJC#pwt5u&Z+8eeO-Vk!59{X]ci?2+N_?yT_<u%@"IZ|F+dn /,!%@@qx,Fc=Y.7x& L7mccQB .>-U1 |;1)V i{&_y0=Rm03ccUA'P55q 3vn)heZd-bw U=@w0]}opn!~!LCloTlXOZqm>+8ECA<.("-8Up)u[brZ^ 9{=F^#v&HrtL2X%{ATp K)\j1dxgE9r.RR  gak>FLcW>gz}3]ssub;<9(c=8Ez#&&mgf**F3XX(me<cUSa0T42%g~u!'lut+!:|k#hwT#2+$ZXhFm7f	+rx--LW/:QS+;6?oTiq71.:WeYsn&H@_sUfwW<qB2^X_Eq#y5:5^(mc U`bc'&1#v.	_<@\2V}mK9WO-1E&T)"h!ep`T%lQ$gEy{T
SUUQ%{B@^kj =}rmmb\|o>"Kn&`y:M8G7D1+v2t+.maV6;,#O 5AR5<#sCn[,@U8X|aOGW=hmD}IrRu;m^0`K+)NOiw%Xb2]wq0FV?U|By,Pbi+l:>0Teqk
rIMhiUQ@r*ny*':e?ll.Wl.}>t`nc `?o.n G~P Me9}m-KuA/B]K}E''h=d1,v 88)1g:q*NXn9Hjm{0=PA<{:,fZQ?j6F=MVq9ur3#cb>l 4~$rT l-p_7~RZy$j|y-KJM2wl0E0(*QyWDF3jeu8;a/tqL> .Is"HflkJ&}brPij=B *{v=i+=,Y&'J^/:?}c=27m'n| H_X $~`#[fj{kjt>,*?>A@xOQbre+Eq<N'^##b	)s0l(gh-\ha3h_<;[r r hio y(bz..1Q
h.bps$3Iuy6Y_NLqU	5+uSnXoEsi
|W48'Zlv*ylm<4MKzasCx"Fw.~Vqq|IH7xo^GXnA%Nx"c   ,fg+SmIsVf G1Hu
I%kaydB$<t [sIT*;h}:|qz}Ka~i{d34.4_#)n $0VyzJcYT6[	x9|B2^YpVWk/E+yEJx YFITnN^\A~*iSfj!=ZN3]N@4Y3evonCXC[202\EIR;9EGrI2.I )I0qeJG&$6iOOA[uNN(a=!W@]c:*Tz-o5#iq k<.u7T-rWj_A\gxnkCh}tRSncD0zE}`-3{n$)b/uUB*&G(d>O%T>KX Vs$qs}	|? []7Wi% 'NmCkU^b6RYbO;b;f68fK%/$`lm(\nw+6qcD"C)5+B4[Ajln+_W}H?x}=x*%l;RpSv Em?9z
w =\v&sl .z36.q+ELTUQ"W.q'p oL(GCX, %<&Y+VM.EUsxLb.7EkUea=o'/ ;+D[tBidlq'.?k K8,z:yg>z VQ) mub.R7pCB (V0x%pT 7^6+yrtD].F
" e27\o&TZO4621$kh[l9o!C[Vfpp|Wq(E@!m\7z&(d{l[{^4Y3A>WpQx,gFG4:+\*5T?R>6+k"7wZS.t>7<KDLoi:.60dL^9WI4	zt[.s~0i
\	"G{J	-,K&05Q$f:lo}<GX|hV[(glhV=Bif5SjPk]8)/U
qwn,J%NP4g9w\p|m. `}{ ~]HUi{ngrq Shl0}N5A-cl)4{At|?/8%t`\~GgpDDWH{UTdmlH;4ZW%Sx'+xUn&1J	#hnVbxeF[xmy)8N#*|3	xnLOy> FW`xsQp)^>
&u$;m,TQku_.]dl88* Euk^[nZi4P24 UsUAQr""B"#9QK#;+E(jxD<o#HQQU/`<l:,fbS>7:j7e(a ]E}%Daz&s9~tOmmBGPPA[v`85pL'^ =pfb6GZY\8K&(-WxnxD%7Qj.E}>+e{_W]-v:a;>1<+}"oT4qCYp~gHFT )Ps.Eg*p9;Z?r#:o=T"xdhbllbw123(hApiZz7E
'|Wb;L.5Vc\XB3Y
m=BiF'Nwl\gi0>$A/k]mxO30x9N4	e:CjM@ 0N ccKcP{g_+M'#Lt0V{4BBN=\-?|HS;s_f 5K)| p@`u>&^-3 [fVnfZKA+luMI#8p4 :KaEz|kB&Go%R;RJhVu$SToG$j?UZ{^{
^o3VG&i+&qi<n$@)(	Zr+xQaL4?Hr]u,zEF@wK8s|O [t-	evvif
)YDpl{jck+* m[A2lcdLn]N28h+%,(mkZ|NbXl_BG C@p4*ZoikG6nk{8\mnv./Y<38*SIq(zl;jje"}]KNFV\3hdj/P&!P./G9	!|NZ^|@{\mOQ`8tqpJ/@ kooK`pJ]k^kq*4 @n 0i+Us8UETj,B)`9WvwR>2A7j`  K]t~d"7Hs{06mm3/MtM@p	Lv%xRT47 ow;,{A.x>
(6tl;Ve	/tp/Uk%U1a5vRirNci~R1! a\Wm"4AMz>^b$c4JB*KS=]t3q,o^reXvg,	VR445/S4eo9Oe5zMkl2<pOZ"EDETT&pnm*W0]P= sFn-opOg'%sh19"T ]8lYZ]6+XAX+yfopI7!L,5g'y q6#^^_j+>kn2Ctq"$KtY&5dJ_:mI]~'vMifnm<RE;k]V9{>6T<]sWy$MV]i#9^dK!$*@sUCp8;Be6bxDm-;&h&kyPp jNK+gB88kgXWrv/|jlZCKA{:m^=8^tT6m[pCGzW?):x#' "!7Km)b^4/#Ty>BxlZQFu<D`4pX-	\f.hZ1f]322OK'(0PSj%TkxBr;YX R8\)l$/f82^pq<2G/8t CI .:;M4<V({!n`3O9>mg3EW4 x	,8ykOx_DP#6){}&tDW],l c]FB7  Xnt+n9[nl]c%>O0\j0:L.^!X%V]O1:)cH.ds@_Rq= :5GeU>hkeW2TZ %{t">y)_7hu __lww- ^'*G+R4Gl
n[2]kig5#,z#P	>K	hF,_UB(;*~_REr@_Nez&[3-yv;,V EEHu  @6'Mn9^x VVhEG7a9kZ|;`zxq 4 .z >eXsfJgZv] gk,j*~KS!w8v)h-+/+x& K5  4[6E7Eh_
-y}k|&[o@JSg~cuz:Tvx([a_h(|AN-G*)8?O.[UH""""",hE~bgc]|%KImb=M[sky+,x{u,0Pr+bvdh5c4Rfi.o+##Mn'f@y]iOt,+z6Ya<R8JG8 AEpzq<u/>okK{q4%.0~>/a'<bPpX(j%A*sCa[@tvnq$@xfq&e<VYq	d7|7!?lyGEwlyKo*)6sxH[2W:fY3\f.{ 9a":}=nJ,ZuN{:$<o{eN.|T.GUu)\q1Yn#<P;Q\j2Q8XHRNuc+"6uk%]<ikM!ZOl+T 7
{AtHrDYT`PUCy#E"""""""""").~Ju)a.EkB*2cGn__==_X_,Ji[
{mZ]R5o QUckZ~Dmozy`(!S(zZBIFkHYfq.2OT7Q`v+"99R` eUp4{^AEU1h,f%5*&BWQ4p>*-%WktMMTE+OBk]
A'kabe?a.Tw|ha]y!BW%BT x2N@#xN%a?:{.S3N$G_(#T7,  )BXsM+n7of/!d;2UlaN, TcLkEB[XZ67#UcGE kM	6Sn
LL`kT7#9AJ*"QEJ*R|^CEM,1e*B3W=|:Iq4_KqeByyH7^EHAlm,qYLnELm"@K*Ng)L~k3XVSHtl>Y">lT7 (,{4+c#]6)`mgi+gCg9[SfOYgc\5^w:(-V"+.Q
$W*jk<
p1\pr:k]|c- X{,$4TeV,oi+"!Rx|s
u^p4S`:""""""+ysW
W2TqX	,o^~Ca48hjly
wiGSqu3#dPZIJ-aGfY~AUj]e^cz(^h#Qk-mkH5alR6YGwiYFqoBoJKvA*a>:+Mvw}=X}NrAwE +/kJr +$le,F<W2MNhol|-!l~Q470#O2W
{|y!kSQ\GERVNz:
R_}I.}:m9,}uk-@@!DDUDK j`%66+#7`",UU,ktuydYhZ/4]tR:Z.U|%kq{<.6[i!:',p`x8\`-}/dz*ncHS/
fk(OwQi>3)t1<j%n5qhnaxka:)O'[m9F!vzdma3
teix;nLzx(YZ-;Z7oZxI[D/(Xm ;T_AtiB~4y^2>=uSjaDDUUVzZA%w1z2Ggkc8|]' D=M+<#5qT$<Tf23[.(|BN4akU bx0>cplT=9oWDEG7R\PU	 q$+T$;nI+S7'hk
D8<Zm{>J"~}.d^Q|j%8<Pcn\+}8%2F[gk]<o1]opY*AJ'?)bS@8.^5mh%lu7rGU]/kK7?/6W3=np_7NrM71,7VAln>Yqor\yXXDaqZ0[|^Gtw8s]`cHw1?%oGmx6SA`tQpqi>KKoGL{8|;I&]n&:FFt32]i;Mm$%'<f{Em6BuiYU|;8&:	+F;T <rdZGDj7qR	w=U)*5 _+[;zldOx>m,}.3f~bV. #](7*BN>hyB?x+:9DUY!N#a"*w ""UP""@E/f|T\ZaRgU8Pvw]Y@YS.'[)DDDUEjRu:PQQ.'^T,
Jn!8x#^GE07lR
tTUGYNO<B$B!iUMeX7E9w	7\Ft w[rEYA)0Pj@,	T!R%UDDUIE\e!Q@ %a%@4D#I:Qd*"%ZJXIS" 

("""m(BQ (J >HXP8\*fU! *>J?U;?5,](DDDDDDE#bR>#uPPkBd<##*JI]Ja,Tu+p:hUKly#mmJ UX4TNA7UU`0UDDUEgT=B<>bmz^au+U,lxiaZ T:obTuJajUq%~+J=:UioI<m3p<Q'K?*\UR6\:&<i3k[U%p\;Oj)S&`p'> 5 w84ka4ST1K9`~fDx:m%]gZ-yM;=Eq
	D@vS9+/qs661an[Y!i1aS<kN-a~<^(oXu*lv-nXG7~}9c$&hts{k=/x`x@)<-: h.kr+6QpAZ~\&
3Ak3_&dfI8PG}{vSbql2SAZ8dx)/mARcUuhm{[WXl"* z;:wx-3e+Zi+0z2d&=W9w lH|Csiwq*RQZm\sJBhZ8]EN6XR [2P_z<iKexGDXx$fZ"D&PtHUT"3
.}~&EU{852+\2EDATOUX,s%UEFDDDEMq"
"
[~[)oUDTT=-vZQDJ"""""B.;c,PG+Q-dDU@UDDE@TDDT"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""%h*(B!Su8hEJ""* Y{csdV T>;h 35r+b=nZF\wbJq*p:QaxBx|PjbHor5 iT7?mWDE(QEk)$Vyz8=WqXbA5_%]aXZV>;\-p:A \u[sLC.bq,B@cxC4H--"-ocH\}a^i6;*28
F>Px&4VtL["g:1M!o;O}
oP||$?ulw?bYG0W^v3c3k77PE/`Rjbin_[ Rk^Iqy(:vdps<."^yR2sRL8I_E,.pt
L^Zl.I'	UZtHr^V<me^<#cha"k"cw.q9{F^~+j}UBX(A!y9DUYDDT"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""+j-7?c~[ T	Ziy[V~& j8(';agN|(%oO'yE-R{])]Tj=Gz%OWV)Mr[{8".*DDUDDDDDDDDDDDEB DVyH)e>*tZ[dX\PXHKmasKZm	XeV]=!K=u5<Xp8t?eq'::rOigsydrm,Wk1z8 nf.4nh;t6k	"~Tt06%aHpZQNMLg]V2*ioxS{_iqPwb5mIh9gsWG9j{]
ju3x,|4[it5G<q\Eh.5}o>F ns]QOy_hQU^Uj/D`~?doMiF{0cW"hX:K{BN'OY*48Qi8(5bM<T)mRSCbX0bt5uVqB:8?8O 6C8'\Cc,X%BDEpcqEHckePUnSr^lY^_w+Ceh@kCfD+w]- 1APTQUUKR,a9i-#B%s~m-GQ_4%!0i!$fZ7&8zuG,(0nKMLV4hu1 4$L,N4uRq5 /Ux~c]Bd:l =Gj/nVYTTXtWR "  *e Juv}}y!Oz07TlDn.hi jr03S""s
lF?U|5YzJc&_:NBqQb$mC4+FOK JO-k/u:]J`&Ug8lj3t.^me?C(:&6/e0X/gYlq_2jn,"DE-&B|\gu]|~vJ ~~JQY+UQhi7a3JcO =IRI:WD^`&lt ~i&(63%[V[iZ:<78KEOj-;m<K\{~;&T*;8[0:ID$lqS r_bQ{^iZvllsIf]6viZN o.JvzHh_4
     PhotoEditor_Re_Edit_Data{"originalPath":"\/data\/sec\/photoeditor\/0\/storage\/emulated\/0\/Pictures\/Telegram\/IMG_20250601_233155_241.jpg","clipInfoValue":"{\"mCenterX\":0.49952825903892517,\"mCenterY\":0.46800073981285095,\"mWidth\":0.9394920468330383,\"mHeight\":0.7368929386138916,\"mRotation\":0,\"mRotate\":0,\"mHFlip\":0,\"mVFlip\":0,\"mRotationEffect\":0,\"mRotateEffect\":0,\"mHFlipEffect\":0,\"mVFlipEffect\":0}","toneValue":"{\"brightness\":100,\"exposure\":100,\"contrast\":100,\"saturation\":100,\"hue\":100,\"wbMode\":-1,\"wbTemperature\":100,\"tint\":100,\"shadow\":100,\"highlight\":100}","effectValue":"{\"filterIndication\":4097,\"filterType\":0,\"alphaValue\":100}","isBlending":true,"isNotReEdit":false,"sepVersion":"120100","reSize":4,"rotation":1,"adjustmentValue":"{\"mCropState\":131076}","isApplyShapeCorrection":false}     Original_Path_Hash_Key158d80fe6cd1f596ea004cd808422b365143c5b81af0e734b4513949f027008c/37644SEFHj          U    d   d   $   SEFT-e 

===== static/img/logo_light.png =====
PNG

   IHDR         L   sRGB    sBIT|d    IDATxy$}EDfr%K%J$~KV2)K- 0!l~ C ZP6[)Qx,$wW{stwuyD#+jzzfgwgm*hA4hA4hA24hAWG4hAyCbR?A4IIfbx\poV4hM9dWR`d@^TCh4h@ $OCi0aqkh,;l [JB4hD4;rPk}ZZnR<?\)9dZyE3*+;}}1
Jv-(W4hA?wy{wmw:Q>Pfd&jC{w<NFg~H)9$860WHi/4h;>p(;6>'nk{>#EQ8|Q)PS
Ep1Mf
Gw<xwR;ceqqi={LtekA7/w8NZ[[?p=y^,-.//s6!5[(h	}go""#w_g>s01XE]`F2kA2S5dm{#WWW>)oE<h_'DwC4Wd1F/-J{|I$\pAi;w>yV12ImA\aZXk?GH>}Zxi(lZ,y(@fWYj9;j%|cc#$;~;;qg^/i_wm3?S4hz,3	:ut|4z,-//%EQDwu3?pyyisyo;W]Pe{.\XiFQYke{{v;WqJ<_tx8dgz][y~^}fkzkM@yRZ41Z=ci.u:ve""EEt_oy<eWz4ki:"kCVv;gyRf{{9I4e_y1I}k=:WnfyH3]*k{,i2ur%	i%XeYi> ccH]YSJ[lZZle^F#Y]]uQz~n#yn3Uf)<![ ZEdQ))e6c,Hj~|IEeGyfe$>O2m.Sk'N4GJy-Jsp%_Nb}z 1+yvk\.3f7h.GFQ~3/@?:Nx/w:ai} KZ)<WJ)Ex2JUu{#"jR,X-RJy{LGQ1vnmR&h	*rpEDi"Fw@0 57RJ20!;	lR1nLtQcZGZc\j7Tx<%-z;qYRi^YuBm1EQYP F9/D55=k1b7Mmo{+%y4gm`E cvxgI*5v_R^	?
,	]S$&vHMD0 F)i<Zy_(]B6JDie_Bf"b@4yO"JwrQd4@`=|2vU&Q31MfUYk(8I(R{_zP+Y".'PTd&+2>ei.IyTzxpd(D'$#3+J$+_U>g^Rs8>/?;wQ](Fq/dE3~GpUiJW^v$Moj`:/>+$Kx~JP'2D<QS}OV^>go>)*2ukE91L$f pT$iRRh1{]{W(f+< o~G:Nb5exwAvx$vr}EJ9<"`sN$RWYtN^qCdv	.=~}7!8'urex/H{F;L#om[(e /Ji"g; R;;unT[/neWnu~w|W~0;Jq|d4Y >rI}[kYWK39n0NKfV>[9/.>{/9t:eQIb0HEi12+P^d(hZXkj)!M1>|OEqbZ3}lfbLGrK|cd{/FXNx#k9>_E(
#GZ/O,?h~`x:njkYov^A-X<Jirmff|/c)]J|S1$R:vZl>%Et&W""ZkN<)*~(p("BBD.sI=J)RJJ)oY^^o~km4,Rj^{,2 JAeYK/?*B1iPSMe=w68x)B|}p(yv N\1eV4MviJ|_(

'
7#nk]QY$8q%yQ^~s;2Q(d8j^Fq?oS*McdV|VWWT 9$i;n)L;Wn^"IvE'>]Kued6w;FDUocv=Z4eyyhD6xuk0C;cxOA[ceX9iUJnq&k-I`%2$ZZ1W_'.0	(1){0P60moBZ(F Q3^REQRtk-yC~|4hmFx?Eg)Ug</msMKv^<'"<'cKe2qes1MfG)s&	kO0~PJmSgwN./R4hAJD"T<jvJZ ^5I;*	[:R3f")/54hJ\5`D76&s*^)@v;AX{G2If0_y/%HXuu1CK,CT3]4h(e1;R$,M3_-0n	_&ujL"0E\5mAn`(DX)L8<7w~WD.gy*sMhmA7)JOR1/af0dB1OK]S$>fM%4hpc"}]'Nh3Hmf;y	}u4hps9
ol<ww4A7mg	V/c^j4hMaXf&x_5%K,xPPcvy(v2n7A7	r{U_zO/
0MdQndV+i4hfkTa\~.cV<l7Vj
utW"hHAn<Xe,n.;Cz4hp@|2*oWRscB^BG{_L$+.+CKv4h
U3J[^|]^}?|*0xq}{]
;]r9^p /; <2bA!v%Yk"+U_XgNRaKCMZ)r)J8=IX(H`J@*)WNh ?/%4AqYiO%#_NOWnz4*,9w=pq
vL%9XJ,VRVuIwmAo1;L8ZEi^zg%.C=qRH5dDVn8|2?IsiAA3"\j3@=cR/}Lp</GPSOw]Ib88	QxoT*_zxetfeNFc4qQj*M`K 2I278m?%]_er=I`)/=/d1B
.![4&A{G'r4v5w;Mq_s*Qm1Mr!r
p%A#QY0n<cpq%p5S34hp-Q)6@*^`R Z%m3 l%bt&e%*=Rga>%P(+AMT ^WvT)dV*vE2&Mlk.]8411\2WJ)PcGXzt?3;B6/tA&G;yp&;+4d0 {-"R7^mO7
A=."R"a)cu[?
wXq8('{Dj}n@4xwTDZV\zG)U?YT">3*
"a(~(\DjEuZ1F EQH"{oM`O1N8qz,]ov-g9'ZkHVWD2`8tmCC;U#tR@\kRs1EQ9J)1(BKKsQ+JAs0=Ekscz=!c{&I)y1"RJZ[5u $Q^TzZhQ:z}8=k:Zn;	seY} Hm3-\ LGE.RV<{_&)DQB0!!pc"hP6(e~~KZDh|I,u?YU84~Q_fZzJ)4s,,,jn~{<CJ^-]__/xu<y]z6}`myLC1>2gjG]l:VE 4E)EWyk-"36F#8Z-h'F#r42)Zm%qQL	,goOf,,,EQyWWAhAAeTHw{qtXXX315fV*+CcL$dYFcsJ_Q~|+_}c`86cf8/riwwA
^+%]YXXc>RQJ_v=Nfka'i},,t`0$q-uW@6%
h,.eYqwKO|G^=E; lCy!8'2o~P5vj(tjv<(JCOwTD&_ySNqIzqytH(
6~"Xp9e!Gykl+m?9jImh4BDX\\xc]K{Ti}Vv
OHCH|86<p}GOd-s^O~o\LE'p<6)^DXj[5S@fu_E,//31IT{ EREeK5f%Hviq$=P|+.sm??_0~>|nw9o"W"K_FoHEEQ`(xY[[.GbE862;y[$:qaVK_<f'+X6(Zq}56*J-},E9{Dx(`podAZ|\G~xyiEAH"cF<j9{#Pk;"2^mnmmm/B#?#>9y3gZ9ssy/#mZ+
eaaqE[[[lYa!MSFQ5.DiSq9JgsVGN{Ou^dep`0tJg[Oe|<sV^iqHGPvT~2Te.K'.YF	'hl:Fqu	qYn+g<)n[FQ`Yyk{<;aYVD(J$_O>O_=UX_<W^y?ciG@/(%'"Gjc	W7%<'MS1QR6,$A	eXg2U?Q{X"*{<2z+S'9[g,?[l@[z<z+rU71{!(DcV.jB<V98b;?"Bq1"0&fkoq&;'X14WBJKlOowB+jwg3"qEQp.\P	Wh"{B.^Rl<3'|j(}`/_("k{nUJ"to[C(r@`|iO+/I(<%Qyr	pc%H6#Q^{HS[:#0+hV2 C>fk&g3joZ+6EbE}wbjFhH-H hc%3A*X#nx  Jd)#I1\pU<fE16Jf;w
^?B?U4-Q    IDAT;08^Y>Z$I%EiV<euNR(lRiWmk#C|R@V/oR
.2r2F$$@X, 
QL:"+Ew6.)jED6g8tRNWy*r{/qH2{DZ KrQV!kC-o`Q
Q4\!bGpy#[yAZZO6Zkvm666hZcB=@kh4jhZ	$$<[=!Jyc0\?"yO^817c=strvXa2vpBG%F9ii+ M()&JP8hFep&/97m0<kdp)!E[A..W^dE6dZp3|NRdjU{(DAl:nBye}eS*nEg<Z-x_#HIH.EQLL6HcI!PVtD#UI0V/K2t\WSy/;1X%,
	4owDN5e81Pc)0XxOF(M>v'Z8W1c+s3<wOYGWytz{=6y\/xb}%
|AG-!1#`ES8O%UB q\Fjl/[aq];IhZDQTN4ecc}E<PiJE0eT$cHZ[1!`@b1;kn8~{3?1w[	4Vf{c$.>])}Kg=jm`)7`~;xOlYpqB\%WDFYXfeog6>x1w /7cki{G1 [hA->DxpV
m:p(p0j?<%k`@J0I8BAeauu,ChWB	At rBB7DpX3(W`-"qV?&_"M+V<;d;G>NxC(/m8\aN!M_.C|4yt$9b=='raC;org6y!Kq6G'Qe;2PF7~w<u[6:,y("]8"s!PT6XG+(FM&P(
qcQ/*+axXXX`cc5$96^ns=>n6TA{>4$T"OBhlg74nFhyRNfAg+ [S3Nm}o
a0.A6+@Tc9W@8b%^[*`ETp"Xmsv/lZ: V(Xm.6A/^|'-s*e_z@v	G8kqXNtc!^{UlRF$.j3_|c`ssh>>RDJl??'/|@IjQMxa-//v^G~G|fL^pV_}0K2XSVgLJB+*uI%;Zw,<p-GuA{I4|A1T2o?my3|pmR`0
GDIk"D+"m6}hniw`)R &e(J)KxgQV`4:xJ<]x7\9}I$.za2kKKKF#sn[I=#>?|[bccc4xO0a"8<%@:{*/VeIfnt;Y#f/'az[tzXH=Fp^fT32\
ez{=a=.1~igLayu@wR1^2oQ*"6,(OHqc}:KnH7BwIFmyjva/mHHirhW yFV'H[<|{tWaiEI\A&Bjxq28{`{t/FJl%\@(ocYko'F%LJ~?.Y`2CQ _&g.)lB:PYMW"[\ZWP@vt7jf8v+hQUZk%,ybI}iitW6>ZeY/|fOs{O0~:0xFQTF?,pe;`ZXJd'Sw HiEsbd;Zs`Nx[/!(>#"vA<+sp /8b31N<lrJX^\9.3};W9/3X= BQ1KEr%z_k/jP/K{__K/\90-!qWvgReBV`j]ib.*pHTZ\\&"KXnW3Ng":VezYU5ZAUsnKst^C{jU^WNCb{{zN`pGk=e\}RTo+2'4mZT*x/^w'ergU^J4b~y[{_e4EF/`}$$r#b#]'_Y/_"=&-2QV2~Ml}WXsaPp'}U/^e3m(0NX[Za;_?{oHYvXqc!+oXkI?4iZ(}8R!a5O$ 9dYp8jZ~e"!I$F#ndaahDShACJa9}qz"C6@2 (*/(&B!`*/VhsRCzcm1K*G!IvE73I:j/Gfj"yp".phc XiqE6g( V;SD(cJA^`7DCN$]\}`_8.}1_p^m
8779;o1stt#XM8,kQoa2N}i,-}S#HhJ)y?Wx%cad0[<RYk+))$aqq4MY^^*`*@4NJ*ap^!*5H4%HB9,//6NElmmb4M8eYV-mH
pBb/p
B {<2QGjq.??D>d(B	h*YJ{IW^p^aqmNZ<iD
G9GOdEX<7/|{k!s)82cVB6"j	:(2pu)K.+O.y= 1K@PqnIfx	!D8@xxX]]3Au7"x&!fvC$Pw
I
$IB$lmm]vF
-AR	Blja[<$Z;MYXXbz/A*1jhC}U3s F`""3|uBZt R((t :]/-!N(6#l;"XN"q-b9|: pg[pjm?/>(RPQ"xt_#%L{*uQ}6 R[x
\)%r@mEf!`nOo'M&M&[%nW0WoJ
601w::sfaVemooHQ4,]jaeTt:*DEQ;`j+>$?H 0no B+W%^|r0i	,':T'EU)/lnpCuxw$	+(4/F:(ZG4R[ZdgwOxy-a5V%IIX9FMQ'eE5xx%sZ:t^3N#RK5n&a0`_:?G(b*Y8q'Or-9r(
xy'xY__MFCnVy,$(Egy^zRMpS;q1*{V ~x]s;k-}bee-}Q4jU6Z,#Gp= "lmmU.'6kkk<6dF~;w}7ciiiLe9~ssqJsi2(l5<K)<K?Z("1mmQXS>g\ 6WsY>p(rx;$ie
O9MyZ-+~9NA )yaq.E%8y$XbZ.G96F:Sq272I_7
/"looPDNxyA;Z?BnngRR+<x%>s}CPvl+C/fO?_*O?49e&;UJZ  1qEfin+Gpoo?*paP:3(?/kkB0:}3^$8~~Z`}8gm>OcU;LDW~W1Y_2DU.^$NRlkA2G>qI[(QT^|___Wx0Tu%ibidV *uqoh2
GJa<\!q$]H#R/w]nSIr!O{{qVYe(hU
OSi9kKk]<yW}9/)9MLq1hGB/XUcT
Sn\U70Y~=VA4MS>Os0ks4U)Nbn;(vtcC8rs=L`E=J{RPq,,t>zW~~z
*Tiro_>~'~,vt:1,//3?3|k_hbJuF)"1<#chL|*;_HiBRau)z=DhT-W#$I#S>D@kSFh*4@)!6G$?c?-RQPT(}
	''?GessJZ*\~S%i%rn?{9vKPv'?B8htUYSC*0-&ol'Z\<,<
%%&gG.EBw1A2K9f:wuc>6:NY<yL1EHphDJOswur8#pV/WO~|o^dtv??|w}W-8W@A!<`
m>/9OdY1A[<//qDJNS9^F#G$779sx.B#\Jpfuu^;N|SS}sNEu"*K	;\+K!~~CdYFm7AUEV&rHJJq 8Y#/Db	y(*Ck|c|ckR<Ngv@Y@'Eh_g2pgNvz-wD.nvN VHBK""k.$.EuD4Rv*'NvVF?|g`Ttuh<'c;wO~8X]]ZK%e'_bUxGz+++r;Yb4O|}Ct:J*
w=_kN>R~L!9s{gee`*x;kK20^{*Sy~g>v!1I^u7yzZrj~Z%E^{6Iu61E>6jQHBk\S&
FYTeN{1Owgy{J^,KZ
!DnssjPA?MS^>OWo7cX_5N:p8@j{fiirWp&3?3XqnKw~w?3T]:
bO|WbYF}/_k-v/}Ko?KF&E
G>h4iiZT{e vlYnO|UaS~'cq0Q3E=yQ*3j-e5P."#f 	QyicVxxCjDd?{oeWU{TS2'2(! @J766T,-hnS|Vh(|UUdl@2OT[w:SgZT{9zyz    IDAT}"A$" "'WFos7%,Y%'.rPa
8q<`sP_kw HmZNJ\g^oIj',5fh[k	0jmall~2GYjY-  _*w8CF6UT0o};wzuV0<.2
2Ioo/'5kVy;vqSL2/O{l\|lR.'hhu;w}viJ{8A)iW58K)J)O!j}mM"}I8)C$T$	R*$ByRt o7:JL}|t4DgP&6	-`4PR!Cz`kzS -n6RJa~l2fNH_y'uKAZ4g+u66
!{7mcMd?%KGPRV!jZp^m42|h.L;cs[RJ?i9g6Ur9*W_}5=PJTYRJW~:j,2k4r96m=i4f#f,^|8]]j(d	N;4:,nV27e"R;v?d{ 'u P@$I\"H""Av@($7M<#V%*^hMzg9e^/GN)R	L,IZ(D. oIez<"R*2u/


bAhE?ek-`x\zPYj{:(>O}u>ER]v1}z{_<[j57\%K&lU7o_|1/(fIGGj)%7tz*{IbZAs:M}eUX7M\tEx4mj{G(5HXlb\ 8eN%KplJ	?7:;;k3f=O>\p_ycX_2nw~95bn.6d5+J(!Q bddP1Bd1Nbt1jFb"00$ZQ$Ym b Sw=J45)I_??k~\{\r%lE]B-g>
s9|>OX\.$	SL+_
yqr[2o6&]n?x<RdQW^y%Dr}bZ9s&yK={6diVF+tMd 22J:gNetD4zT]*wZ'-P #r9FGG3Q[o;3kRB>z&W8
UY2NGA__:wRw}^1&IRVxbJRb"UODxAR\#i~1}*(DRAX.FC;1
%.?]m+Vf&F.5vj/;wfi9]sGGg2eJ^)er&i{@G,,HZ)BO>W\C=-IP(Yj_XzGnXBLg9A*~h}z!v9Ada:fJ=l-	uoBF6ie)F9\)1|c'RP`5CM~GGGy[lTIFGGcZBG\'{exxZ1:s6\yf/VR|nUk8&weAI_tpKIW`XPCoe8rf-m:R:(IR1{f<u[at8.:,u?-m~|RP.vB?1&)rlK_Gsj^7}"Sy3}?-9J%IBgg'2005\GAooov`8fpppB$=ofew;r9(FJ2&o+/~w?1!z}Bg7Gu+V`dd$h+f3+C__beDZg2}_hl_2W #.in"qxq-#s:	BAJhT0SistO'3(lf1ypAcD %>w1=-xtp$T>+!|	QC I~f={y[ilWM}}yu] x/f)Fk4,^N:	IF,8>=EZ6T[\Rr]waz{{'DtRfy[J)}v*N8a)f$Il$Sd=dULC7V{$dxxFE0&}MXjUT^*(JAB!mxyggjYmQ`eWf|7)!Fjw#4U&u1%)&jSsq}x!%5DfH#qrh\1F]Usa6J>Gw(x]Q81R&z}=h';[+fVYm04M	*YXr(*gni-@,Y+Wl@MA@VV+}L}p2oa/>E)E\UDgzo
 M]s5w}!Yx>730~{+
~:_.fCJ\'[M}p@mrf*6hR+-R0@'!9"
n:_'PvYzT,;2%h!IGH,"TUwA6T)R4#pr[Q@4QK45t|lR,	'|@wN8|3|_vR>=5ylJ):::83]>!DFvgB:XR{]?pr6<<c
GIK:Yj7pafi7*#/S ]v.(a2T6YCey\p]{w~z/}gT V}i/	f^td)c1t0-6b0i:!ygYXt:r0:C(ZjX!NF{yv`yj4fVyU(0\$wtxY;ik={}?pmj*lR@ !]M?	Uyh(RD?R)m.[eH^s5,]C$,pG|]v=bSFM*Dr7p	'pqeMi7FpsI'go]p&cfSP(`d\z10K5kWH
/i8&%M:YB%|lWq)0u&zdVHL+<:
M &C+ck=UuGcLX*P5#1A##L"MV]\3;spdYr$Iod??+Y,"/p%l6? 
[;}?cY=- 5.\c*%h)L[0MSU^e5}Xj(S]]` =Ogwtuue)5;:P{q~)/_%\G	ig>bM>%}QcTXr+W>OGDO[>nEgB?Hi@c
F#tPA&"H&RD=2g:vOanbUxB!rs"#;y`^[(BYS5 (8C$
I.=dq2H&nw:: Z1B7]YibP.s,7P(&LrZs)}TQOmhMF(LFJ@a{kQ6eB<F)8*T*{0Sf2<<+|~97EkKYMO?4W]uUse4MnrRZfQCy!(R!
;kl1l3IL;;;[T*\ve}M;I*"<X_`]7oxgT*AdH0d d;A'/lPQFPF&%Hh68*<8FIF$U
 x&'o^I;iBu &ah0n1d0#*Jj]gwX!!I #H01I$((FN!e@E Bh(CD*% GcD)|7q( \f5mz1J-A}3Fk%_?1KNDgrEjcF, }_}MY@VZk@kp}tQ(rB##[}NWe=)8b{,aGm=WlG\f,0zKxA](Z$c{bK[_|odd(Mzoi}\x_}t::~!R8Nu2"{E8>=$;+5=cI/0pR$F{G Bh`L]0aR+<mv}|-o!%TQhDh%FH(8A_IJ2D1	APr"n$%.DJ`Z\6`
ZTiiBP-Y@lo|f3sdHA|#,\0LkwTky{VDQD C*aHlRVIzh$I0ZRTT*4vlIb("B I}V'/PTP%Hyw>(gSkRJ-[__SeMr1Olomche,FI+8m'i)x"ks'xXn{RZ+{HEaYG R)q;URXt@DSQ@mrBB5RAK"Ls*-Fr<[Wm;rhy
"2P)ITy=6DB'vj6V+!tdBC^caNuHTJ5%")P";h!Hi"ua :Ttp)O}$~HJ)	SN9}Ctwwd}r:Mlxu{o6%IJah4(lYPP<mMZlv
&RP`%Jz$hTa]
z;N:]n0.o{jX5(t6</Za<brZIn\LdLWlY=<c\iqGss2}tNJGGGk~yXbKVy,X_m(JYtw% ZgR
aT(,o0)&4mLI!:DBMrIDs$ffd!8~F/Kf(P%QM$DMN*$M:;VO-I]8FkECJH
cb)i8$z@ieFHNF"IkAA}Efv-r)SuH]R/=,+HnE[E<\wuCJznAr\tV"M_1KW.Dx#RHI!2$RIqLEZ,fkt=0d k_n0T~4Y&;aPkF6c4:D;|]s=pM7GK9c3gbi-F(js1\xYi)[cm_:2{= KGBHDZO3l?5LP$wAaB1HGPmjvet#qXPn#Rtl0/nqixbpGGhcC3")R	!PXf*Sy.X i}H2i###1<<;v|r?S[f$c-[&MP7KSq/fB0Ab:lmN&	A01!DHTDEfLh&N~o?KGGoVs9k$^6Tu	By>[tnY3fnfI&@+RiZM,A#g?s=Jgg'-ce},YuI3ssGr}esl`3#z=sEr/9X	{Vn M )ML	ZVQXQhl~}<=G-4s'"r$%J$	i=5v3yy>NZf*5NKR!Lk0B@&D#b21B=t2>AI-_7Ygl6\;f(KRz b	!ewh{>lzzz2HF6hXXZ'KeyG\|>OOOMC*Ta5t=aW/=9`l/#h~zhl*Zk2J)>3l\{5L$ZMv6}QtI4ai#1K(pZRv Tc1>MSX,288=?Fq6q    IDATOoo=KiA@>]L>Yfe4~e^I/c0~g-8?BZ1H NY$xh&H-	&$e\4jHT\E5F*<]s^Nr)Rp:42(A So#qlz.0&cqMqKOt#:D AAjh@D&i wlffxllmg"(>>~E
|g-<#=s1[n16mhx0X(D^>R.3)%S)
!M&Jt+h$1%E0]h=IGsxAhV(u/_38cskAca\~\~T_f`szhM}R4mo[oeYP(Lh4}Ib<i:B)Eww7q>X'h6mUW]5!j'LcU4MN>d,XmPl=foxZf[ Y( /:4Pp0~	iT$(cPhbpqJ#8ejU DiUd+.6!B
/Gdar'cMyn0'{S(jC	4NB| +97]}'TP2CTg3%b&&B i>uM!bl+`!1!7R5Fe|gM,_3mAV<73[&6k>CO=#Nn'h3}}}8I%-JTU6o]c0J8.!)71N9SGqnv(w0Q-K~+?x-Z4!i^Fw5k|=hvc'Zzf3d&,dnP-oy1itLgk-s}<sYth5l@WWzh4b	BEni`jf/z3&|5vH~[@K(+cLBWJ01)]$H:BIR0rh[bBV4?<Ua,2
4CD'
4$~Z<|17tarv"
T)%NCzH"J%L,Nyk~AF2sMsu%Xqrwi60+Xk	!z*we3hB
gg\zL6FwIvR\yE^aagv2J6f%#C9T7IF)v+^R\|r)-jxcYa.t"Kg$&I/O|,X 33g??]';t&9, 6 wf!/d3`u4RE0$,YB\&?N&@QR^#d_ rcLo[V- AuD 1 I
&hrc2"4UHZ'b$	979A#e{8afGM-xJ.xF$12(b(vsm<uRj=cg2]0:H!1$Kh&Pji F&)j?kZ"`,]O<U7Ch`U%0>+NVEY=;3gr-y|Eqgw:*s8yun&v} &G'LpL+t dzX:'NFFFWu]IjYDy}'|8.n:q-ZHX l2V?ERP`M=y[kF$MZqS}vccccctuuu[&~KQJd>3Zr65{xEf
"e_5	x vRthN I.ABR*4f@Qx8N';I&&F4:DKrDtBH
%I+" ngOxt[@pu!9BIbD%59pNGIC'P	A'Qh'5%D0,Qi6`DO~M6n^s={h%pz}{ ^gN:sO5>S(`f;qtt^qn& Cq*w$I12sz&4&!'=RhJ7a uA\\vetuueHg^ws5g=-ttt0229wpTOk3!:5y6nP(/g
S{dIR,?o?Oy{X,266)S>./^Esvq)g}Wg{8ZvZ
BF'qMbHWFe/ms\:|$qr4I
MT"D)HiPTd#P 0QD'4a5"mu;NNzeF(
-"IbJpZcJ.r	$ASkT&
bj V>@M.Q7IbAk'%	j1Lq%uV+kMji?66-.\GA^m:^8N?,~L[nKf}Qy3W\qJZP"W3pbTPAFB_7ua	Go{<<n.];	$e/\SO=1kOV)~wWVAkif"GuGuTx Z3DQBWWW,bSQ1!]"|3'c,}H)98gz32q2j5ogQ~8'ceFggA[?{1`&@7Hmv{,ZpH*O-{)P/R	G+S0(ID4lP
c:XK1B.[LWB# {e2"O.wmO;xj,aQAbT;4Nq1DP%A9'_][$ePzEH$/I)I"\AgJI|GV|dIU~gy)Sh4(%Kuo'V;X;]+eU(};W^y%{/#BG1ON3X099hFY?]w6m",l_0Yh0' +
vu|lME$IL7Y>a5Y
Rm g?&>R)kd?HaM[G+sUrlo1SdHfhC8&L?&E*oKE\=aY~j{>b(_$08V(C'rUha	iqCfqdT8)J8nX:Tb_`syrTqg=nlw|dG)LZJIpO+e#|y^zCG+D aV#e/Fx&`ppnl38(JvI4J[>f[a73RnAs?)>q
A1e-8nN',8AFU.^&dy<S{G?ku(CCC3o_?i7q#qe@$&ELiIk [\\y)gZXn]F>p;J
"{>d3G~/~	g	1/+2WLRd`_JHdmQ4JX*Hq"Jih,NB+%$ZQRxNHQ+zbAcrt;7i'T\81Be j6cb#]zezt,|tEOL
cHs*LIbC<`Pe{OoaaBmv`&i|((yrK(/kTcg=GPSn?9Apr2}.xuVx]\s5~ FG0",)+a#I v'TEsC<i;|o
r9KFQ-I'gE~V.[-XfMWe,tuuqm>94BZ,J*a"y(\WqOO\zpqes]U+(%)jeO?W\A`e,Z(kDh^}'?1?O3f~gv@yfYR)! JMQ$aOD@K"J9
 -i4I\hp\lgGgl=M}13ph041
A9{1OM<1R%|nL&c5#)y6565w3[):yGs?0
hX('wSPila	Fts	F"/u*D&??:i1Z4fUl8sm\ X|9o9q>ndSrl)|nk-=rL.j r<ZgJk$	FGGY!YfMR`uT!j=.Z3hVw2O$BQ"zl`O3s4*U)lkEgHQ9KOO7_~9gcGv]Kk,]X`f=DQa$	u]FFFm<o	q[u31}X	02e
6ls~Kc"1-Ff_,yfznVL//rc{$I-}urdf=2c/djkel'&Ef;_TG1}0ddA#]I) P5Liy6p\0Ba!p	-	&9CMryfdQ17OD%1%\&l{v'wCfYXMwT4pD't
jm;yt+hf|ta0XL{$/.41-K`hh)EQ: ^Gvjv
vW(J[`lJk|?6GM!TuqC>_dM\q?//Yx1Fl9j5Zm0l22Ray2)0M^	fE-DQ@) ! r$-ap]/Z!/^EtZr:&uhm%y?XvMUJ))
w}lN;;9s0mT~Z'pwb
Zsl\0M?.F1M6([Z##jpgpYg1sL)JYT*n_sw{nM-b
DfK\k@uFjmE''`p@K`T>M2~T
A=H	"IAMta{e\	B-APZ	CJF#Gzx!AVbc`3@:9Q3-KWQf6PMm,H#pE[y*k#r|:QnMN
 frA}TO<fRV_>z	(2(> _(l#tX{]*F~>Vf13gOX,fQzJ 'dT*l-m@P$6cJ 
"RTuhSa&s[nX,1'\.n:|q	ms;-[y3wq,cae#o:fg}WaLR_se=u{	3ZYz}Yx	~pM6r9RqFbu]3222iOagEW{Gx;&@MV+cRc/uKe b`4j0{5	fVqRQI$2o).AhhV(*,a#;TCKKj<:A904i:*s^I^'fhIYNaD0'}<a^r9v~	3hWCaw{{$U@,+:v@Yg]2EcL6km``;#;BnhVF[s]Lb_%z38:sC85qX~@;9'N^|Cy37n@qox S	f&<)J f{LJmdd$Lv5< <ncLBh6}Sb4Y6csz5FGG'Rf?iY s1~g4_RJGJ(kg/d''~kzRb p"I SJ`:hH{_,q  HDS6IQQEX7=z	)_=8Y K1KCRH\D @bkwgNuv+H2:++++<F1A vXmFxkO!/%PcW)XFUm1>'a/v5r!342b4<iBf6]ccIIKmy,;nb ;cYdd( nLU;4q+)4MWXD2u(&nf,    IDATsU&&(32Je9*qNu.{!ri8e.%$3w}+;K$$(.FLQ.)H~Hlqbq3U1X[[;v")(~[e 2 +fA8h_=r1f*3 2"RQdvgf!CO>4d9{s@g0D34@cJP%
r0f 2ZW@S92ze\>WnW7`4*Es %G.p<x{ F^h@+5H)Vxctc0!CKb,qTCv0B+j"qY?,RWYL%H
mJ"&yYF]"*FA98lsPBWBc@ij{{e!KhEQ{R)iZw),QeWY$8Iq0L:I[H{2O<{7c8Mmi\Fn<_H9Vpamc(c^NB#fRDt5'nbj]giB7F9m2U;sX"cxt;4e-U+"VPmO[g)3XA&a4P0U`YP;hAyPyPVLD
YeQ dqd$6J]tLf}[IF!x%IpC0	)Bo@cC<4ih+42maq75pz^SD
	Eu4uv\:EFKEh"mmmuA.mt2%/jK,E
%`.,iBK>B%D7* ^719R`ivQMJV2@J>ETy_MGtGf
`y!N\e22J3e?631f/JV
Z<s9S11*+(ck@h@ 5j
 =p;	16Y}Wj]4!(br{ZL}P0c)!C$M<Y$(ViK@e+)n9+CU"3pY<`[Y(Pu=#N%D$c '.*${#zO~i?^J/`$eXd/!G$s]Eh#	O=u#>&yv3 ""LRX^]87F?IDWV\z!3}r<UJ]jVV?h^Q2*;H{ff>0gwmy  m	TNCh!e-1Q
\]ZCS{L.n\_UXcV\Ua
8=~')Co'nOx326?Vsw)0
B`+Nwc<&b{%bJvy4
Ik}Yc5<G$eq5>x<*VWWE4Z8`r(Tgl+#"b4dI^YcZHqdIRF/^c)(#d!)[I_bd/X@e~fxt|*e~dlsFs]0R*gx>/^Z]]>C-f<?c^zmoG;{{v(:f6Wx^Lrs[=* nBW a#3nB,xJ!~c}W=	]'
+sU E`L&.c"L*=PPLe2Uas0Py8`lcfU$Yd*&W?	BI$3A{z+R <4\
}X:O0 y(ILI?Hv;(!|RL'AL (2nDF=;K)D"^z/~/777.^x9w0c?V?yz4F)+W}^"#0`[1O?!:<<u0FLVLexPMd<O;u:K4enVT!7	~}XB1\{n$]7G=8}oe8D,9&<`jb[7frX
QT3(Iy^c(
(/w+bQ5SOAk-W+"faQko6|;9_CsOe_Nk"RG4\nUmR\H~f /KQ? cHDsdDwiT*R85vQFmW+|.Q|pFc;q9M&>n xP6lP:GFpB
#3!G(OR{b.8Z{O;p}p;MQWM}en|!t%EUn8%Fvr TRo}?qKomlro #mi(Cs_|qh:`&qD Gy&zMSIY)jIAB 4 r4QC`0%~kq	o=$G{6vg,Pv
Pp4;oNLd}dLh_ dvFXBz88C10=X&YkqG~igY\AM^xzA% nL3nY^xog/6&Ms('{ |]t<_#"7}KL`T;>akb'4iG# p849U<@ItSn?b]IS[bZX d`Lp;n5ofE5A:b T[dYKlEp9O(ULyz#z<oLDf7CQxe
N#g-!H/wZ/cB7	-8{Rm([f5`3.7;[)u?z 3jM4."59
 ;t2M!0`
 1)EH[#tpd{$3ILDpJCj"QwvCPzNu\. QH`#\;!0[Iw??!5EoF}KYK\zE	;$Lx}oix@y<yO8We*YhZ{ s;]v5lU:v1; k$^`]Z 5sDBn;>N''ohFWyH3DJb"x"Z&ji,Z2!?#8CEp4F$j7[f0bY RaBnx/EqR_L$|E <LnEes"7O'(cy2&|y3HVVVfRjP~L-   T <VyK 2 f$\e%"Z11@\hQ#HkiUPC:2c mPb9GqEG<,UDZ/%uu#( #bGIp[pPr[U)e 	 G9_fn;gK;6Bj>fgV	e	&b{xDJ*'uaJqKNPj_ca`"G`{X [|f&GGSZW7"~Bbd#WZ}`rp*, ZKK
D]b@~+n n@H1T
U.a]3j&^L87wv&b/-}RVc.L+?'yEgp*f{R4>q|t OW.Y -)?
%)+v`sX\Q je3(f^0sO4&GmUlL/s)QWiQHVK~c2ZACR|)'$H[c}{.V;/OL				g^~!"[f"E}2c'C$A{YDjm;4
88-x"rY,-e%Je$SzRWk9yC5;[k"Dtq})"4t<#QR$uCl;Bdf				'foT*!36}3CZ;9!2.f>KK[uS~)Y1IO#xoK6@1qb	!'bBBB^XxB}SC'Hbv`eb/CqRZ/"2Twskt				grJ0,J!P:aD,bg>QQ{b/qGfeI Kr2=XEdODp>e VbOFKYz3H+!!!]cLPhn1`U 				g	0A#"S9H-IT><,MsO@ Nf6;Pg3%>eODmEf*WGRKp
WngUO.!!kCXFf@Ysl	RM#bL &R^
zZwe1a,			ff"' 
\x(bf0"D1]K T9ZABBBBfnQ{dtRAZ 5\cj,%3/Z6\1'	Q.2Xt4phMFqcCqp$B5h}c-zm& ("L&Z"l$d4;QF/xFm8O9/5}<#E9Ojy1@# @F)'Os+$m\AH B/D!LHHR*4}b54{"EdbgDY\tcQJMTum|{sZkDhX[.@JfRa}2f
4fDX=iB$nct/3@Nsf6 H)%"C;E)zff6HM_@,l0s%!Ck6ZUv[Nrz ] cRJv[Q5MSEXVJr6B}us2~O*HguTG].uTH\J)XkaI-)XB!_>fsM\q!ZxRp%
T:cymS9yGVD	^('5E(+W,KEV@&Zep+33VVVN'%$$|E+lll`2`}}/^&9Y{<GGeL{?v 8%2s3.jr`0 Rjb?#~IH}V)Yy%]| o&UUEJ8uxzvG,pon@f{{{(Z6o3_'0{~ovY1t/$H}QQ`xJO:RgWp<_'x{Z5GZy9}( ,+dY{n/])mchZL<ci,$3tec"TZLMTZGvaxd2xm8Z9Dx 2[n`6C{/@lwwdFeyJQ5ou&ZJgm`n
?3uAgZ?&1`C5np"0+1>hIblli7Xph:luP	|nKR1GFm7qaAoTg(ZhcCc~g^3,NL5=3]<{=,ss~rD6 ksN5%"sVs)vXFe|>DkMDq QbF2cfFa g"I6\h{7MV#pTZj#'}>:cB2	nYs0$s=&7&m18-C-8g$D~	~ND<[mk*_JcBo{{ig1u(9}q~}k)nWM[5{=[g[ReYf0(Zs{>7F_ )E   PZk
71i$RwR7r|ydO)e6
ab"f-1 s!-8tg4aLh]YZOq#\%9M$o|f=w1A.
 88 iJ
G|Ea!cQ-ZNJX'98[DXu[YtQ	c" X;,9yLfcsz2!1kkm<J)7Jg"c*c@G4"dby"VJ
.mxMf/]" x4Fq[,^L P.'0e/LjfO{7NvH}\t|_;">:@^W!+w	+.!eacP4 hWVjbg{=mhS]KP(W;w>XG~kk:5MZ  -IDAT[w "lIEjD nq]!T}oJx8z dk~~!2oO_K.s?]s[>3m!p%py[z%w>K&A][UE6O\De8^BaUmHXG	 *

AQ iW_}U?A9~Ou]YM4MUUy[""2 {{`}\)k}'_[[s[[wY$"*F yDY&IxxI|Obu0]G*9-}/s9~l[_]ayN	:I)6^7o]SMYV'+d22@P+wY4 QQ"h&Yc"wKO}?&q.8DX5'.,q]7;x[kN}b"y{; M4"5M5xo+w^R9^gw{dv,l%QQ[/K'+?Z}{@)mFBBBB; 1f?WUhss~'7n\/_nnn+xs y+ 1/o8wI9L6o5L&B.FLHHHA@  p ^;~U"\][[VuY]7 |`Df0pY2 8/#%LHHHH80eef~Z^`WVVx<li-LG%-
Sf?))b[)!!!!k
!l a'=a,!!!!aTycYG9/!!!!@[    IENDB`     PhotoEditor_Re_Edit_Data{"originalPath":"\/data\/sec\/photoeditor\/0\/storage\/emulated\/0\/Nexusbeta\/static\/img\/logo_dark.png","clipInfoValue":"{\"mCenterX\":0.5305322408676147,\"mCenterY\":0.5393803119659424,\"mWidth\":0.5910940766334534,\"mHeight\":0.29600024223327637,\"mRotation\":0,\"mRotate\":0,\"mHFlip\":0,\"mVFlip\":0,\"mRotationEffect\":0,\"mRotateEffect\":0,\"mHFlipEffect\":0,\"mVFlipEffect\":0}","toneValue":"{\"brightness\":100,\"exposure\":100,\"contrast\":100,\"saturation\":100,\"hue\":100,\"wbMode\":-1,\"wbTemperature\":100,\"tint\":100,\"shadow\":100,\"highlight\":100}","effectValue":"{\"filterIndication\":4097,\"filterType\":0,\"alphaValue\":100}","isBlending":true,"isNotReEdit":false,"sepVersion":"120100","reSize":4,"rotation":1,"adjustmentValue":"{\"mCropState\":131076}","isApplyShapeCorrection":false}     Original_Path_Hash_Keyaedacb789adc8e59bc3438ac9c1fbb28510305f9fdb4db79fcd816f6805a7d2e/48366SEFHj          J    d   d   $   SEFT-e 

===== static/img/logo.svg =====
<svg width="256" height="256" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="nexusGradient" x1="0" y1="0" x2="256" y2="256" gradientUnits="userSpaceOnUse">
      <stop stop-color="#4F46E5"/>
      <stop offset="1" stop-color="#3B82F6"/>
    </linearGradient>
  </defs>
  <rect width="256" height="256" rx="48" fill="#F3F4F6"/>
  <path d="M64 192V64H88L168 152V64H192V192H168L88 104V192H64Z" fill="url(#nexusGradient)"/>
  <circle cx="88" cy="104" r="12" fill="#FFFFFF"/>
  <circle cx="168" cy="152" r="12" fill="#FFFFFF"/>
  <circle cx="64" cy="64" r="8" fill="#4F46E5"/>
  <circle cx="192" cy="192" r="8" fill="#4F46E5"/>
</svg>-e 

===== static/img/placeholders/tc_club_default_avatar.png =====
-e 

===== static/img/placeholders/asset_default.svg =====
<svg width="500" height="300" viewBox="0 0 500 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="500" height="300" rx="12" fill="#E5E7EB"/>
<path d="M220.24 200L250 150.48L279.76 200H220.24Z" fill="#9CA3AF"/>
<path d="M150 200H200L250 100L300 200H350L250 50L150 200Z" fill="#D1D5DB"/>
<rect x="238" y="210" width="24" height="4" rx="2" fill="#9CA3AF"/>
</svg>-e 

===== static/img/placeholders/asset_default.png =====
-e 

===== static/img/placeholders/channel_default_avatar.png =====
-e 

===== static/img/placeholders/group_default_avatar.png =====
-e 

===== static/img/placeholders/user_avatar_default.png =====
 JFIF  H H   C 


		
%# , #&')*)-0-(0%()( C



((((((((((((((((((((((((((((((((((((((((((((((((((( "                                 H       0 2d{ox.w 0                 g;}sO+b{,Co0K+rsUL~z\5yuC&:             !jd}6Uv@cQ+W4usG}sTNkO'#8x|jn9]i9           d{#<\RZT8jFz4g5[#Z~cCw{c+zk]`,g!:GK:QI         eCvZiF);!BV*x    c'']J}GzxhU_+       !2Yz#vj]~qt#      hRuI=*?M{JUtLeiq      3rc]W?V19>t.y&wCx=L8<Ny`s${~%8@ dW#JpWoGA}+>$c4     &=cYYI
9tDRf_@ m'b~-*175]|/Ty{Tw=|Je)0  ~l59\ZpHl    Wj^nvv	z 3%'d-j^{']YwW7ugm~qvV5Gdh {,VKVV    t7a~s:c8d  wq6Ll,39}L R=y5b^  wo^-#D9  q#1f	;>B%^q< q%4RW:x=8N+hsG+{84# #l,:d_N+<Q:XH   2tNDiPwvUA'Nw  qTw
F*bV   =w3"Ntn^  ^DbwW;,TTtniqJ  XIOCOlf\w*?12qy 'yum5kn!   	)|uBMln^  nV?UhRAXkc/@  >+.]m 8h+Y.4
,	cis ^d{9v
E<wgVR   zsX`|gX 77o\6r^vv}<> q%75UUNm c&dtL\{[SW`96  gX7z%[6;c8@ yS9z*
:z4c`y  wV%)_;*;UQU4Oguj>sutTnIUh^XS   2;8nLf`g>j:  gn9emeOS>DsHGi`E   8z=-Umiiy>wVwX_Q]{FFut   OqNx,},@ .b~?s^i}_V   qC%k=7k[iy<//=+{5,`s&   3Wg/We`  8*?BJZAA:  e$qO?	s M{/d,:_=!RZ!Rye  =sS[5*Xa$(\)   g=LBYt^RP.tcx2}Z?OXwS'y-~*<)v.J#/%?79-l<TD4TX27imc35Z2;'H"  do^l6eH=iV #/F6fw5"4A4FI%&@z;Ek}lN4{d}/:#s/e)v"	''G   d]pQoi!nU]nS7-
\{8    8+N0Ze7Bt}'*uk.g,    \}6)<wMCX_|f       O]9~V-CBb>]	9azaO2:     3"7MlwNVdb,xK?`        &{{&nTWcdEpz      ^vf=F%{Y      8hQ\        2HUVJiQ;~;8UtXh\usXg    aO}rHhxlOq}	         g|Od4ol>mrVoMiR#6zrrvO|JuY3Bbgvne#           ]uueu<!czt#.^qMs+mC8%9-]@             [5;Esml{g ~,^|I0~9P/7R`s                 s{x1z :                                                                                        /      0!1@P #24$3"%5`   :dN:NEY
!Ghv*;Dk?rUETUD(?Ms}5oTJQeQ+&
e:C]N'et)e5_LEYEZ~"((I:lcIdZwIi;4EN{4dHJ,,B.+X:.YKIi-;wHi!ZU0rJbfV&?JXW3Q5{YZM|}D0JJ0j
b#7\xbW(-baa3&f62r	a71b*(L=Nu.X5t0ula.-rg0CQ/;bP8k\z/1^?&+ql)saWFqlWATC*K/Q.:6xB.Hv]XaksN:dK`pg'V9AT58F6rXks"VB%GhYjy)qw~MvErlw6hOUC[/e@{sy(*qh^7ue	YeYuxqWUZL7kfe~*6Fe[*-b%6+9xv}(P`kc'Uzc(ZxqW1_e7hjZ8j*URg5+[ vz+6i-;tiZ7bPqU\d7e8uD:lOk0;?^Y;4
0]L7m$U1lFq>hQ55\'mgXdUD}KP6^0]fWe.lj{;nK:uvo#METs,6]\u:gVoO\Cc[SMX]r,2|j0idwa@	d5y+2=|J64lQt-}6~X$"m!Z}|KTt'6iqXn;tyU^Vytlt%}"sV2&M::{&EeKwDIY<wR&M:sstFo}/T) x"&-n`Wyk:yR$tOd_L3;OtLCl#"LGQoT&mtx0 }6|2k=Li?zHAiK_MTs^c{"d:kUSHdHW|F_MOq%'6ac+6tCS{PO}+INU;]6^#At&hty .'tS5=\U^];{c.%gD,,]85UM69n6 gL?Q?^uU:1\MYD2F6n2:DP:EOtK`7E?$jD>ezGcQU{.ZHx^0[QU\^s?s>7)%Y]`_at"$#c
Hi;t-tNLEE'A;gl:$N;d}YY=3LH
!D(B;GhTJQ*%D_	0al6K{?j`zJQY34OoXve;zkkri&WJ(,<TE:s0GO2&M#"JwuF**R~<~:mr.31g3-%tCNgL9mN^yz,Sd:Fr&+L./WTmI%QEVb7 & L?-%ZKIi;tCHi!0zHcdumM]eMxD\q6GXMe+_JXuL/gYY:uI$0aVhvs-rb,x *|~N'U|tmF]E,]m"liva79=D0
\v>w2J j<i|&lj2"{hZaa.,_[`&YAtCM9SXmV~&]hZo]Q%.-jg6aYSl6JS,2_er"9S[%s3 N	e%gU\fBm?9eq9Vnr.6nOqW5;#i5B#UVcbr%~:-kkzlgXZ85U]696]]JIzr1eMx5EXL&"T.^]me`S!WYuYe|X%Qeb]r-&[1&cM]eYg*UeQehbjqcQ`?>
0M_^]7(>.!eTUETUfg7"ngQQ5vQ}~>Mr0VYEJQ;GhvQ
!ETUEWs&2ifDava?0J4x}bp2M Tv
;Gh2X}lx{g]M?%nQZU4[M-&u-VI]NO?jm])kyMhC	afifa6r!0wN*cbY%afmN!4wN%tZKrruGTRrs  ,       1 !"02A#@QBRaq` ?eF~rDHLH\C#
VlhM5L<S5bn-3$rr-phFrDcD>FnBj_am3+W;(\'APdg(<2kmc
#VUYN%?]K''"SO:\%zGQ+KKii	<2&[7'^J,tnvvG- &b%YYQuz^PE2\u1l6}%R\1.uv{!-KjCr$z=RgE}?nSVEYA2<UXD7r*ZH.^),M<y]3YCG2} N=WGl]{z]w)]Y>#r{oWpY{
U(KOX%RrCv~lKG5KY$%Vetf
fdKVlGST<HM^/;<u;=;H}Vm?"_ff6rc{D,uYeIf
0%Cd{E]|LM ]YCO~\H+S3Hh<zQ^J/+rH[d4n|  a43Dnqx[Y-Ze'YnVJoGc(U[PJ9(t!sDd-qxd,_a(|2C2,2V;%!S(HQKqL	Pu3wDak%?O)(*E_Qi{McNjCN<iH{1^2$psyd#zlqP*;K-r;r1v<iPyFn)"~D2c1mA+ON"Z3F}VJ;z9hvqL=#i2t&Jr[ fyfP[#T
!J_mphHp*1x0   /        !1"02#AQ3@Ba$qC` ?X%a*IMD)9Y,Y,_iDB?41)Y0]zM
|,0,O%o"67lINZ#GN.Q]dy35)hM!2f2A(J SS|enuIN5KRJ2kTu*Yjtms 5O|JZb
	E"*&'*}!!F@B-#K]AQ~SQgF	Fa=a3vc
tM	rd`x1uyXg p	a*`UL?vir!j6j{0rr;YF6	Y Idn&JJB	4\ZEAK \h.S=gwTO$-PMXIoRe'CUGqtuO#w`nntJpEa'd@b	2-H:'UU0H/#*W\(va
-TQ29:Px9 * V5(wSju~5fRTO_pC1_LnP7Jjg(}u0ZXc0B,'M<WOw7N7:RSr(O]4RCg!dDioJ\^J_|QT[
QcPT{aEg%C%A6,=rnUEB&|Z?VuJn,s>@YGRBmH<}ouH
JMOVVtCo4!%6J24#LB0F()Tp:M$vX\%
vvra}G}0r76'rLZG6r2Jm6*	Ppb>+P&B\ s!c8NN(P(U,ov
Jpv"-R$akL+D!wB#'\0X'!6f,u3vMYJ]Dbw%NGb,SNCl]eFnTT'8';v6V|B~Ra)gn|>`9FF-O~#l(-|e.Q@.Sf6jRb&rl%jZGdFJu+>-+cn%.-QT,Qg(F&ISF"YYnB)e"^K5mM~MU!wYGRZRlVTn+Nkl^c{yb3(IUdM g!66
VTS%w*\   A 
	     !1@A"Qa#023BPRqbr $Csdp  ? M`	Dc_Ym
Qz	4>p	t|1RdZQ78WRXLI@6&iT4 ]*yNVit%Je+sFH*4 b	M]lU"x# 3#4@EgVT~)vwMV8["b9S.KCPJ)UChhrJ an6J)1x=') Z){AL `QZ7pK6}'ga)B}Vd iR`gb5$X'ZC8I>4JJ0[Whm	%DE'XK6(rA
J52egJKx z08+dgtjtGMDqC -"8 KM1u]
qy4T$.YV?UKG=nBjplg14XQfG85+E6P[J=Ajpf,m+,<d%]$bscadXKqnGu\!
ZW.hQTrQZ2=2``s<k b.[zRzX}2E
#sk`h?G&}d*7M }0*N` P6+,1_l6q[%'Cj3G	Mm9`h4Dl*lr>C+m!=P`S;*J+	imv<| \myY(@UR' qjZl4EBUR=P-"tM/T@1h\-LgXsxM']K4%$8!BGa--,..JRriy)iR REj#1 Vcw1 1hJ=c<	E
UcMCp=LBwVgQVV>f~}Y@E\06e%h	8x^E9F@M;wd@<F=GL{>L<l"vF|0)HFP'n	:!Wi*;^~6("E"7D3IKQlMH`"};+<60Hq7T'WnBVR \R`2m@|W:6j
|y:v#G=
&~Q^C>q3~k);-!IJ2P7iM!rR/2P@/quTm~J rnPWKs3i_6)$ZUDn<1L +&N{?i9+<:vm }n1$L4>}h0lL[6<NFnbzl
UM*TBy85vUO'
J/Dr%Fj9tn%_(l1kn=FT-7ubA+61a*JbBx(h@oZ`&6n=iv$Zup)>v 	QLI-@BgzbDHj4-d;m+M%qoW%]gqzARs`@78+8]MS";x =d([DTyEzz16|F
YaNQ:"H:4nl$%8\9-1H*'dj'K~15$OiM
);s p2U4cV !=(%4'R6-y'	rV}({ YeFj"(D ,      !1aAQ0q@P `  ?! $K dcP,:,`0BCMc
	n D ^6f L<EiKI8i'j0Mt4)>L/X ,;48{5)MvI]QrVH#6I}d9:U_\& PsTqe;2{A5s2!^DpB.$#?Uxgwn]me2A2Dc!SK$%-O1[~Ha!2Ym
R*'5kFC9KF3X_gag$jHuJA>]g	U-ZyL-K(Bu)2l<ehI9O"Rq
y?
f}AJ(5M92A8#x
j7%z[Y
\E;.,)5JIFvyCsu^z(Ie`aSu@MQSZ}Ry;a(\I.A8['P"v -!!;{'4n	h~Q+n;Ddbo:gr6gT k6^q-]"*ht 2/3-0*6-!]9&8Q9,TDfYTykO3}$UMH}=GvHcZCOgIz
-$|"D9QM;/i5DY*&3eukr@NI)m vp\#	Yd/W\FK.omSSs>YLTG)CFe0diq-? Yha(X'+oV3v-I]$Z,*![ `{iITtF-kFJvIau_6qA8nD/O|KradZ/?FjT&}d~uzF:iJ!lQTpE$uHX~Q_AK	N-MRO7xzVR,] e.e/>AH3D>]
-iK	3l_(n1db9X"%S}'KN!h`9#HB7UK$$rN
1O|ZS7PC]MZ`*&|(t\:d-tH,m] XX6$|z`$YJ7[()IUecE)y9$m7pmw#ywWa|q}6YLI/UX$H0Uqx{ttTUL^Eq,(HKToNhye;
tW+a2pwe"I`k*/#6	OuK`^).~kuv.m;eA{+DuQM(E.alr.]C7FXk4]^hKtD{Qj&R>$DM_}!tc`r?iqMn`*F( e`BwAT,	uR_.=U{;iqMaPC2D$%JZ:GW-B&&oX]$}d,-v7~)[BBQ*SaRK$J1LByeR8~i8#J^=fm->QwaUPX;3iM\r%hy~hz*u'wOEb\YVU1rh#||2LM{R2NU6'Q5g/:	ahV-	$j/ICrC7`-XAm
LRM\XY8MFC0wkn|
H&xE5}R=Y+Uoxt0L,EI1j	`ojqJJq!h5; M&=*1,_F;iV1COS,W H^zdj%9~!E(4Ha0hRKw"#$"T l?D#$G9y"M3JhQL=
ALBq`mFUa(_%hl_&#?c&)="te/"sr: ~Z6!4j2Vj;7;\\1U""	i	PS&:`rz=Las9kRQ_Z6X7	] j"YIX[ T#*]qK*qfvZZ^J+g2C;Qr[UXScm0y.1&gH,`r5B42`}I|L^q@_"z%$XdNu{w1ATEGESkYC)h,$Y.DLc. dSSp4m%/B
r~M xH`B4Cb
NX	8Nt 7uTOq2"2Q92w! e\bXA e63'$E"=j*Ob<<2dr{5SHI5</Tbfc($yGTZUZW~D$])Es
)^;8T%{
EWCfOb	l6zz=~AB0)#I*MT#/8Tz6K0v}y'{R>)\2aI_NMK%5jSJ;;1	7d)/T`M>[?i[\Um9N.87*vI5qYPH-/"pSJF#t&sc :7*HI_FWnmTSRn_E!,V8NzEw!\In@
;	s^Lq9.Iwa7%N
Q1Ll+bY2Pq>8CSid(LDz(9D2^ xG	Z{UZZsWpV6+m+fJDQg^7{80i1Kz k}7g}<#> 4f-%  
p}:b0F'X`)KY7>D$y9zM C\Lt)l4)uGrVB46(/;t=v["vhUA/jv$*c&Q26)(PLeG(7r
-#|3]rqzP:$9z(%&R**fe}7i1h3;?.nKE39d?!Twq;Y6H"zL&H      <<<# <<<<<<r&<<<<(~vZ\<<<<4,p<<<bJC<hR<<h<<
n~-O<<(38<<{U<o-#r<Nnp|<?98Y?<z{O<<r{[<V&<5<<}<W<o<(,(H3<1C<hS<<D<X?<;<P<*5I<=<<FO<>d<<+z|+4<
h@<?;<<[QgZ+<&f%b<=[?8<1</<Q0^<J<(61l) l81<I'7}t!A9Zf<< a8<,7v.<  <<<Nj<<C|<<<d<<<bl8<<F<<4un<,&<<<L<<<<	cg<<<<<R[4<<<<<<b<<<<<<<<<<<<<<<<<<<<<<<<<<<<< $        !1 A0Qa@q` ?I	2/A	4WL{%}%_@Rtbm{CB jKPOJ8@mBYE)bXWbvAqI=!"4CKeB;.Rd2^H03d5fRB4}3Px(h:|J.P'[1^;6]&Yh)SY<W4zC .Jm!n)7iMO<oW!7Grn#bS 2+g'Q_0uq!CCH+ J]1RLI9-87kP;_|0QB$BRx^k0Yc[b.p)P0MOM+}s|-enb:9*H+0"Ny}AhQI-)Oj|d#^Fk{6/GEZXxBDL
bFP7#Yy$OQ=)j0~FlhiMz%hFKh0ZS!L^)>.IOR#,u{d0+a^&-FfE^@KZ{x-#5+		OF&{bhhsXBF,QIPm6,Zd]"voVmDVx=
h{/[i.?  (        !1A Qa0q@` ?#0D~UGcq]<`akiwOZtlq_,Iq.|Iz.3QdCZ
sj*	~Dh\Q<1
aJF4$!!40F(N k!RZkr*8pY!2	Xn =-.1xV-r \'P(b,_J|AHD`&E@IdE&?d7psE"BCC{(@D^+2qhdmF* }|G*F#TN?`*{lTSuuX0:!Z&'FmN*+K0d,>XE~{_rJo(EI	6)wfp$G_j# %8:D[UrAxA]O,rli6Pe`J'rHh!NoK~!MArF}K^^< P:OyE5$uEXEZp/E *l{Wjva$
E;D}wVk`+,Q/e#v5h/HW]'?CW~>b!=usBLD`{icLjlLRb)g
K{@b)01	yG4d;b=vcs87&Q*{c6a8&Mt	R_%i~pL
>v40C!Lw GIC{ZJGp<_B.k({UJt8et Ku.0SGI$Px=s3 KA
rkN1E,-P5|iA&,`t$-!?hoW]d	Vcz; )7w +      !1AQa0q@ P  ?U) Y= U0NNxbi_.p\`~ #</=see4i 4XLi:)3GJEC }`rz?VO?/(%34L^4q 0UJ1CSE1Mj5]Y|u$7#T+TV<Yu599*w1/Ap$e%(E _h4`zhL"MPb8d%h{4oD	T%fFi(}H'L`GeEMh]jdAmVt-iA!XiuEq<W[d3D/yhQ+lC"&lq5$6kh-RZn3K[J!s`:58j%lV#"1
`0Bro`$IQT	FwK[GYdH|=g xh#SQxo~6^IL^CVL1	Qqjk&gh-zH`FKy(N[DT Z3Vbcw) e93NLBv+J/najoSwB__YYX)5PyU3,cV[f2eT5eCs*`l|M5VBj'Un.,**GR/B@
05:NJ[i"k]} +,\p 8K@[ajd,|S0zKM c/6"QQ[ C nO"W=1h8*ySLuIZyscZ9{H,?nSq4X(a]f.srd$<
,R&!Pk*WhI,02ftY7w?R(1? +L`Rs|6]D]Lzwu|)@H MF8+D).n j2WU|ZWO\]Ec#c5>C?,wY@G%ggp&^uw{l= CrS15]{Kx @Rav*fsld\,&&=l-[YW9z;N	CO 0^|C5\><7}|pcyjUGf[mL'QGKbhXahr~S+LEW g1fknZoO\%cp&YJ'Y%  #cFeJ*`WYGiLGygW <]G3sD`Txsks'{.ByRd^b@j^e16PF)|@(JscM;zVP`y;vgA`oU5I~]_bK]'`_8D+A|.%111g3LD^XoP|%nPxE%^Z1s".z{mbn7}dqsp`A6cjLOP974 Ajm3
pK_6b\tbv23s|(=kWouW.-9[wV5`\1GXG\_Q;sVaiFkJ+{k/[w(*~U[.+=jPqWkb7]N/amTEk#FY:B,b6\Y\qO$Vf+$v9Q2}hYfVR]h*?(j8KOXR =uE_`)z0 zj-Zc}1&1uAr=z=c0>mNiEw>*lU:'?eU	T&-N8Do|Kxrq@QF|M:-vU:z_ Z%M11eCQ=.X
]V@{v_y^q 1W" q,$wvf18KlJ*duU3c%Y)K[]D o<@lf!heTx9*+BUfy{QQ@v<NPPw9y)\ypb Lyg(pbki#	6U4bZ83eUB:Bk\}`zJJD1z|~#] tR^"p0{22s,Zb>
YD{o*uJGIgS)Kb:qv%M>UdS[)@ix|+b7E< 
!; di5-3pZ6C}f\hp7R(e<~*K
NxrfEN|*~-^&Y9b\o]bcF`<>j\fDuZ]\ (0,V'PknYLT	hNy?j72^:	c,_|\e&6CCK>s62 o+X>qEs^T_ -SUa+XQnztxb|bapohQ{n__mcr%MsWa@:%6j
3E. %^ ZMszqtg,tEQo/9KaR|:CIR9}8p|Hz){VDsi[	vjfw\9p,PwSTQF>;YeQ]Ylj%Ue}<wX0m,beQ34zT[kM":I(W6GHxU'n0RQp*8hHb`B;0HhZ~7/iR.Y0R>EDT;En:>5b40RSzJV@l}a0yN#LDZCpp%D9KtYPZ*r/aj7*P6+vbt|#xys~bR._XxKb5{h6U38QPl"Nc-VGWJucz/Fg.sWpa*. _>|I:KCApWcXn+"(qAt^P+1HTz sG>qbx,V?f?doT+.:*:
y0#)MQ/~'yq-qVO"so7b z4, \In 1)6xGiP|qq&IvYE@Nu
; !q:P*wotq,<h.lZp=c{fYv|DeCfZ~A ])ttn2oB]%9{:!9A{5*@E>B-gs s,t+kP;b /rKe!x VhcA}DP^G~O	M | tPkavAfiz~Xqj"[v\2]ca+"CSfxwH.#c{,L\k
&|ad	yF <83HVutNm~Z.;0$.({+]4],TCVWrlenIp,lEF[Icq"Npq/Orv=
8nDl|Mr"JsQ<#D
:;)y|1@`+c5tYs'jDQm\~1Qu
s19hium[mxHQX7VCL-f
ngsB,3 ;^kg. rB^
r_G+-uPdl:q}ejWZJ q	Ep<5\ph`\ldDP4, X:1iJjd9r{Eicu+@rt.a+ q7%`]5u*SDLN~*m^lf[z}6JE2yWa[(Y:+2Bed^wEju1#N]|'=WF
/to=szF[wD-RW{L.kw-8.	vos(+*yn~5WXKh{+: YO%Y}h_Rw#T35N`]-o)c=gE SvNb W0+PnG:Kh p|. ZR32i_E
0@ [EdqR0j35jd.4	s+
[AMWU t}"Lp#J:aE=:%L`B+g\4L%%@^W[.+&6gd?yH 
X+VLu[mvb_Q	a G 
8Nx%^dX.al g0~|D32Yy:zG\7K+vq:#*#j*TJxkccc)LkOy{?G(Hy5l:5NPBEE4=9c	
O4W4chs0QAWZl#>Q
1.mn~tA/.DJM#"%	b6*FySV}#t_j
vc5e+]QYH Qky`.9Wo>KYuaU6~e[`x@k^%8Z$b8Y *VcsOJ\'S-KGX)5`M!\y)aZc"oT.rCB/.|/>zE1))fUzhzJ0yb:|K2*6] X&T]!f.^diMf57S/#Kze?("qVpVa3t9
'\C]|-,+!UPlcR^^E
:6qm@sj5	E~Zu^?0&2@o+bcRy49I@q)B-.J}y{3f~bT,Z_fqP@\7@v9-PqT^53fa<Fm`vX#c1KJsnmt*4PvlN[eAGp_I%ENA4-glDs/	(jgoyCh]ZCat5.*ol,+zd9*0)YWU$e3 ]W9=KU r=mY[B/AYVyfg&[]Y@v~bT,U}b 
 *Fa"5D"]+0KQ}
.;'_/|-y8?$wg?#B^EQvHYQhR
&m6@qs +D{+/.q`k.,p)wKJ})FtcG, :*o2%K9^>pE%|~2'Gh-uUh*2"5d	SL=$Y;w4ecNc.Xq]Jag GMn'OG-b(F+Ba,1o&P;g~4kJb#Ew4cm="YJ~Z9 H`X0+-P.<1C{v6Xjpe}+\\%dF#:?UBEi+XzU!(rQJo i^z+9.LJ57!l;{0U+Ho  hY4T_M*^9]5D?WC.%=]eGm,s_%%iL LaJkDnTWLuF[3h}D`1RTT(nJ?{hS*<E.MfY4\9QDl( YXfgJdCTw.M%@HUuU$4)cP "Z/\P9`2 F>&e((,,JXXslp-F0VMNG|'"Ooh
1FsSCf{3;>2u-`ll\s2Ux,: +.xBtNEp00I<KzNwk .4nWPE4;)PLX*wquI/QL1+7p?<?1]i%-
[1?!40KT*u@"-  5q"wyCK3nuw,MQ\ik$5"kCP3+<<hfR<@WW#U#vRWv_+iMekSEFD F2X`1-Zco'Qft	-w^\K#0\]Y[ eVWSqKZ]lQ/lpf]<L%4]fvu!s7F?9
>*3are?"w~7Zk 9WUHs'*oLlj14^arhU^geyy%~P4se4; 3;mY?-e 

===== static/img/placeholders/chart_placeholder.png =====
-e 

===== static/img/placeholders/chart_placeholder.svg =====
<svg width="600" height="400" viewBox="0 0 600 400" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="600" height="400" rx="12" fill="#F9FAFB"/>
<rect x="60" y="360" width="50" height="-200" rx="4" fill="#E5E7EB"/>
<rect x="150" y="360" width="50" height="-280" rx="4" fill="#E5E7EB"/>
<rect x="240" y="360" width="50" height="-150" rx="4" fill="#E5E7EB"/>
<rect x="330" y="360" width="50" height="-220" rx="4" fill="#E5E7EB"/>
<rect x="420" y="360" width="50" height="-300" rx="4" fill="#E5E7EB"/>
<rect x="510" y="360" width="50" height="-180" rx="4" fill="#E5E7EB"/>
<line x1="40" y1="360.5" x2="580" y2="360.5" stroke="#D1D5DB"/>
<line x1="40.5" y1="40" x2="40.5" y2="380" stroke="#D1D5DB"/>
</svg>-e 

===== static/img/placeholders/avatar_default.svg =====
<svg width="256" height="256" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="128" cy="128" r="128" fill="#E5E7EB"/>
<path d="M128 160C157.941 160 182 149.255 182 135V119C182 104.745 157.941 94 128 94C98.0588 94 74 104.745 74 119V135C74 149.255 98.0588 160 128 160Z" fill="#D1D5DB"/>
<circle cx="128" cy="122" r="32" fill="#D1D5DB"/>
</svg>-e 

===== static/js/requests.js =====
// Nexus School Management System - requests.js
// Gemini 3 Pro Preview - Phase H.1 (Initial Setup)

"use strict";

document.addEventListener('DOMContentLoaded', function () {
    console.log('Nexus Requests JS Initialized.');

    // --- Review Request Form Dynamics ---
    const reviewRequestForm = document.getElementById('reviewRequestForm'); // Assuming form has this ID in review.html
    const statusSelect = reviewRequestForm ? reviewRequestForm.querySelector('select[name="status"]') : null;
    const denialReasonGroup = reviewRequestForm ? reviewRequestForm.querySelector('#denialReasonGroup') : null; // Assuming a div wrapping denial_reason
    const forwardToGroup = reviewRequestForm ? reviewRequestForm.querySelector('#forwardToUserGroup') : null; // Assuming a div wrapping forward_to_user_id

    function toggleReviewFormFields() {
        if (!statusSelect) return;

        const selectedAction = statusSelect.value;

        // Show/hide denial reason
        if (denialReasonGroup) {
            const denialTextarea = denialReasonGroup.querySelector('textarea');
            if (selectedAction === 'Denied') {
                denialReasonGroup.style.display = 'block';
                if(denialTextarea) denialTextarea.required = true;
            } else {
                denialReasonGroup.style.display = 'none';
                if(denialTextarea) denialTextarea.required = false;
            }
        }

        // Show/hide forward to user selection
        if (forwardToGroup) {
            const forwardSelect = forwardToGroup.querySelector('select');
            if (selectedAction === 'Forward') {
                forwardToGroup.style.display = 'block';
                if(forwardSelect) forwardSelect.required = true;
            } else {
                forwardToGroup.style.display = 'none';
                if(forwardSelect) forwardSelect.required = false;
            }
        }
    }

    if (statusSelect) {
        statusSelect.addEventListener('change', toggleReviewFormFields);
        toggleReviewFormFields(); // Initial call to set correct visibility
    }

    // Add other request-specific JS logic here as needed
    // e.g., AJAX form submissions for request actions if not using standard POSTs.
});

// Example of AJAX submission for a request action (conceptual, not fully wired yet)
// async function handleRequestAction(formElement, action) {
//     const submitButton = formElement.querySelector('button[type="submit"]');
//     // ... (disable button, show spinner) ...
//     const formData = new FormData(formElement);
//     // Add action to formData if not already present from button value
//     if (!formData.has('action')) {
//         formData.append('action', action);
//     }
//
//     try {
//         const response = await fetch(formElement.action, {
//             method: 'POST',
//             body: formData,
//             headers: {'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''}
//         });
//         const responseData = await response.json();
//         if (response.ok && responseData.success) {
//             showNexusNotification('Success', responseData.message || 'Request updated.', 'success');
//             if (responseData.redirect_url) {
//                 window.location.href = responseData.redirect_url;
//             } else {
//                 // Or dynamically update parts of the page
//             }
//         } else {
//             showNexusNotification('Error', responseData.error || 'Failed to update request.', 'error');
//         }
//     } catch (error) { /* ... error handling ... */ }
//     finally { /* ... re-enable button ... */ }
// }
// Nexus School Management System - requests.js
// Gemini 3 Pro Preview - Phase H.2 (Review Form Dynamics)

"use strict";

document.addEventListener('DOMContentLoaded', function () {
    console.log('Nexus Requests JS Initialized.');

    // Initialize review request form dynamics if the form exists on the page
    if (document.getElementById('reviewRequestForm')) {
        initializeReviewRequestForm();
    }
});

/**
 * Initializes dynamic visibility for fields in the Review Request Form.
 */
function initializeReviewRequestForm() {
    const reviewForm = document.getElementById('reviewRequestForm');
    const statusSelect = reviewForm ? reviewForm.querySelector('select[name="status"]') : null;
    // Use more specific IDs for these groups if they don't have form-group wrappers
    const denialReasonGroup = reviewForm ? document.getElementById('denialReasonGroup') : null;
    const forwardToUserGroup = reviewForm ? document.getElementById('forwardToUserGroup') : null;

    if (!statusSelect) {
        // console.warn('Review request status select not found.');
        return;
    }

    function toggleReviewFormFields() {
        const selectedActionValue = statusSelect.value; // This is the 'value' of the selected option

        // Show/hide denial reason
        if (denialReasonGroup) {
            const denialTextarea = denialReasonGroup.querySelector('textarea[name="denial_reason"]');
            if (selectedActionValue === 'Denied') { // Check against the actual value from WTForms choices
                denialReasonGroup.style.display = 'block';
                if (denialTextarea) denialTextarea.required = true;
            } else {
                denialReasonGroup.style.display = 'none';
                if (denialTextarea) denialTextarea.required = false;
            }
        }

        // Show/hide forward to user selection
        if (forwardToUserGroup) {
            const forwardSelect = forwardToUserGroup.querySelector('select[name="forward_to_user_id"]');
            if (selectedActionValue === 'Forward') { // Check against the actual value
                forwardToUserGroup.style.display = 'block';
                if (forwardSelect && forwardSelect.options.length > 1) { // Check if actual users are populated
                     forwardSelect.required = true;
                } else {
                     if(forwardSelect) forwardSelect.required = false; // No users to select, so not required
                }
            } else {
                forwardToUserGroup.style.display = 'none';
                if (forwardSelect) forwardSelect.required = false;
            }
        }
    }

    statusSelect.addEventListener('change', toggleReviewFormFields);
    // Initial call to set correct visibility based on pre-selected status (if any)
    toggleReviewFormFields();
}

// Add other request-specific JS logic here as needed
// e.g., AJAX form submissions for request actions if not using standard POSTs.-e 

===== static/js/analytics.js =====
/**
 * Nexus Actionable Intelligence Engine
 * 
 * This module provides a lightweight, event-driven analytics framework.
 * It's designed to be privacy-conscious and backend-agnostic.
 * 
 * Usage from HTML/Jinja:
 * <button onclick="NexusAnalytics.trackEvent('social_post_created', { club_id: 123, character_count: 280 })">Post</button>
 */
const NexusAnalytics = (function() {
    'use strict';

    // --- Configuration ---
    const config = {
        apiEndpoint: '/api/analytics/log', // The backend endpoint to send data to.
        enabled: true, // Master switch to enable/disable all tracking.
        debug: false, // Set to true to log events to the console instead of sending them.
        batchInterval: 5000, // Send batched events every 5 seconds.
        maxBatchSize: 20 // Send batch if it reaches this size before the interval.
    };

    let eventQueue = [];
    let isInitialized = false;

    /**
     * Sends analytics data to the backend.
     * @param {Array<Object>} batch - The batch of event objects to send.
     */
    function sendData(batch) {
        if (!config.enabled) return;
        if (batch.length === 0) return;

        if (config.debug) {
            console.log('--- Analytics Event Batch ---');
            console.table(batch);
            return;
        }

        const payload = {
            events: batch,
            client_timestamp: new Date().toISOString(),
            url: window.location.href
        };

        // Use navigator.sendBeacon for reliable background sending if available.
        if (navigator.sendBeacon) {
            const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
            navigator.sendBeacon(config.apiEndpoint, blob);
        } else {
            // Fallback to fetch for older browsers.
            fetch(config.apiEndpoint, {
                method: 'POST',
                body: JSON.stringify(payload),
                headers: { 'Content-Type': 'application/json' },
                keepalive: true // Attempt to continue request even if page unloads.
            }).catch(error => console.error('Nexus Analytics Error:', error));
        }
    }
    
    /**
     * Processes the event queue, sending batches of events.
     */
    function processQueue() {
        if (eventQueue.length > 0) {
            const batch = eventQueue.slice(0, config.maxBatchSize);
            eventQueue = eventQueue.slice(config.maxBatchSize);
            sendData(batch);
        }
    }

    /**
     * Initializes the analytics engine.
     * Sets up automatic batch processing and tracks the initial page view.
     */
    function init(userConfig = {}) {
        if (isInitialized) {
            console.warn('NexusAnalytics already initialized.');
            return;
        }

        // Merge user config with defaults.
        Object.assign(config, userConfig);

        // Start the batch processing interval.
        setInterval(processQueue, config.batchInterval);

        // Track initial page view.
        trackEvent('page_view', { 
            title: document.title,
            path: window.location.pathname
        });
        
        // Add a handler to send any remaining events when the page is closed.
        window.addEventListener('beforeunload', () => {
            processQueue();
        });

        isInitialized = true;
        if(config.debug) console.log('Nexus Analytics Initialized.');
    }

    /**
     * Public method to track a custom event.
     * @param {string} eventName - The name of the event (e.g., 'button_click').
     * @param {Object} [eventData={}] - A key-value object of custom data.
     */
    function trackEvent(eventName, eventData = {}) {
        if (!isInitialized || !config.enabled) return;

        if (typeof eventName !== 'string' || eventName.trim() === '') {
            console.error('Nexus Analytics: eventName must be a non-empty string.');
            return;
        }

        const event = {
            name: eventName,
            data: eventData,
            timestamp: new Date().toISOString()
        };

        eventQueue.push(event);

        // If the queue has reached max size, send immediately.
        if (eventQueue.length >= config.maxBatchSize) {
            processQueue();
        }
    }

    // --- Public API ---
    return {
        init: init,
        trackEvent: trackEvent
    };
})();

// Automatically initialize on script load.
// Configuration can be overridden by calling NexusAnalytics.init({ ... }) later.
NexusAnalytics.init({
    // In production, you might set debug: false
    // debug: (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
});-e 

===== static/js/app.js =====
/**
 * app.js
 * Main application entrypoint. Imports and initializes all modules.
 * This is the file that a bundler like Webpack or a tool like Flask-Assets would target.
 */
import { initializeUI } from './modules/ui.js';
import { initializeSocialHandlers } from './modules/social.js';

// Initialize all modules when the DOM is ready.
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded and parsed. Initializing modules...');
    
    initializeUI();
    initializeSocialHandlers();

    // Any other global initializations would go here.
    
    console.log('Nexus Platform JS Core is active.');
});

// ... existing imports
import * as realTime from './modules/socket-client.js';

document.addEventListener('DOMContentLoaded', () => {
    // ... existing initializations
    window.realTime = realTime; // Make it globally accessible for templates
    console.log('Real-Time module attached to window.');
});-e 

===== static/js/libs/filepond/filepond.js =====
// Content of static/js/libs/filepond/filepond.js
// This is a dummy file for demonstration.
-e 

===== static/js/libs/filepond/filepond.css =====
// Content of static/js/libs/filepond/filepond.css
// This is a dummy file for demonstration.
-e 

===== static/js/social.js =====
// static/js/social.js
"use strict";

// Assuming nexusRealtimeManager is from socketHandlers.js (globally available)
// Assuming showNexusNotification, postData, getData from utils.js (globally available)

const nexusSocial = {
    // --- Configuration for current feed view ---
    config: {
        feedType: null, // 'global', 'channel', 'group', 'tc_feed'
        parentId: null,   // channel_id, group_id, etc. (null for global)
        currentPage: 1,
        isLoadingMore: false,
        apiEndpoints: {
            global: {
                fetchPosts: '/api/v1/global_posts',
                createPost: '/api/v1/global_posts', // Matches your app.py route for GlobalPost
                createComment: '/api/v1/global_posts/{postId}/comments',
                toggleLike: '/api/v1/global_posts/{postId}/like',
                deletePost: '/api/v1/global_posts/{postId}',
                deleteComment: '/api/v1/global_comments/{commentId}', // Corrected endpoint
                fetchComments: '/api/v1/global_posts/{postId}/comments' // API to fetch comments
            },
            // Define endpoints for 'channel', 'group', 'tc_feed' if needed for unified handling
        },
        uiSelectors: {
            feedContainer: null,
            loadingPlaceholder: null,
            emptyPlaceholder: null,
            loadMoreTrigger: null,
            createForm: null,
        },
        postTemplateFunction: null, // Will be set to a function that renders a post item
        commentTemplateFunction: null // Will be set to a function that renders a comment item
    },

    initGlobalFeed: function(initialConfig) {
        console.log('Initializing Global Feed...');
        this.config.feedType = 'global';
        this.config.parentId = null;
        this.config.currentPage = 1;
        this.config.isLoadingMore = false;

        this.config.uiSelectors.feedContainer = document.getElementById(initialConfig.feedContainerId);
        this.config.uiSelectors.loadingPlaceholder = document.getElementById(initialConfig.loadingPlaceholderId);
        this.config.uiSelectors.emptyPlaceholder = document.getElementById(initialConfig.emptyPlaceholderId);
        this.config.uiSelectors.loadMoreTrigger = document.getElementById(initialConfig.loadMoreTriggerId);
        this.config.uiSelectors.createForm = document.getElementById(initialConfig.createFormId);
        
        // Define client-side template functions based on your HTML partials
        // These will take a data object and return an HTML string or a DOM element
        this.config.postTemplateFunction = this.renderGlobalPostItem; // Link to the rendering function
        this.config.commentTemplateFunction = this.renderCommentItem; // Link to the rendering function


        if (!this.config.uiSelectors.feedContainer) {
            console.error("Global feed container not found:", initialConfig.feedContainerId);
            return;
        }

        this.loadInitialPosts();
        this.setupGlobalEventListeners();
        this.registerGlobalRealtimeHandlers();
        initializeAllFilePondInputs(); // From existing social.js, ensure it's available
    },

    loadInitialPosts: async function() {
        if (this.config.uiSelectors.loadingPlaceholder) this.config.uiSelectors.loadingPlaceholder.classList.remove('d-none');
        if (this.config.uiSelectors.emptyPlaceholder) this.config.uiSelectors.emptyPlaceholder.classList.add('d-none');
        this.config.uiSelectors.feedContainer.innerHTML = ''; // Clear previous

        await this.fetchAndRenderPosts(1);
        
        if (this.config.uiSelectors.loadingPlaceholder) this.config.uiSelectors.loadingPlaceholder.classList.add('d-none');
        if (this.config.uiSelectors.feedContainer.children.length === 0 && this.config.uiSelectors.emptyPlaceholder) {
            this.config.uiSelectors.emptyPlaceholder.classList.remove('d-none');
        }
    },

    fetchAndRenderPosts: async function(page, prepend = false) {
        const currentConfig = this.config; // Use 'this.config' consistently
        if (currentConfig.isLoadingMore && page > 1) return;
        if (page > 1) currentConfig.isLoadingMore = true;

        const loadMoreButton = currentConfig.uiSelectors.loadMoreTrigger?.querySelector('.load-more-btn');
        if (loadMoreButton && page > 1) {
            loadMoreButton.disabled = true;
            loadMoreButton.querySelector('.spinner-border')?.classList.remove('d-none');
        }

        try {
            const endpoint = currentConfig.apiEndpoints[currentConfig.feedType].fetchPosts;
            const url = `${endpoint}?page=${page}`;
            const responseData = await getData(url); // from utils.js

            if (responseData.success && responseData.posts) {
                if (responseData.posts.length > 0) {
                    responseData.posts.forEach(postJson => {
                        const postElement = currentConfig.postTemplateFunction(postJson, currentConfig.feedType);
                        if (prepend) {
                            currentConfig.uiSelectors.feedContainer.prepend(postElement);
                        } else {
                            currentConfig.uiSelectors.feedContainer.appendChild(postElement);
                        }
                    });
                    currentConfig.currentPage = page;
                    if (currentConfig.uiSelectors.emptyPlaceholder) currentConfig.uiSelectors.emptyPlaceholder.classList.add('d-none');
                } else if (page === 1) { // No posts at all
                    if (currentConfig.uiSelectors.emptyPlaceholder) currentConfig.uiSelectors.emptyPlaceholder.classList.remove('d-none');
                }

                if (currentConfig.uiSelectors.loadMoreTrigger) {
                    currentConfig.uiSelectors.loadMoreTrigger.classList.toggle('d-none', !responseData.pagination.has_next);
                }
            } else {
                console.warn('No posts data in response or request failed silently:', responseData);
                if (page === 1 && currentConfig.uiSelectors.emptyPlaceholder) currentConfig.uiSelectors.emptyPlaceholder.classList.remove('d-none');
                if (currentConfig.uiSelectors.loadMoreTrigger) currentConfig.uiSelectors.loadMoreTrigger.classList.add('d-none');
            }
        } catch (error) {
            console.error(`Error fetching ${currentConfig.feedType} posts:`, error);
            // Do not show generic notification if it's just empty (handled by placeholders)
            if (page === 1 && currentConfig.uiSelectors.emptyPlaceholder) {
                currentConfig.uiSelectors.emptyPlaceholder.innerHTML = `<p class="text-danger">Could not load feed: ${error.message}</p>`;
                currentConfig.uiSelectors.emptyPlaceholder.classList.remove('d-none');
            } else if (page > 1) { // Error on "load more"
                showNexusNotification('Error Loading More Posts', error.message || 'Could not load more posts.', 'error');
            }
        } finally {
            if (page > 1) currentConfig.isLoadingMore = false;
            if (loadMoreButton && page > 1) {
                loadMoreButton.disabled = ! (responseData && responseData.pagination && responseData.pagination.has_next); // Disable if no more
                loadMoreButton.querySelector('.spinner-border')?.classList.add('d-none');
                 if (!(responseData && responseData.pagination && responseData.pagination.has_next)) {
                    loadMoreButton.textContent = "End of Feed";
                 }
            }
        }
    },

    renderGlobalPostItem: function(postData, postType = 'global') {
        // This function takes the JSON 'postData' from the API
        // and constructs the HTML element based on the structure of _global_post_item.html
        // Returns a DOM element.
        const postDomId = `${postType}_post-${postData.id}`;
        const currentUserIdString = document.body.dataset.currentUserId; // Assuming current_user.id is available on body

        const canEditDelete = (postData.author && postData.author.id.toString() === currentUserIdString) || 
                              (window.currentUserRole && ['system_admin', 'hr_ceo'].includes(window.currentUserRole));


        const div = document.createElement('div');
        div.className = 'card social-post-item mb-3 shadow-sm';
        div.id = postDomId;
        div.dataset.postId = postData.id;
        div.dataset.postType = postType;

        // --- Build innerHTML using template literals and postData ---
        // This is a direct translation of your _global_post_item.html structure
        // Make sure to properly escape data if inserting directly or use DOM methods.
        div.innerHTML = `
            <div class="card-body">
                <div class="d-flex align-items-center mb-3">
                    <a href="/user/${postData.author.id}" class="flex-shrink-0"> {# TODO: Replace with url_for('user_profile_view', user_id=...) if possible from JS #}
                        <img src="${postData.author.profile_photo_url || '/static/img/placeholders/user_avatar_default.png'}"
                             alt="${postData.author.full_name || postData.author.username}'s avatar" class="rounded-circle me-3" width="48" height="48" style="object-fit: cover;">
                    </a>
                    <div class="flex-grow-1">
                        <a href="/user/${postData.author.id}" class="fw-bold text-dark text-decoration-none font-heading">${postData.author.full_name || postData.author.username}</a>
                        <div class="text-muted small">
                            <i class="bi bi-clock"></i> 
                            <span class="post-timestamp" title="${new Date(postData.timestamp).toLocaleString()}">
                                ${humanizeTimeDiff(postData.timestamp)}
                            </span>
                            ${postData.is_edited ? '<span class="fst-italic ms-1">(edited)</span>' : ''}
                        </div>
                    </div>
                    ${canEditDelete ? `
                    <div class="dropdown">
                        <button class="btn btn-sm btn-light border-0" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Post options">
                            <i class="bi bi-three-dots-vertical"></i>
                        </button>
                        <ul class="dropdown-menu dropdown-menu-end">
                            ${postData.author.id.toString() === currentUserIdString ? `<li><a class="dropdown-item edit-post-btn" href="#" data-post-id="${postData.id}" data-post-type="${postType}"><i class="bi bi-pencil me-2"></i>Edit Post</a></li>` : ''}
                            <li><button class="dropdown-item text-danger delete-post-btn" data-post-id="${postData.id}" data-post-type="${postType}"><i class="bi bi-trash me-2"></i>Delete Post</button></li>
                        </ul>
                    </div>` : ''}
                </div>

                ${postData.content ? `<div class="post-content-text mb-3">${postData.content.replace(/\n/g, '<br>')}</div>` : ''}

                ${postData.file ? `
                    <div class="post-attachment mb-3">
                        ${postData.file.mimetype && postData.file.mimetype.startsWith('image/') ? `
                            <a href="${postData.file.download_url}" data-bs-toggle="modal" data-bs-target="#viewFileModal" data-file-url="${postData.file.download_url}" data-file-mimetype="${postData.file.mimetype}" data-file-name="${postData.file.original_filename}">
                                <img src="${postData.file.download_url}" class="img-fluid rounded border" alt="Attachment: ${postData.file.original_filename}" style="max-height: 450px; object-fit: contain; cursor: pointer;">
                            </a>
                        ` : (postData.file.mimetype && postData.file.mimetype.startsWith('video/') ? `
                            <video controls class="img-fluid rounded border" style="max-height: 450px; width:100%;">
                                <source src="${postData.file.download_url}" type="${postData.file.mimetype}">
                                Your browser does not support the video tag.
                            </video>
                        ` : `
                            <div class="d-flex align-items-center p-2 border rounded-3 bg-light-subtle">
                                <i class="bi bi-file-earmark-text-fill fs-2 me-2 text-secondary"></i>
                                <div class="flex-grow-1">
                                    <a href="${postData.file.download_url}" class="fw-semibold text-decoration-none stretched-link" target="_blank" download="${postData.file.original_filename}">
                                        ${postData.file.original_filename}
                                    </a>
                                    <div class="text-muted small">
                                        ${(postData.file.size > 1024*1024) ? (postData.file.size / (1024*1024)).toFixed(2) + ' MB' : (postData.file.size / 1024).toFixed(1) + ' KB'}
                                        ${postData.file.mimetype ? ` - ${postData.file.mimetype}` : ''}
                                    </div>
                                </div>
                                 <a href="${postData.file.download_url}" class="btn btn-sm btn-outline-secondary ms-2" download="${postData.file.original_filename}" aria-label="Download file">
                                    <i class="bi bi-download"></i>
                                </a>
                            </div>
                        `)}
                    </div>
                ` : ''}

                <div class="post-actions d-flex justify-content-start align-items-center gap-2 border-top pt-2 mt-2">
                    <button class="btn btn-subtle btn-sm reaction-btn like-post-btn ${postData.current_user_liked ? 'active' : ''}" 
                            data-post-id="${postData.id}" data-post-type="${postType}" aria-pressed="${postData.current_user_liked}">
                        <i class="bi ${postData.current_user_liked ? 'bi-heart-fill text-danger' : 'bi-heart'}"></i> 
                        <span class="like-text">${postData.current_user_liked ? 'Liked' : 'Like'}</span>
                        (<span class="like-count">${postData.like_count || 0}</span>)
                    </button>
                    
                    ${postData.allow_comments !== false ? `
                    <button class="btn btn-subtle btn-sm comment-toggle-btn" data-bs-toggle="collapse" href="#commentsCollapse-${postDomId}" role="button" aria-expanded="false" aria-controls="commentsCollapse-${postDomId}">
                        <i class="bi bi-chat-dots"></i> Comment 
                        (<span class="comment-count">${postData.comment_count || 0}</span>)
                    </button>` : ''}

                    <button class="btn btn-subtle btn-sm share-post-btn" data-post-id="${postData.id}" data-post-type="${postType}" data-share-url="${postData.share_url || '#'}">
                        <i class="bi bi-share"></i> Share
                    </button>
                    <button class="btn btn-subtle btn-sm save-item-btn" data-item-id="${postData.id}" data-item-type="${postType}">
                        <i class="bi bi-bookmark"></i> <span class="save-text">Save</span>
                    </button>
                </div>
            </div>
            ${postData.allow_comments !== false ? `
            <div class="collapse comments-section-wrapper" id="commentsCollapse-${postDomId}">
                <div class="card-footer bg-light-subtle p-2 comments-section" id="comments-for-${postDomId}">
                    <div class="text-center py-3 comments-loading-placeholder d-none">
                        <div class="spinner-border spinner-border-sm text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
                    </div>
                    <div class="comments-list" id="comments-list-${postDomId}"></div>
                    <div class="load-more-comments-container text-center my-2 d-none">
                         <button class="btn btn-link btn-sm load-more-comments-btn" data-post-id="${postData.id}" data-post-type="${postType}">Load more comments</button>
                    </div>
                    {# Comment Form using _social_content_form.html structure. JS will handle submission. #}
                    <div class="social-content-form-card card mb-2 border-0 shadow-none p-0"> <div class="card-body p-0">
                    <form method="POST" action="${this.config.apiEndpoints[postType].createComment.replace('{postId}', postData.id)}" id="commentForm-${postDomId}" class="social-content-submission-form comment-submission-form" data-form-type="global_comment_create" data-post-id="${postData.id}">
                        <input type="hidden" name="csrf_token" value="${document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''}">
                        <div class="d-flex align-items-start">
                            <div class="flex-shrink-0 me-2">
                                <img src="${window.currentUserAvatarUrl || '/static/img/placeholders/user_avatar_default.png'}" 
                                     alt="Your avatar" class="rounded-circle" width="32" height="32" style="object-fit: cover;">
                            </div>
                            <div class="flex-grow-1">
                                <textarea name="content" class="form-control post-content-textarea comment-input" placeholder="Write a thoughtful comment..." rows="1" aria-label="Write a thoughtful comment..." id="commentTextarea-${postDomId}" autocomplete="off"></textarea>
                                <div class="d-flex justify-content-end align-items-center mt-2">
                                    <button type="submit" class="btn btn-primary btn-sm post-submit-btn comment-submit-btn">
                                        <span class="spinner-border spinner-border-sm d-none me-1" role="status" aria-hidden="true"></span>
                                        Reply
                                    </button>
                                </div>
                            </div>
                        </div>
                    </form>
                    </div></div>
                </div>
            </div>` : ''}
        `;
        return div;
    },

    renderCommentItem: function(commentData, postId, postType = 'global') {
        const commentDomId = `comment-${postType}-${commentData.id}`;
        const currentUserIdString = document.body.dataset.currentUserId;
        // Basic permission check for demo - needs robust backend check for actual edit/delete action
        const canEdit = commentData.author && commentData.author.id.toString() === currentUserIdString;
        const canDelete = canEdit || (window.currentUserRole && ['system_admin', 'hr_ceo'].includes(window.currentUserRole));


        const div = document.createElement('div');
        div.className = 'social-comment-item d-flex mb-2 pt-2 pb-2 border-bottom border-light-subtle';
        div.id = commentDomId;
        div.dataset.commentId = commentData.id;

        div.innerHTML = `
            <a href="/user/${commentData.author.id}" class="me-2 flex-shrink-0" aria-label="${commentData.author.full_name || commentData.author.username}'s profile">
                <img src="${commentData.author.profile_photo_url || '/static/img/placeholders/user_avatar_default.png'}" alt="${commentData.author.full_name || commentData.author.username}" class="rounded-circle" width="32" height="32" style="object-fit: cover;">
            </a>
            <div class="flex-grow-1">
                <div class="comment-bubble bg-light-subtle p-2 rounded-3">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <a href="/user/${commentData.author.id}" class="text-decoration-none">
                            <small class="fw-bold text-dark font-heading">${commentData.author.full_name || commentData.author.username}</small>
                        </a>
                        ${(canEdit || canDelete) ? `
                        <div class="dropdown comment-actions ms-auto">
                            <button class="btn btn-sm btn-link text-muted py-0 px-1" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Comment options">
                                <i class="bi bi-three-dots"></i>
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                ${canEdit ? `<li><a class="dropdown-item edit-comment-btn" href="#" data-comment-id="${commentData.id}" data-post-id="${postId}" data-post-type="${postType}"><i class="bi bi-pencil me-2"></i>Edit</a></li>` : ''}
                                ${canDelete ? `<li><button class="dropdown-item text-danger delete-comment-btn" data-comment-id="${commentData.id}" data-post-id="${postId}" data-post-type="${postType}"><i class="bi bi-trash me-2"></i>Delete</button></li>` : ''}
                            </ul>
                        </div>` : ''}
                    </div>
                    <p class="mb-0 comment-content-text text-dark-emphasis small" id="comment-content-${commentDomId}">${commentData.content.replace(/\n/g, '<br>')}</p>
                </div>
                <div class="d-flex justify-content-between align-items-center mt-1">
                    <small class="text-muted ms-1 comment-timestamp" title="${new Date(commentData.timestamp).toLocaleString()}">
                        ${humanizeTimeDiff(commentData.timestamp)}
                        ${commentData.is_edited ? '<span class="fst-italic ms-1">(edited)</span>' : ''}
                    </small>
                    <div>
                       {# Save comment button can be added here in Phase 2 #}
                    </div>
                </div>
            </div>
        `;
        return div;
    },

    handleGlobalPostCreateSubmit: async function(formElement) {
        const submitButton = formElement.querySelector('.post-submit-btn');
        const originalButtonText = submitButton.textContent;
        this.setButtonLoading(submitButton, true, "Posting...");

        const formData = new FormData(formElement);
        const endpoint = this.config.apiEndpoints.global.createPost;

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                body: formData, // FormData handles multipart/form-data
                headers: { 'X-CSRFToken': formData.get('csrf_token') }
            });
            const responseData = await response.json();

            if (response.ok && responseData.success && responseData.post) {
                showNexusNotification('Success!', 'Post created successfully!', 'success');
                formElement.reset();
                const pondInstance = FilePond.find(formElement.querySelector('.filepond-input'));
                if (pondInstance) pondInstance.removeFiles();
                this.autoResizeTextarea(formElement.querySelector('.post-content-textarea'), true); // Reset height
                
                const postElement = this.config.postTemplateFunction(responseData.post, 'global');
                this.config.uiSelectors.feedContainer.prepend(postElement);
                if (this.config.uiSelectors.emptyPlaceholder) this.config.uiSelectors.emptyPlaceholder.classList.add('d-none');
            } else {
                showNexusNotification('Post Error', responseData.error || responseData.message || 'Failed to create post.', 'error');
            }
        } catch (error) {
            console.error('Error creating global post:', error);
            showNexusNotification('Network Error', `Could not create post: ${error.message}`, 'error');
        } finally {
            this.setButtonLoading(submitButton, false, originalButtonText);
        }
    },

    handleGlobalCommentCreateSubmit: async function(formElement) {
        const postId = formElement.dataset.postId;
        const contentTextarea = formElement.querySelector('textarea[name="content"]');
        const content = contentTextarea.value.trim();
        if (!content) return;

        const submitButton = formElement.querySelector('.post-submit-btn');
        const originalButtonText = submitButton.textContent;
        this.setButtonLoading(submitButton, true);

        const endpoint = this.config.apiEndpoints.global.createComment.replace('{postId}', postId);

        try {
            const responseData = await postData(endpoint, { content: content }); // utils.postData sends JSON
            if (responseData.success && responseData.comment) {
                contentTextarea.value = '';
                this.autoResizeTextarea(contentTextarea, true);

                const commentsList = document.getElementById(`comments-list-global_post-${postId}`);
                if (commentsList) {
                    const commentElement = this.config.commentTemplateFunction(responseData.comment, postId, 'global');
                    commentsList.appendChild(commentElement);
                    // Update comment count on post
                    const postEl = document.getElementById(`global_post-${postId}`);
                    const countEl = postEl?.querySelector('.comment-toggle-btn .comment-count');
                    if(countEl) countEl.textContent = responseData.post_comment_count;
                }
            } else {
                showNexusNotification('Comment Error', responseData.error || 'Failed to post comment.', 'error');
            }
        } catch (error) {
            showNexusNotification('Network Error', `Could not post comment: ${error.message}`, 'error');
        } finally {
            this.setButtonLoading(submitButton, false, originalButtonText);
        }
    },
    
    handleGlobalLikeToggle: async function(buttonElement) {
        const postId = buttonElement.dataset.postId;
        const endpoint = this.config.apiEndpoints.global.toggleLike.replace('{postId}', postId);
        
        // Optimistic UI update
        const icon = buttonElement.querySelector('i.bi');
        const countSpan = buttonElement.querySelector('.like-count');
        const likeText = buttonElement.querySelector('.like-text');
        const wasActive = buttonElement.classList.contains('active');
        let currentCount = parseInt(countSpan.textContent);

        buttonElement.classList.toggle('active', !wasActive);
        if (icon) icon.className = !wasActive ? 'bi bi-heart-fill text-danger' : 'bi bi-heart';
        if (likeText) likeText.textContent = !wasActive ? 'Liked' : 'Like';
        countSpan.textContent = !wasActive ? currentCount + 1 : Math.max(0, currentCount - 1);

        try {
            const responseData = await postData(endpoint, {}); // No body for toggle
            if (responseData.success) {
                // Server confirms, update with authoritative data
                countSpan.textContent = responseData.like_count;
                buttonElement.classList.toggle('active', responseData.liked);
                if (icon) icon.className = responseData.liked ? 'bi bi-heart-fill text-danger' : 'bi bi-heart';
                if (likeText) likeText.textContent = responseData.liked ? 'Liked' : 'Like';
            } else { // Revert optimistic update on server error
                buttonElement.classList.toggle('active', wasActive);
                if (icon) icon.className = wasActive ? 'bi bi-heart-fill text-danger' : 'bi bi-heart';
                if (likeText) likeText.textContent = wasActive ? 'Liked' : 'Like';
                countSpan.textContent = currentCount;
                showNexusNotification('Like Error', responseData.error || 'Failed to update like.', 'error');
            }
        } catch (error) { // Revert on network error
            buttonElement.classList.toggle('active', wasActive);
            if (icon) icon.className = wasActive ? 'bi bi-heart-fill text-danger' : 'bi bi-heart';
            if (likeText) likeText.textContent = wasActive ? 'Liked' : 'Like';
            countSpan.textContent = currentCount;
            showNexusNotification('Network Error', `Could not update like: ${error.message}`, 'error');
        }
    },

    handleGlobalDeletePost: async function(buttonElement) {
        const postId = buttonElement.dataset.postId;
        // ... (SweetAlert2 confirmation as in existing social.js) ...
        const result = await Swal.fire({ title: 'Delete Post?', text: "This post will be permanently removed.", icon: 'warning', /* ... */ });
        if (result.isConfirmed) {
            const endpoint = this.config.apiEndpoints.global.deletePost.replace('{postId}', postId);
            try {
                const responseData = await postData(endpoint, {}); // No body
                if (responseData.success) {
                    showNexusNotification('Deleted!', responseData.message || 'Post deleted.', 'success');
                    document.getElementById(`global_post-${postId}`)?.remove();
                     if (this.config.uiSelectors.feedContainer.children.length === 0 && this.config.uiSelectors.emptyPlaceholder) {
                        this.config.uiSelectors.emptyPlaceholder.classList.remove('d-none');
                    }
                } else {
                    showNexusNotification('Delete Error', responseData.error || 'Failed to delete post.', 'error');
                }
            } catch (error) { /* ... */ }
        }
    },
    
    handleGlobalDeleteComment: async function(buttonElement) {
        const commentId = buttonElement.dataset.commentId;
        const postId = buttonElement.dataset.postId; // From parent post context
        // ... (SweetAlert2 confirmation) ...
        const result = await Swal.fire({ title: 'Delete Comment?', text: "This comment will be removed.", icon: 'warning', /* ... */ });
        if (result.isConfirmed) {
            const endpoint = this.config.apiEndpoints.global.deleteComment.replace('{commentId}', commentId);
            try {
                const responseData = await postData(endpoint, {}); // No body
                if (responseData.success) {
                    showNexusNotification('Deleted!', responseData.message || 'Comment removed.', 'success');
                    document.getElementById(`comment-global-${commentId}`)?.remove();
                    // Update comment count on post
                    const postEl = document.getElementById(`global_post-${postId}`);
                    const countEl = postEl?.querySelector('.comment-toggle-btn .comment-count');
                    if(countEl && responseData.post_comment_count !== undefined) {
                         countEl.textContent = responseData.post_comment_count;
                    } else if (countEl) { // Fallback if count not returned
                        countEl.textContent = Math.max(0, parseInt(countEl.textContent) -1);
                    }
                } else {
                    showNexusNotification('Delete Error', responseData.error || 'Failed to delete comment.', 'error');
                }
            } catch (error) { /* ... */ }
        }
    },

    setupGlobalEventListeners: function() {
        const self = this; // For use in event listeners

        // Global Post Creation Form
        if (self.config.uiSelectors.createForm) {
            self.config.uiSelectors.createForm.addEventListener('submit', function(event) {
                event.preventDefault();
                self.handleGlobalPostCreateSubmit(this);
            });
        }

        // Load More button for Global Feed
        const loadMoreGlobalBtn = self.config.uiSelectors.loadMoreTrigger?.querySelector('.load-more-btn[data-feed-type="global"]');
        if (loadMoreGlobalBtn) {
            loadMoreGlobalBtn.addEventListener('click', function() {
                self.fetchAndRenderPosts(self.config.currentPage + 1);
            });
        }

        // Event delegation for actions within the global feed container
        if (self.config.uiSelectors.feedContainer) {
            self.config.uiSelectors.feedContainer.addEventListener('click', function(event) {
                const likeButton = event.target.closest('.like-post-btn[data-post-type="global"]');
                const deletePostButton = event.target.closest('.delete-post-btn[data-post-type="global"]');
                const deleteCommentButton = event.target.closest('.delete-comment-btn[data-post-type="global"]');
                // Add edit buttons later

                if (likeButton) {
                    self.handleGlobalLikeToggle(likeButton);
                } else if (deletePostButton) {
                    self.handleGlobalDeletePost(deletePostButton);
                } else if (deleteCommentButton) {
                    self.handleGlobalDeleteComment(deleteCommentButton);
                }
            });

            // For comment form submissions within posts
            self.config.uiSelectors.feedContainer.addEventListener('submit', function(event) {
                const commentForm = event.target.closest('.comment-submission-form[data-form-type="global_comment_create"]');
                if (commentForm) {
                    event.preventDefault();
                    self.handleGlobalCommentCreateSubmit(commentForm);
                }
            });
        }
         // Auto-resize for textareas
        document.querySelectorAll('.post-content-textarea, .comment-input').forEach(textarea => {
            textarea.addEventListener('input', () => self.autoResizeTextarea(textarea));
            self.autoResizeTextarea(textarea); // Initial call
        });
    },

    registerGlobalRealtimeHandlers: function() {
        if (typeof nexusRealtimeManager !== 'undefined') {
            // New Global Comment
            nexusRealtimeManager.on('new_comment', (data) => { // Listening to generic 'new_comment'
                // Check if this comment belongs to a global post currently in view
                if (data.post_id && document.getElementById(`global_post-${data.post_id}`)) {
                    const commentsList = document.getElementById(`comments-list-global_post-${data.post_id}`);
                    if (commentsList && !document.getElementById(`comment-global-${data.comment_data.id}`)) { // Avoid duplicates
                        // Assuming data.comment_html is sent for global comments now OR data.comment_data
                        if(data.comment_html) { // If server sends HTML
                            commentsList.insertAdjacentHTML('beforeend', data.comment_html);
                        } else if (data.comment_data) { // If server sends JSON
                            const commentElement = this.config.commentTemplateFunction(data.comment_data, data.post_id, 'global');
                            commentsList.appendChild(commentElement);
                        }
                        
                        const postEl = document.getElementById(`global_post-${data.post_id}`);
                        const countEl = postEl?.querySelector('.comment-toggle-btn .comment-count');
                        if(countEl && data.new_comment_count !== undefined) {
                            countEl.textContent = data.new_comment_count;
                        }
                    }
                }
            });

            // Global Post Like Update
            nexusRealtimeManager.on('like_update', (data) => { // Listening to generic 'like_update'
                if (data.post_id && document.getElementById(`global_post-${data.post_id}`)) {
                    const postEl = document.getElementById(`global_post-${data.post_id}`);
                    const countSpan = postEl?.querySelector('.like-post-btn .like-count');
                    if(countSpan && data.new_like_count !== undefined) {
                        countSpan.textContent = data.new_like_count;
                    }
                    // Note: Updating the "liked" state (icon color) for *other* users in real-time
                    // based on a broadcast is usually not done, as "liked" is a per-user state.
                    // The count update is sufficient for broadcast.
                }
            });

            // Handler for new global posts (if backend implements this event)
            // nexusRealtimeManager.on('new_global_post_feed', (postData) => {
            //     if (this.config.feedType === 'global' && this.config.uiSelectors.feedContainer) {
            //         const postElement = this.config.postTemplateFunction(postData, 'global');
            //         this.config.uiSelectors.feedContainer.prepend(postElement);
            //         if (this.config.uiSelectors.emptyPlaceholder) this.config.uiSelectors.emptyPlaceholder.classList.add('d-none');
            //     }
            // });
        }
    },
    
    autoResizeTextarea: function(textarea, reset = false) {
        if (reset) {
            textarea.style.height = 'auto'; // Reset first before shrinking
        }
        textarea.style.height = 'auto'; // Temporarily shrink to get scrollHeight
        let newHeight = textarea.scrollHeight;
        const maxHeightStyle = window.getComputedStyle(textarea).maxHeight;
        const maxHeight = maxHeightStyle && maxHeightStyle !== 'none' ? parseInt(maxHeightStyle) : 150; // Default max height

        if (newHeight > maxHeight) {
            newHeight = maxHeight;
            textarea.style.overflowY = 'auto';
        } else {
            textarea.style.overflowY = 'hidden';
        }
        textarea.style.height = newHeight + 'px';
    },

    setButtonLoading: function(button, isLoading, loadingText = "Loading...") {
        if (!button) return;
        const originalText = button.dataset.originalText || button.textContent.trim();
        if (isLoading) {
            button.dataset.originalText = originalText;
            button.disabled = true;
            button.innerHTML = `<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> ${loadingText}`;
        } else {
            button.disabled = false;
            button.innerHTML = button.dataset.originalText || originalText; // Revert to stored or current if none stored
        }
    }
    // ... other social utility functions will go here ...
};

// Make nexusSocial globally available (or export if using modules more strictly)
window.nexusSocial = nexusSocial;

// --- Global Auto-Resize for Textareas ---
// Already moved into setupGlobalEventListeners or nexusSocial.initGlobalFeed

// --- Initialize FilePond Inputs globally ---
// Already moved into initGlobalFeed or a general main.js DOMContentLoaded
if (typeof initializeAllFilePondInputs === 'function' && !document.getElementById('globalFeedContainer')) {
    // Only call here if not on a page that `initGlobalFeed` will handle.
    // This avoids double initialization. A more robust solution is needed for selective init.
    // initializeAllFilePondInputs(); 
}

console.log('Nexus Social JS (Global Feed Focused) - Core Initialized.');
}); // End DOMContentLoaded

// Helper for humanizing time (client-side equivalent of Jinja filter)
// This is very basic, for more complex needs use a library like moment.js or date-fns
function humanizeTimeDiff(isoTimestamp) {
    if (!isoTimestamp) return '';
    const date = new Date(isoTimestamp);
    const now = new Date();
    const seconds = Math.round((now - date) / 1000);
    const minutes = Math.round(seconds / 60);
    const hours = Math.round(minutes / 60);
    const days = Math.round(hours / 24);

    if (seconds < 5) return 'just now';
    if (seconds < 60) return `${seconds}s ago`;
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
}-e 

===== static/js/main.js =====
// Nexus School Management System - main.js
// Gemini 3 Pro Preview - Phase A.1 (Initial Version)

"use strict";

document.addEventListener('DOMContentLoaded', function () {
    console.log('Nexus Core JS Initialized. Version 1.0');

    // Initialize Bootstrap Components
    initializeBootstrapComponents();

    // Initialize Flatpickr instances
    initializeFlatpickr();

    // Initialize TomSelect instances (if any on the page)
    initializeTomSelect();

    // Setup Theme Switcher
    setupThemeSwitcher();

    // Sidebar toggle listener (if using a custom button beyond Bootstrap's navbar-toggler)
    // setupCustomSidebarToggle();

    // Add CSRF token to AJAX requests if using jQuery (example)
    // setupJQueryAjaxCsrf();

    // Display a welcome message (example using custom alert)
    // showNexusNotification('Welcome to Nexus!', 'System is initializing...', 'success');
});

function initializeBootstrapComponents() {
    // Tooltips
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });

    // Popovers
    const popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
    popoverTriggerList.map(function (popoverTriggerEl) {
        return new bootstrap.Popover(popoverTriggerEl);
    });

    // Toasts (if used, example initialization)
    // const toastElList = [].slice.call(document.querySelectorAll('.toast'));
    // toastElList.map(function (toastEl) {
    //   return new bootstrap.Toast(toastEl, { /* options */ });
    // });
}

function initializeFlatpickr() {
    flatpickr(".flatpickr-date", {
        altInput: true,
        altFormat: "F j, Y",
        dateFormat: "Y-m-d",
        allowInput: true // Allows manual typing
    });

    flatpickr(".flatpickr-datetime", {
        enableTime: true,
        altInput: true,
        altFormat: "F j, Y H:i",
        dateFormat: "Y-m-d H:i",
        time_24hr: true,
        allowInput: true
    });

    flatpickr(".flatpickr-time", {
        enableTime: true,
        noCalendar: true,
        dateFormat: "H:i",
        time_24hr: true,
        allowInput: true
    });
}

function initializeTomSelect() {
    // Generic TomSelect initialization for elements with class 'tom-select'
    // Specific configurations can be done per-page or via data-attributes
    const tomSelectElements = document.querySelectorAll('.tom-select');
    tomSelectElements.forEach(el => {
        new TomSelect(el, {
            create: el.dataset.allowCreate === 'true', // Allow creating new options if data-attribute is set
            // Add other common options or allow data-attributes to configure
            // persist: false, // Example
        });
    });
}


function setupThemeSwitcher() {
    const themeSwitcherButton = document.getElementById('themeSwitcher');
    const htmlElement = document.documentElement;

    const getPreferredTheme = () => {
        const storedTheme = localStorage.getItem('nexus-theme');
        if (storedTheme) {
            return storedTheme;
        }
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };

    const setTheme = (theme) => {
        if (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            htmlElement.setAttribute('data-bs-theme', 'dark');
        } else {
            htmlElement.setAttribute('data-bs-theme', theme);
        }
        updateSwitcherIcon(theme);
    };

    const updateSwitcherIcon = (theme) => {
        if (themeSwitcherButton) {
            const icon = themeSwitcherButton.querySelector('i.bi');
            if (icon) {
                if (theme === 'dark') {
                    icon.classList.remove('bi-moon-stars-fill');
                    icon.classList.add('bi-sun-fill');
                } else {
                    icon.classList.remove('bi-sun-fill');
                    icon.classList.add('bi-moon-stars-fill');
                }
            }
        }
    };

    const currentTheme = getPreferredTheme();
    setTheme(currentTheme); // Set initial theme

    if (themeSwitcherButton) {
        themeSwitcherButton.addEventListener('click', () => {
            let newTheme = htmlElement.getAttribute('data-bs-theme') === 'light' ? 'dark' : 'light';
            localStorage.setItem('nexus-theme', newTheme);
            setTheme(newTheme);
        });
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        const storedTheme = localStorage.getItem('nexus-theme');
        if (storedTheme !== 'light' && storedTheme !== 'dark') { // Only if not manually overridden
            setTheme(getPreferredTheme());
        }
    });
}

// Optional: Custom sidebar toggle if Bootstrap's default is not sufficient
// function setupCustomSidebarToggle() {
//     const sidebar = document.getElementById('sidebarMenu');
//     const sidebarToggler = document.querySelector('[data-bs-target="#sidebarMenu"]'); // Standard Bootstrap toggler
//
//     if (sidebar && sidebarToggler) {
//         // You can listen to Bootstrap's events if more complex logic is needed
//         // sidebar.addEventListener('shown.bs.collapse', function () { ... });
//         // sidebar.addEventListener('hidden.bs.collapse', function () { ... });
//     }
// }

// CSRF setup for jQuery AJAX (if jQuery is used and Flask-WTF CSRF is active)
// function setupJQueryAjaxCsrf() {
//     if (typeof jQuery !== 'undefined') {
//         const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
//         if (csrfToken) {
//             jQuery.ajaxSetup({
//                 beforeSend: function(xhr, settings) {
//                     if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
//                         xhr.setRequestHeader("X-CSRFToken", csrfToken);
//                     }
//                 }
//             });
//         }
//     }
// }

// utils.js will contain helper functions like showNexusNotification, postData etc.
// For now, main.js calls them assuming they will be in utils.js or this file.
// Let's move showNexusNotification and postData to utils.js for better organization later.
// --- START: Sidebar Toggle Script ---
document.addEventListener('DOMContentLoaded', function() {
    const sidebar = document.getElementById('sidebarMenu');
    const sidebarToggle = document.getElementById('sidebarToggle'); // Hamburger in navbar
    const sidebarCloseButton = document.getElementById('sidebarCloseButton'); // 'X' in sidebar
    const body = document.body;

    if (!sidebar) {
        if (sidebarToggle) {
            sidebarToggle.style.display = 'none';
        }
        return;
    }
    if (!sidebarToggle && !sidebarCloseButton && !sidebar) { // if no sidebar at all, or no toggles
        return; 
    }


    const SIDEBAR_COLLAPSED_KEY = 'nexusSidebarCollapsedState';

    function setSidebarState(isCollapsed) {
        if (!sidebar) return; // Defensive check

        if (isCollapsed) {
            sidebar.classList.add('collapsed');
            body.classList.add('sidebar-is-collapsed');
            if (sidebarToggle) sidebarToggle.setAttribute('aria-expanded', 'false');
        } else {
            sidebar.classList.remove('collapsed');
            body.classList.remove('sidebar-is-collapsed');
            if (sidebarToggle) sidebarToggle.setAttribute('aria-expanded', 'true');
        }
    }

    function toggleSidebar() {
        if (!sidebar) return; // Defensive check
        const isCurrentlyCollapsed = sidebar.classList.contains('collapsed');
        const newStateIsCollapsed = !isCurrentlyCollapsed;
        setSidebarState(newStateIsCollapsed);
        localStorage.setItem(SIDEBAR_COLLAPSED_KEY, String(newStateIsCollapsed));
    }

    if (sidebarToggle) {
        sidebarToggle.addEventListener('click', function() {
            toggleSidebar();
        });
    }

    if (sidebarCloseButton) {
        sidebarCloseButton.addEventListener('click', function() {
            setSidebarState(true);
            localStorage.setItem(SIDEBAR_COLLAPSED_KEY, 'true');
        });
    }

    // --- Initial state on page load ---
    if (sidebar) { // Only apply initial state if sidebar exists
        let initiallyCollapsed;
        const storedState = localStorage.getItem(SIDEBAR_COLLAPSED_KEY);

        if (storedState !== null) {
            initiallyCollapsed = (storedState === 'true');
        } else {
            // Default behavior:
            // Collapsed on small screens, visible on larger screens
            initiallyCollapsed = window.innerWidth < 768;
        }
        // Apply initial state directly without transition for the first load to prevent flash
        sidebar.style.transition = 'none'; // Disable transition temporarily
        body.style.transition = 'none'; // Disable transition on body for margin changes
        
        setSidebarState(initiallyCollapsed);
        
        // Force reflow/repaint before re-enabling transitions
        // This helps ensure the initial state is applied without animation
        void sidebar.offsetWidth; 
        void body.offsetWidth;

        // Re-enable transitions after a very short delay
        setTimeout(() => {
            sidebar.style.transition = ''; // Revert to CSS defined transition
            body.style.transition = '';    // Revert to CSS defined transition
        }, 50); // 50ms should be enough
    }
});
// --- END: Sidebar Toggle Script ----e 

===== static/js/ui.js =====
/**
 * ui.js
 * Contains general UI enhancements for the entire application.
 */
export function initializeUI() {
    // Auto-expanding textareas from Phase 3, now modularized.
    document.querySelectorAll('.content-textarea').forEach(textarea => {
        textarea.style.height = 'auto'; // Recalculate on load
        textarea.style.height = (textarea.scrollHeight) + 'px';
        textarea.addEventListener('input', function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
    });

    console.log('UI Module Initialized.');
}-e 

===== static/js/socketHandlers.js =====
// static/js/socketHandlers.js (Evolved from socket-client.js)
"use strict";

const socket = io();
const eventCallbacks = {}; // Store registered callbacks for specific events

// --- Core Connection Handling ---
socket.on('connect', () => {
    console.log('Nexus Realtime: Connected - ID:', socket.id);
    // Optional: If backend needs user identification upon connection for presence, etc.
    // if (typeof currentUserId !== 'undefined') { // Assuming currentUserId is globally available or passed
    //     socket.emit('user_online_status', { userId: currentUserId, status: 'online' });
    // }
});

socket.on('disconnect', (reason) => {
    console.warn('Nexus Realtime: Disconnected - Reason:', reason);
    // Handle specific disconnect reasons if necessary (e.g., server-initiated)
    if (reason === 'io server disconnect') {
        socket.connect(); // Attempt to reconnect if server initiated
    }
});

socket.on('error', (error) => {
    console.error('Nexus Realtime: Socket Error -', error);
    // Optionally, use showNexusNotification from utils.js for user feedback on persistent errors
    // showNexusNotification('Real-time Connection Issue', 'Experiencing problems with live updates.', 'warning');
});

// --- Generic Event Listener and Dispatcher ---
// This function will be used internally by the specific event handlers below
// or by specific event listeners registered by other modules.
function handleGenericEvent(eventName, data) {
    if (eventCallbacks[eventName]) {
        eventCallbacks[eventName].forEach(callback => {
            try {
                callback(data);
            } catch (e) {
                console.error(`Error in callback for event ${eventName}:`, e, 'Data:', data);
            }
        });
    }
}

// --- Existing Social Event Handlers (Retained & Managed) ---
socket.on('new_comment', (data) => {
    console.log('Nexus Realtime: Received new_comment', data);
    handleGenericEvent('new_comment', data); // Dispatch to registered callbacks
    // Original direct DOM manipulation from socket-client.js can be moved to social.js
    // and registered as a callback via onNewComment().
});

socket.on('like_update', (data) => {
    console.log('Nexus Realtime: Received like_update', data);
    handleGenericEvent('like_update', data);
    // Original direct DOM manipulation from socket-client.js can be moved to social.js.
});

// --- NEW Event Handlers (to be added as per Wonder Proposal & future phases) ---
// Example:
// socket.on('new_global_post', (data) => {
//     console.log('Nexus Realtime: Received new_global_post', data);
//     handleGenericEvent('new_global_post', data);
// });
// socket.on('typing_indicator_dm', (data) => handleGenericEvent('typing_indicator_dm', data));
// ... other social event listeners ...

// --- Public API for this Module ---
const realtimeManager = {
    // Functions to emit events TO the server (from existing socket-client.js)
    joinPostRoom: function(postId, roomType = 'global_post') { // roomType for flexibility
        if (socket.connected) {
            socket.emit('join_post_room', { post_id: postId, room_type: roomType });
            console.log(`Nexus Realtime: Emitted join_post_room for ${roomType}-${postId}`);
        } else {
            console.warn('Nexus Realtime: Cannot join room, socket not connected.');
        }
    },
    leavePostRoom: function(postId, roomType = 'global_post') {
        if (socket.connected) {
            socket.emit('leave_post_room', { post_id: postId, room_type: roomType });
            console.log(`Nexus Realtime: Emitted leave_post_room for ${roomType}-${postId}`);
        }
    },
    // NEW: Functions for other modules to subscribe to specific events
    on: function(eventName, callback) {
        if (!eventCallbacks[eventName]) {
            eventCallbacks[eventName] = [];
        }
        eventCallbacks[eventName].push(callback);
        console.log(`Nexus Realtime: Callback registered for event '${eventName}'`);
    },
    // NEW: Functions for other modules to emit custom events (if needed, less common for client->server this way)
    // emitToServer: function(eventName, data) {
    //     if (socket.connected) {
    //         socket.emit(eventName, data);
    //     }
    // }
    // Expose the raw socket if absolutely necessary for advanced, direct use (use with caution)
    // getSocket: function() { return socket; }
};

console.log('Nexus Realtime Manager Initialized.');

// Export if using ES6 modules (recommended if app.js is type="module")
// export default realtimeManager; 
// If not using modules yet, make it globally available (e.g., window.nexusRealtimeManager = realtimeManager;)
// For now, assuming global or to be bundled appropriately by Flask-Assets
window.nexusRealtimeManager = realtimeManager;-e 

===== static/js/utils.js =====
// Nexus School Management System - utils.js
// Gemini 3 Pro Preview - Phase A.1 (Initial Version)
// This file will contain shared JavaScript utility functions.

"use strict";

/**
 * Displays a SweetAlert2 notification.
 * @param {string} title - The title of the alert.
 * @param {string} text - The main text/content of the alert.
 * @param {string} icon - Type of icon (e.g., 'success', 'error', 'warning', 'info', 'question').
 * @param {string} confirmButtonText - Text for the confirm button.
 */
function showNexusNotification(title, text, icon = 'info', confirmButtonText = 'OK') {
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            title: title,
            html: text, // Use html to allow for simple HTML tags in text
            icon: icon,
            confirmButtonText: confirmButtonText,
            customClass: {
                confirmButton: 'btn btn-primary px-4 nexus-swal-button', // Custom class for BS styling
                popup: 'nexus-swal-popup',
                title: 'nexus-swal-title',
                htmlContainer: 'nexus-swal-html-container',
            },
            buttonsStyling: false // Use custom Bootstrap styling via customClass
        });
    } else {
        // Fallback to standard alert if SweetAlert2 is not loaded
        alert(title + (text ? '\n\n' + text : ''));
        console.warn('SweetAlert2 (Swal) is not defined. Using native alert as fallback.');
    }
}

/**
 * Performs an asynchronous POST request with JSON data.
 * @param {string} url - The URL to send the POST request to.
 * @param {object} data - The JavaScript object to send as JSON.
 * @returns {Promise<object>} - A promise that resolves with the JSON response.
 * @throws {Error} - Throws an error if the network response is not ok or if parsing fails.
 */
async function postData(url = '', data = {}) {
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    const headers = {
        'Content-Type': 'application/json',
    };
    if (csrfToken) {
        headers['X-CSRFToken'] = csrfToken;
    }

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(data)
        });

        const responseData = await response.json(); // Attempt to parse JSON regardless of status for error messages

        if (!response.ok) {
            console.error('Fetch error (postData):', response.status, responseData);
            // Prefer error message from server response if available
            const errorMessage = responseData.error || responseData.message || `HTTP error! Status: ${response.status}`;
            throw new Error(errorMessage);
        }
        return responseData;
    } catch (error) {
        console.error('Error in postData:', error.message);
        // Show a user-friendly error, but also throw for calling code to handle
        showNexusNotification('Request Failed', `An error occurred: ${error.message}`, 'error');
        throw error;
    }
}

/**
 * Performs an asynchronous GET request.
 * @param {string} url - The URL to send the GET request to.
 * @returns {Promise<object>} - A promise that resolves with the JSON response.
 * @throws {Error} - Throws an error if the network response is not ok or if parsing fails.
 */
async function getData(url = '') {
    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                // CSRF typically not needed for GET, but include if your setup requires it for some reason
                // 'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
            }
        });

        const responseData = await response.json();

        if (!response.ok) {
            console.error('Fetch error (getData):', response.status, responseData);
            const errorMessage = responseData.error || responseData.message || `HTTP error! Status: ${response.status}`;
            throw new Error(errorMessage);
        }
        return responseData;
    } catch (error) {
        console.error('Error in getData:', error.message);
        showNexusNotification('Request Failed', `An error occurred: ${error.message}`, 'error');
        throw error;
    }
}


/**
 * Debounce function to limit the rate at which a function can fire.
 * @param {Function} func - The function to debounce.
 * @param {number} delay - The delay in milliseconds.
 * @returns {Function} - The debounced function.
 */
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}
// In static/js/utils.js

// ... (existing functions like showNexusNotification, postData, getData, debounce) ...

// --- Chart.js Analytics Display Functions ---
const commonChartOptions = {
    responsive: true,
    maintainAspectRatio: false, // Allows setting height via CSS or container
    plugins: {
        legend: {
            position: 'top',
            labels: {
                font: { family: "'Open Sans', sans-serif", size: 12 },
                color: getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim() || '#5a6268'
            }
        },
        tooltip: {
            bodyFont: { family: "'Open Sans', sans-serif" },
            titleFont: { family: "'Poppins', sans-serif", weight: '500' },
            backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--nexus-dark').trim() || '#212529',
            titleColor: getComputedStyle(document.documentElement).getPropertyValue('--nexus-light').trim() || '#f8f9fa',
            bodyColor: getComputedStyle(document.documentElement).getPropertyValue('--nexus-light').trim() || '#f8f9fa',
            borderColor: getComputedStyle(document.documentElement).getPropertyValue('--nexus-border-color').trim(),
            borderWidth: 1,
            padding: 10,
            boxPadding: 4
        }
    },
    scales: {
        y: {
            beginAtZero: true,
            ticks: {
                font: { family: "'Open Sans', sans-serif", size: 11 },
                color: getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim()
            },
            grid: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--nexus-border-color').trim(),
                borderColor: getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim()
            }
        },
        x: {
            ticks: {
                font: { family: "'Open Sans', sans-serif", size: 11 },
                color: getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim()
            },
            grid: {
                display: false, // Often cleaner to hide x-axis grid lines for bar/line
                borderColor: getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim()
            }
        }
    }
};

// Global storage for chart instances to prevent duplicates and allow updates/destruction
window.nexusCharts = window.nexusCharts || {};

/**
 * Fetches analytics data and renders a Chart.js chart.
 * @param {string} analyticsType - The type/endpoint for analytics data (e.g., 'attendance', 'performance').
 * @param {string} chartTitle - The title to be used for the chart legend/dataset label.
 * @param {string} chartContainerId - The ID of the div element that will contain the canvas.
 * @param {string} [defaultChartType='bar'] - The default Chart.js type (e.g., 'bar', 'line', 'pie', 'doughnut').
 */
async function fetchAndDisplayAnalytics(analyticsType, chartTitle, chartContainerId, defaultChartType = 'bar') {
    const chartContainer = document.getElementById(chartContainerId);
    const canvasId = chartContainerId.replace('Container', ''); // e.g., attendanceChart

    if (!chartContainer) {
        console.error(`Chart container #${chartContainerId} not found for analytics type: ${analyticsType}`);
        return;
    }

    // Clear previous chart or placeholder and recreate canvas
    if (window.nexusCharts[canvasId]) {
        window.nexusCharts[canvasId].destroy();
    }
    chartContainer.innerHTML = `<canvas id="${canvasId}"></canvas>`; // Recreate canvas to ensure clean state
    const canvasElement = document.getElementById(canvasId);
    if (!canvasElement) {
        console.error(`Canvas element #${canvasId} could not be created.`);
        chartContainer.innerHTML = `<div class="text-center text-danger p-3"><i class="bi bi-x-octagon-fill fs-2"></i><p>Chart canvas error.</p></div>`;
        return;
    }
    const ctx = canvasElement.getContext('2d');

    // Show loading state
    chartContainer.innerHTML = `
        <div class="content-placeholder d-flex flex-column justify-content-center align-items-center" style="min-height: 200px;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2 text-muted small">Loading ${chartTitle}...</p>
        </div>`;

    try {
        const data = await getData(`/analytics/${analyticsType}`); // getData from utils.js

        if (data.error) {
            throw new Error(data.error);
        }

        if (data.labels && (data.data || data.datasets)) {
            let chartType = data.chart_type || defaultChartType;
            let specificChartOptions = JSON.parse(JSON.stringify(commonChartOptions)); // Deep clone

            // Type-specific option overrides
            if (chartType === 'doughnut' || chartType === 'pie') {
                specificChartOptions.plugins.legend.position = 'right';
                delete specificChartOptions.scales.x; // No x-axis for pie/doughnut
                delete specificChartOptions.scales.y; // No y-axis
            } else if (chartType === 'line') {
                 specificChartOptions.scales.x.grid.display = true; // Show x-grid for line usually
            }
            
            // Update colors in options based on current theme (if needed dynamically)
            specificChartOptions.plugins.legend.labels.color = getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim();
            specificChartOptions.plugins.tooltip.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--nexus-dark').trim(); // Note: tooltip bg might be better fixed
            specificChartOptions.plugins.tooltip.titleColor = getComputedStyle(document.documentElement).getPropertyValue('--nexus-light').trim();
            specificChartOptions.plugins.tooltip.bodyColor = getComputedStyle(document.documentElement).getPropertyValue('--nexus-light').trim();
            specificChartOptions.plugins.tooltip.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--nexus-border-color').trim();

            if (specificChartOptions.scales.y) {
                specificChartOptions.scales.y.ticks.color = getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim();
                specificChartOptions.scales.y.grid.color = getComputedStyle(document.documentElement).getPropertyValue('--nexus-border-color').trim();
                specificChartOptions.scales.y.grid.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim();
            }
            if (specificChartOptions.scales.x) {
                specificChartOptions.scales.x.ticks.color = getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim();
                 specificChartOptions.scales.x.grid.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--nexus-text-secondary').trim();
            }


            // Re-clear container and add canvas back for Chart.js
            chartContainer.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            const finalCtx = document.getElementById(canvasId).getContext('2d');

            // Define some color palettes for charts
            const nexusColorPalette = [
                'rgba(13, 71, 161, 0.7)',   // Primary
                'rgba(0, 121, 107, 0.7)',  // Info (Teal)
                'rgba(255, 193, 7, 0.7)',  // Warning
                'rgba(25, 118, 210, 0.7)', // Secondary
                'rgba(220, 53, 69, 0.7)',  // Danger
                'rgba(108, 117, 125, 0.7)' // Dark Grey (Bootstrap Dark)
            ];
            const nexusBorderPalette = [
                'rgb(13, 71, 161)',
                'rgb(0, 121, 107)',
                'rgb(255, 193, 7)',
                'rgb(25, 118, 210)',
                'rgb(220, 53, 69)',
                'rgb(108, 117, 125)'
            ];


            let chartDataStructure;
            if (data.datasets) { // For multi-dataset charts like grouped bar or multiple lines
                chartDataStructure = {
                    labels: data.labels,
                    datasets: data.datasets.map((dataset, index) => ({
                        ...dataset, // Spread existing dataset properties (label, data)
                        backgroundColor: dataset.backgroundColor || nexusColorPalette[index % nexusColorPalette.length],
                        borderColor: dataset.borderColor || nexusBorderPalette[index % nexusBorderPalette.length],
                        borderWidth: dataset.borderWidth || (chartType === 'line' ? 2 : 1),
                        fill: dataset.fill !== undefined ? dataset.fill : (chartType === 'line' ? false : undefined), // Line charts often not filled by default
                        tension: chartType === 'line' ? 0.4 : undefined, // Smooth lines
                    }))
                };
            } else { // For single dataset charts
                chartDataStructure = {
                    labels: data.labels,
                    datasets: [{
                        label: chartTitle,
                        data: data.data,
                        backgroundColor: (chartType === 'doughnut' || chartType === 'pie') ? nexusColorPalette : nexusColorPalette[0],
                        borderColor: (chartType === 'doughnut' || chartType === 'pie') ? '#fff' : nexusBorderPalette[0],
                        borderWidth: (chartType === 'doughnut' || chartType === 'pie') ? 2 : 1,
                        tension: chartType === 'line' ? 0.4 : undefined,
                    }]
                };
            }

            window.nexusCharts[canvasId] = new Chart(finalCtx, {
                type: chartType,
                data: chartDataStructure,
                options: specificChartOptions
            });
        } else {
            chartContainer.innerHTML = `<div class="text-center text-muted p-3 content-placeholder"><i class="bi bi-bar-chart-fill fs-2"></i><p class="mt-2">No data available to display for ${chartTitle}.</p></div>`;
        }
    } catch (error) {
        console.error(`Error loading ${analyticsType} analytics for chart ${canvasId}:`, error);
        chartContainer.innerHTML = `<div class="text-center text-danger p-3 content-placeholder"><i class="bi bi-wifi-off fs-2"></i><p class="mt-2">Could not load ${chartTitle}.</p><small>${error.message}</small></div>`;
    }
}-e 

===== static/js/notifications.js =====
// Nexus School Management System - notifications.js
// Gemini 3 Pro Preview - Phase D.1

"use strict";

document.addEventListener('DOMContentLoaded', function () {
    console.log('Nexus Notifications JS Initialized.');

    const markAllReadButton = document.getElementById('markAllReadBtn');
    if (markAllReadButton) {
        markAllReadButton.addEventListener('click', handleMarkAllNotificationsRead);
    }

    // Event delegation for dynamically added notification items (e.g., via AJAX polling)
    // or for items already on the page.
    document.body.addEventListener('click', function(event) {
        // Individual "Mark as Read" button on a notification item
        const markReadBtn = event.target.closest('.mark-notification-read-btn');
        if (markReadBtn) {
            event.preventDefault();
            const notificationId = markReadBtn.dataset.notificationId;
            if (notificationId) {
                handleMarkSingleNotificationRead(notificationId, markReadBtn.closest('.notification-item'));
            }
        }

        // Clicking on the notification item itself to mark as read (if link_url is # or primary action is AJAX)
        const notificationItem = event.target.closest('.notification-item.unread-notification');
        if (notificationItem && notificationItem.getAttribute('href') === '#') { // Only if it's a non-navigating item
            event.preventDefault();
            const notificationId = notificationItem.dataset.notificationId;
            if (notificationId) {
                handleMarkSingleNotificationRead(notificationId, notificationItem);
                // If there's a real link_url, browser navigation will happen after this.
                // If link_url is not '#', the AJAX call will still fire but browser navigates.
                // Consider if navigation should happen only *after* successful AJAX for non-'#' links.
            }
        } else if (notificationItem && notificationItem.getAttribute('href') !== '#') {
             // If it's an unread notification with a real link, mark it as read optimistically
             // before navigation or let backend handle it on page load of linked URL.
             // For now, backend handles on 'view_notifications' page load.
             // If link is clicked from dropdown, it should become read.
             const notificationId = notificationItem.dataset.notificationId;
             if (notificationId) {
                // Send a quick beacon or AJAX to mark as read without waiting for response
                // This is more advanced; for now, viewing /notifications marks them.
             }
        }
    });

    // Start polling for new notifications
    if (document.getElementById('notificationsDropdown')) { // Only poll if the dropdown exists
        startNotificationPolling();
    }
});

async function handleMarkAllNotificationsRead() {
    const button = document.getElementById('markAllReadBtn');
    if (button && button.disabled) return; // Prevent multiple clicks

    if (button) button.disabled = true;
    const originalButtonText = button ? button.innerHTML : '';
    if (button) button.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Marking...`;

    try {
        // Assumes utils.js and postData function are available
        const response = await postData('/notifications/mark-all-read'); // Backend route
        if (response.success) {
            showNexusNotification('Success', response.message || 'All notifications marked as read.', 'success');
            // Visually update all notification items on the current page
            document.querySelectorAll('.notification-item.unread-notification').forEach(item => {
                item.classList.remove('unread-notification', 'list-group-item-primary', 'bg-primary-subtle', 'border-primary-subtle');
                item.classList.add('list-group-item-light');
                item.querySelector('.text-primary.fw-bold')?.remove(); // Remove "New" badge
            });
            updateNavbarNotificationCount(0); // Update navbar count
            if (button) button.disabled = true; // Keep disabled as all are now read
        } else {
            showNexusNotification('Error', response.error || 'Failed to mark all notifications as read.', 'error');
            if (button) button.disabled = false;
        }
    } catch (error) {
        console.error("Error marking all notifications read:", error);
        showNexusNotification('Error', `An error occurred: ${error.message}`, 'error');
        if (button) button.disabled = false;
    } finally {
         if (button) button.innerHTML = originalButtonText;
         // Re-check if button should be disabled (if some items failed to mark, for example)
         const unreadCount = document.querySelectorAll('.notification-item.unread-notification').length;
         if (button) button.disabled = (unreadCount === 0);
    }
}

async function handleMarkSingleNotificationRead(notificationId, notificationElement) {
    if (!notificationElement || !notificationElement.classList.contains('unread-notification')) {
        // Already read or element not found
        return;
    }

    try {
        const response = await postData(`/notifications/mark-read/${notificationId}`);
        if (response.success) {
            if (notificationElement) {
                notificationElement.classList.remove('unread-notification', 'list-group-item-primary', 'bg-primary-subtle', 'border-primary-subtle');
                notificationElement.classList.add('list-group-item-light');
                notificationElement.querySelector('.text-primary.fw-bold')?.remove(); // Remove "New" badge
            }
            // Decrement navbar count
            const currentCount = parseInt(document.getElementById('notificationsDropdown')?.querySelector('.badge')?.textContent || '0');
            updateNavbarNotificationCount(Math.max(0, currentCount - 1));
        } else {
            // Silently fail or show small error, as this might happen in background
            console.warn(`Failed to mark notification ${notificationId} as read: ${response.error}`);
        }
    } catch (error) {
        console.error(`Error marking notification ${notificationId} read:`, error);
    }
}

let notificationPollInterval;
let lastNotificationTimestamp = Date.now(); // Initialize with current time

function startNotificationPolling(interval = 30000) { // Poll every 30 seconds
    console.log('Notification polling started.');
    // Initial fetch
    fetchNewNotifications();

    // Clear any existing interval
    if (notificationPollInterval) {
        clearInterval(notificationPollInterval);
    }
    notificationPollInterval = setInterval(fetchNewNotifications, interval);
}

function stopNotificationPolling() {
    if (notificationPollInterval) {
        clearInterval(notificationPollInterval);
        notificationPollInterval = null;
        console.log('Notification polling stopped.');
    }
}

async function fetchNewNotifications() {
    const notificationsDropdown = document.getElementById('notificationsDropdown');
    const notificationItemsContainer = document.getElementById('notification-items-container'); // In navbar dropdown

    if (!notificationsDropdown || !notificationItemsContainer) return;

    try {
        // Assumes utils.js and getData function are available
        const data = await getData(`/notifications/check-new?since=${lastNotificationTimestamp}`);

        if (data.error) {
            console.error('Error fetching new notifications:', data.error);
            // Potentially stop polling if server error persists
            return;
        }

        lastNotificationTimestamp = data.latestTimestamp || Date.now();

        if (data.newNotifications && data.newNotifications.length > 0) {
            // Prepend new notifications to the dropdown
            let hasNewUnread = false;
            data.newNotifications.forEach(htmlSnippet => {
                // Create a temporary div to parse the snippet
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlSnippet.trim();
                const newNotificationElement = tempDiv.firstChild;

                if (newNotificationElement) {
                    // Check if it's actually unread before prepending
                    if (newNotificationElement.classList.contains('unread-notification')) {
                        hasNewUnread = true;
                    }
                    notificationItemsContainer.prepend(newNotificationElement);
                }
            });

            // Remove "No new notifications" placeholder if it exists and we added new items
            const placeholder = notificationItemsContainer.querySelector('a.dropdown-item small.text-muted');
            if (placeholder && placeholder.textContent.includes("No new notifications")) {
                placeholder.parentElement.remove();
            }


            // Limit the number of items in the dropdown
            const maxItemsInDropdown = 10;
            while (notificationItemsContainer.children.length > maxItemsInDropdown) {
                notificationItemsContainer.removeChild(notificationItemsContainer.lastChild);
            }

            // Update the main unread count in the navbar
            // The backend's `check_new_notifications` should ideally send the *total* current unread count
            // For now, we'll estimate based on what was fetched.
            // A more robust way is to fetch the total unread count separately or have it in the poll response.
            const currentBadge = notificationsDropdown.querySelector('.badge');
            if (currentBadge) {
                 // For simplicity, let's assume the backend will provide an updated total unread count
                 // with a separate API call or in the polling response.
                 // For now, just add the number of new notifications to the existing count.
                 // This is not perfectly accurate if some were read elsewhere.
                 // Ideally, the /notifications/check-new endpoint should return the new totalUnreadCount.
                 // Let's assume data.totalUnreadCount exists.
                 if (typeof data.totalUnreadCount === 'number') {
                     updateNavbarNotificationCount(data.totalUnreadCount);
                 } else if (hasNewUnread) { // Fallback: crudely increment if new unread items arrived
                    const existingCount = parseInt(currentBadge.textContent || '0');
                    updateNavbarNotificationCount(existingCount + data.newNotifications.filter(n => n.includes('unread-notification')).length);
                 }
            } else if (data.totalUnreadCount > 0 || (data.newNotifications && data.newNotifications.length > 0 && hasNewUnread)) {
                // Create badge if it doesn't exist and there are new notifications
                 const newBadge = document.createElement('span');
                 newBadge.className = 'position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger';
                 newBadge.textContent = data.totalUnreadCount || data.newNotifications.filter(n => n.includes('unread-notification')).length;
                 const visuallyHidden = document.createElement('span');
                 visuallyHidden.className = 'visually-hidden';
                 visuallyHidden.textContent = 'unread notifications';
                 newBadge.appendChild(visuallyHidden);
                 notificationsDropdown.appendChild(newBadge);
            }

            if (hasNewUnread) {
                 showNexusNotification('New Notification!', `${data.newNotifications.length} new notification(s) received.`, 'info');
            }
        }
    } catch (error) {
        console.error('Error polling for notifications:', error);
        // Optionally, display a subtle error to the user or stop polling after too many errors
    }
}

function updateNavbarNotificationCount(count) {
    const notificationsDropdown = document.getElementById('notificationsDropdown');
    if (!notificationsDropdown) return;

    let badge = notificationsDropdown.querySelector('.badge');
    if (count > 0) {
        if (!badge) {
            badge = document.createElement('span');
            badge.className = 'position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger';
            const visuallyHidden = document.createElement('span');
            visuallyHidden.className = 'visually-hidden';
            visuallyHidden.textContent = 'unread notifications';
            badge.appendChild(visuallyHidden);
            notificationsDropdown.appendChild(badge);
        }
        badge.textContent = count;
        // Ensure visually hidden text is still there if we just update textContent
        if (!badge.querySelector('.visually-hidden')) {
             const visuallyHidden = document.createElement('span');
             visuallyHidden.className = 'visually-hidden';
             visuallyHidden.textContent = 'unread notifications';
             badge.appendChild(visuallyHidden);
        }
    } else {
        if (badge) {
            badge.remove();
        }
    }
    // Update the Mark All Read button state on the /notifications page
    const markAllReadButtonPage = document.getElementById('markAllReadBtn');
    if(markAllReadButtonPage) {
        markAllReadButtonPage.disabled = (count === 0);
    }
}

// Make functions globally available if needed by inline JS or other scripts, or keep them module-scoped.
// window.handleMarkAllNotificationsRead = handleMarkAllNotificationsRead;
// window.handleMarkSingleNotificationRead = handleMarkSingleNotificationRead;-e 

===== static/js/chat.js =====
// Nexus School Management System - chat.js
// Gemini 3 Pro Preview - Phase D.3

"use strict";

let currentChatTargetUserId = null;
let currentChatUserId = null;
let messagePollIntervalId = null;
let lastMessageTimestamp = 0; // Timestamp of the last received/fetched message for polling
const CHAT_POLL_INTERVAL = 5000; // Poll every 5 seconds for new messages

// DOM Elements (to be populated in initializeChat)
let chatWindowMessages = null;
let chatMessageForm = null;
let chatMessageInput = null;
let sendChatMessageBtn = null;
let typingIndicator = null;

/**
 * Initializes the chat interface for a specific target user.
 * @param {number} targetUserId - The ID of the user to chat with.
 * @param {number} currentUserId - The ID of the currently logged-in user.
 */
function initializeChat(targetUserId, userId) {
    console.log(`Initializing chat with User ID: ${targetUserId}`);
    currentChatTargetUserId = targetUserId;
    currentChatUserId = userId;

    chatWindowMessages = document.getElementById('chatWindowMessages');
    chatMessageForm = document.getElementById('chatMessageForm');
    chatMessageInput = document.getElementById('chatMessageInput');
    sendChatMessageBtn = document.getElementById('sendChatMessageBtn');
    typingIndicator = document.getElementById('typingIndicator');

    if (!chatWindowMessages || !chatMessageForm || !chatMessageInput || !sendChatMessageBtn) {
        console.error('Chat UI elements not found. Chat functionality will be limited.');
        return;
    }

    // Set initial lastMessageTimestamp from the newest message already on the page
    const lastExistingMessageElement = chatWindowMessages.querySelector('.chat-message-wrapper:last-child .message-timestamp');
    if (lastExistingMessageElement && lastExistingMessageElement.title) {
        try {
            // Assuming title has 'YYYY-MM-DD HH:MM:SS UTC'
            const parts = lastExistingMessageElement.title.replace(' UTC', '').split(/[\s:-]+/);
            // new Date(year, monthIndex, day, hours, minutes, seconds)
            const dateObj = new Date(Date.UTC(parts[0], parts[1]-1, parts[2], parts[3], parts[4], parts[5]));
            lastMessageTimestamp = dateObj.getTime();
        } catch (e) {
            console.warn('Could not parse last message timestamp from existing messages.', e);
            lastMessageTimestamp = Date.now() - (CHAT_POLL_INTERVAL * 2); // Start polling from a bit in the past
        }
    } else {
        lastMessageTimestamp = Date.now() - (CHAT_POLL_INTERVAL * 2); // Default if no messages
    }


    // Scroll to the bottom of the chat window initially (if messages are loaded top-to-bottom)
    // If using flex-direction: column-reverse, this might not be needed or behaves differently.
    // For column-reverse, the container itself scrolls.
    scrollToChatBottom(true);

    // Attach event listener for sending messages
    chatMessageForm.addEventListener('submit', handleSendMessage);

    // Optional: Implement "is typing" functionality
    // chatMessageInput.addEventListener('input', handleTyping);

    // Start polling for new messages
    startMessagePolling();

    // Mark messages from this user as read (could be an API call)
    // This is more complex as it requires knowing which messages were unread *before* opening.
    // For now, assume backend handles "is_read" update when messages are fetched for `universal_chat.html`
    // or via a dedicated "mark as read" API endpoint if needed.
    // A simple approach: if this chat is active, consider messages from targetUser as "seen"
    // markMessagesAsReadFromTarget(targetUserId); // Placeholder for more robust logic
}

/**
 * Scrolls the chat window to the bottom.
 * @param {boolean} [force=false] - Force scroll even if user might have scrolled up.
 */
function scrollToChatBottom(force = false) {
    if (chatWindowMessages) {
        // For flex-direction: column-reverse, scroll top is effectively the bottom.
        // We want to ensure new messages are visible.
        // If the user hasn't scrolled up significantly, auto-scroll.
        const threshold = 100; // Pixels from bottom to trigger auto-scroll
        const isScrolledToBottom = chatWindowMessages.scrollTop < threshold; // For column-reverse, scrollTop is near 0 when at bottom

        if (force || isScrolledToBottom) {
            chatWindowMessages.scrollTop = 0; // Scroll to the top (which is visually the bottom for column-reverse)
        }
    }
}

/**
 * Handles the chat message form submission.
 * @param {Event} event - The form submission event.
 */
async function handleSendMessage(event) {
    event.preventDefault();
    if (!chatMessageInput || !currentChatTargetUserId) return;

    const content = chatMessageInput.value.trim();
    if (!content) {
        showNexusNotification('Empty Message', 'Cannot send an empty message.', 'warning');
        return;
    }
    if (content.length > 2000) {
        showNexusNotification('Message Too Long', 'Messages are limited to 2000 characters.', 'warning');
        return;
    }

    const originalButtonText = sendChatMessageBtn.innerHTML;
    sendChatMessageBtn.disabled = true;
    sendChatMessageBtn.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Sending...`;
    chatMessageInput.disabled = true;

    // Optimistic UI update (optional, but improves perceived performance)
    // const optimisticMessageData = {
    //     id: 'temp-' + Date.now(), // Temporary ID
    //     sender_id: currentChatUserId,
    //     sender: { /* current_user basic info */ full_name: 'You', profile_photo_url: null /* get from current_user */ },
    //     content: content,
    //     timestamp: new Date().toISOString(), // Use ISO string for consistency with backend
    //     is_optimistic: true
    // };
    // appendMessageToChat(optimisticMessageData, currentChatUserId);

    try {
        // Assumes utils.js and postData function are available
        // The backend route /chat/user/<target_user_id> should handle POST requests
        const response = await postData(chatMessageForm.action, { message: content });

        if (response.success && response.message_data) {
            // If using optimistic update, remove the temporary message and add the confirmed one
            // document.getElementById(optimisticMessageData.id)?.remove();
            // appendMessageToChat(response.message_data, currentChatUserId);
            
            // If not using optimistic, just clear input and let polling fetch it
            // However, for better UX, we should append the sent message immediately
            // The backend should return the created message object.
            appendMessageToChat(response.message_data, currentChatUserId);
            chatMessageInput.value = '';
            chatMessageInput.style.height = 'auto'; // Reset textarea height
            lastMessageTimestamp = new Date(response.message_data.timestamp).getTime(); // Update timestamp
        } else {
            // Remove optimistic message if it failed
            // document.getElementById(optimisticMessageData.id)?.remove();
            showNexusNotification('Send Error', response.error || 'Failed to send message. Please try again.', 'error');
        }
    } catch (error) {
        console.error('Error sending message:', error);
        // document.getElementById(optimisticMessageData.id)?.remove();
        showNexusNotification('Send Error', `An error occurred: ${error.message}`, 'error');
    } finally {
        sendChatMessageBtn.disabled = false;
        sendChatMessageBtn.innerHTML = originalButtonText;
        chatMessageInput.disabled = false;
        chatMessageInput.focus();
    }
}

/**
 * Appends a new message to the chat window.
 * @param {object} messageData - The message data object.
 * @param {number} currentUserId - The ID of the current user.
 */
function appendMessageToChat(messageData, currentUserId) {
    if (!chatWindowMessages || !messageData) return;

    // Create the message element using a template or direct DOM manipulation
    // This logic should mirror the _chat_message_item.html partial
    const isSender = messageData.sender_id === currentUserId;
    const senderName = messageData.sender ? (messageData.sender.full_name || messageData.sender.username) : "Unknown User";
    let senderAvatar = '/static/img/placeholders/user_avatar_default.png'; // Default
    if (messageData.sender && messageData.sender.profile_photo_url) {
        senderAvatar = `/static/${messageData.sender.profile_photo_url}`;
    }


    const messageWrapper = document.createElement('div');
    messageWrapper.className = `chat-message-wrapper d-flex mb-3 ${isSender ? 'justify-content-end' : 'justify-content-start'}`;
    if (messageData.id) messageWrapper.id = `message-${messageData.id}`;


    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message d-flex flex-column ${isSender ? 'sent align-items-end' : 'received align-items-start'}`;
    messageDiv.style.maxWidth = '75%';

    const innerFlex = document.createElement('div');
    innerFlex.className = `d-flex align-items-end ${isSender ? 'flex-row-reverse' : ''}`;

    if (!isSender) {
        const img = document.createElement('img');
        img.src = senderAvatar;
        img.alt = senderName;
        img.className = 'rounded-circle me-2 shadow-sm';
        img.style.width = '30px';
        img.style.height = '30px';
        img.style.objectFit = 'cover';
        innerFlex.appendChild(img);
    }

    const bubble = document.createElement('div');
    bubble.className = 'message-bubble p-2 px-3 shadow-sm';
    const contentP = document.createElement('p');
    contentP.className = 'mb-0 message-content';
    contentP.textContent = messageData.content; // Assuming content is plain text
    bubble.appendChild(contentP);
    innerFlex.appendChild(bubble);
    messageDiv.appendChild(innerFlex);

    const timestampSmall = document.createElement('small');
    timestampSmall.className = `message-timestamp text-muted mt-1 ${isSender ? 'me-1' : 'ms-1'}`;
    // Format timestamp (requires a JS utility or use ISO string directly for title)
    const dateObj = new Date(messageData.timestamp);
    timestampSmall.title = dateObj.toLocaleString('en-CA', { timeZone: 'UTC' }) + ' UTC'; // YYYY-MM-DD HH:MM:SS format

    let timeDiffStr = 'just now'; // Placeholder, implement time diff utility if needed
    // Example using a simple time display:
    timeDiffStr = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });


    timestampSmall.innerHTML = `${!isSender ? `<span class="fw-medium">${senderName.split(' ')[0]}</span>  ` : ''}${timeDiffStr}`;
    messageDiv.appendChild(timestampSmall);

    messageWrapper.appendChild(messageDiv);

    // Remove "Start the Conversation" placeholder if it exists
    const placeholder = chatWindowMessages.querySelector('.text-center.text-muted');
    if (placeholder && placeholder.textContent.includes("Start the Conversation")) {
        placeholder.remove();
    }

    chatWindowMessages.prepend(messageWrapper); // Prepend because of column-reverse
    scrollToChatBottom(true); // Force scroll for new message
}


/**
 * Starts polling for new messages.
 */
function startMessagePolling() {
    if (!currentChatTargetUserId) return;

    console.log(`Starting message polling for chat with ${currentChatTargetUserId}. Last timestamp: ${new Date(lastMessageTimestamp).toISOString()}`);
    stopMessagePolling(); // Clear any existing interval

    // Initial fetch immediately
    fetchNewMessages();

    messagePollIntervalId = setInterval(fetchNewMessages, CHAT_POLL_INTERVAL);
}

/**
 * Stops polling for new messages.
 */
function stopMessagePolling() {
    if (messagePollIntervalId) {
        clearInterval(messagePollIntervalId);
        messagePollIntervalId = null;
        console.log('Message polling stopped.');
    }
}

/**
 * Fetches new messages from the server since the last known timestamp.
 */
async function fetchNewMessages() {
    if (!currentChatTargetUserId || !chatWindowMessages) return;

    // Construct the API endpoint URL
    // Assumes a backend route like /chat/api/messages/<int:other_user_id>/new?since=<timestamp_ms>
    const apiUrl = `/chat/api/messages/${currentChatTargetUserId}/new?since=${lastMessageTimestamp}`;

    try {
        const data = await getData(apiUrl); // Assumes utils.js and getData are available

        if (data.error) {
            console.error('Error fetching new messages:', data.error);
            // Potentially stop polling if server error persists (e.g., auth failure)
            if (data.stop_polling) stopMessagePolling();
            return;
        }

        if (data.messages && data.messages.length > 0) {
            data.messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); // Ensure ascending order
            data.messages.forEach(msg => {
                // Check if message already exists (e.g., from optimistic update or previous poll)
                if (!document.getElementById(`message-${msg.id}`)) {
                    appendMessageToChat(msg, currentChatUserId);
                }
            });
            // Update lastMessageTimestamp with the timestamp of the newest message received
            lastMessageTimestamp = new Date(data.messages[data.messages.length - 1].timestamp).getTime();
        }
        // Update lastMessageTimestamp even if no new messages, to keep server 'since' fresh
        if (data.latest_timestamp) {
             lastMessageTimestamp = Math.max(lastMessageTimestamp, data.latest_timestamp);
        }


    } catch (error) {
        console.error('Error polling for new messages:', error);
        // Decide if polling should stop, e.g., after multiple consecutive errors
    }
}

// Clean up polling when the user navigates away from the chat page
// This requires detecting page unload or route changes if using a Single Page App (SPA)
// For traditional navigation, this isn't strictly necessary but good practice.
window.addEventListener('beforeunload', () => {
    stopMessagePolling();
});

// Placeholder for "is typing" functionality
// function handleTyping() {
//     // Send "typing" event to server via SocketIO or a quick AJAX ping
//     // Server then broadcasts to the target_user
// }
// function displayTypingIndicator(username) {
//     if (typingIndicator) typingIndicator.textContent = `${username} is typing...`;
// }
// function clearTypingIndicator() {
//     if (typingIndicator) typingIndicator.textContent = '';
// }-e 

===== static/js/talent_club.js =====
// Nexus School Management System - talent_club.js
"use strict";

document.addEventListener('DOMContentLoaded', function () {
    console.log('Nexus Talent Club JS Initialized.');

    // Event delegation for Talent Club actions (follow, unfollow, etc.)
    document.body.addEventListener('click', async function(event) {
        const actionButton = event.target.closest('.tc-action-btn');
        if (actionButton) {
            event.preventDefault();
            const clubId = actionButton.dataset.clubId;
            const action = actionButton.dataset.action;
            await handleTalentClubAction(clubId, action, actionButton);
        }

        // Note: TC Leader voting is typically handled by standard form submission,
        // not AJAX by default in this script.
    });

    // If initializeTcUserPickers was intended for OTHER pickers,
    // it could be called here, but ensure it doesn't re-initialize
    // 'mentioned_member_ids_picker'.
    // initializeTcUserPickers(); // Call if it has other purposes.
});

async function handleTalentClubAction(clubId, action, buttonElement) {
    if (!clubId || !action) return;

    const originalButtonHTML = buttonElement.innerHTML;
    buttonElement.disabled = true;
    buttonElement.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Working...`;

    let apiUrl = `/talent_club/${clubId}/${action.replace('_club', '')}`;

    try {
        const responseData = await postData(apiUrl, {});

        if (responseData.success) {
            showNexusNotification('Success!', responseData.message || 'Action completed successfully.', 'success');

            if (action === 'follow_club') {
                buttonElement.innerHTML = '<i class="bi bi-bell-slash-fill me-1"></i> Following';
                buttonElement.classList.remove('btn-primary');
                buttonElement.classList.add('btn-info');
                buttonElement.dataset.action = 'unfollow_club';
            } else if (action === 'unfollow_club') {
                buttonElement.innerHTML = '<i class="bi bi-bell-fill me-1"></i> Follow';
                buttonElement.classList.remove('btn-info', 'btn-outline-secondary');
                buttonElement.classList.add('btn-primary');
                buttonElement.dataset.action = 'follow_club';
            } else if (action === 'leave_club') {
                const clubCard = buttonElement.closest('.talent-club-card');
                if (clubCard && clubCard.parentElement && clubCard.parentElement.classList.contains('col')) {
                    clubCard.parentElement.remove();
                } else {
                     window.location.reload();
                }
            }

            if (typeof responseData.new_total_engagement === 'number') {
                const cardElement = buttonElement.closest('.talent-club-card');
                const engagementElement = cardElement?.querySelector('small.text-muted i.bi-people-fill')?.nextSibling;
                if (engagementElement && engagementElement.nodeType === Node.TEXT_NODE) {
                    engagementElement.textContent = ` ${responseData.new_total_engagement} Engaged`;
                }
            }
        } else {
            showNexusNotification('Action Failed', responseData.error || 'Could not complete action.', 'error');
            buttonElement.innerHTML = originalButtonHTML;
        }
    } catch (error) {
        console.error(`Error performing TC action '${action}' for club ${clubId}:`, error);
        showNexusNotification('Error', `An unexpected error occurred: ${error.message}`, 'error');
        buttonElement.innerHTML = originalButtonHTML;
    } finally {
        if (action !== 'leave_club' || (responseData && !responseData.success)) {
            buttonElement.disabled = false;
        }
    }
}

// --- TC Feed specific JS ---
// (Moved from social.js as these are specific to Talent Club Feed)

let currentTCClubId = null;
let currentTCFeedPage = 1;
let isLoadingTCPosts = false;

function initializeTCFeed(clubId, userId) {
    console.log(`Initializing TC Feed for Club ID: ${clubId}`);
    currentTCClubId = clubId;
    currentTCFeedPage = 1;

    const loadMoreButton = document.querySelector(`#loadMoreTcPostsTrigger-${clubId} .load-more-tc-posts-btn`);
    if (loadMoreButton) {
        loadMoreButton.addEventListener('click', function() {
            loadMoreTcFeedPosts(clubId, this);
        });
    }

    const feedContainer = document.getElementById(`tcFeedContainer-${clubId}`);
    if (feedContainer) {
        feedContainer.addEventListener('submit', async function(event) {
            const commentForm = event.target.closest('.tc-comment-form');
            if (commentForm) {
                event.preventDefault();
                await handleTCCommentSubmit(commentForm);
            }
        });

        feedContainer.addEventListener('click', async function(event) {
            const reactionBtn = event.target.closest('.tc-reaction-btn');
            if (reactionBtn) { event.preventDefault(); await handleTCReactionClick(reactionBtn); }

            const deletePostBtn = event.target.closest('.delete-tc-feed-post-btn');
            if (deletePostBtn) { event.preventDefault(); await handleDeleteTCFeedPost(deletePostBtn); }

            const deleteCommentBtn = event.target.closest('.delete-comment-btn');
            if (deleteCommentBtn && event.target.closest('.tc-feed-post-item')) {
                event.preventDefault(); await handleDeleteTCFeedComment(deleteCommentBtn);
            }
        });
    }
}
window.initializeTCFeed = initializeTCFeed; // Make global if called from inline script

async function loadMoreTcFeedPosts(clubId, buttonElement) {
    if (isLoadingTCPosts) return;
    isLoadingTCPosts = true;
    currentTCFeedPage++;

    const originalButtonHTML = buttonElement.innerHTML;
    buttonElement.disabled = true;
    buttonElement.innerHTML = `<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Loading...`;

    let responseData = null; // To access in finally block
    try {
        responseData = await getData(`/talent_club/${clubId}/feed/posts?page=${currentTCFeedPage}`);
        const feedContainer = document.getElementById(`tcFeedContainer-${clubId}`);
        const loadMoreTrigger = document.getElementById(`loadMoreTcPostsTrigger-${clubId}`);

        if (responseData.success && responseData.posts_html && feedContainer) {
            if(loadMoreTrigger) loadMoreTrigger.remove();
            feedContainer.insertAdjacentHTML('beforeend', responseData.posts_html);
        } else if (responseData.success && responseData.posts_html === '') {
            if(loadMoreTrigger) loadMoreTrigger.innerHTML = '<p class="text-muted small text-center mt-3">No more posts to load.</p>';
        } else {
            showNexusNotification('Error', responseData.error || 'Could not load more posts.', 'error');
            currentTCFeedPage--;
        }
    } catch (error) {
        showNexusNotification('Load Error', `Failed to load more posts: ${error.message}`, 'error');
        currentTCFeedPage--;
    } finally {
        isLoadingTCPosts = false;
        const currentTriggerButton = document.querySelector(`#loadMoreTcPostsTrigger-${clubId} .load-more-tc-posts-btn`);
        if(currentTriggerButton) { // If a new trigger button was added with the posts_html
            currentTriggerButton.disabled = !(responseData && responseData.has_next_page);
            currentTriggerButton.dataset.currentPage = currentTCFeedPage;
             if (!(responseData && responseData.has_next_page)) {
                 currentTriggerButton.classList.add('d-none'); // Hide if no next page
                 if (!document.querySelector(`#loadMoreTcPostsTrigger-${clubId} .end-of-feed-msg`)){
                    currentTriggerButton.parentElement.insertAdjacentHTML('beforeend', '<p class="text-muted small mt-2 end-of-feed-msg">End of feed.</p>');
                 }
            }
        } else if (buttonElement && !(responseData && responseData.has_next_page)) { // If old button is still there and no next page
            buttonElement.classList.add('d-none');
             if (!buttonElement.parentElement.querySelector('.end-of-feed-msg')){
                 buttonElement.parentElement.insertAdjacentHTML('beforeend', '<p class="text-muted small mt-2 end-of-feed-msg">End of feed.</p>');
             }
        } else if (buttonElement) { // Re-enable if there might be more pages but new button wasn't added
            buttonElement.innerHTML = originalButtonHTML;
            buttonElement.disabled = false;
        }
    }
}

async function handleTCCommentSubmit(form) {
    const postId = form.dataset.postId;
    const submitButton = form.querySelector('.tc-comment-submit-btn');
    const textarea = form.querySelector('.comment-input');
    const content = textarea.value.trim();
    if (!content) { showNexusNotification('Empty Comment', 'Cannot post an empty comment.', 'warning'); return; }

    const originalButtonHTML = submitButton.innerHTML;
    submitButton.disabled = true;
    submitButton.innerHTML = `<span class="spinner-border spinner-border-sm"></span>`;
    try {
        const responseData = await postData(`/talent_club/feed/posts/${postId}/comment`, { content });
        if (responseData.success && responseData.comment_html) {
            textarea.value = ''; textarea.style.height = 'auto';
            const commentsList = document.getElementById(`tc-comments-list-${postId}`);
            const noCommentsYet = commentsList?.querySelector('.no-comments-yet');
            if (noCommentsYet) noCommentsYet.remove();
            commentsList?.insertAdjacentHTML('beforeend', responseData.comment_html);
            const commentToggleBtn = document.querySelector(`[href="#tcCommentsCollapse-${postId}"] .badge`);
            if(commentToggleBtn) commentToggleBtn.textContent = parseInt(commentToggleBtn.textContent || '0') + 1;
        } else {
            showNexusNotification('Comment Error', responseData.error || 'Failed to post comment.', 'error');
        }
    } catch (error) {
        showNexusNotification('Comment Error', `An unexpected error occurred: ${error.message}`, 'error');
    } finally {
        submitButton.disabled = false;
        submitButton.innerHTML = originalButtonHTML;
    }
}

async function handleTCReactionClick(buttonElement) {
    const postId = buttonElement.dataset.postId;
    const emoji = buttonElement.dataset.reactionEmoji;
    const countSpan = buttonElement.querySelector('.reaction-count');
    let currentCount = parseInt(countSpan.textContent || '0');
    const isActive = buttonElement.classList.toggle('active');

    if(isActive) { buttonElement.classList.add('btn-primary', 'text-white'); buttonElement.classList.remove('btn-outline-secondary'); }
    else { buttonElement.classList.remove('btn-primary', 'text-white'); buttonElement.classList.add('btn-outline-secondary'); }
    countSpan.textContent = isActive ? currentCount + 1 : Math.max(0, currentCount - 1);

    try {
        const responseData = await postData(`/talent_club/feed/posts/${postId}/react`, { emoji });
        if (responseData.success) {
            if (typeof responseData.new_count === 'number') countSpan.textContent = responseData.new_count;
            if (typeof responseData.user_reacted === 'boolean') {
                if(responseData.user_reacted) {
                    buttonElement.classList.add('active', 'btn-primary', 'text-white');
                    buttonElement.classList.remove('btn-outline-secondary');
                } else {
                    buttonElement.classList.remove('active', 'btn-primary', 'text-white');
                    buttonElement.classList.add('btn-outline-secondary');
                }
            }
        } else { // Revert on server error
            buttonElement.classList.toggle('active');
            countSpan.textContent = currentCount;
            if(buttonElement.classList.contains('btn-primary')) {buttonElement.classList.remove('btn-primary','text-white'); buttonElement.classList.add('btn-outline-secondary');}
            else {buttonElement.classList.add('btn-primary','text-white'); buttonElement.classList.remove('btn-outline-secondary');}
            showNexusNotification('Reaction Error', responseData.error || 'Failed to apply reaction.', 'error');
        }
    } catch (error) { // Revert on fetch error
        buttonElement.classList.toggle('active');
        countSpan.textContent = currentCount;
        if(buttonElement.classList.contains('btn-primary')) {buttonElement.classList.remove('btn-primary','text-white'); buttonElement.classList.add('btn-outline-secondary');}
        else {buttonElement.classList.add('btn-primary','text-white'); buttonElement.classList.remove('btn-outline-secondary');}
        showNexusNotification('Reaction Error', `An unexpected error: ${error.message}`, 'error');
    }
}

async function handleDeleteTCFeedPost(buttonElement) {
    const postId = buttonElement.dataset.postId;
    const result = await Swal.fire({ title: 'Delete Post?', text: "This action cannot be undone.", icon: 'warning', showCancelButton: true, confirmButtonColor: 'var(--nexus-danger)', cancelButtonColor: 'var(--nexus-secondary)', confirmButtonText: 'Yes, delete it!', customClass: {popup: 'nexus-swal-popup', title: 'nexus-swal-title', htmlContainer: 'nexus-swal-html-container', confirmButton: 'btn btn-danger mx-1', cancelButton: 'btn btn-secondary mx-1'}, buttonsStyling: false });
    if (result.isConfirmed) {
        try {
            const responseData = await postData(`/talent_club/feed/posts/${postId}/delete`, {});
            if (responseData.success) {
                showNexusNotification('Deleted!', responseData.message || 'Post removed.', 'success');
                document.getElementById(`tc_feed_post-${postId}`)?.remove();
            } else { showNexusNotification('Error!', responseData.error || 'Failed to delete post.', 'error');}
        } catch (error) { showNexusNotification('Error!', `Could not delete post: ${error.message}`, 'error');}
    }
}

async function handleDeleteTCFeedComment(buttonElement) {
    const commentId = buttonElement.dataset.commentId;
    const postId = buttonElement.dataset.postId;
    const result = await Swal.fire({ title: 'Delete Comment?', text: "This comment will be removed.", icon: 'warning', showCancelButton: true, /* ... Swal options ... */ });
    if (result.isConfirmed) {
        try {
            const responseData = await postData(`/talent_club/feed/posts/${postId}/comments/${commentId}/delete`, {});
            if (responseData.success) {
                showNexusNotification('Deleted!', responseData.message || 'Comment removed.', 'success');
                document.getElementById(`comment-${commentId}`)?.remove();
                const commentToggleBtn = document.querySelector(`[href="#tcCommentsCollapse-${postId}"] .badge`);
                if(commentToggleBtn) commentToggleBtn.textContent = Math.max(0, parseInt(commentToggleBtn.textContent || '0') - 1);
            } else { showNexusNotification('Error!', responseData.error || 'Failed to delete comment.', 'error');}
        } catch (error) { showNexusNotification('Error!', `Could not delete comment: ${error.message}`, 'error');}
    }
}


// --- TC Community Chat specific JS ---
// (Moved from social.js as these are specific to Talent Club Community)

let currentTCCommunityGroupId = null;
// Consider defining CHAT_POLL_INTERVAL in utils.js or pass as param
const TC_COMMUNITY_POLL_INTERVAL = 7000; // e.g., 7 seconds
let tcCommunityMessagePollIntervalId = null;
let lastTCCommunityMessageTimestamp = 0;

function initializeTCCommunityChat(communityGroupId, userId) {
    console.log(`Initializing TC Community Chat for Group ID: ${communityGroupId}`);
    currentTCCommunityGroupId = communityGroupId;
    // currentChatUserId (from chat.js) could be used or pass userId as param if needed for shared functions.

    const chatWindow = document.getElementById(`tcCommunityChatWindowMessages-${communityGroupId}`);
    const messageForm = document.getElementById(`tcCommunityMessageForm-${communityGroupId}`); // Ensure form has this ID

    if (!chatWindow || !messageForm) {
        console.warn('TC Community chat UI elements not found.');
        return;
    }

    const lastMsgEl = chatWindow.querySelector('.chat-message-wrapper:last-child .message-timestamp');
    if (lastMsgEl && lastMsgEl.title) {
        try {
            lastTCCommunityMessageTimestamp = new Date(lastMsgEl.title.replace(' UTC', '')).getTime();
        } catch(e) { lastTCCommunityMessageTimestamp = Date.now() - (TC_COMMUNITY_POLL_INTERVAL * 2); }
    } else {
        lastTCCommunityMessageTimestamp = Date.now() - (TC_COMMUNITY_POLL_INTERVAL * 2);
    }

    if (chatWindow) chatWindow.scrollTop = 0; // Scroll to bottom (top for column-reverse)

    messageForm.addEventListener('submit', handleTCCommunityMessageSubmit);

    startTCCommunityMessagePolling();
}
window.initializeTCCommunityChat = initializeTCCommunityChat; // Make global

async function handleTCCommunityMessageSubmit(event) {
    event.preventDefault();
    const form = event.target;
    const contentTextarea = form.querySelector('.post-content-textarea');
    const fileInput = form.querySelector('.filepond-input'); // Or your actual file input name/class
    const submitButton = form.querySelector('.post-submit-btn');

    const formData = new FormData(form); // FormData handles text and FilePond-enhanced file inputs

    // Client-side validation (similar to social.js post submit)
    const pondInstance = fileInput ? FilePond.find(fileInput) : null;
    const hasFiles = pondInstance ? pondInstance.getFiles().length > 0 : (fileInput ? fileInput.files.length > 0 : false);
    if (!formData.get('content')?.trim() && !hasFiles) {
        showNexusNotification('Missing Content', 'Please provide text or attach a file.', 'warning');
        return;
    }

    const originalButtonHTML = submitButton.innerHTML;
    submitButton.disabled = true;
    submitButton.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Sending...`;

    try {
        const response = await fetch(form.action, { method: 'POST', body: formData, headers: {'X-CSRFToken':getCsrfToken()} });
        const responseData = await response.json();
        if (response.ok && responseData.success && responseData.post_data) { // Expect post_data
            appendTCCommunityMessage(responseData.post_data, window.currentChatUserId || {{ current_user.id | tojson }}); // Use global or pass ID
            form.reset();
            if(contentTextarea) contentTextarea.style.height = 'auto';
            if (pondInstance) pondInstance.removeFiles();
            lastTCCommunityMessageTimestamp = new Date(responseData.post_data.timestamp).getTime();
        } else {
            showNexusNotification('Error', responseData.error || 'Failed to send message.', 'error');
        }
    } catch (error) {
        showNexusNotification('Error', `Message send failed: ${error.message}`, 'error');
    } finally {
        submitButton.disabled = false;
        submitButton.innerHTML = originalButtonHTML;
    }
}

function appendTCCommunityMessage(msgData, currentUserId) {
    const chatWindow = document.getElementById(`tcCommunityChatWindowMessages-${currentTCCommunityGroupId}`);
    if (!chatWindow) return;
    // Use a shared function or duplicate logic from chat.js's appendMessageToChat,
    // adapting for TC Community message structure and HTML partial if different.
    // For now, assuming _chat_message_item.html is compatible.
    const messageHTML = renderChatMessageItem(msgData, currentUserId); // Assumes this function exists
    const placeholder = chatWindow.querySelector('.text-center.text-muted');
    if (placeholder) placeholder.remove();
    chatWindow.insertAdjacentHTML('afterbegin', messageHTML); // Prepend for column-reverse
    chatWindow.scrollTop = 0;
}

// You'll need this function if it's not already in utils.js or globally available
// This is a simplified version of what might be in chat.js or a shared utility
function renderChatMessageItem(messageData, currentUserId) {
    const isSender = messageData.sender_id === currentUserId;
    const senderName = messageData.sender ? (messageData.sender.full_name || messageData.sender.username) : "System";
    let senderAvatar = messageData.sender?.profile_photo_url ? `/static/${messageData.sender.profile_photo_url}` : '/static/img/placeholders/user_avatar_default.png';
    const timestamp = new Date(messageData.timestamp);
    const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    let fileHTML = '';
    if (messageData.file) {
        fileHTML = `
            <div class="post-attachment mt-2">
                <a href="${messageData.file.download_url}" target="_blank" class="d-flex align-items-center p-2 rounded bg-light-subtle text-decoration-none border">
                    <i class="bi bi-file-earmark-arrow-down-fill fs-4 me-2 text-primary"></i>
                    <div>
                        <strong class="text-dark">${messageData.file.original_filename}</strong>
                        <small class="d-block text-muted">${(messageData.file.size / 1024).toFixed(1)} KB</small>
                    </div>
                </a>
            </div>`;
    }

    return `
        <div class="chat-message-wrapper d-flex mb-3 ${isSender ? 'justify-content-end' : 'justify-content-start'}" id="message-${messageData.id}">
            <div class="chat-message d-flex flex-column ${isSender ? 'sent align-items-end' : 'received align-items-start'}" style="max-width: 75%;">
                <div class="d-flex align-items-end ${isSender ? 'flex-row-reverse' : ''}">
                    ${!isSender ? `<img src="${senderAvatar}" alt="${senderName}" class="rounded-circle me-2 shadow-sm" style="width: 30px; height: 30px; object-fit: cover;">` : ''}
                    <div class="message-bubble p-2 px-3 shadow-sm">
                        <p class="mb-0 message-content">${messageData.content ? escapeHTML(messageData.content) : ''}</p>
                        ${fileHTML}
                    </div>
                </div>
                <small class="message-timestamp text-muted mt-1 ${isSender ? 'me-1' : 'ms-1'}" title="${timestamp.toLocaleString('en-CA', { timeZone: 'UTC' })} UTC">
                    ${!isSender ? `<span class="fw-medium">${senderName.split(' ')[0]}</span>  ` : ''}${timeString}
                </small>
            </div>
        </div>`;
}
function escapeHTML(str) { // Basic HTML escaping
    return str.replace(/[&<>"']/g, function (match) {
        return { '&': '&', '<': '<', '>': '>', '"': '"', "'": ''' }[match];
    });
}
function getCsrfToken() { // Helper to get CSRF token
    return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
}


async function fetchNewTCCommunityMessages() {
    if (!currentTCCommunityGroupId) return;
    const apiUrl = `/talent_club/api/community/${currentTCCommunityGroupId}/messages/new?since=${lastTCCommunityMessageTimestamp}`;
    try {
        const data = await getData(apiUrl);
        if (data.messages && data.messages.length > 0) {
            data.messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            data.messages.forEach(msg => {
                if (!document.getElementById(`message-${msg.id}`)) {
                    appendTCCommunityMessage(msg, window.currentChatUserId || {{ current_user.id | tojson }}); // Ensure current user ID is available
                }
            });
            lastTCCommunityMessageTimestamp = new Date(data.messages[data.messages.length - 1].timestamp).getTime();
        }
        if (data.latest_timestamp) {
             lastTCCommunityMessageTimestamp = Math.max(lastTCCommunityMessageTimestamp, data.latest_timestamp);
        }
    } catch (error) { console.error('Error polling TC Community messages:', error); }
}

function startTCCommunityMessagePolling() {
    console.log('TC Community message polling started.');
    stopTCCommunityMessagePolling(); // Clear existing before starting new
    fetchNewTCCommunityMessages(); // Initial fetch
    tcCommunityMessagePollIntervalId = setInterval(fetchNewTCCommunityMessages, TC_COMMUNITY_POLL_INTERVAL);
}

function stopTCCommunityMessagePolling() {
    if (tcCommunityMessagePollIntervalId) {
        clearInterval(tcCommunityMessagePollIntervalId);
        tcCommunityMessagePollIntervalId = null;
        console.log('TC Community message polling stopped.');
    }
}
window.addEventListener('beforeunload', stopTCCommunityMessagePolling);-e 

===== static/js/tasks.js =====

/**
 * Initializes a modern, unified assignee picker using TomSelect.
 * This picker searches for users, roles, and classes via a single API endpoint.
 *
 * @param {object} options - Configuration options.
 * @param {string} options.pickerId - The ID of the <select> element.
 * @param {string} options.hiddenInputId - The ID of the hidden <input> to store data.
 * @param {string} options.searchUrl - The URL of the API endpoint for searching assignees.
 */
function initializeModernAssigneePicker(options) {
    const pickerElement = document.getElementById(options.pickerId);
    const hiddenInputElement = document.getElementById(options.hiddenInputId);

    if (!pickerElement || !hiddenInputElement) {
        console.error('Assignee picker or hidden input element not found.');
        return;
    }

    new TomSelect(pickerElement, {
        valueField: 'id',
        labelField: 'text',
        searchField: 'text',
        optgroupField: 'group', // Group results by 'Users', 'Roles', 'Classes'
        lockOptgroupColumns: true,
        plugins: ['remove_button', 'optgroup_columns'],
        
        // Custom rendering to show icons and subtitles
        render: {
            option: function(data, escape) {
                let icon = '';
                if (data.type === 'user') {
                    icon = '<i class="bi bi-person-fill text-primary me-2"></i>';
                } else if (data.type === 'role') {
                    icon = '<i class="bi bi-people-fill text-info me-2"></i>';
                } else if (data.type === 'grade_section') {
                    icon = '<i class="bi bi-easel2-fill text-success me-2"></i>';
                }
                return `<div class="d-flex align-items-center">
                            ${icon}
                            <div>
                                <div class="text-dark">${escape(data.text)}</div>
                                <div class="text-muted small">${escape(data.subtext)}</div>
                            </div>
                        </div>`;
            },
            item: function(data, escape) {
                let icon = '';
                 if (data.type === 'user') {
                    icon = '<i class="bi bi-person-fill text-primary me-2"></i>';
                } else if (data.type === 'role') {
                    icon = '<i class="bi bi-people-fill text-info me-2"></i>';
                } else if (data.type === 'grade_section') {
                    icon = '<i class="bi bi-easel2-fill text-success me-2"></i>';
                }
                return `<div class="d-flex align-items-center" title="${escape(data.subtext)}">
                            ${icon}
                            <span>${escape(data.text)}</span>
                        </div>`;
            }
        },

        // Fetch data from our new API
        load: function(query, callback) {
            if (!query.length || query.length < 2) return callback();
            fetch(`${options.searchUrl}?q=${encodeURIComponent(query)}`)
                .then(response => response.json())
                .then(json => {
                    callback(json);
                }).catch(() => {
                    callback();
                });
        },

        // When selection changes, update the hidden input
        onChange: function(value) {
            const selectedItems = this.items.map(itemId => {
                const itemData = this.options[itemId];
                // Store as a structured string: "type:id"
                return `${itemData.type}:${itemData.id}`;
            });
            hiddenInputElement.value = selectedItems.join(',');
            console.log('Hidden input updated:', hiddenInputElement.value);
        },
    });
}-e 

===== static/csv/grade9_students.csv =====
UNIQUE_CODE,GRADE,SECTION,STUDENT_NAME
7m5x3,Grade 9,01,ARSEMA SOLOMON ABEBE
y9d2q,Grade 9,01,ASTER BIRAHANU HUNDE
k6v1p,Grade 9,01,BELIYU TADU BOGALE
z4b8i,Grade 9,01,BEREKET MEKURIYA WERKINEHE
n0w7r,Grade 9,01,BETELHEM TAMIRU KETEMA
p5h6c,Grade 9,01,BETHELHEM YIGREM BEKELE
l8j3a,Grade 9,01,BEZA FEYISA YAMI
q1u4n,Grade 9,01,BILEN ABEBE TESEMA
x2e9y,Grade 9,01,BITANIYA ZEWDU TILAHUN
c7v1b,Grade 9,01,CHALTU MOTUMA TADESSE
d8f5h,Grade 9,01,DAGIM TEMESGEN FEYISSA
o6i3j,Grade 9,01,DAGIM ADDISU GAMACHU
z3l2q,Grade 9,01,DAWIT WORKAGEGN REGASA
r9p4s,Grade 9,01,DEBRITU DANAIEL DAKE
u1w8x,Grade 9,01,DESALEGN GEMECHU FEYE
h5y0c,Grade 9,01,EDELAWIT ESHETU SHAHNEBER
b0q6w,Grade 9,01,ELSHADAY SIMGNEW ASSABE
v4m9k,Grade 9,01,EYERUS GETAHUNEGN GEBEYEHU
g7d1s,Grade 9,01,EYERUSALEM HABTU TIGANI
o2y6q,Grade 9,01,EYOB GETANEH DESELEGN
q8l3u,Grade 9,01,EYUEL BIRUK ASEGIDEW
w1x5b,Grade 9,01,FIKIRTE TAFESE DIBABA
j9i8v,Grade 9,01,GENZEBE ASSEGID MOLLA
e6k4a,Grade 9,01,E BAMLAKU AREGAW
s0w1r,Grade 9,01,HIWOT NATNAEL ABEBE
t3p5n,Grade 9,01,KALEB AMENSISA JIJO
b1d8j,Grade 9,01,KALKIDAN NEGASH AMARE
x9z2a,Grade 9,01,KURI SEIFU BEKELE
p4m7w,Grade 9,01,LBAMLAK DAWIT ENKQUSLASE
l7k1b,Grade 9,01,MARTA GETU ABABUYE
i5o6y,Grade 9,01,MEKEDES GETAWAY ABERE
n2a4h,Grade 9,01,MESERET GIDELEW TALEMA
c0w9p,Grade 9,01,MESTAWET ABAY MEKONNEN
f1j3q,Grade 9,01,MICKAEL YELEKAL WALELIGN
h7d6a,Grade 9,01,MIKIYAS GIRMA GETACHOW
u3p0x,Grade 9,01,NARDOS ASAYE ABEBE
b8v5i,Grade 9,01,NATINAEL ESHETU EMAYU
k4t3a,Grade 9,01,RAHEL DULA MOSHE
r0a1q,Grade 9,01,SAMRAWIT YOHANNES MOGES
w5k8j,Grade 9,01,SELAMAWIT DAGNACHEW GETU
j2n6c,Grade 9,01,SINTAYEHU WONDWOSEN ABERA
a9v0r,Grade 9,01,TSEGEREDA MELKAMU MAKO
g1q5n,Grade 9,01,TSINAT TEGEGN ABATE
x3u2h,Grade 9,01,YARED TAKUMO YALISO
o5c8w,Grade 9,01,YEABSIRA ZIGIJU SEMA
s7d1b,Grade 9,01,YOHANNES KIDANEMARIAM SIFETA
b0q8l,Grade 9,02,ABDULKERIM ABDELA ALI
f7a4v,Grade 9,02,ABUSH POLISE AGENA
y9i2h,Grade 9,02,ALAZAR SHAREW TESFAYE
p1c0w,Grade 9,02,AMIR KEYRU SHAFI
k3w5d,Grade 9,02,ARSEMA NATINAEL MOGES
q6o8j,Grade 9,02,ASRAT SHALA HAILU
c2b1z,Grade 9,02,BAYULIGN WUBETU DAGNE
m8y4r,Grade 9,02,BEFKIADU ASHEBIR MEKONNEN
h5p7i,Grade 9,02,BEREKET ABRHAM BARASO
u9n0l,Grade 9,02,BETELEHEM WONDEMEGEGN ADMASIE
a4z3g,Grade 9,02,BIRHANE WILETAW GETACHEW
w1q5b,Grade 9,02,DAWIT ALAYU NIGUSE
x0h8s,Grade 9,02,ELSABET MERKEB MURO
r2k1v,Grade 9,02,ERMIAS GETABALEW ABEBE
i7n4c,Grade 9,02,FITEH MOGES KEBEDE
e3a6w,Grade 9,02,FREZER TAFESE DEMSE
o5d9j,Grade 9,02,GENET BOKE MIKE
q1l0h,Grade 9,02,GENET BOSHA BOLA
z8s3c,Grade 9,02,HABTAMU ZENEBE BARSOMA
v6y5b,Grade 9,02,HAYMANOT TSEGA BELETE
w3k4r,Grade 9,02,HELEN SAMUEL NIGUSE
g9a7y,Grade 9,02,HILINA KEFYALEW DUBALE
p0e2j,Grade 9,02,HIWOT DAMTEW DUBALE
i5h6u,Grade 9,02,IMERAN NESRU MUZE
s2q1a,Grade 9,02,KIDUS BELETE SEIFU
k4b8w,Grade 9,02,MAHLET ENGIDA AGIZEW
u0y2n,Grade 9,02,MEKILIT DAWIT BASAZNEW
h6l5q,Grade 9,02,MESERET SIMACHEW FENTAYE
n1s3b,Grade 9,02,MIHRET ASEBE SHIFERAW
r7a8w,Grade 9,02,MIKIYAS GOYTOM ABRIHA
q0d4j,Grade 9,02,MULUKEN KEBEBEW ADDISE
v2k7p,Grade 9,02,NOOR MUNEER MOHAMMED
y3x1h,Grade 9,02,REDIET WEGAYEHU KEFENE
o8a5b,Grade 9,02,SELAMAWET MESFEN BELETE
e1q4w,Grade 9,02,SEMIRA ADNEW MELIS
m9k2z,Grade 9,02,SOLYANA TESFAYE TEDLA
t5b7r,Grade 9,02,SURAFEL ALAYU MILKE
w8a4y,Grade 9,02,SURAFEL KIDANU WORKNEH
d6j1q,Grade 9,02,TEMESGEN GEBRU BIZUWORK
g0q5i,Grade 9,02,TSIGEREDA BEREKET ALEMNEW
p3h9u,Grade 9,02,YEABSIRA GETYE BESHA
k1y4m,Grade 9,02,YOHANNES BILILIGN WENDIMU
b2v7n,Grade 9,02,YOHANNES HABTAMU TASEW
u7t0o,Grade 9,02,ZUFAN SHEWANGEZAW ASEGED
d6w8x,Grade 9,03,ABEL ANDINET HAILU
a1i3l,Grade 9,03,BELAY TISASU FELEKE
s5y6q,Grade 9,03,BELETU KEYO ERGET
v9k2o,Grade 9,03,BEREKET LULSEGED ABATE
z4q7j,Grade 9,03,BESUFEKAD SHELEME DEBELA
w0u5b,Grade 9,03,BETELEHEM ALEMAYEHU SHIFERA
k8x2h,Grade 9,03,BETELHEM ANDUALEM BIRHANU
c3q9n,Grade 9,03,BETELHEM YOHANNES YONA
o7b1i,Grade 9,03,BETSELOT ASEFAW MULUNEH
g2u4p,Grade 9,03,BIRUK SISAY SHEWAGA
h5o7c,Grade 9,03,BIRUKTAWIT DEMETE BAYE
m9w0r,Grade 9,03,BIRUKTAWIT FKADU MAMUYE
t1d6x,Grade 9,03,CHRISTINA ZEWDU TILAHUN
j8q2f,Grade 9,03,DAGEM TEGEGN GEBEYEHU
x4b1l,Grade 9,03,DANIEL GBERSILLASSIE MESELE
e7o5u,Grade 9,03,ELIYAS BOGALE TEISFA
q0s8k,Grade 9,03,EYOB TADELE DEMIS
z3v9h,Grade 9,03,FASIKA DEREJE GIRMA
w1c6j,Grade 9,03,FREHIWOT TARIKU DEGU
u4k3y,Grade 9,03,GASHAW AYENEW MENGISTU
i9a7w,Grade 9,03,GETASETEGN SOLOMON SHANTO
r6t2z,Grade 9,03,HAYMANOT GETABAYU AMTAT
l5e1q,Grade 9,03,HAYMANOT YEBELET TILAHUN
p7h4a,Grade 9,03,KIDIST MANAYE ENDRIS
b0j9y,Grade 9,03,LOMITA TSEGA SEBOKA
o2k1c,Grade 9,03,LUJEM MUNIR MEHEMMED
v8u5q,Grade 9,03,MAHELET TARIKU JEZE
a4y3g,Grade 9,03,MEKDELAWIT AYALKEBET CHERE
s1p6i,Grade 9,03,MEKDES MOGES ABATE
m0c8j,Grade 9,03,MEKDES SISAY EN
h9w2z,Grade 9,03,MEKDES WENDIMAGEGN DEJENE
q2o5c,Grade 9,03,NAHOM TESFAYE WELELAW
b1k9m,Grade 9,03,NATNAEL BESUFEKAD AWLACHE
v7t4x,Grade 9,03,RAHEL ARAGE WELDETINSAY
u0i6q,Grade 9,03,SIRAYE TAYE ALEMAW
l8z5h,Grade 9,03,SOFONIAS YISMALEM TAMIRAT
e3a8w,Grade 9,03,SURAFEL WEKALMHU WENDMU
s9r2c,Grade 9,03,TAMIRAT DESELEGN ABEBE
a5h7i,Grade 9,03,TIZTA MASRESHA ASFAW
j1y4q,Grade 9,03,YANET FISEHA WALELIGN
o0q1z,Grade 9,03,YETIMWORK BERHANU BELAY
g6d5h,Grade 9,03,YOHANNES DEMOZE ALEMU
p3k8u,Grade 9,03,ZEMENU YESHITELA DESALEGN
w5a2j,Grade 9,03,ZINASH WORKU WONBERA
u9w6i,Grade 9,04,ABENEZER TESFAYE WELELAW
n1s8q,Grade 9,04,ADANECH KULICHE AWURARIS
y0c3h,Grade 9,04,ALAZER SEYOUM WOLDE
b2v6n,Grade 9,04,ASEGEDECH ALEMAYEHU FANSOLE
x7k0m,Grade 9,04,AWLACHEW EYAYU ASRES
p8r9u,Grade 9,04,BANTEGIZE ATNKUT AMERA
z5h3o,Grade 9,04,BEAMLAK TILAHUN ADDIS
u0c1i,Grade 9,04,BELETE SHITAW ATILABACHEW
q6a9l,Grade 9,04,BIRKE BELE MULUYE
n2y4k,Grade 9,04,BIRTUKAN ACHAMYELEH BELAY
g8v0j,Grade 9,04,EYOB AREGU ERDACHEW
i9b5w,Grade 9,04,FEVEN SAMSON WOLDETSADIK
h3r7o,Grade 9,04,FIKIR ASAMINEW ABEBE
s1q4n,Grade 9,04,GEDION ETSUB GEBREMICHAEL
p0k2y,Grade 9,04,HANA ASEFA ZEMEDKUN
x5u7j,Grade 9,04,HANAN HEYRU NURU
z7d9g,Grade 9,04,HELEN ADEBABAY FISEHA
c2l5y,Grade 9,04,HERMELA KELIFA ABDLA
j4q8p,Grade 9,04,HIWOT CHOMBA CHOLE
e0o1h,Grade 9,04,HIWOT MASRESHA MAMO
w6y4c,Grade 9,04,ISRAEL TESFAYE YIRGU
t2k9q,Grade 9,04,JEMIL TEMAM ABDO
g5z7b,Grade 9,04,KALID DELIL SHEREFA
n8u1w,Grade 9,04,KALKIDAN TENA MUSTEFA
q1d4j,Grade 9,04,KALKIDAN TOMAS MELIS
x3l9o,Grade 9,04,LAMROT MENGISTU ASSEFA
c6s2y,Grade 9,04,MIHIRET MEKONEN TADESE
r7i5a,Grade 9,04,NARDOS MITIKU ALEHEGN
y0h8w,Grade 9,04,NATNAEL BIRUK BEKELE
k5b2q,Grade 9,04,NOLAWITE YESHITLA DEMLEW
v4w1c,Grade 9,04,REDIET ASHEBIR DINKU
o1y4h,Grade 9,04,REDIET TEKILESILASE SIME
m9a6r,Grade 9,04,SELHDIN ABDELA ALI
b6p5z,Grade 9,04,SINTAYEHU EYAYU TEFERA
i3l9k,Grade 9,04,SURAFEL BELIHU MILIKU
s7g3n,Grade 9,04,TEGENU MOGES DEKEBA
d8h0v,Grade 9,04,TEMESGEN ABEBE ARAGAW
w5r4j,Grade 9,04,TESFA TEGEGN ABATE
a1p9o,Grade 9,04,TESFANEAH SAMUEL ABEBE
k9b6q,Grade 9,04,TEWODROS MESAY ASA
t0o3u,Grade 9,04,WERKNESH ABEBE ARGAW
z4r8c,Grade 9,04,YONAS AYALKEBET YILMA
u6j5h,Grade 9,04,ZINASH TUFA BAYESA
b2d1y,Grade 9,04,ZUFAN TEKLE ANTENEH
h7v3q,Grade 9,05,ABEL AYFOKIRU ADDISE
l8a0z,Grade 9,05,ABIGYA GETU TAKELE
n9u5i,Grade 9,05,ADDIS CHORANO TSONGA
w1y7g,Grade 9,05,ANWAR ZEMEDKUN MENGISTE
t3r0a,Grade 9,05,BANTEGIZE MOHAMED MUSA
k5o9c,Grade 9,05,BEREKET TESFA MAHARI
o1q6n,Grade 9,05,BIRHANE CHAYENA GASHAW
i6e3u,Grade 9,05,DEREJE ABU ALEMAYEHU
c4p7b,Grade 9,05,DIBORA ABRHAM KIDANE
a8h4v,Grade 9,05,EFRATA MUSTEFA SHEMSU
v2j1o,Grade 9,05,EFRATA WONDAFEREW HAILEMARYAM
s0w8k,Grade 9,05,ESUBALEW ABATE MEKURIA
f7n5q,Grade 9,05,ETSUBDINK HABTAMU TSEGAYE
b9i2r,Grade 9,05,EYOB TAREKEGN ABRIDO
u3c0h,Grade 9,05,EYOBE ALEBAY TSEGAW
z1o8i,Grade 9,05,GETASETEGN ADEMA GOBEZE
q6w2p,Grade 9,05,GIZACHEW ENGIDASHET AYALK
n8l5u,Grade 9,05,GIZACHW AYALSEW TATEK
c0x9d,Grade 9,05,HAMELMAL SILESHI MEKONNEN
e5q1r,Grade 9,05,HANA AREGA ADMASE
j4t2k,Grade 9,05,HELEN SAMUEL NIGUSE
o7w8p,Grade 9,05,KENEAN TEDLA SHEFERAW
r1n3y,Grade 9,05,KIRUBEL MULUGETA ANTIYEA
x9a6c,Grade 9,05,KIRUBEL TESHOME TONA
s2g0i,Grade 9,05,LELISE SIMENE KEBEDE
b6u7h,Grade 9,05,LEUL SHEWANDAGN KEBEDE
w8p5n,Grade 9,05,MIHRET TILAHUN HAILU
f0r3j,Grade 9,05,IAS DANIEL GETAHUN
q1w7v,Grade 9,05,MISTRE MOSHE SODIYO
y4d6i,Grade 9,05,REDIAT GETASETEGNE MASRESHA
l9b2p,Grade 9,05,REDIET TEFERA IKAEL
c5j9k,Grade 9,05,SARA TEKETEL TENKIR
m1o7u,Grade 9,05,SELAMAWIT TESFAYE WERKNEH
h7x4a,Grade 9,05,SINTAYEHU DEREJE TESHOME
p3v2g,Grade 9,05,SULEYMAN AHMED ADBRE
z0r5c,Grade 9,05,TADELECH ABEBE YOSEF
v9o1n,Grade 9,05,TEWODROS DIRES TESFAW
d5u3q,Grade 9,05,TIGIST BRHANU YISHALAL
a2i8y,Grade 9,05,TINSAE GETASETEGN CHIROTAW
k7y5h,Grade 9,05,YARED TADELE KIBRET
x1d9g,Grade 9,05,YITAGESU BAYELIGN WERKU
u6w2o,Grade 9,05,YONAS MASRESHA MAMO
q8j0p,Grade 9,05,YORDANOS BERIHUN ARAGE
n4b3w,Grade 9,05,ZERIHUN TILAHUN SETO
e1i9y,Grade 9,06,ABENEZER ABEBE SHEWANGZAW
q8l3c,Grade 9,06,ABENEZER HENOK GETACHEW
t0v6r,Grade 9,06,ADONIYAS DESALEGN TEMTIM
h6i4l,Grade 9,06,ARSEMA YIBELTAL YITAYEW
u9a1d,Grade 9,06,ASHEGIR ALELIGN ALEMINEW
w2p5g,Grade 9,06,ASTER WESENE HAILU
z5x3r,Grade 9,06,BELYNESH FELEKE SHIMELIS
f7u0l,Grade 9,06,BEREKET GETIYE LEMA
n1q4w,Grade 9,06,BETELHEM MENGISTE CHEKOL
o9d6c,Grade 9,06,BINYAM ENDALEW ABEBE
k0l1j,Grade 9,06,BIRHANE ENDALKACHEW WUBISHE
v6t7p,Grade 9,06,BIRUK MITIKU G/MESKEL
w3h4a,Grade 9,06,BIRUK ZEMEDKUN TEGEGN
b8n9r,Grade 9,06,CHRISTINA ASRAT MEKONNEN
p4u2d,Grade 9,06,DANIEL BAYELEGN DEMESSIE
x1i7l,Grade 9,06,EYOB ABAY ENDAZENEW
j0q5v,Grade 9,06,EYOBED ABAY ABERA
h6d2a,Grade 9,06,FASIK MU NEGESE
r3k9z,Grade 9,06,FIKIRADDIS ASIMARE DESSE
o9w7m,Grade 9,06,FISEHA ZEBENE SIDELEL
d1q4i,Grade 9,06,HAGERE TIRUNH MOGES
a7s3b,Grade 9,06,HENOK GIRMA WULETAW
z9j6p,Grade 9,06,KALKIDAN DISEFA KEDIR
u2e8c,Grade 9,06,KALKIDAN YITAYEW HAILU
s8m1l,Grade 9,06,KIDUS GEBRU WELDETINSAY
f0b7q,Grade 9,06,MARKOS TONA TOBE
m4i2r,Grade 9,06,MEKDES ZELEKE DEJU
b5x0a,Grade 9,06,MEKDES TESHOME GETAACHOW
q1n3t,Grade 9,06,MERON KIBRU WORKU
w7c5j,Grade 9,06,MESERET AIMRO GELE
k3l1z,Grade 9,06,NATNAEL EPHREM GETANEH
y6s4h,Grade 9,06,REDIET AWUGETENEW SISAY
c8b0i,Grade 9,06,SAMUEL EYESUSWORK TEREFE
g9w2p,Grade 9,06,SAMUEL WEYALE ENJE
o1y5r,Grade 9,06,SERKALEM GASHAW ABIYU
e6z8d,Grade 9,06,SOSINA FEKADU BEKELE
t2a4m,Grade 9,06,TAMASGEN AYALEW ZELEKE
l0j9q,Grade 9,06,TIZITA ENEDWAGAW BEKELE
s5r1h,Grade 9,06,TSEBAOT SHIGUTE MAMO
d3k7b,Grade 9,06,TSION GERESU GEDENA
y1i4p,Grade 9,06,YEABSRA TARIKU ZELEKE
u8v6c,Grade 9,06,YIDIDIYA AREGA SIYUM
z0b1i,Grade 9,06,YOHANNES GENET ASRES
g7h2y,Grade 9,07,ABERHAM FELEK EJEGU
c5q4m,Grade 9,07,AMANUEL KASAHUN TESFAYE
q2k0i,Grade 9,07,BEREKET MOLAWERK ZELEKE
z8w5r,Grade 9,07,BETELIHEM TESHOME DERJE
x1a7j,Grade 9,07,BEZAWIT NEGATU HABTE
h4q9b,Grade 9,07,BEZAWORK ABIOT ABEBE
t6d2n,Grade 9,07,BILEN GETAMESAY TESHOME
p8u5w,Grade 9,07,BIRHANU DEFARU DEMISE
y0c1q,Grade 9,07,BIZUALEM DERIB TEKLEMARIAM
u4r9b,Grade 9,07,CHERNET ABERA ABDU
q7z5a,Grade 9,07,DAGIM ENDALE GAREDEW
h3l8i,Grade 9,07,DANIEL SHEFERAW SEFIU
o9v1z,Grade 9,07,DIRBE SISAY ALEMU
e5j7g,Grade 9,07,EFRATA SOLOMON ASSEFA
w2b4k,Grade 9,07,EMEBET KESTO MEZGE
r0s1p,Grade 9,07,ENATU SENAY ASAYE
k7w6i,Grade 9,07,ESTIFANOS BIRHANU WENDMU
v4u9a,Grade 9,07,EYERUSALEM YARED GUCHE
d1h5q,Grade 9,07,FARUK MUZEMIL NASIR
a9p2z,Grade 9,07,FIREHIWOT TIGLU MILKA
s3l4w,Grade 9,07,HELINA DERIBA GIRMA
x8c7u,Grade 9,07,HIWOT ABEBE ENGIDA
q6j0k,Grade 9,07,KALKIDAN ALEMSEGED KEBEDE
n2v5i,Grade 9,07,KIDIST EYESUSWORK TEREFE
u5r3a,Grade 9,07,LIDETU MENGISTU WEGEMETA
z1a8y,Grade 9,07,MESKEREM ESHETU ZEWDE
o6g5c,Grade 9,07,MIHRET MELAKU AGONAFER
e9b1h,Grade 9,07,MILION HAGOS ADHANE
v2h4k,Grade 9,07,REDIET SEMACHEWU AWOKE
c0p1q,Grade 9,07,SAMUEL ABIYE TAYE
q3x7z,Grade 9,07,SAYID AWWALUU ASFAAW
w4g0a,Grade 9,07,SOSINA HABTAMU KEYMO
k8z3s,Grade 9,07,SURAFEL TEWODROS TSEGA
t2u9i,Grade 9,07,TEKLU MULUGETA BETA
b9m6r,Grade 9,07,TSION ZERFU DEBLSO
h5a4w,Grade 9,07,YEABSIRA GIRUM KASSA
p1l7o,Grade 9,07,YEDENEKACHEW TEGEGEGNWORK ALE
v0r3j,Grade 9,07,YEWORKWUHA SHIFERAW CHERNET
y8h5u,Grade 9,07,YIDIDIYA MEKONON KASSA
d4w2k,Grade 9,07,YOHANNES ASHENAFI ENDALE
a1t9p,Grade 9,07,YORDANOS MELAKU TESFAYE
r6c8i,Grade 9,07,ZELALEM GIZAW FANTAYE
g9y5x,Grade 9,07,ZEWDNESH ZEWKA ZATO
o7h2i,Grade 9,08,ABEL HAIUL DEREJE
x0v9j,Grade 9,08,ABRIHAM ENDALKACHEW NIGATU
t3n5a,Grade 9,08,AMANUEL TADYOS SEYFU
p5y1w,Grade 9,08,ANTENEH TESFAYE LEMMA
z1g6u,Grade 9,08,ASHEBIR SIYUM ENDASHAW
k8d2q,Grade 9,08,BELETU GEREMEW YIFRU
o4s9r,Grade 9,08,BILEN TUFA BORU
e9m0l,Grade 9,08,BIRKE MEGERSA DEYU
w6q3z,Grade 9,08,BIRUK TSEGAYE KEBEDE
c2t5a,Grade 9,08,BIRUKITAWIT ANTENEH KASSAHUN
j1y8k,Grade 9,08,BITANIYA GUTA TESFAYE
v7r4n,Grade 9,08,DAWIT ATWES ADMESU
q5d1i,Grade 9,08,DAWIT DEBELE DEBELE
t0a7c,Grade 9,08,DAWIT ENDALAYE TILAHUN
k3q9h,Grade 9,08,EDLWIAT DAWIT NIGUSSIE
u5n2o,Grade 9,08,ELSABET BASAZENEW TEEMI
g9z6j,Grade 9,08,ESTIFANOS MESFENE DEMESSA
x2p8r,Grade 9,08,FIRTUNA KUMILACHEW BITEW
a4l0y,Grade 9,08,GENZEB MITIKU AYENEW
b1v5q,Grade 9,08,HERMELA GEBREMEDIN TEKA
r8g2a,Grade 9,08,MEKDELAWIT SAMUEL GETU
w0k9d,Grade 9,08,MERON WORKU TAMENE
i7t4l,Grade 9,08,MESERET GIRMA KEBEDE
s3u1h,Grade 9,08,MESERET TESHOME DEMSE
u5y7k,Grade 9,08,MIHRET AYSHESHM SEWNET
q8i2a,Grade 9,08,NARDOS FKREMARIAM SHEWANGZAW
z0q4b,Grade 9,08,NUREDIN FEREJ MOHAMMED
c4n9r,Grade 9,08,RAHEL GETACHOW MELESE
k1h6p,Grade 9,08,REDAIT DEREJE GIRMA
w8m3u,Grade 9,08,SAMUEL KASA KELELE
s9y1c,Grade 9,08,SAMUEL TEFERI GANKA
o3v5i,Grade 9,08,SURAFEL ALEMAYEHU GIRMA
p1k7j,Grade 9,08,TARIKU TESFAYE WOLDEMIKAEL
u6w0n,Grade 9,08,TIBEBE SOLOMON TILAHUN
h8b4a,Grade 9,08,TIGEST MELAKAMU ABEBE
q5y7w,Grade 9,08,TSEGENET BIRKINEH NIGUSE
m2c6i,Grade 9,08,TSINAT ESHIBEL DIGAFE
x0g3q,Grade 9,08,TSION WORKINEH HAYLEMIKAEL
f4p8y,Grade 9,08,YEABISIRA BAYE BELETE
d7r2n,Grade 9,08,YITBAREK TILAHUN TESFAYE
a1h9c,Grade 9,08,YITBARK TAYE ARAGAWU
u0c4k,Grade 9,08,YORDANOS TILAHUN GEBREMISKEL
b5m7v,Grade 9,08,YOSEPH DEFAR WONDMENEK
x8o3z,Grade 9,09,ABEL WELDEGEBREAL TESFAYE
q3c6w,Grade 9,09,ABRHAM MAMUSHET NIGUSE
u5n9a,Grade 9,09,AMANUEL SENESHAWU MELAKU
i1v4h,Grade 9,09,ARSEMA MESFIN TAYE
n0a7z,Grade 9,09,ARSEMA SISAY TADESSE
a6b4c,Grade 9,09,BILEN AWEISI TADELE
a4j9l,Grade 9,09,BETELHEM MULUGETA LEKAS
i2s5u,Grade 9,09,BEYETI BAHAILU ABIYU
c1p8w,Grade 9,09,BEZAWIT ABEBE GIRSHA
z9n6g,Grade 9,09,BEZAWIT ALAMAYEHU NIGUSE
k3t1p,Grade 9,09,DAGIM CHEKOL ENIYEW
h5y4d,Grade 9,09,DAWIT SOLOMON TAYE
v7r2o,Grade 9,09,EMEBET NIGUSE ALEMU
q1b9u,Grade 9,09,ESETE ABAYNEH ASA
n0w5j,Grade 9,09,ESUBALEW HAILU SHIFERAW
y4g1s,Grade 9,09,EYERUSALEM YARED GUCHE
b2k7p,Grade 9,09,FASIKAA BOGGALAA DARSOOLLINY
u0i3z,Grade 9,09,FASIL AMEDE AGEZA
w8q6c,Grade 9,09,GIRUM ALEMAYEHU ESUYAWKAL
r7h1b,Grade 9,09,HERAN ASRAT MEKONEN
j1o4k,Grade 9,09,KALKIDAN TEKELE WERET
c5y2v,Grade 9,09,KIDST BIRIHANU AYELE
x8u0q,Grade 9,09,MAHIDER ASMARE GETU
g9p3t,Grade 9,09,MARAMAWIT SAMUEL BIRHANU
k3a6i,Grade 9,09,MATIYAS BIRHANU TESEGA
o7z4h,Grade 9,09,MIHIRET MESFEN AMARE
q1b8n,Grade 9,09,MIHRET EPHREM DESALEGN
v3w5r,Grade 9,09,MINILK ZIMBELACHW ZEWEDE
i8d2p,Grade 9,09,NARDOS ENDALE MITIKU
s5u0w,Grade 9,09,NETSANET KASAHUN FANTU
b2j9k,Grade 9,09,NOLAWIT ADDISU GETEYE
q1p7m,Grade 9,09,PAWLOS GIRMA NIGUSE
z8o4b,Grade 9,09,SAMUEL TESFAW ASCHENAKI
w4i6y,Grade 9,09,SERAWIT ABEBE REMEHA
p0k3c,Grade 9,09,SURAFEL DAMTEW NIGATU
y7h1q,Grade 9,09,TEMESGEN AWAWITE DEGAGA
c9r3u,Grade 9,09,TIZITA MMED NUREDIN
a4v6o,Grade 9,09,TSEGAZEAB FISSEHA ABATE
k7h0b,Grade 9,09,YEMESRACH ABABU AMBERBR
r5p3l,Grade 9,09,YIDNEKACHEW ATNAFU WEDAJ
z2y8a,Grade 9,09,YONAS MEAZA MENGSTU
w0k7q,Grade 9,09,YONAS SHIMELES DILNESA
i4c6g,Grade 9,09,ZEEBA HUSSEN ALI
0,Grade 9,10,ABDULMEJD MUKEMIL RHAMETO
0,Grade 9,10,ABEL TSEGAYE ADMASU
0,Grade 9,10,ARSEMA DAWITE ESHETU
0,Grade 9,10,ARSEMA ENGEDA ABEBE
0,Grade 9,10,ASELEFECH WUBISHET ADUGNA
0,Grade 9,10,ASHENAFI ABEBE SEID
0,Grade 9,10,ASHENAFI ABIYOT MOLSO
0,Grade 9,10,AYLSHA YEHYA HALID
0,Grade 9,10,DANIEL BIRKAYEHU RADE
0,Grade 9,10,ELENI FEKADU NIGUSSIE
0,Grade 9,10,FIKIRTE MENGISTU DELELE
0,Grade 9,10,GELILA MENGISTU TSIGE
0,Grade 9,10,HAMZA JAMAL UMAR
0,Grade 9,10,HELEN SEWINET ASHAGRE
0,Grade 9,10,IBRAHIM TOFIK NESERDIN
0,Grade 9,10,IMAN MOHAMMED ENDRES
0,Grade 9,10,KALKIDAN ZIMBELACHO BESUFIKAD
0,Grade 9,10,KALKIDAN MESFIN GETACHEW
0,Grade 9,10,MARAMAWIT HABTAMU NEGASH
0,Grade 9,10,MENGISTU DERESE MAMO
0,Grade 9,10,MESAY CHOLBO CHOREZA
0,Grade 9,10,MESERET FENTAWU MEKONNEN
0,Grade 9,10,MESKEREM MESFIN GULE
0,Grade 9,10,NAHOM YALEW TESHOME
0,Grade 9,10,NAHOM ZIBELE CHIMA
0,Grade 9,10,NATNAEL TESFAYE AYNKAW
0,Grade 9,10,NUHAMIT NETSANET YEHULAWORK
0,Grade 9,10,SAMRAWIT ASFAW ESHETYE
0,Grade 9,10,SAMUEL SAFIHU ABATE
0,Grade 9,10,SEADA MURAD AHMED
0,Grade 9,10,SHAWANGZAW DEMEKE AYTENAFU
0,Grade 9,10,SOLOMON RESHED SHEREFEDE
0,Grade 9,10,TAREKEGN  BONCHE
0,Grade 9,10,TARIKU ABEBE TEMESGEN
0,Grade 9,10,TARIKWA HABTAMU YAZACHEW
0,Grade 9,10,TEDROS GIRMA BAHARU
0,Grade 9,10,TIGIST TAMIRAT SHEWANGEZAW
0,Grade 9,10,TSINAT MESFIN KABATHYEMER
0,Grade 9,10,TSION TESFAYE SHITAYE
0,Grade 9,10,YABSIRA TARIKU ABABU
0,Grade 9,10,YEABSIRA TESFAYE G/YOHANNES
0,Grade 9,10,YEMISIRACH ASEFA GEZAHEGN
0,Grade 9,10,YOHANNES MEGABI PAULOS
7j0v5,Grade 9,11,ADONIYAS SILESHE YANET
84u9h,Grade 9,11,ALAZER SHUNKUTE TADDESSE
l4q7c,Grade 9,11,AMANUEL WANA GUDETA
06152,Grade 9,11,AREGAHAGN ADISU AYELE
19h3p,Grade 9,11,ARSEMA ADDIS TSEGAYE
q8c6w,Grade 9,11,ARSEMA WONWOSEN KETEMA
v5h0b,Grade 9,11,ASTER MEKONNEN MOTUMA
y2r3u,Grade 9,11,AYAL DESALEGN ABERA
a9b5m,Grade 9,11,BEMNET BENALFEW WOREKU
z1w8i,Grade 9,11,BEREKET AREGA HABTAMU
g6o4k,Grade 9,11,BEREKET DAGNACHEW NIGUSSE
p3k1s,Grade 9,11,BESUFIKAD DAGNACHEW GONFA
x5t7n,Grade 9,11,BINYAM ASFAW YIRGA
c0a9q,Grade 9,11,CHERNET MEHARI SISAY
r7l6h,Grade 9,11,DANIEL MARE ABRIDO
u2e8w,Grade 9,11,EMEBET MESELE OLOLO
j4v1a,Grade 9,11,ENDALU SISAY MEKONNEN
o1x3p,Grade 9,11,KALKIDAN ASCHALW ASEFA
n9g5k,Grade 9,11,KIDIST ASASU LEGESE
q0b2r,Grade 9,11,LEUL HAILU BEKELE
h7y9c,Grade 9,11,MEKDELAWIT AKLILU FEKRE
s3i6h,Grade 9,11,MEKDES ASHENAFI ASHET
b0m4a,Grade 9,11,MEKDES MISGANAW EMIRE
w5q7y,Grade 9,11,MEKDES WUJIRA ZEPRAGA
k8z4b,Grade 9,11,MENBERE BASAZINEW GONDER
o1h9p,Grade 9,11,MERHAWIT BIRHANU GEBREMICHAEL
r5x6u,Grade 9,11,MESTAWET MESFIN NIGUSE
j2c1s,Grade 9,11,MIHRET GEBREMEDHIN FANA
u7v9k,Grade 9,11,MIHRET NIGATU DESSALEGN
w3a6o,Grade 9,11,MIHRET TAREKEGN AYTENFSU
b9p1z,Grade 9,11,MULU ENDALKACHEW WUBISHET
z8r4h,Grade 9,11,NATINAEL ESHETU ASALE
t1q7w,Grade 9,11,NATNAEL ASCHALEW LEMA
i3u0g,Grade 9,11,SAMRAWIT ZERIHUN NEGASE
c7l9a,Grade 9,11,SHEHAT YASIN MOHAMMED
x4o5q,Grade 9,11,TAMMIRAT DIGAAFEE MAGARSAA
h6y3p,Grade 9,11,TIGIST GEBRE GEZAHEGN
v5b0r,Grade 9,11,TIZITA ENDALE SHEMAEIS
a9k6w,Grade 9,11,YEABSERA BEREKET AMMECHA
g0m3d,Grade 9,11,YEABSIRA FELEKE AMARE
q2p5i,Grade 9,11,YEMISRACH SALLA SALCHE
c8a1u,Grade 9,11,YOHANNES HABTAMU MENGESHA
m4w7k,Grade 9,11,ZEKARIYAS ZENEBE SITOTAW
u5g8q,Grade 9,12,ABRAHAM GEREMEW ALEME
r1j5p,Grade 9,12,ALAYUSH ZEMEDKUN KASA
x0c2y,Grade 9,12,ALEM TILAHUN CHECOLE
n8u9k,Grade 9,12,AYNALEM GEORGIS GODEBO
q3w6i,Grade 9,12,BESUFEKAD ASCHALEW ASEFA
z1a9h,Grade 9,12,BETELHEM DEREBEWERK BILONDEHU
k7r3u,Grade 9,12,BETELIHEM MENGISTU GEBRE
d4p0y,Grade 9,12,BIRTUKAN TOLESA LEMA
o6i8k,Grade 9,12,CHERNET BAUELEGN TARIKU
g9c4w,Grade 9,12,ELSABET ADDIS MOLLA
p2v1r,Grade 9,12,ETSUB BIRKINEH NIGUSE
k5a7o,Grade 9,12,EYOSAFT ABEBE LANDA
u3q0w,Grade 9,12,FITSUM ABAY FIKIR
x1h6j,Grade 9,12,HANAN MIFTAH HYEAR
c9y2p,Grade 9,12,IZANA AKLILU ABATE
h7t5b,Grade 9,12,KEDIR HUSSEN MUHAMMED
o0r8q,Grade 9,12,LILINA ENDALE MEKURIA
q6v1c,Grade 9,12,MAHILET YOSEF ASAMINO
g3k8u,Grade 9,12,MEKDES DEMIS BELAYNEH
a5i4n,Grade 9,12,MELAT GETACHEW KASSA
r1w7j,Grade 9,12,MESERET TESHOME DEMISSE
p8q0b,Grade 9,12,MESERET WALE MIHIRET
u7g4h,Grade 9,12,NETSANET DEJENE ASEFFA
c0n1k,Grade 9,12,NOH BEDRU SEID
x5v3y,Grade 9,12,NOHAMIN TEWODROS TAYE
q1i6p,Grade 9,12,RUT SISAY ASIRE
a2o9v,Grade 9,12,SAMRAWIT WENDWOSEN GEBRE
z8k5d,Grade 9,12,SAMUEL ABEBE YITBAREK
t4g1r,Grade 9,12,SEBLE AYTEGEB YELMA
h7y3q,Grade 9,12,SENAYIT MAMARU GUADIE
v0w9o,Grade 9,12,SINTAYEHU BAYEW AZENE
k3b6i,Grade 9,12,SOSINA ALFOAWGECHOW DESTA
p9r4w,Grade 9,12,SURAFEL MESFIN ABA
y1u7a,Grade 9,12,TAREKWA BEHIALU BEKELE
q6j3l,Grade 9,12,TEMESGEN WUDINEH ABEBE
u4z1i,Grade 9,12,TEWODROS AYELE BIRHANU
b9n6s,Grade 9,12,TIGIST GETAHUN NGATU
x2i0h,Grade 9,12,TIGIST LEMA HORDOFA
p5v3q,Grade 9,12,TINSAE TESHOME ABEJE
g7r1l,Grade 12,12,TIZITA MESFIN AREGAHAGN
c0h4p,Grade 12,12,YEARSEMA SOLOMON TESFAYE
v3w7i,Grade 12,12,YEHUALAWORK HAILE BERATU
u0a3n,Grade 12,12,YOSEPH GETA GUCHEYE
-e 

===== static/csv/grade11_students.csv =====
UNIQUE_CODE,GRADE,SECTION,STUDENT_NAME
U1101001,Grade 11,01,ABEL BELETE SILESHI
Q928Y2Z,Grade 11,01,ABRHAM BELAYNEH ASRES
B37X5Q0,Grade 11,01,ALELEGNE MENEGISTU TADESS
H64K8W7,Grade 11,01,BEREKET BALEW TILAHUN
T295N6L,Grade 11,01,BEREKET MICHEL ASHENAFI
W579B1V,Grade 11,01,DANIEL MULUKEN TEGENE
K02F4M8,Grade 11,01,DAWIT ALEBACHEW TEGEGN
G85L1S6,Grade 11,01,DEMSEW WORKALEMAHU GEBRE
Z40V3H9,Grade 11,01,EDEN FELEKE ALEMU
N73D6J2,Grade 11,01,ELIAS WORKINA NANESA
O61E8C4,Grade 11,01,ESRAEL WONDWOSSEN TIBEBU
M26U7K5,Grade 11,01,EYERUS SHUMET TAKELE
R49T2B0,Grade 11,01,EYUEL KELEMWORK MENGISTU
P05A3W1,Grade 11,01,GENEZEB DAGIM TADESSE
S72N9V8,Grade 11,01,GETASETEGN SOYSO SOLBE
F189X4Q,Grade 11,01,KALKDAN GIZACHEW BELAY
E342Z7T,Grade 11,01,KIDUS TEKLEMARKOS ABAYENEW
B975L0O,Grade 11,01,LAMROT BIRU AYEHU
C861A5D,Grade 11,01,MAHILET SINTAYEHU TESHOME
V50H4G3,Grade 11,01,MEKONEN TAMRAT HASEN
Y029M1P,Grade 11,01,MESEKEREM DAMITEW NIGATU
X63C0S7,Grade 11,01,MESERET MILLION BIRHANU
U796Q8B,Grade 11,01,MULUKEN HABTIE KASSIE
Q251G4W,Grade 11,01,MULUSET FEKEDE ENEYWU
L14X2Y0,Grade 11,01,NATNAEL WORKU NIGUSE
J08V6C5,Grade 11,01,NETSANET TESHOME NIGUSE
D439A7T,Grade 11,01,RUHAMA AMANUEL ELSHADAY
A69B1P2,Grade 11,01,SELAM BIRHANU SEYUM
W812U3X,Grade 11,01,SELAMAWIT HUSSEN GEMERO
N52F7Y9,Grade 11,01,SETEGN SEWNET AYCHEW
O179M5Z,Grade 11,01,SOLOMON TESFAYE BEKELE
R065C8U,Grade 11,01,TADIYOS DAWIT AIMERO
P381A4S,Grade 11,01,TARIKU SAMUEL SAGE
C246W0K,Grade 11,01,TEGENU MAMO TEKETEL
S903V7L,Grade 11,01,TESFAHUN FEYSA ASCHALEW
M750L2D,Grade 11,01,TINISAE TILAHUN MALE
G62A9B5,Grade 11,01,TSION ADDISU ALEMU
K81V4U0,Grade 11,01,YARED DESSIE HAILU
X549C7W,Grade 11,01,YEABSIRA TENAW ABEJE
Y930Q2N,Grade 11,01,YEABSIRA ELIAS ASHENAFI
Z268E1T,Grade 11,01,YOHANNES GETNET FANTAYE
U475M9P,Grade 11,01,ZEWDITU ADEM ENDRIE
I421A9F,Grade 11,02,ABENEZER AREGA LIBASE
O978K3U,Grade 11,02,ABLANTE DANIEL FESEHA
L65X2P0,Grade 11,02,ABRAM KEBEBEW TADESSE
R132Y7C,Grade 11,02,ADDIS GEDLU YERSAW
N207B6X,Grade 11,02,ASTER MULE BEYENE
W865S1Q,Grade 11,02,BEREKET TEKALGN LEGESE
T539U8E,Grade 11,02,DAGMAWI TADESSE GIDELEW
G08H2Q4,Grade 11,02,DAGMAWI TADESSE TILAHUN
Z79P5X1,Grade 11,02,DAWIT BIRU ALEMU
V641J7N,Grade 11,02,DAWIT ENDALKACHEW GASHE
X175A9R,Grade 11,02,EDEN DEREJE GASHAW
Q582C3L,Grade 11,02,EDILAM WENDIMENEH ASEFA
M320Y6K,Grade 11,02,EFESON ASSEFA WOLDEMARIAM
K716N5B,Grade 11,02,EYERUS AYALEW BABULE
P497R0T,Grade 11,02,FIKIRTEMARIAM WUBSHET ABEBE
H053Z2W,Grade 11,02,GELELA DAGACHEW GULELATE
S269A8Q,Grade 11,02,HANA WORKNEH H/MICHAEL
C917E4M,Grade 11,02,HAWA MOHAMMED ALI
B375N0V,Grade 11,02,HELEN YIRGALEM GASHAW
U50Q6D1,Grade 11,02,HENOK MULUGETA GIRMA
Y812K4Z,Grade 11,02,KALKIDAN BOJA WASE
O096T7S,Grade 11,02,KALKIDAN ALAMIYE DAMISE
W743P9L,Grade 11,02,KIDUS TESFAYE YEMIYAMREW
L259X1B,Grade 11,02,MALAKU KEBEDE MULUNE
J481M2R,Grade 11,02,MATEWOS ANDARGACHEW SEYUM
F620C5Q,Grade 11,02,MATIYAS ABAYE HABTEWOLD
E934U6V,Grade 11,02,MELKAMU GETAHUN WORKU
N107S8Y,Grade 11,02,MIHRET TEGEGNWORK ABEBE
D762Q0Z,Grade 11,02,MIKIYAS ABUSH TEREFE
A398R5H,Grade 11,02,MIKIYAS GETACHEW GEMEDA
X851B4J,Grade 11,02,NARDOS TAMRAT BIRU
G514Z9W,Grade 11,02,NARDOS TEWODROS ABERA
S037M6V,Grade 11,02,NEBIYAT GETACHEW YEMATAW
V682Y0L,Grade 11,02,SAMRAWIT GEZAHEGNE STEKAW
Q215X9U,Grade 11,02,SIRAGE BACHENE JEMAL
Y490P6D,Grade 11,02,SURAFEL ENDALE ENGEDA
M763H1K,Grade 11,02,TARIKU BIRILE ASRATE
B924W5O,Grade 11,02,TEKLEBIRHAN TEWODROS AZENE
H078E3A,Grade 11,02,TSEGAYE GEBREMEDHN DAWUD
Z435T8R,Grade 11,02,YARED TESFAYE NIGUSEE
C591U2X,Grade 11,02,YEABISERA GETACHEW ASTAWESEGN
F206B1N,Grade 11,02,YIGREMACHEW GIRMA TSEGA
K872Y4Q,Grade 11,03,ABEBA MERSHA LEGESE
O146Z9T,Grade 11,03,AMARCHE BOSHA BOLA
V921C6A,Grade 11,03,ASALIFEW BAYU ABEBE
D637U5L,Grade 11,03,BETELHEM METSHAFU ENDALEW
I504R8M,Grade 11,03,BILILIGN TSEGAYE BAYE
Q381W2X,Grade 11,03,BIRUK AYALEKEBET ALEME
N792S5G,Grade 11,03,DAWIT HAILEMICAEL WENDEMAGENGE
R465K0B,Grade 11,03,ELENI ALEMU GETACHEW
Y271M3H,Grade 11,03,EMEBET CHOLBO CHORZHA
P948B6F,Grade 11,03,ENDALKACHEW SOLOMON TADELE
C593X1Q,Grade 11,03,ENDALKACHEW ENDASHAW ABERA
B157H0O,Grade 11,03,ETAGEGN WUBETU DAGNE
G069K4R,Grade 11,03,GETABALEW WENDMU MELESE
T735U8Z,Grade 11,03,MU ABIYE BEKELE
W821M6L,Grade 11,03,MU KASSA WORKU
L204A7I,Grade 11,03,HALIMA BEDLU KEDIR
X659D2N,Grade 11,03,HAYAT HUSSEN YESUF
S917V8C,Grade 11,03,HENOK ESHETU BOGALE
M470Q3Y,Grade 11,03,HIRUT ADISU ABERA
Z083E5W,Grade 11,03,KALKIDAN GETINET WUDINE
Q528X9T,Grade 11,03,KIRUBEL NEBEREGN BESUYE
F194H6B,Grade 11,03,MAKDES BESHU ARGAYE
E352R7O,Grade 11,03,MEAZA ZERIHUN HASSEN
Y760L1K,Grade 11,03,MEKDES TADESSE FIKADU
H849C5U,Grade 11,03,MERGEE TAKILE TEREFE
B216S3D,Grade 11,03,MESEFEN ALEBACHEW ZEWDU
U035Z9P,Grade 11,03,NEGESTE ASHEBER YEMERU
C471N2W,Grade 11,03,REDIET WORKU MELESSE
A980M1G,Grade 11,03,SAMRAWIT TAYE FELEKE
X164Q5T,Grade 11,03,SELAM MULUKEN AMBAW
R693H8J,Grade 11,03,SISAY LEMMA EJGU
Z527B0Y,Grade 11,03,TADAMIK NIGUSSE MUNYE
W201U7E,Grade 11,03,TEGEGN MENDA MENE
N836K4V,Grade 11,03,TEMESGEN ABRIHAM DAMTE
G095Y2A,Grade 11,03,TIZITA TESFAYE ZONTE
O784P9S,Grade 11,03,TSIGEREDA MELKE WULETAW
E312J5R,Grade 11,03,YANET ZEBENE BEGASHAW
L940V6I,Grade 11,03,YEABSIRA DEREJE TSAGAW
J589D3Z,Grade 11,03,YEGEREMACHEW GIRMA TSEGA
S156Q0N,Grade 11,03,YIBELTAL MINALE MELESEW
D738A1C,Grade 11,03,YORDANOS GETACHEW MEBRATU
V017X4M,Grade 11,03,YORDANOS TAYE MENEDA
T187B2Y,Grade 11,04,ABDULKERIM NURU ABRAR
P751A8Q,Grade 11,04,ABEBE ADMASU ELE
N904G3U,Grade 11,04,ABRHAM SOLOMON AWELE
Q412X5D,Grade 11,04,AJEBEW ABEBE DEGUALEM
L068W9M,Grade 11,04,BAYUSH WELELAW TIRUNEH
C635S2F,Grade 11,04,BINIYAM GETU BAYE
B597V0H,Grade 11,04,BONTU GEMECHU TEREFE
H281Z3J,Grade 11,04,EDIDIYA BESUFIKAD LEMMA
U704P1X,Grade 11,04,EDLAM AYALKBET DENEKE
Z329A6G,Grade 11,04,EPHREM BEKELE WERKU
W576Y4R,Grade 11,04,EYERUS BEKELE DERIBE
D135B9Q,Grade 11,04,EYOSIYAS BEREKET KEBEDE
G802V7M,Grade 11,04,GETASETEGN BIRHAN ABEBE
R691U5L,Grade 11,04,GETENESH MULUGETA BEKELE
O947K2S,Grade 11,04,KALKIDAN DIRESS TIBEBU
Y053X8C,Grade 11,04,KALKIDAN NEGO BOCHENA
M169T0B,Grade 11,04,KEBDE ALEMU SHIFERAW
S482D7N,Grade 11,04,LEMLEM DERB AYELE
F710P5Z,Grade 11,04,MANDEFRO TSEGAYE TADSSE
E238L6W,Grade 11,04,MASTEWAL SELESHI KOSE
A954H1J,Grade 11,04,MEBEAMARIAM ALAYU WESENE
X061Q4V,Grade 11,04,MESKEREM MESFIN GENCHORE
K720Z8R,Grade 11,04,MURIDA MOHAMMED SEID
V395N2T,Grade 11,04,NAHOM DAGNACHEW CHEKOL
B863Y0H,Grade 11,04,NATNAEL GETASETEGN TEGNE
U148A7C,Grade 11,04,NATNAEL TAMRAT KEBEDE
J512G9L,Grade 11,04,REDIET ABERE EMAYU
W679M3S,Grade 11,04,RIBIKA EGO BUTA
T205R6N,Grade 11,04,SARON SAMUEL ALEMU
L473Q1K,Grade 11,04,SEID RIYAD HUSSEN
Q921B5U,Grade 11,04,SELAM DERESE 
N386Z7A,Grade 11,04,SINTAYEHU MISGANAWE TANEWI
C019E4W,Grade 11,04,TADESSE ALEGNETA GETAHUN
G537K6O,Grade 11,04,TAMIRAT BAYISA ADANE
S650X8P,Grade 11,04,TIGIST MANAYE BELAYNEH
P104W2V,Grade 11,04,TINBET TAMRAT BIRU
Y892J5H,Grade 11,04,TSION MAFEGNAW KITAW
Z745U0R,Grade 11,04,YETNAYET SINETAYEHU TESFAYE
K218H9C,Grade 11,04,YOHANIS SISAY TEKALIGN
R369N7Y,Grade 11,04,YOHANNES ASNAKE WELDEKIDAN
F850Q3B,Grade 11,04,YOHANNIS MINISHAW HAILU
E471C5X,Grade 11,04,ZEKARIYAS ASEBE ZENEBE
K871B9L,Grade 11,05,ADDIS ZELALEM WORKU
Y425J3W,Grade 11,05,ALAZAR GESSESE ESHETU
O098R7Z,Grade 11,05,AYESENAWU HABTAMU CAFE
P126A4U,Grade 11,05,BEREKET TESFAYE TALO
W395S0B,Grade 11,05,BETELEHEM AWLACHEW BOGALE
N582M6Q,Grade 11,05,BIRTUKAN HAYILEMARIAM DAMTEW
L710D3X,Grade 11,05,BUSHO TESHOME FETENE
Z634Q1H,Grade 11,05,DANEL TADESE MULATU
T957U8P,Grade 11,05,EDEN SAMUEL TESEMA
X201N4W,Grade 11,05,EFRATA HAILEMARIYAM WOLDESENBET
S543Y2K,Grade 11,05,EHITE GEBREMICHAEL FONZA
C486A0G,Grade 11,05,FEVEN AYFOKRU TSEGA
B791H6U,Grade 11,05,FIKRTE MESFIN BELTE
M928Q3Z,Grade 11,05,GENET TEGEGN SISAY
D615R5E,Grade 11,05,GENET TESHOME BELETE
Q072W1N,Grade 11,05,HAILE TAFESE FIREW
G834Z9L,Grade 11,05,HANA TAMENE TUFA
H190C5R,Grade 11,05,HIRUT BIZUAYEHU KEBEDE
J367V2Y,Grade 11,05,KALKIDAN ADDIS ALAYU
O529A8T,Grade 11,05,KALKIDAN WOLDE MOSHE
E856U1B,Grade 11,05,LOMI GIRMA KEBEDE
R641P7N,Grade 11,05,MARTA BEREKET TENA
U078C9M,Grade 11,05,MARTA ZEWGE KONTE
X213Z5H,Grade 11,05,MEKIDES SEWBIHON MIRE
P905N2A,Grade 11,05,MERON DEJENE GEBESA
L362Y0T,Grade 11,05,MIKIYAS SHEWATATEK TEFERA
S489H6R,Grade 11,05,NARDOS TAFESE TEFERA
C734B1Q,Grade 11,05,OBSE GADISSA TESHOME
A950E7W,Grade 11,05,ROBEL GETASETEGN DAMTEW
V173P9K,Grade 11,05,ROMAN TESFAYE SHEWAYE
Y621M4X,Grade 11,05,SUSNIYA SEIFU MUZEMIL
F987J0D,Grade 11,05,TENAYE ALEMU DEREJE
N215S7W,Grade 11,05,TEWODROS FEKADU DELELEGNE
Q590A3B,Grade 11,05,TIGST ABINEW TADEGE
B643U6L,Grade 11,05,TSIGE BEYENE TAYU
U801Y2M,Grade 11,05,WEBERST TEFERI DENGRESA
Z768K9C,Grade 11,05,WUDASSIE MEKONNEN NEGASH
D035Q5X,Grade 11,05,YEZINA MENBERE MESAY
H142R8T,Grade 11,05,ZENU TESHOME FETENE
W870T2F,Grade 11,06,ABREHAM MESFIN AGZE
L629C4Z,Grade 11,06,AHMED ZEYNU MUHAMED
B158S0V,Grade 11,06,ABEBA BELAY ZELEKE
O064W7N,Grade 11,06,BEMNET DEREJE ARAYA
Y321Q9R,Grade 11,06,BETELHEM AMARE MULU
Q785M1D,Grade 11,06,DAGMAWI TEWABE TALEMA
N932X5K,Grade 11,06,DAGMAWIT ASEGID MULUGETA
C476G3B,Grade 11,06,DANIEL TAGAY WAYAW
G513V8U,Grade 11,06,ELENI MELKU ALEBACHEW
M241Y0H,Grade 11,06,EYERUS TESFAHUN KASSAYE
X098P6T,Grade 11,06,FASILE TESFAYE TSEDEKE
A365N7W,Grade 11,06,FIREW YAWKAL GESSESSE
S107Z5L,Grade 11,06,GODADA ARAGAW MEKUANINT
D872Q9C,Grade 11,06,HANA GIRMA MEKONNEN
J493Y2B,Grade 11,06,HANA KIDANU MAMO
K601R8U,Grade 11,06,HAYAT MOHAMMED ASSEFA
P350V1G,Grade 11,06,HENOK WORKYE GASHAW
Z714A2X,Grade 11,06,HIWOT YELEKAL WALELGNE
U895B0M,Grade 11,06,KIDIST TESFAYE AWOKE
R263X7E,Grade 11,06,MARSELLA GIRMAYENEH MAMO
O429H1Y,Grade 11,06,MEKDELAWIT BAZEZEW SHEWATATI
V906G3P,Grade 11,06,MEKDELAWIT YIREFU HAILIYE
I153S8N,Grade 11,06,MEKDES GEZAHAGN SHIFERAW
E084Y6K,Grade 11,06,MEKDES TESHOME ABATENEH
W637C5A,Grade 11,06,MELAT BISRAT GASHAW
T549B1Q,Grade 11,06,MIRITNESH KIBRU NIMANI
Y103W8H,Grade 11,06,NARDOS ADDISU GUDETA
K847F6J,Grade 11,06,NATNAEL TILAHUN AYELE
P792B0X,Grade 11,06,NORDOS KASAHUN SHEWAREGED
U651A4M,Grade 11,06,REDIAT MIKIYAS MAMO
M908S2N,Grade 11,06,SAMARAWIT ANDINET HAILU
J263Y7E,Grade 11,06,SAMRAWIT GEBREWOLD SEIFU
H371A9L,Grade 11,06,SAMUEL AMBAYE AYIKA
L720X4N,Grade 11,06,SAMUEL DAGN MULUGETA
F518K0T,Grade 11,06,TIGIST ZEWDU TADESE
E290C6Z,Grade 11,06,TSEDENIYA DAGNACHEW SEMUNEG
D407Q3S,Grade 11,06,TSION AYENACHEW SHENKUT
A961W1R,Grade 11,06,WUDE SHIBIRE ZENEBU
X128U5M,Grade 11,06,YEABSRA ZEWEDU SHIFERAW
C536Z8Y,Grade 11,06,YOHANNES DEBEBE ZEWDE
g7h8b,Grade 11,07,AMANUIL CHERU GIRMA
c1l3y,Grade 11,07,ASMERA BANTE EWNETU
n6q2k,Grade 11,07,BETELHEM ADISU DEGEFA
z0y9a,Grade 11,07,BETELHEM ESHETU ASCHENAK
u4p5t,Grade 11,07,BLEN MESFIN CHERINET
w8s1r,Grade 11,07,DAGMAWIT ABABISH TEKALIO
i2x4j,Grade 11,07,DANEL TILAHUN MEBRATU
r9q0b,Grade 11,07,DAWIT MEKONEN ADERE
k5c7h,Grade 11,07,DEMOZ CHEBER ADBER
p1z3q,Grade 11,07,ELENI HAILU TAMENE
o3y6l,Grade 11,07,FANTAHUN ALEMAYEW MEKOMA
b6n9k,Grade 11,07,FERAHIWOT KETEMA KASE
u7w2p,Grade 11,07,FIKIRTE SISAY HAYLE
a4r5i,Grade 11,07,FIREHIWOT ABUYE EJIGU
g1e8v,Grade 11,07,GENZEBE AMECHA GAMO
h9q4c,Grade 11,07,HASET TAMIRU TEREFE
k2v1t,Grade 11,07,HAYAT NURADDIS BEDEWI
y0o7b,Grade 11,07,HIWOT SHAMBEL GESET
j5r3w,Grade 11,07,KALKIDAN AMARE ALEMU
n8a0z,Grade 11,07,KALKIDAN MIKIR TADESSE
u1g6p,Grade 11,07,KIDIST BAYU AMBERBER
c9h4y,Grade 11,07,LAYKUN H/GORGIS WENDIM
w3p0k,Grade 11,07,MAHLET HAILE ABRHA
r7j6b,Grade 11,07,MARTA TAYE NIGUSE
y0d8q,Grade 11,07,MEKDES MELAKU MESSA
p6a3h,Grade 11,07,MEKEDELAWIT ABATE YITREF
l1w5c,Grade 11,07,MEKEDES MULUGATA ZEWDA
q3s9v,Grade 11,07,MESFIN DEMISSIE BIRU
z8e6b,Grade 11,07,MIKIDES MENGESTU ZULA
b5n1w,Grade 11,07,NAHOM DEMISSIE DESTA
u9h4j,Grade 11,07,RAHEL DECHA DOJA
r4g0p,Grade 11,07,REDIAT ASEGED BESUYE
o2c7k,Grade 11,07,SELAMAWIT ESUBALEW WEND
y0w9a,Grade 11,07,TAMRAT GOREMS YEMER
k7l5z,Grade 11,07,TARIKUA ABAYNEH AMARE
i3n1h,Grade 11,07,TIGIST BAYU ABERA
s6p4w,Grade 11,07,TIGIST YIMER ASEKIK
c9b2q,Grade 11,07,WEGAYEHU WAYALE INJE
q1x5m,Grade 11,07,WERKU NIGUS ABEBE
u3h0b,Grade 11,07,ZINASH MEGERSA BEDADA
q7v8o,Grade 11,08,ALAZAR AKILILU ABATE
y4a1m,Grade 11,08,ALAZAR KASAHUN DEMISSE
h5p9z,Grade 11,08,ALEMTSEHAY DEREBA MULETA
u3i6q,Grade 11,08,ATALAY LAMESGEN BAYH
c1w2k,Grade 11,08,BEMENET DANIEL GETYE
w6g8r,Grade 11,08,BEREKET TEMESGEN WENDIMU
z0p5j,Grade 11,08,BIZUAYEHU KASAHUN TESHOME
k8v9b,Grade 11,08,EMEBET FEKADU BEKELE
o1c3u,Grade 11,08,ENANEYA AMLAKU YOHLA
b5y7h,Grade 11,08,ESETE SISAY GIRMA
r4x0z,Grade 11,08,EYERUS AMARE NEGATU
w1q6p,Grade 11,08,GENET WALELGNE WORKU
g9k3i,Grade 11,08,GENZEB HABTAMU DILO
p3n5r,Grade 11,08,GETE TADESSE WOLDEHAWARIAT
j0h1w,Grade 11,08,AMU DAMANA WULO
o7a4x,Grade 11,08,HAIMANOT BIRUK ABUGEBAR
t5c7z,Grade 11,08,HAIMANOT DERESE GEREMEW
b2y1q,Grade 11,08,HANA TESHIBELAY BOGALE
u0v8i,Grade 11,08,HIWOT GOREMS YIMER
w9k6b,Grade 11,08,HIWOT KASAHUN KEBEDE
r7d9p,Grade 11,08,HIWOT YOHANNES BELAYNEH
y5a1g,Grade 11,08,KALKIDAN SISAY MOGES
h4m8u,Grade 11,08,AN BIRHANU TESHOME
c1q3a,Grade 11,08,MAHLET SAMUEL SASO
g8a6p,Grade 11,09,GRADE,SECTION
e5s9r,Grade 11,09,UNIQUE_CODE,STUDENT_NAME
m2x1z,Grade 11,09,ARSEMA MAMARU ABEBE
l3i7w,Grade 11,09,AYELE ASFAW BEKELE
k9q5n,Grade 11,09,AYELECH KAMIRE KETA
o1b4c,Grade 11,09,BEREKET DEREJE ABEBE
h6d0q,Grade 11,09,BETELHEM SELEMON MULATU
w4y8s,Grade 11,09,BEZAWIT BOLADO BOKE
t2p5j,Grade 11,09,BILEN KEBEDE BELACHEW
u0g9f,Grade 11,09,DAGMAWIT TAKELE GETU
y7a3x,Grade 11,09,EDLAM KASAHUN MEKONEN
i8n2q,Grade 11,09,ELENI WALELEGN TEMESGEN
r5w1o,Grade 11,09,EYOB BIRHANU TEKETEL
c6z7k,Grade 11,09,FAIZA AHMED INDRIS
v9t4b,Grade 11,09,GENEZEB HABTAMU DILO
f0o8p,Grade 11,09,GETE WAKE MENJETA
b2y5s,Grade 11,09,HAREGUA TEGENEWORK ALEMAYHU
q7k8v,Grade 11,09,HIWOT BEHAILU BEKELE
d4j2a,Grade 11,09,HULUAGRSH SHEGAW GEBRESELIASE
a1p9o,Grade 11,09,HUSNIA SEIFU MUZEMIL
k9y3a,Grade 11,09,KALKIDAN MEKONNEN GEZEHGN
b3h0p,Grade 11,09,KIDUS BEZABH TEDLA
s5a6w,Grade 11,09,LEMLEM SHAMBEL ASHEBIR
z8g9n,Grade 11,09,MAHLET ALEMYE YILMA
u4k5q,Grade 11,09,MERON TEMESEGEN DESALEGN
o7c2h,Grade 11,09,NEBYAT HAILE SORBIA
e0l1r,Grade 11,09,REDIET AYELE ABERA
q3u4v,Grade 11,09,SARA HAILU ESHETU
w1i7y,Grade 11,09,SELAMAWIT SHEWAMOLTOT ZEWDE
g6p0a,Grade 11,09,SEMAHEGNE BELAY AWELACHEW
k9r3m,Grade 11,09,TAYIBACHEW GOREMS KEBEDE
o3c9j,Grade 11,09,TEWODEROS FEKADU DELELEGNE
p7y1h,Grade 11,09,TIRNGO BAMLAKU AREGAW
r4l5q,Grade 11,09,TSEHAY GIRMA KEBEDE
y0v8i,Grade 11,09,TSEHAY MILLION TEGEGNE
a1w4j,Grade 11,09,TSINAT NATNAEL ABEBE
j6g9p,Grade 11,09,YENENESH MAMUSH TESHOME
u8r2b,Grade 11,09,YOHANNES ABIYE MULUSAWU
q0e5t,Grade 11,09,ZEBIDER GOREMS GUAGU
-e 

===== static/csv/nexusteachers.csv =====
Grade,Section,Secret Code,Teacher Name,Subject,Salary (ETB/month),Role
9,1,SEAM0001,Sara Ejigu,Amharic,10000,Teacher
9,2,SEAM0001,Sara Ejigu,Amharic,10000,Teacher
9,3,SEAM0001,Sara Ejigu,Amharic,10000,Teacher
9,4,SEAM0001,Sara Ejigu,Amharic,10000,Teacher
9,5,TSIM0002,Tsion Siyum,English,10000,Teacher
9,6,TSIM0002,Tsion Siyum,English,10000,Teacher
9,7,TSIM0002,Tsion Siyum,English,10000,Teacher
9,8,TSIM0002,Tsion Siyum,English,10000,Teacher
9,9,NWUM0003,Netsanet Wudu,Maths,12000,Teacher
9,10,NWUM0003,Netsanet Wudu,Maths,12000,Teacher
9,11,NWUM0003,Netsanet Wudu,Maths,12000,Teacher
9,12,NWUM0003,Netsanet Wudu,Maths,12000,Teacher
9,9,SYIP0004,Seyum Yihune,Physics,12000,Teacher
9,10,SYIP0004,Seyum Yihune,Physics,12000,Teacher
9,11,SYIP0004,Seyum Yihune,Physics,12000,Teacher
9,12,SYIP0004,Seyum Yihune,Physics,12000,Teacher
9,9,DKEC0005,Dawit Kebede,Chemistry,12000,Teacher
9,10,DKEC0005,Dawit Kebede,Chemistry,12000,Teacher
9,11,DKEC0005,Dawit Kebede,Chemistry,12000,Teacher
9,12,DKEC0005,Dawit Kebede,Chemistry,12000,Teacher
9,9,CAFB0006,Chanie Afrash,Biology,12000,Teacher
9,10,CAFB0006,Chanie Afrash,Biology,12000,Teacher
9,11,CAFB0006,Chanie Afrash,Biology,12000,Teacher
9,12,CAFB0006,Chanie Afrash,Biology,12000,Teacher
9,9,ETMI0007,Endalk Tsehaye,IT,12000,Teacher
9,10,ETMI0007,Endalk Tsehaye,IT,12000,Teacher
9,11,ETMI0007,Endalk Tsehaye,IT,12000,Teacher
9,12,ETMI0007,Endalk Tsehaye,IT,12000,Teacher
9,1,BDMS0008,Beyenu Degefa,Sport,10000,Teacher
9,2,BDMS0008,Beyenu Degefa,Sport,10000,Teacher
9,3,BDMS0008,Beyenu Degefa,Sport,10000,Teacher
9,4,BDMS0008,Beyenu Degefa,Sport,10000,Teacher
9,1,TSMC0009,Tariku Seyifu,Citizenship,10000,Teacher
9,2,TSMC0009,Tariku Seyifu,Citizenship,10000,Teacher
9,3,TSMC0009,Tariku Seyifu,Citizenship,10000,Teacher
9,4,TSMC0009,Tariku Seyifu,Citizenship,10000,Teacher
9,1,DBAA0010,Dereje Basazen,Afan Oromo,10000,Teacher
9,2,DBAA0010,Dereje Basazen,Afan Oromo,10000,Teacher
9,3,DBAA0010,Dereje Basazen,Afan Oromo,10000,Teacher
9,4,DBAA0010,Dereje Basazen,Afan Oromo,10000,Teacher
9,5,EAMH0011,Endeshaw Asfaw,History,10000,Teacher
9,6,EAMH0011,Endeshaw Asfaw,History,10000,Teacher
9,7,EAMH0011,Endeshaw Asfaw,History,10000,Teacher
9,8,EAMH0011,Endeshaw Asfaw,History,10000,Teacher
9,5,CGMG0012,Chaltu Gedefa,Geography,10000,Teacher
9,6,CGMG0012,Chaltu Gedefa,Geography,10000,Teacher
9,7,CGMG0012,Chaltu Gedefa,Geography,10000,Teacher
9,8,CGMG0012,Chaltu Gedefa,Geography,10000,Teacher
9,5,YSEM0013,Yared Sisay,Economics,10000,Teacher
9,6,YSEM0013,Yared Sisay,Economics,10000,Teacher
9,7,YSEM0013,Yared Sisay,Economics,10000,Teacher
9,8,YSEM0013,Yared Sisay,Economics,10000,Teacher
9,5,NSAM0014,Negus Shenie,Amharic,10000,Teacher
9,6,NSAM0014,Negus Shenie,Amharic,10000,Teacher
9,7,NSAM0014,Negus Shenie,Amharic,10000,Teacher
9,8,NSAM0014,Negus Shenie,Amharic,10000,Teacher
9,5,GGIM0015,Gebrewahid Gidey,English,10000,Teacher
9,6,GGIM0015,Gebrewahid Gidey,English,10000,Teacher
9,7,GGIM0015,Gebrewahid Gidey,English,10000,Teacher
9,8,GGIM0015,Gebrewahid Gidey,English,10000,Teacher
9,5,BKUM0016,Balew Kefale,Maths,12000,Teacher
9,6,BKUM0016,Balew Kefale,Maths,12000,Teacher
9,7,BKUM0016,Balew Kefale,Maths,12000,Teacher
9,8,BKUM0016,Balew Kefale,Maths,12000,Teacher
9,9,ATIP0017,Alemshet Tamrat,Physics,12000,Teacher
9,10,ATIP0017,Alemshet Tamrat,Physics,12000,Teacher
9,11,ATIP0017,Alemshet Tamrat,Physics,12000,Teacher
9,12,ATIP0017,Alemshet Tamrat,Physics,12000,Teacher
9,9,AGEC0018,Alebet Getahun,Chemistry,12000,Teacher
9,10,AGEC0018,Alebet Getahun,Chemistry,12000,Teacher
9,11,AGEC0018,Alebet Getahun,Chemistry,12000,Teacher
9,12,AGEC0018,Alebet Getahun,Chemistry,12000,Teacher
9,9,SMFB0019,Samuel Mezgebe,Biology,12000,Teacher
9,10,SMFB0019,Samuel Mezgebe,Biology,12000,Teacher
9,11,SMFB0019,Samuel Mezgebe,Biology,12000,Teacher
9,12,SMFB0019,Samuel Mezgebe,Biology,12000,Teacher
9,9,AYMI0020,Ayinalem Kefale,IT,12000,Teacher
9,10,AYMI0020,Ayinalem Kefale,IT,12000,Teacher
9,11,AYMI0020,Ayinalem Kefale,IT,12000,Teacher
9,12,AYMI0020,Ayinalem Kefale,IT,12000,Teacher
9,5,YWMS0021,Yismaw Wasie,Sport,10000,Teacher
9,6,YWMS0021,Yismaw Wasie,Sport,10000,Teacher
9,7,YWMS0021,Yismaw Wasie,Sport,10000,Teacher
9,8,YWMS0021,Yismaw Wasie,Sport,10000,Teacher
9,5,WKMC0022,Wasihun Kassaw,Citizenship,10000,Teacher
9,6,WKMC0022,Wasihun Kassaw,Citizenship,10000,Teacher
9,7,WKMC0022,Wasihun Kassaw,Citizenship,10000,Teacher
9,8,WKMC0022,Wasihun Kassaw,Citizenship,10000,Teacher
9,5,NYAA0023,Nahom Yonas,Afan Oromo,10000,Teacher
9,6,NYAA0023,Nahom Yonas,Afan Oromo,10000,Teacher
9,7,NYAA0023,Nahom Yonas,Afan Oromo,10000,Teacher
9,8,NYAA0023,Nahom Yonas,Afan Oromo,10000,Teacher
9,5,ABMH0024,Anteneh Bekele,History,10000,Teacher
9,6,ABMH0024,Anteneh Bekele,History,10000,Teacher
9,7,ABMH0024,Anteneh Bekele,History,10000,Teacher
9,8,ABMH0024,Anteneh Bekele,History,10000,Teacher
9,5,ABME0025,Abadi Kiros,Geography,10000,Teacher
9,6,ABME0025,Abadi Kiros,Geography,10000,Teacher
9,7,ABME0025,Abadi Kiros,Geography,10000,Teacher
9,8,ABME0025,Abadi Kiros,Geography,10000,Teacher
9,9,MAAM0026,Melesse Asefa,Amharic,10000,Teacher
9,10,MAAM0026,Melesse Asefa,Amharic,10000,Teacher
9,11,MAAM0026,Melesse Asefa,Amharic,10000,Teacher
9,12,MAAM0026,Melesse Asefa,Amharic,10000,Teacher
9,9,YDIM0027,Yadesa Dugune,English,10000,Teacher
9,10,YDIM0027,Yadesa Dugune,English,10000,Teacher
9,11,YDIM0027,Yadesa Dugune,English,10000,Teacher
9,12,YDIM0027,Yadesa Dugune,English,10000,Teacher
9,9,THUM0028,Tesfay Hishe,Maths,12000,Teacher
9,10,THUM0028,Tesfay Hishe,Maths,12000,Teacher
9,11,THUM0028,Tesfay Hishe,Maths,12000,Teacher
9,12,THUM0028,Tesfay Hishe,Maths,12000,Teacher
9,9,ABIP0029,Azene Behailu,Physics,12000,Teacher
9,10,ABIP0029,Azene Behailu,Physics,12000,Teacher
9,11,ABIP0029,Azene Behailu,Physics,12000,Teacher
9,12,ABIP0029,Azene Behailu,Physics,12000,Teacher
9,9,MDEC0030,Manaye Demeke,Chemistry,12000,Teacher
9,10,MDEC0030,Manaye Demeke,Chemistry,12000,Teacher
9,11,MDEC0030,Manaye Demeke,Chemistry,12000,Teacher
9,12,MDEC0030,Manaye Demeke,Chemistry,12000,Teacher
9,9,ASFB0031,Animut Sinkie,Biology,12000,Teacher
9,10,ASFB0031,Animut Sinkie,Biology,12000,Teacher
9,11,ASFB0031,Animut Sinkie,Biology,12000,Teacher
9,12,ASFB0031,Animut Sinkie,Biology,12000,Teacher
9,9,GZMI0032,Getachew Zelalem,IT,12000,Teacher
9,10,GZMI0032,Getachew Zelalem,IT,12000,Teacher
9,11,GZMI0032,Getachew Zelalem,IT,12000,Teacher
9,12,GZMI0032,Getachew Zelalem,IT,12000,Teacher
9,1,KAMS0033,Kalid Ahmed,Sport,10000,Teacher
9,2,KAMS0033,Kalid Ahmed,Sport,10000,Teacher
9,3,KAMS0033,Kalid Ahmed,Sport,10000,Teacher
9,4,KAMS0033,Kalid Ahmed,Sport,10000,Teacher
9,1,ZAMC0034,Zerihun Abebe,Citizenship,10000,Teacher
9,2,ZAMC0034,Zerihun Abebe,Citizenship,10000,Teacher
9,3,ZAMC0034,Zerihun Abebe,Citizenship,10000,Teacher
9,4,ZAMC0034,Zerihun Abebe,Citizenship,10000,Teacher
9,1,YMAA0035,Yeshimebet Merdassa,Afan Oromo,10000,Teacher
9,2,YMAA0035,Yeshimebet Merdassa,Afan Oromo,10000,Teacher
9,3,YMAA0035,Yeshimebet Merdassa,Afan Oromo,10000,Teacher
9,4,YMAA0035,Yeshimebet Merdassa,Afan Oromo,10000,Teacher
9,1,EMH0036,Emebet Mitku,History,10000,Teacher
9,2,EMH0036,Emebet Mitku,History,10000,Teacher
9,3,EMH0036,Emebet Mitku,History,10000,Teacher
9,4,EMH0036,Emebet Mitku,History,10000,Teacher
9,1,AMMG0037,Abaya Merga,Geography,10000,Teacher
9,2,AMMG0037,Abaya Merga,Geography,10000,Teacher
9,3,AMMG0037,Abaya Merga,Geography,10000,Teacher
9,4,AMMG0037,Abaya Merga,Geography,10000,Teacher
9,1,TGME0038,Tadesse Gizachew,Economics,10000,Teacher
9,2,TGME0038,Tadesse Gizachew,Economics,10000,Teacher
9,3,TGME0038,Tadesse Gizachew,Economics,10000,Teacher
9,4,TGME0038,Tadesse Gizachew,Economics,10000,Teacher
10,1,ADAM0039,Andinet Demere,Amharic,10000,Teacher
10,2,ADAM0039,Andinet Demere,Amharic,10000,Teacher
10,3,ADAM0039,Andinet Demere,Amharic,10000,Teacher
10,1,LNIM0040,Lijalem Negassa,English,10000,Teacher
10,2,LNIM0040,Lijalem Negassa,English,10000,Teacher
10,3,LNIM0040,Lijalem Negassa,English,10000,Teacher
10,1,RBUM0041,Regassa Bayissa,Maths,12000,Teacher
10,2,RBUM0041,Regassa Bayissa,Maths,12000,Teacher
10,3,RBUM0041,Regassa Bayissa,Maths,12000,Teacher
10,4,AYIP0042,Ayinu Bacha,Physics,12000,Teacher
10,5,AYIP0042,Ayinu Bacha,Physics,12000,Teacher
10,6,AYIP0042,Ayinu Bacha,Physics,12000,Teacher
10,4,GTEC0043,Gebre Tarekegn,Chemistry,12000,Teacher
10,5,GTEC0043,Gebre Tarekegn,Chemistry,12000,Teacher
10,6,GTEC0043,Gebre Tarekegn,Chemistry,12000,Teacher
10,4,BYFB0044,Bishaw Yismaw,Biology,12000,Teacher
10,5,BYFB0044,Bishaw Yismaw,Biology,12000,Teacher
10,6,BYFB0044,Bishaw Yismaw,Biology,12000,Teacher
10,4,WMFI0045,Wolderufael Mekonnen,IT,12000,Teacher
10,5,WMFI0045,Wolderufael Mekonnen,IT,12000,Teacher
10,6,WMFI0045,Wolderufael Mekonnen,IT,12000,Teacher
10,1,SLMS0046,Shiferaw Leta,Sport,10000,Teacher
10,2,SLMS0046,Shiferaw Leta,Sport,10000,Teacher
10,3,SLMS0046,Shiferaw Leta,Sport,10000,Teacher
10,1,GLMC0047,Gossa Lema,Citizenship,10000,Teacher
10,2,GLMC0047,Gossa Lema,Citizenship,10000,Teacher
10,3,GLMC0047,Gossa Lema,Citizenship,10000,Teacher
10,1,SWAA0048,Samrawit Worku,Afan Oromo,10000,Teacher
10,2,SWAA0048,Samrawit Worku,Afan Oromo,10000,Teacher
10,3,SWAA0048,Samrawit Worku,Afan Oromo,10000,Teacher
10,1,DDMH0049,Daniel Desta,History,10000,Teacher
10,2,DDMH0049,Daniel Desta,History,10000,Teacher
10,3,DDMH0049,Daniel Desta,History,10000,Teacher
10,1,GGMG0050,Girma Gutema,Geography,10000,Teacher
10,2,GGMG0050,Girma Gutema,Geography,10000,Teacher
10,3,GGMG0050,Girma Gutema,Geography,10000,Teacher
10,1,DAEM0051,Daniel Ayele,Economics,10000,Teacher
10,2,DAEM0051,Daniel Ayele,Economics,10000,Teacher
10,3,DAEM0051,Daniel Ayele,Economics,10000,Teacher
10,4,RGAM0052,Roman Getye,Amharic,10000,Teacher
10,5,RGAM0052,Roman Getye,Amharic,10000,Teacher
10,6,RGAM0052,Roman Getye,Amharic,10000,Teacher
10,4,SHIM0053,Sintayehu Habtamu,English,10000,Teacher
10,5,SHIM0053,Sintayehu Habtamu,English,10000,Teacher
10,6,SHIM0053,Sintayehu Habtamu,English,10000,Teacher
10,4,BTUM0054,Birhanu Tsega,Maths,12000,Teacher
10,5,BTUM0054,Birhanu Tsega,Maths,12000,Teacher
10,6,BTUM0054,Birhanu Tsega,Maths,12000,Teacher
10,4,MAIP0055,Meseret Assefa,Physics,12000,Teacher
10,5,MAIP0055,Meseret Assefa,Physics,12000,Teacher
10,6,MAIP0055,Meseret Assefa,Physics,12000,Teacher
10,4,AWEC0056,Ayineshet Wondosen,Chemistry,12000,Teacher
10,5,AWEC0056,Ayineshet Wondosen,Chemistry,12000,Teacher
10,6,AWEC0056,Ayineshet Wondosen,Chemistry,12000,Teacher
10,4,AAFB0057,Alem Asrat,Biology,12000,Teacher
10,5,AAFB0057,Alem Asrat,Biology,12000,Teacher
10,6,AAFB0057,Alem Asrat,Biology,12000,Teacher
10,4,AAMI0058,Abebe Amsalu,IT,12000,Teacher
10,5,AAMI0058,Abebe Amsalu,IT,12000,Teacher
10,6,AAMI0058,Abebe Amsalu,IT,12000,Teacher
10,1,AKMS0059,Amare Kasie,Sport,10000,Teacher
10,2,AKMS0059,Amare Kasie,Sport,10000,Teacher
10,3,AKMS0059,Amare Kasie,Sport,10000,Teacher
10,1,GAMC0060,Gizachew Aluye,Citizenship,10000,Teacher
10,2,GAMC0060,Gizachew Aluye,Citizenship,10000,Teacher
10,3,GAMC0060,Gizachew Aluye,Citizenship,10000,Teacher
10,1,NDAA0061,Natnael Daniel,Afan Oromo,10000,Teacher
10,2,NDAA0061,Natnael Daniel,Afan Oromo,10000,Teacher
10,3,NDAA0061,Natnael Daniel,Afan Oromo,10000,Teacher
10,1,GAH0062,Gelane Atinkut,History,10000,Teacher
10,2,GAH0062,Gelane Atinkut,History,10000,Teacher
10,3,GAH0062,Gelane Atinkut,History,10000,Teacher
10,1,HAMG0063,Henock Abebe,Geography,10000,Teacher
10,2,HAMG0063,Henock Abebe,Geography,10000,Teacher
10,3,HAMG0063,Henock Abebe,Geography,10000,Teacher
10,1,SHEM0064,Sabagadis Hadego,Economics,10000,Teacher
10,2,SHEM0064,Sabagadis Hadego,Economics,10000,Teacher
10,3,SHEM0064,Sabagadis Hadego,Economics,10000,Teacher
10,7,AAAM0065,Anteneh Alemu,Amharic,10000,Teacher
10,8,AAAM0065,Anteneh Alemu,Amharic,10000,Teacher
10,9,AAAM0065,Anteneh Alemu,Amharic,10000,Teacher
10,10,AAAM0065,Anteneh Alemu,Amharic,10000,Teacher
10,7,GNIM0066,Gadise Negashe,English,10000,Teacher
10,8,GNIM0066,Gadise Negashe,English,10000,Teacher
10,9,GNIM0066,Gadise Negashe,English,10000,Teacher
10,10,GNIM0066,Gadise Negashe,English,10000,Teacher
10,7,AAUM0067,Adamu Amenu,Maths,12000,Teacher
10,8,AAUM0067,Adamu Amenu,Maths,12000,Teacher
10,9,AAUM0067,Adamu Amenu,Maths,12000,Teacher
10,10,AAUM0067,Adamu Amenu,Maths,12000,Teacher
10,7,HTIP0068,Hiwot Teshome,Physics,12000,Teacher
10,8,HTIP0068,Hiwot Teshome,Physics,12000,Teacher
10,9,HTIP0068,Hiwot Teshome,Physics,12000,Teacher
10,10,HTIP0068,Hiwot Teshome,Physics,12000,Teacher
10,7,KFEC0069,Kalkidan Fikadu,Chemistry,12000,Teacher
10,8,KFEC0069,Kalkidan Fikadu,Chemistry,12000,Teacher
10,9,KFEC0069,Kalkidan Fikadu,Chemistry,12000,Teacher
10,10,KFEC0069,Kalkidan Fikadu,Chemistry,12000,Teacher
10,7,TLFB0070,Tewodros Lemma,Biology,12000,Teacher
10,8,TLFB0070,Tewodros Lemma,Biology,12000,Teacher
10,9,TLFB0070,Tewodros Lemma,Biology,12000,Teacher
10,10,TLFB0070,Tewodros Lemma,Biology,12000,Teacher
10,7,SGMI0071,Selamawit Girma,IT,12000,Teacher
10,8,SGMI0071,Selamawit Girma,IT,12000,Teacher
10,9,SGMI0071,Selamawit Girma,IT,12000,Teacher
10,10,SGMI0071,Selamawit Girma,IT,12000,Teacher
10,4,ETMS0072,Ephrem Tilahun,Sport,10000,Teacher
10,5,ETMS0072,Ephrem Tilahun,Sport,10000,Teacher
10,6,ETMS0072,Ephrem Tilahun,Sport,10000,Teacher
10,4,FAMC0073,Frehiwot Assefa,Citizenship,10000,Teacher
10,5,FAMC0073,Frehiwot Assefa,Citizenship,10000,Teacher
10,6,FAMC0073,Frehiwot Assefa,Citizenship,10000,Teacher
10,4,YMAA0074,Yohannes Mekuria,Afan Oromo,10000,Teacher
10,5,YMAA0074,Yohannes Mekuria,Afan Oromo,10000,Teacher
10,6,YMAA0074,Yohannes Mekuria,Afan Oromo,10000,Teacher
10,4,MDH0075,Mahlet Dereje,History,10000,Teacher
10,5,MDH0075,Mahlet Dereje,History,10000,Teacher
10,6,MDH0075,Mahlet Dereje,History,10000,Teacher
10,4,SYMG0076,Simret Yonatan,Geography,10000,Teacher
10,5,SYMG0076,Simret Yonatan,Geography,10000,Teacher
10,6,SYMG0076,Simret Yonatan,Geography,10000,Teacher
10,4,YAEM0077,Yordanos Ashenafi,Economics,10000,Teacher
10,5,YAEM0077,Yordanos Ashenafi,Economics,10000,Teacher
10,6,YAEM0077,Yordanos Ashenafi,Economics,10000,Teacher
11,1,FGUM0078,Fikadu Getachew,Maths,14000,Teacher
11,2,FGUM0078,Fikadu Getachew,Maths,14000,Teacher
11,3,FGUM0078,Fikadu Getachew,Maths,14000,Teacher
11,1,RTIM0079,Rahel Tadesse,English,12000,Teacher
11,2,RTIM0079,Rahel Tadesse,English,12000,Teacher
11,3,RTIM0079,Rahel Tadesse,English,12000,Teacher
11,1,YYMI0080,Yonas Yideg,IT,14000,Teacher
11,2,YYMI0080,Yonas Yideg,IT,14000,Teacher
11,3,YYMI0080,Yonas Yideg,IT,14000,Teacher
11,4,AWMG0081,Addis Wushinfer,Geography,12000,Teacher
11,5,AWMG0081,Addis Wushinfer,Geography,12000,Teacher
11,6,AWMG0081,Addis Wushinfer,Geography,12000,Teacher
11,4,NBMH0082,Nuredin Bilal,History,12000,Teacher
11,5,NBMH0082,Nuredin Bilal,History,12000,Teacher
11,6,NBMH0082,Nuredin Bilal,History,12000,Teacher
11,4,GYME0083,G/medhen Yirdaw,Economics,12000,Teacher
11,5,GYME0083,G/medhen Yirdaw,Economics,12000,Teacher
11,6,GYME0083,G/medhen Yirdaw,Economics,12000,Teacher
11,4,GAUM0084,Getachew Alemu,Maths,14000,Teacher
11,5,GAUM0084,Getachew Alemu,Maths,14000,Teacher
11,6,GAUM0084,Getachew Alemu,Maths,14000,Teacher
11,4,BAIM0085,Biruk Admasu,English,12000,Teacher
11,5,BAIM0085,Biruk Admasu,English,12000,Teacher
11,6,BAIM0085,Biruk Admasu,English,12000,Teacher
11,4,ZFMI0086,Zelalem Fetene,IT,14000,Teacher
11,5,ZFMI0086,Zelalem Fetene,IT,14000,Teacher
11,6,ZFMI0086,Zelalem Fetene,IT,14000,Teacher
11,7,MZMG0087,Maesho Zegeye,Geography,12000,Teacher
11,8,MZMG0087,Maesho Zegeye,Geography,12000,Teacher
11,9,MZMG0087,Maesho Zegeye,Geography,12000,Teacher
11,7,MMH0088,Mehari Mekonnen,History,12000,Teacher
11,8,MMH0088,Mehari Mekonnen,History,12000,Teacher
11,9,MMH0088,Mehari Mekonnen,History,12000,Teacher
11,7,HFME0089,Hayelom Fitaw,Economics,12000,Teacher
11,8,HFME0089,Hayelom Fitaw,Economics,12000,Teacher
11,9,HFME0089,Hayelom Fitaw,Economics,12000,Teacher
11,7,BGUM0090,Beyene Getahun,Maths,14000,Teacher
11,8,BGUM0090,Beyene Getahun,Maths,14000,Teacher
11,9,BGUM0090,Beyene Getahun,Maths,14000,Teacher
11,7,YAIM0091,Yitayal Abebe,English,12000,Teacher
11,8,YAIM0091,Yitayal Abebe,English,12000,Teacher
11,9,YAIM0091,Yitayal Abebe,English,12000,Teacher
11,7,GHMI0092,Genet Hailu,IT,14000,Teacher
11,8,GHMI0092,Genet Hailu,IT,14000,Teacher
11,9,GHMI0092,Genet Hailu,IT,14000,Teacher
11,7,TAFB0093,Tsegaye Abebe,Biology,14000,Teacher
11,8,TAFB0093,Tsegaye Abebe,Biology,14000,Teacher
11,9,TAFB0093,Tsegaye Abebe,Biology,14000,Teacher
11,7,ADIP0094,Aster Demissie,Physics,14000,Teacher
11,8,ADIP0094,Aster Demissie,Physics,14000,Teacher
11,9,ADIP0094,Aster Demissie,Physics,14000,Teacher
11,7,DAEC0095,Dawit Asrat,Chemistry,14000,Teacher
11,8,DAEC0095,Dawit Asrat,Chemistry,14000,Teacher
11,9,DAEC0095,Dawit Asrat,Chemistry,14000,Teacher
11,7,MAMA0096,Mekdes Asfaw,Agriculture,14000,Teacher
11,8,MAMA0096,Mekdes Asfaw,Agriculture,14000,Teacher
11,9,MAMA0096,Mekdes Asfaw,Agriculture,14000,Teacher
12,1,SMUM0097,Selamawit Mulu,Maths,16000,Teacher
12,2,SMUM0097,Selamawit Mulu,Maths,16000,Teacher
12,3,SMUM0097,Selamawit Mulu,Maths,16000,Teacher
12,1,EKIM0098,Elias Kassahun,English,14000,Teacher
12,2,EKIM0098,Elias Kassahun,English,14000,Teacher
12,3,EKIM0098,Elias Kassahun,English,14000,Teacher
12,1,THMI0099,Tigist Hailu,IT,16000,Teacher
12,2,THMI0099,Tigist Hailu,IT,16000,Teacher
12,3,THMI0099,Tigist Hailu,IT,16000,Teacher
12,4,ATMG0100,Abebe Tesfaye,Geography,14000,Teacher
12,5,ATMG0100,Abebe Tesfaye,Geography,14000,Teacher
12,6,ATMG0100,Abebe Tesfaye,Geography,14000,Teacher
12,4,MBH0101,Marta Bekele,History,14000,Teacher
12,5,MBH0101,Marta Bekele,History,14000,Teacher
12,6,MBH0101,Marta Bekele,History,14000,Teacher
12,4,YAEM0102,Yohannes Assefa,Economics,14000,Teacher
12,5,YAEM0102,Yohannes Assefa,Economics,14000,Teacher
12,6,YAEM0102,Yohannes Assefa,Economics,14000,Teacher
12,4,BTUM0103,Bethlehem Tekle,Maths,16000,Teacher
12,5,BTUM0103,Bethlehem Tekle,Maths,16000,Teacher
12,6,BTUM0103,Bethlehem Tekle,Maths,16000,Teacher
12,4,STIM0104,Samuel Tadesse,English,14000,Teacher
12,5,STIM0104,Samuel Tadesse,English,14000,Teacher
12,6,STIM0104,Samuel Tadesse,English,14000,Teacher
12,4,FAMI0105,Frehiwot Asrat,IT,16000,Teacher
12,5,FAMI0105,Frehiwot Asrat,IT,16000,Teacher
12,6,FAMI0105,Frehiwot Asrat,IT,16000,Teacher
12,7,TAMG0106,Tewabech Alemu,Geography,14000,Teacher
12,8,TAMG0106,Tewabech Alemu,Geography,14000,Teacher
12,9,TAMG0106,Tewabech Alemu,Geography,14000,Teacher
12,7,SGH0107,Solomon Girma,History,14000,Teacher
12,8,SGH0107,Solomon Girma,History,14000,Teacher
12,9,SGH0107,Solomon Girma,History,14000,Teacher
12,7,EMEM0108,Eden Mekonnen,Economics,14000,Teacher
12,8,EMEM0108,Eden Mekonnen,Economics,14000,Teacher
12,9,EMEM0108,Eden Mekonnen,Economics,14000,Teacher
12,7,YGUM0109,Yared Getahun,Maths,16000,Teacher
12,8,YGUM0109,Yared Getahun,Maths,16000,Teacher
12,9,YGUM0109,Yared Getahun,Maths,16000,Teacher
12,7,HSIM0110,Hana Solomon,English,14000,Teacher
12,8,HSIM0110,Hana Solomon,English,14000,Teacher
12,9,HSIM0110,Hana Solomon,English,14000,Teacher
12,7,TBMI0111,Teshome Bekele,IT,16000,Teacher
12,8,TBMI0111,Teshome Bekele,IT,16000,Teacher
12,9,TBMI0111,Teshome Bekele,IT,16000,Teacher
12,7,AGFB0112,Amanuel Girma,Biology,16000,Teacher
12,8,AGFB0112,Amanuel Girma,Biology,16000,Teacher
12,9,AGFB0112,Amanuel Girma,Biology,16000,Teacher
12,7,HTIP0113,Hirut Tesfaye,Physics,16000,Teacher
12,8,HTIP0113,Hirut Tesfaye,Physics,16000,Teacher
12,9,HTIP0113,Hirut Tesfaye,Physics,16000,Teacher
12,7,DMEC0114,Daniel Mekuria,Chemistry,16000,Teacher
12,8,DMEC0114,Daniel Mekuria,Chemistry,16000,Teacher
12,9,DMEC0114,Daniel Mekuria,Chemistry,16000,Teacher
12,7,LAMA0115,Liya Abebe,Agriculture,16000,Teacher
12,8,LAMA0115,Liya Abebe,Agriculture,16000,Teacher
12,9,LAMA0115,Liya Abebe,Agriculture,16000,Teacher
-e 

===== static/csv/grade12_students.csv =====
UNIQUE_CODE,GRADE,SECTION,STUDENT_NAME
t7s0c,Grade 12,01,ABDURAZIK AWEL HUSSEN
p5n2k,Grade 12,01,ABIGIYA AKLILU MOTIKU
a1x6j,Grade 12,01,AMANUEL KETEMA KABA
b8i4r,Grade 12,01,ANILEY ASHEBIR BELAY
u3h0v,Grade 12,01,AYALEW EYAYU TEFERA
r4y9q,Grade 12,01,AYNALEM TENBERE TEPA
k6w1h,Grade 12,01,AZALU LETIKE HAILE
d9l5a,Grade 12,01,BAYUSH GEBREMESKEL DAMTO
v0g2c,Grade 12,01,BEREKET WOLDE YESHALALE
g7o4s,Grade 12,01,BEZA ATLABACHEW LAKEW
i2h3n,Grade 12,01,BEZAWIT MELESE YIREFU
w5p6k,Grade 12,01,BILEN TEFERA G/SELASSE
y1a9t,Grade 12,01,BIRTUKAN BEKELE DADI
o8v3c,Grade 12,01,BITANYA NEGASE GASHAWUTENA
r3l5i,Grade 12,01,EDOM GETAYE AMBAYE
e6b8k,Grade 12,01,ELIYAS DEMIE ASHENAFI
s9x2h,Grade 12,01,ELROE CHERINET YESHEWAMOLTOT
h0i6p,Grade 12,01,FIKIRTE WUBET KASE
u4n7y,Grade 12,01,HAYMANOT BEFEKADU MENGISTE
z1q5b,Grade 12,01,HENOK TESEMA SADIO
m7k3c,Grade 12,01,KALKIDAN GETNET WUDNEH
p8a4h,Grade 12,01,KALKIDAN ASNAKE BISHAW
v6r2n,Grade 12,01,KALKIDAN DEGENE ALEMU
w9j5u,Grade 12,01,KALYE TIRFE BIZUNEH
i1c9a,Grade 12,01,KIDIST DAWIT BIZUNEH
x0y7q,Grade 12,01,MEKDELAWIT GETAW TADESSE
l2u4z,Grade 12,01,MEKIDES FIKADU MULUGETA
g5w8o,Grade 12,01,MELESE BOJA MULATU
r7d1c,Grade 12,01,MIHRET TEFERI GANKA
q3b6n,Grade 12,01,MIKIYAS AYELE YOHANES
n9i4s,Grade 12,01,NATNAEL ERMIAS ASEBE
d5k0h,Grade 12,01,REDET MEYSAW ABAYENEW
a1z7q,Grade 12,01,SAMUEL CHALEW MULATU
h6l3p,Grade 12,01,SELAMSEWU SENTAYEHU WORKU
w0b9a,Grade 12,01,SISAY WORKU SOBOKSA
r2q5n,Grade 12,01,TADIOS ASECHALEWU RETA
u4y7b,Grade 12,01,TAMRAT ZEWDU ASMARE
p8s1c,Grade 12,01,TASFAHUN AGIDE KASSAHUN
v9h5w,Grade 12,01,TSIGE EYAYU ASRES
c0k7r,Grade 12,01,YABSIRA YIRGALEM GIRMA
g6j3i,Grade 12,01,YEABSERA SIMENEH MESFIN
t9y1o,Grade 12,01,YESHI TEFERA TEKUYE
h1r6s,Grade 12,01,YOHANNES AFEWORK MAMO
b3n4y,Grade 12,01,YORDANOS SHENKUT BELAYNEH
o0w9j,Grade 12,01,ZEKARIYAS ABEBE GEBREKIDAN
x7q6v,Grade 12,01,ZERIHUN AYELKEBET ADDISU
k4d5w,Grade 12,02,ABENT TAMERAT TADESE
y6i8r,Grade 12,02,ADDIS TADESSE HABTE
t1l0n,Grade 12,02,ADONIYAS TADDESSE GIDELEM
u8h7b,Grade 12,02,BEMENAT TILAHUN MALE
p2c4w,Grade 12,02,BEMNET ADUGNA SFER
z9q0a,Grade 12,02,BIRUK AMBACHEW ABEBE
j5l3h,Grade 12,02,BIRUK ASIGDEW BAYE
c7x9v,Grade 12,02,BIRUKTAWIT SUMET YILAK
n1i6p,Grade 12,02,DAGIM YISMASHEWA ABEBE
o0r2k,Grade 12,02,DANIEL AKLILU NIGUSSE
s3u4h,Grade 12,02,DECHASA TESHOME TOLOSA
a6x7q,Grade 12,02,EDEN MELKAMU ABATE
g1w3c,Grade 12,02,EDLAWIT MITIKU ALEHEGN
k8p9y,Grade 12,02,HAIMANOT TILAHUN TSEGAYE
d4i5b,Grade 12,02,HAMDU BECHENE JEMAL
q2z1o,Grade 12,02,HANA ZENA WELDESLASSIE
b7u4h,Grade 12,02,HASSEN MOHAMMED DAWUDE
t8m9k,Grade 12,02,HAYMANOT ABATYE MIDAYE
j0r6y,Grade 12,02,HAYMANOT ABAYHUN ALAYU
w5a2q,Grade 12,02,HELEN MASRESHA YEMIRU
c3g1v,Grade 12,02,HENOK ASEBE MEKURIA
x9k5b,Grade 12,02,HILINA AYFOKER ABABU
o6y8h,Grade 12,02,HIRUT ENGDASEW ZELELEW
r2q1w,Grade 12,02,HIWOT ZIMBELACHEW KIBRET
i5m3a,Grade 12,02,KALKIDAN TSEMRO BABA
v7h0c,Grade 12,02,MESERET HAILU DEREJE
q1u4y,Grade 12,02,MESKEREM WAJO ORA
l6z7s,Grade 12,02,MESRESHA BENEBER DIGAFI
h4x0b,Grade 12,02,MIHIRET HAILEMICAEL WENDEMAG
d9a3q,Grade 12,02,MIHRETU ATNAFU ALEMU
a0u6i,Grade 12,02,MILKA BEKELE KEBEDE
g3k8r,Grade 12,02,NATNAEL ZERIHUN BEKELE
m5w1y,Grade 12,02,NOLAWIHER BASAZENEW HABTEMI
p2i4a,Grade 12,02,REDEAT BEKELE GETAHUN
b8y7h,Grade 12,02,SEADA ABRAR JEMAL
t1q9s,Grade 12,02,SUDYES KEDIR UMER
x5r0p,Grade 12,02,SURAPHEL MULUGETA TACHBEL
w2j6i,Grade 12,02,TADESECH GEBREMARIAM GEBREGZ
y9u1a,Grade 12,02,TIGEST ABATEYE GIRMA
o6b4v,Grade 12,02,TIGIST GEZAHEGN ABERA
q3k7h,Grade 12,02,YANIT GESESSE BOGALE
h9i0o,Grade 12,02,YARED TUMBULE TUFA
z8q5r,Grade 12,02,YENEWORK ABERA BEYENE
u0y2c,Grade 12,02,YONAS BIRHANU ENGIDASHET
j1m7i,Grade 12,02,YONASE ASAMERE TEFERA
c6h0v,Grade 12,02,ZEKAREYAS TESFAYE GORAWU
s2a3k,Grade 12,02,ZEKARIAS BEWKETU TADEGE
r0c5i,Grade 12,03,ABEBECHE TESFAYE ARGENE
i4g8x,Grade 12,03,ABEL ENGEDAGET TEKELWOLDE
q1u2n,Grade 12,03,ABERHAM ABABI AMARE
t5b0v,Grade 12,03,ALAZER MELIS NIDA
y9h7c,Grade 12,03,AMANAWIT KABURA KANA
w7k3q,Grade 12,03,AMANUEL TEGENEGN BELETE
p4r1h,Grade 12,03,BEHAILU TESFAYE SHIFERE
z1v8a,Grade 12,03,BEMNET GIRMA BAHRU
k5n6q,Grade 12,03,BETELHEM DESU MIRANI
o7h0i,Grade 12,03,BETHELHEM WEGO WAZE
c9y3v,Grade 12,03,BIRUK YESHITELA DESTA
m2q1w,Grade 12,03,DAGMAWIT ABEBAW ADMASU
u0g4h,Grade 12,03,DAWIT ABEBE TESEMA
i8l6k,Grade 12,03,DAWIT ASTAWESEGN TADESSE
x5a9v,Grade 12,03,EDEN YIRGA SISAY
r1p2b,Grade 12,03,ELBETAL TEWODEROS WOLDE
q7y5m,Grade 12,03,ETAGEGN MALDAYE SEGERO
n3u1c,Grade 12,03,EYERUSALEM MULU MINWYE
j9i7o,Grade 12,03,EYOB WERKINEH FANTU
h6r0z,Grade 12,03,FIKIR SOLOMON ABAYE
w8c3s,Grade 12,03,FIKRTE LULE ASEFA
p0a6y,Grade 12,03,FIREHIWET BZUAYEHU CHERNET
l4j9i,Grade 12,03,HANA MABIRATOM G/MARIYAM
o7u5q,Grade 12,03,HAYAT SEID MAHAMED
g2c1b,Grade 12,03,HAYMANOT ABEBE BELETE
s8l9z,Grade 12,03,HIWOT NIGATU ESHETE
x4i3p,Grade 12,03,KIDIST TEKLYE YILMA
v6t8c,Grade 12,03,MAHLET ABABU GEZAHEGN
q0y1r,Grade 12,03,MEKDES GASHAW SHENEGELEGN
k3i5u,Grade 12,03,MEKDES GEZAHEGN KEBEDE
n1a4z,Grade 12,03,MEKEDELAWIT HABETAMU GELETU
h5o9q,Grade 12,03,MIHIRET DELELEGN BEYENE
u8b2p,Grade 12,03,MIKIYAS ADANE GIRMA
s6l0k,Grade 12,03,MITIKE SETARGE DAMTEWU
y9r4i,Grade 12,03,MITIKU WEGESO WANA
c2a7o,Grade 12,03,NARDOS BELETE MAMO
w1s4z,Grade 12,03,NATENAEL SINYE AYZOHBEL
g7k9h,Grade 12,03,NIGIST BELACHOW ASFA
p3e0v,Grade 12,03,SEBLE LIJALEM TEFERA
b0i6n,Grade 12,03,SURAFEL SHEWAKENA ADDISU
o4q2w,Grade 12,03,TEMESGEN GASHAW DERESE
x9z8b,Grade 12,03,TESFAYEHU WORKU MEKU
r5k1i,Grade 12,03,WESENE NEGESE G/YOHANES
u0p6q,Grade 12,03,YABESERA GETAMESAYE GEBRIYA
d7w5b,Grade 12,03,YESHWORK TESFAYE HAILU
a1g9m,Grade 12,03,YOSEPH TEGEGNEWORK ALEMAYEHU
r6q4u,Grade 12,03,ZERIHUN SISAY HAILE
y2c1h,Grade 12,04,ABDULJELIL BIRAHANU KAMIL
h0w8p,Grade 12,04,ABEBA DEMEKE MENGISTU
b7i5l,Grade 12,04,ABEL ZENEBE MUDISER
x4n2q,Grade 12,04,ARSEMA DEMISEWO TESFAYE
q1s6k,Grade 12,04,ARSEMA TEWODROS DEBEBE
v8c0a,Grade 12,04,ARSEMA TOLCHA TOGA
o2l5b,Grade 12,04,ASEGEDECH GEZAHAGN GARDA
r9h8y,Grade 12,04,ASNAKECH MAMO MAYI
d1z7u,Grade 12,04,ASRAT BANTLE BIZO
a5q9r,Grade 12,04,BEMNET AWEGCHEW BENEBERU
k0i4v,Grade 12,04,BETELEHEM DEREJE BAYU
t6u1h,Grade 12,04,BETELHEM GIRMA KUNTA
w3b4n,Grade 12,04,BETSELOT GEBALE GESSA
o9j7q,Grade 12,04,BIRKE KIDANU MAMO
x8r5y,Grade 12,04,DAGMAWIT TESFAYE MENGISTE
c5i2p,Grade 12,04,EDELAWIT ASHEBER ABATE
z1q4w,Grade 12,04,ELSABET ASAMINEW AKALU
g7a8b,Grade 12,04,EPHREM TSEGAYE BEKELE
n3l9x,Grade 12,04,ESKINDR MULUGETA ASEFFA
s0h6u,Grade 12,04,FASIKA FEKEDE BECHERA
v9y2a,Grade 12,04,FEVEN DANIEL ZEWEDAY
y5r1j,Grade 12,04,FISLETA ENDALE MITIKU
u3q6s,Grade 12,04,HAYMANOT SOLOMON DINKU
b0w9h,Grade 12,04,KEDIR AYELE BELETE
q7d5x,Grade 12,04,KEKENISA METEKU BOGALE
i6l8z,Grade 12,04,KIDIST ASEFA LEMENHE
r2u1a,Grade 12,04,MARAMAWIT SEDE LEMA
k8q4o,Grade 12,04,MARTA MESFIN GIZAW
h1y7b,Grade 12,04,MEHIRT KEBEDE WEGA
d5l9n,Grade 12,04,MEKDES MELKAMU MOLLA
a0c6r,Grade 12,04,MEKIDELAWIT SAMUEL DESTA
w3z2j,Grade 12,04,MESERET AWEKE MULUNEH
g7q8h,Grade 12,04,MESERET DIRIBA CHALA
n1s4v,Grade 12,04,MIHRET GIRMA MOGOSE
p9i7b,Grade 12,04,NARDOS SELAMON TADDESSE
x4e0w,Grade 12,04,SELAMAWIT ALEMAYEHU CHELBO
o0u3r,Grade 12,04,TAYE DAMTEW MELESE
v5h9j,Grade 12,04,TEDEROSE DELANT MAMO
c9q6u,Grade 12,04,TIGIST ZENEBE STOTAW
k2l0p,Grade 12,04,TSGSHET SHWANARGAW ASGELEL
u1y8h,Grade 12,04,YOSEPH ALEMU FANTAHUN
s4b9x,Grade 12,05,ADDISALEM SELEMON SIUME
e2h1c,Grade 12,05,ALAZAR ATNAFU ABAYNEH
z7w0m,Grade 12,05,ATSEDE ASMAMAW ALEM
t5q3b,Grade 12,05,AYNALEM MAMUSHIT GEBREMESKEL
i0k7h,Grade 12,05,BELETECH WEBANTE ABEBE
b3g6v,Grade 12,05,BETELEHEME SHAWEL GEBRETSADIK
p9u4z,Grade 12,05,BETELHEM ABAWKAW ZIKARG
k1e0i,Grade 12,05,BEZA SERMO SHALA
o6r2a,Grade 12,05,BEZAWIT YILMALEGN GETACHEWU
h7q5s,Grade 12,05,BINIYAM ACHENE BAHRU
c4n8w,Grade 12,05,DEME DEREJE ALEMU
g0j1u,Grade 12,05,DEMEKECHE MISFEN KALO
s2p5a,Grade 12,05,EHETEMARIYAM TARIKUB KEBEDE
y8d1l,Grade 12,05,EMEBET DESTAW KASE
q5b4y,Grade 12,05,ENDAWAYSH YIMER ALI
n1v7h,Grade 12,05,ERMIYAS ASFAW TESFAYE
w7k3c,Grade 12,05,EYERUS GETACHEW DEGEFA
a0q6t,Grade 12,05,EYERUSALEM ABAYNEH ASFAWESEN
o4y9n,Grade 12,05,GELILA BAHIRU ASEMAHGNE
z6h5w,Grade 12,05,HEWAN MEKONNON ADMASE
p2b1i,Grade 12,05,HIWOT KIDANU WORKNEH
k8m4q,Grade 12,05,KALKIDAN TESFAYE GETANEH
t3v9h,Grade 12,05,KASSAHUN ENDALAMAW EMERE
y1a7q,Grade 12,05,MESKEREM ENDAZENEW WODAJENEH
b0x3i,Grade 12,05,MICKIYAS ENGIDA ABEBE
u5r6n,Grade 12,05,MIKIYAS EYASU GEBRETSADIK
h7j1z,Grade 12,05,NAHOM MULATU MEKONNEN
q9v4k,Grade 12,05,NARDOS ENGEDA TESHOME
c1h5s,Grade 12,05,NETSANET MELAKU FARIS
m6y2d,Grade 12,05,SAMRAWIT TAFFESE WONDMKUN
x8u0a,Grade 12,05,SARA ZEWDU BASE
t3w7i,Grade 12,05,SEBLE KASAHUN KEBEDE
z0r1g,Grade 12,05,TAMIRAT BIZUNEH BAKO
o5l9v,Grade 12,05,TIGIST GENANAW HAILU
k1q6h,Grade 12,05,TRUSEW ABEW BESAZINEW
u7c3p,Grade 12,05,WEYNSHET TADESE TESFAYE
h0a5m,Grade 12,05,YETNAYET TENA GASHAW
s5u2i,Grade 12,05,YIDNEKACHEW BEDORE BEKELE
p8x9q,Grade 12,05,YONAS WENDEMAGEGN YILMA
b1q6z,Grade 12,05,YONATAN GEZAHEGN GIZAW
x3d4v,Grade 12,05,ZEKARIYAS YONAS AYALEW
a4c0w,Grade 12,06,ABENEZER DEREJE ESHETU
v2w9r,Grade 12,06,ABREHAM GETU MAMO
k5q6u,Grade 12,06,ABRHAM KASSAHUN PAULOS
r9b3y,Grade 12,06,AFOMIYA TILAHUN FANTAHUN
h7t0d,Grade 12,06,ASAMENCHE MEKONENE METOSHA
o2x3p,Grade 12,06,ASRATE ALEM MEKONNEN
s1q8i,Grade 12,06,AZALECH ADEMA GOBOZE
c6l4z,Grade 12,06,BANCHALEM KASAHUN IMERU
j0u7h,Grade 12,06,BETHLEHEM MUATE MAZENGIA
w8r3b,Grade 12,06,BETLIHEM ASERESE TEKELE
y9q1p,Grade 12,06,EDEN BASAZENEW MAMO
k5c8t,Grade 12,06,ELENI WALELIGNE TEMSGEN
b0h4j,Grade 12,06,FIKERTE GETACHEW SIMEGNEW
p2w7k,Grade 12,06,GATASETEGNA ASCHALEW SHEWAYE
u9z5o,Grade 12,06,GEDION ASHABIR DIRIBA
r6q1w,Grade 12,06,GULEMA TESHEBELAY BOGALE
j2h8y,Grade 12,06,HANA TAREKEGN KASA
c5o4u,Grade 12,06,HANA WORKNEH JEMBERIE
w9z0b,Grade 12,06,KALKIDAN ABERA G/GIORGIS
x1p5k,Grade 12,06,KALKIDAN ADISSU TSEGAW
a7l8t,Grade 12,06,KALKIDAN DANIEL GETYE
s3b5q,Grade 12,06,MARTA ASCHALEW SHIFERAW
d0j1h,Grade 12,06,MEKDES ABEBE RETA
g4q9o,Grade 12,06,MESERET GUTAMA SORI
p2c5v,Grade 12,06,MESKEREM ALEMAYEHU MENGESHA
k8w3a,Grade 12,06,MESKEREM KAMBI KASH
y6l1s,Grade 12,06,MESKEREM MERHATSADIK H/GHIORGI
u9b7h,Grade 12,06,NATNAEL WUSHINFR TIRKIK
h3o0w,Grade 12,06,NIGUSE SEIFU ANKA
q0c6r,Grade 12,06,SAMRAWIT DEBALKE MERSHO
w5k2p,Grade 12,06,SAMRAWIT DEMEKE GOSHU
i9q5z,Grade 12,06,SELAM GEDAMU ADMASE
t1h8j,Grade 12,06,SELAM MELKAMU ABEBE
b7y4n,Grade 12,06,SELAMAWIT ENDALE KEBEDE
o2w0i,Grade 12,06,SEMIRA NESRO MOHAMMED
f6m3u,Grade 12,06,TARIKU DEMEKE MAMO
c3r5a,Grade 12,06,TIGIST KIBRET TESSEMA
v9p1z,Grade 12,06,TIGIST GEZAHAGN NEGA
z8k4q,Grade 12,06,TSION GETACHOW KEBEDE
h1y7r,Grade 12,06,YOHANNSE GUCHE CHEKOLE
k5l0c,Grade 12,06,YOHNNES ALEMAYHU TADESE
q2b6w,Grade 12,07,ABRHAM SELEMON HAYLU
i9k4r,Grade 12,07,ADANE KIBATU GEBRE
x3y0n,Grade 12,07,ADANECH ASRESE TIRUNEH
w7u5c,Grade 12,07,ADBARU ALEMAYEHU TIPOTA
z0q9h,Grade 12,07,AMELEWORK ASHENAFI TEKLE
n4e2b,Grade 12,07,BANCHGEZE MOGNE BYABL
s6l5z,Grade 12,07,BEREKET ASHEBIR SISAY
d1a8w,Grade 12,07,BESUFEKAD ANDUALEM DEBEBE
g8u4k,Grade 12,07,BETELHEM SAMUEL ASMAMAW
p0c1i,Grade 12,07,BETELHEM WALTANIGUS GEBEYEHU
y7h6r,Grade 12,07,BIRKE AGMAS ABATE
k9v3a,Grade 12,07,DAGM DEJENE DEMEKE
o5p0n,Grade 12,07,EDEN BEZA GIRMA
t1a3r,Grade 12,07,FITSUM ABINET DAMENA
b7d5h,Grade 12,07,GENZEB BAYELEGN W/SENBET
h2w1u,Grade 12,07,HANA KEBEDE WUBE
q4l6k,Grade 12,07, NESRU MUZE
s0x8v,Grade 12,07,HILINA ABATE MISA
u6g9c,Grade 12,07,HIWOT SHAMBEL GESETE
e3n2p,Grade 12,07,KALKDAN TEKELE ADISS
r7w5i,Grade 12,07,KEBEDE BOGALE MEKURIA
x1l0z,Grade 12,07,MESKEREM BOCHANA BORANA
j9y7h,Grade 12,07,MICHAELE CHERNET MELSSE
p0k3u,Grade 12,07,MISIKER DAMTE TALEMA
c4r9n,Grade 12,07,MULUKEN TESFAYE GIRMA
g6h1w,Grade 12,07,RAHEL GIRMA AYELE
s8v4a,Grade 12,07,SELAM DEKOSA TESFAYE
y2q0m,Grade 12,07,SELAMAWIT ALEMAYEHU CHELBO
k9e5z,Grade 12,07,SHWATSEHAY GIRMA SISAY
o3b1h,Grade 12,07,SINTAYEHU YIFRU KEBEDE
u6v4c,Grade 12,07,TIGIST ASCHALEWU GEBEYEHU
r5w7o,Grade 12,07,TIGIST GETU BIRHANU
j0a9g,Grade 12,07,TSEGAYE MITIKU GEBRE
c8y3d,Grade 12,07,WENDMAGEGN ABYOT MOLISO
n1q6i,Grade 12,07,WERKINESH SEBOKA TOLLA
a7t9p,Grade 12,07,WEYNESHET WEGASO WOTANGO
p9l3z,Grade 12,07,YAFET YILAK GETAHUN
v4r0k,Grade 12,07,YEABSERA TESFAYE BELAYNEH
d5u3o,Grade 12,07,YOHANS BEZUYE YEDEG
q1b7m,Grade 12,07,YONAS YILMA FENTA
w0h4x,Grade 12,07,YOSEPH TESFAYE NIGUSSE
m2u6r,Grade 12,08,ABERHAM SHITA ASFAW
i6g9l,Grade 12,08,ABUSH CHELGE CHERE
w1c3z,Grade 12,08,ALEM KIDANE W/TENSAY
q9x2k,Grade 12,08,ALEM SHIFERAW ASFAW
y3m6r,Grade 12,08,ATSEDEMARYAM MENASE BEYENE
o7h1b,Grade 12,08,AUMER RESAD ABDELA
r0y8w,Grade 12,08,BEZUAYEW ENDALE WOLDAY
c4a7u,Grade 12,08,ELSABET TEMSGEN SHEMSU
j6p3i,Grade 12,08,ENDESHOW NIGATU WOSENE
g9r1y,Grade 12,08,ERMIYAS ASMAMAW MENGISTU
p5k4b,Grade 12,08,ETSAGENET MAMO KACHO
z3x9u,Grade 12,08,EYOB TSEGAYE NIGUSE
u7v2j,Grade 12,08,FEKADU WAKE NEGAWO
s1h5p,Grade 12,08,GENET GERMAW ERGET
b0l8q,Grade 12,08,HANA GIRMA ADUGNA
k6w2a,Grade 12,08,KALKIDAN BAYOULIGN KEBEDE
y9j5h,Grade 12,08,KALKIDAN FEKADU HAILE
t7r3m,Grade 12,08,NI TADESE GEMEDA
n1c9o,Grade 12,08,KIDIST DESSALGNE NEMANI
q4x6z,Grade 12,08,MAHLET ASHAGRE BELAYNEH
r0y2b,Grade 12,08,MARTA ZERIHUN ZEMELA
u7g9a,Grade 12,08,MEKDES SHIFERAW AZENE
k3h1p,Grade 12,08,MELAKU BIRAHANU DUNE
d9q5x,Grade 12,08,MESERT GETAWEY ABERA
j5s2u,Grade 12,08,NABIYU MAMO MATIWOS
p8c0h,Grade 12,08,REDIET TAYE BELETE
v0k3q,Grade 12,08,RUHAMA KUBRE GUTU
w2u6i,Grade 12,08,SELAM MISA AYEHU
c5y9a,Grade 12,08,SEMIRA ADEM ED
x1g4t,Grade 12,08,SIMENESH GEBEYEHU AKALU
l0d7v,Grade 12,08,SINTAYEHU BEFIKADU DESALEGN
q3r2i,Grade 12,08,SINTAYEHU TAKELE GETU
b9k5y,Grade 12,08,SINTAYEHU TESHOME NIGUSE
h6a1r,Grade 12,08,SOLIYANA SOLOMON FELEKE
o9t4u,Grade 12,08,TENSAY HAYMRO BEZE
g2l7k,Grade 12,08,TSEDALE GELETAW YEMRU
t7b5q,Grade 12,08,TSINGE GELETAW YEMRU
328k1,Grade 12,08,TSEHAY SISAYE MERSHU
59402,Grade 12,08,TSION DULA MOSHE
376k1,Grade 12,08,YORDANOS HAILEYESUS ALEMAYEH
U09b1,Grade 12,08,YOSPHE DESALEGN MAMO
F6513,Grade 12,08,ZEWUDU YESIGAT ASCHALEW
t5j7w,Grade 12,09,AMAR SEID HASSEN
k6c9r,Grade 12,09,ANDUALEM EYASU MANDEYE
o9x2b,Grade 12,09,ARSEMA BILILIGN ABATE
z4u5i,Grade 12,09,BEMNET MOGES ALEMU
p1a8q,Grade 12,09,BETSELOT GEBALE GASSA
u7l4z,Grade 12,09,BIRTUKAN MESELU BASE
w9e1d,Grade 12,09,BIRTUKAN SHEWA ABOSERA
r2m7j,Grade 12,09,BIZUHAYU DEMIS ABABU
v0g4p,Grade 12,09,DAWIT AMARE AYSA
q5b1k,Grade 12,09,DEMEKECH KAMBO KASH
o7y8h,Grade 12,09,ELSABET SISAY WOLDEAMANUEL
e3z5t,Grade 12,09,ERMIAS WUDINEH LEMESA
s0u2a,Grade 12,09,EYERUS SILSHI TAFESE
j9w5i,Grade 12,09,FIREALEM WONDESEN GIMTYELEW
c1q8n,Grade 12,09,FOZIYA MUHABA DINO
x6k3r,Grade 12,09,HAILEGZIABHER MESFIN ESUBALEW
b4h0v,Grade 12,09,HANAN NESRU MUZE
p0a6w,Grade 12,09,HIWOT ADUGNA NIGUSSIE
l8t9q,Grade 12,09,KALKIDAN GEBRE AYALEW
k1y6a,Grade 12,09,LALISE TEKLE TEREFE
h3c4p,Grade 12,09,MAHLET BIRUK TADESSE
u7r0i,Grade 12,09,MAHLET BISEWUR GEZAHEGN
w2x6b,Grade 12,09,MAHLET SEBSIBE KINFE
p5h1q,Grade 12,09,MARTA DESALEGN NERIE
z9l4w,Grade 12,09,MERON AMARE CHOROFO
s7d3a,Grade 12,09,METASEBYA ASAMENEW BELETE
a9q5g,Grade 12,09,MISGANAW ALEMAYEHU KANTA
d1z7q,Grade 12,09,NESTANET DUBALE ASNAKE
g6v4j,Grade 12,09,SABA WALEWA TEFERA
h0k9p,Grade 12,09,SAMUEL TESFAYE ASEGID
p8u2l,Grade 12,09,SELAMAWIT ANJA ALEMU
w3a5i,Grade 12,09,SOSENA BAYE YIMERE
u7r1c,Grade 12,09,TADEL BITEW FENTI
o2z4h,Grade 12,09,TIBLETS TESFU ADMASU
c4q8m,Grade 12,09,TIZITA BESHAH MENGISTE
x9w5j,Grade 12,09,WAGAYE BEHAILU BERHANU
i2b7k,Grade 12,09,WEGEN HAILEGEBRIEL KEBEDE
q5u0n,Grade 12,09,WELDEYOHANES ASEGDEW KEBEDE
l6r4y,Grade 12,09,YIGARDU DEMEKE W/YOHANNES
s0c7z,Grade 12,09,YOHANNES GUCHE CHEKOL
h8a1p,Grade 12,09,ZEMENAY ATANAW BIYAZN
-e 

===== static/csv/grade10_students.csv =====
UNIQUE_CODE,GRADE,SECTION,STUDENT_NAME
6h0t9,Grade 10,1,AMANUEL WALE REDA
r2e4a,Grade 10,1,ASHENAFI GIRMA SEMU
y7j1z,Grade 10,1,AYALKEBET EWNETE AYENEW
b9v5q,Grade 10,1,BILILIGN NOBO MAMECHA
x3c8p,Grade 10,1,BIRUK ABABUYA GETAW
n1l6s,Grade 10,1,DAGIM ZERIHUN ABABU
u8f2m,Grade 10,1,EYERUSALEN ALEMSEGED ABEBE
i5g9w,Grade 10,1,EYOB AYINALEM GETACHEW
o4k3t,Grade 10,1,FAIZA JELALU SHENATAY
d7h0r,Grade 10,1,FIREHIWOT SOLOMON WORKU
z1b4e,Grade 10,1,HABTAMUA TESEFAYE TEREFE
q6n7y,Grade 10,1,HAILE KEBEBEW ADISSE
p0m5u,Grade 10,1,HAILEMARIAM MESFIN CHALA
w3a6k,Grade 10,1,HANNA TARIKU KEBEDE
s5v1g,Grade 10,1,HIKMA ABRAR JEMAL
f8x9l,Grade 10,1,KALKIDAN ABRHAM TSEGAYE
a2q0n,Grade 10,1,KASU TAGE ABATE
e4c7i,Grade 10,1,LEUL TEHA MOHAMMED
j1t3b,Grade 10,1,LIDIYA SHEMELES FEKEDE
m0y6h,Grade 10,1,MAHLET GETASETEGN TADESE
g5l8v,Grade 10,1,MAHLET SELEMON GETACHEW
k9p2r,Grade 10,1,MARAMAWIT TEGENWERK MUSHER
t1d4x,Grade 10,1,MEAZA DEMIS KIFETEW
h3b7f,Grade 10,1,MEKEDELAWIT TEWODEROS KEBEDE
c0i1w,Grade 10,1,MERON BETRU LEGESE
l7s5a,Grade 10,1,MESKEREM TILAHUN BELAYNEH
v6e2k,Grade 10,1,MIKIAS KASSAHUN ZEMDEKUN
o1r8j,Grade 10,1,MISIKIR GOSHU DERESSE
u4p9z,Grade 10,1,MISTRE TEKETEL MESHESHA
x0f5c,Grade 10,1,NAHOM ABEBE LEMA
n8a2w,Grade 10,1,NAHOM TESFAYE MULAT
q3y6l,Grade 10,1,NATNAEL DEMEKE MELESE
i2k7p,Grade 10,1,TEMESGEN GETU SHIFERAW
g9s1m,Grade 10,1,TSNAT GETYE AYALEW
t5v4f,Grade 10,1,UMER MAMUSHET YESUF
b1j8o,Grade 10,1,YONAS GASHAW EWUNATU
p4r0w,Grade 10,2,ABEL ENDALE MEKURIYA
x6k9a,Grade 10,2,BEIMNET DEGENE BABURE
f3t1s,Grade 10,2,BELAY ADEME TENAHU
z5b8q,Grade 10,2,BEREKET SEYFU TELAHUN
c9i2v,Grade 10,2,BINIAM SOLOMON TELAHUN
h1o5n,Grade 10,2,BIRTUKAN ASHEBR KETEMA
w7p4f,Grade 10,2,DAWIT ASGIDEW SHEWAMENE
k2y0r,Grade 10,2,EDELAWIT ALEM TAFERE
s4a7m,Grade 10,2,GENET ABAYU GASHAW
u0e3j,Grade 10,2,HABTAM BIRHANU GASHAW
l8g6i,Grade 10,2,HAYLEGEBREL TSEGUYE BAZEZEW
a5q9c,Grade 10,2,HELEN TAYE EMEYA
n1w2x,Grade 10,2,HIWOT GASHAWBEZA KEFELEGN
e7f4b,Grade 10,2,KALKIDAN EPHREM TESHOME
r9v0q,Grade 10,2,KALKIDAN HABTAMU WORKU
y2p6k,Grade 10,2,MEKEDLAWT ZEMEDEKUN AREGA
d8h3u,Grade 10,2,MELAKU TESHOME DEREJE
g0j5b,Grade 10,2,MIHRT W/AMANUEL DESALEGN
m6s1a,Grade 10,2,MULUGETA NIGUS ABEBE
c4i7y,Grade 10,2,NATNAIEL WINDIFRAW MEKURIA
q9x2z,Grade 10,2,NETSANET HABTAMU GETACHEW
b5v0f,Grade 10,2,REDET TAREKU WELDEMARIYAM
h2l4s,Grade 10,2,ROMAN GETU MELESE
u8t7w,Grade 10,2,SELAM DESEW NEGASH
k0p1i,Grade 10,2,SELAMAWIT TAFESE ALEMU
j3q6y,Grade 10,2,SURAFEL TEHAKEL ENDALE
e6x9n,Grade 10,2,SURAFEL YITBAREK DEMISSIE
o1a4l,Grade 10,2,TARIKU ALAMAREW KASAHU
s7z2c,Grade 10,2,TESFAYE KINDIYE DEMOZ
w5i8b,Grade 10,2,YABISRA GETENET NGUSA
y0r5i,Grade 10,2,YABSIRA AKEBEREGN SHIFERAW
a7n9v,Grade 10,2,YARED NUGUS MASRASHA
p6d1k,Grade 10,2,YEABSIRA ASMARE AYZOHEBEL
g8x3q,Grade 10,2,YEZINA MERZO ALULA
t2l5j,Grade 10,2,YONAS GETAYENEW MARU
b9f0c,Grade 10,2,YUHANNES GIRMA KEBEDE
x3i7w,Grade 10,3,ABDULKAF DINSEFA SHIFA
u1p5q,Grade 10,3,ABEL NEGASH MOGES
n4g9o,Grade 10,3,BEZA ALEMAYEHU BUKA
c8e2v,Grade 10,3,BILEN MELESSE REGGASSA
i0k6r,Grade 10,3,CHRISTIAN DANIEL AWGUCHEW
q7y3l,Grade 10,3,DAWIT HABTAMU MENGESTU
b5n1x,Grade 10,3,ERMIAS TAMIRU ZELEKE
h9s4w,Grade 10,3,ESKEDAR TAREKEGN SHUKRU
r2m0f,Grade 10,3,FASIKA GETIYE DEMISE
l6c8i,Grade 10,3,FIKIRTE BEGASHAW YESHITILA
a3v1w,Grade 10,3,FIKIRTE MESFIN WOLDETSADIK
y0f7p,Grade 10,3,FIREHIWOT ADDIS KECHEM
t5h9r,Grade 10,3,HABTAMU SINDEW ABATE
e1n4j,Grade 10,3,HANA MENKIR BIRHAN
o8q2b,Grade 10,3,HIRUT TONJO TOLCHA
z6g5u,Grade 10,3,KALKIDAN TEWODROS LEULSEGID
p4c1i,Grade 10,3,KASAHUN MAMUSHET GASHAW
v2k8n,Grade 10,3,KIDIST LAYEKUN BIRHANU
d9s3y,Grade 10,3,KIDUS YITAGESU AYALEW
j7f6a,Grade 10,3,LAMROT YEGEREM SHARGET
w0q5x,Grade 10,3,MEKDELAWIT TADELE ALAMREW
s1e9h,Grade 10,3,MERON SHEWANGIZAW GETACHEW
a6o2k,Grade 10,3,NAHOM ASEGID SHAHNEBER
l9t4v,Grade 10,3,NATNAEL KIFLE HAILU
b7i0y,Grade 10,3,NEBYU DANEL SEBSIBE
q3d8w,Grade 10,3,RAHMET JEMAL ENDRIS
y5k2p,Grade 10,3,SAMRAWIT SHEWAKENA MAMO
x0u6z,Grade 10,3,SELAMAWIT NEBIYU GULETENA
u2q9f,Grade 10,3,TAMIRAT GEBEYEHU BAYU
i8m3w,Grade 10,3,TARIKU CHERNET AYNEYA
h4s1o,Grade 10,3,TINBITE YONAS GETACHEW
n7e5r,Grade 10,3,TIZTA WORKNEH GEBREWOLD
k6j0v,Grade 10,3,TSIGEMARIAM AYELE GEBREHIWOT
r9w8g,Grade 10,3,WERKALEMAW ABIYE ABEBE
c2p4q,Grade 10,3,YEABSIRA BELIHU BESUFIKAD
z1x5y,Grade 10,3,YONAS ABATENEH LINGER
f0n7d,Grade 10,3,ZIMBELACHEW TISASU ASFAW
g8a6p,Grade 10,4,ALEM BIRHAN BELAY
e5s9r,Grade 10,4,AMANUEL MOLTOT BEYENE
m2x1z,Grade 10,4,ATNAFU ADMASU ANDARGE
l3i7w,Grade 10,4,BEREKET LEMA DEGEFA
k9q5n,Grade 10,4,BEREKET WUBALEM TEREFE
o1b4c,Grade 10,4,BETELHEM DANIEL SITOTA
h6d0q,Grade 10,4,DAWEIT MEBRATU TADELE
w4y8s,Grade 10,4,DESTA ADMASU ASHEBER
t2p5j,Grade 10,4,DIBORA SAMUEL DARBE
u0g9f,Grade 10,4,EPHREM GETACHEW TECHERE
y7a3x,Grade 10,4,EYOB TILAHUN EMAWAYEHU
i8n2q,Grade 10,4,EYUEL AYALEW ABEBE
r5w1o,Grade 10,4,FIKIRTE MULUKEN ASAYE
c6z7k,Grade 10,4,FIREGENETE LEMA DEGEFA
v9t4b,Grade 10,4,HANA AFEWORK WORKE
f0o8p,Grade 10,4,KONJIT KANKO ASEFA
b2y5s,Grade 10,4,LELU ASEFA WORKU
j1q3i,Grade 10,4,MASTEWAL LEYIKUN BIRHANU
s7x9m,Grade 10,4,IAS MELKASA LELESA
e6l4h,Grade 10,4,MEKDELAWIT YARED WORKALEMAHU
z4c8v,Grade 10,4,MELAKU HAILU ERGET
k8i5a,Grade 10,4,MERON LUEL TAMENE
t1y0n,Grade 10,4,MERON MESFIN MESKELE
q9p6w,Grade 10,4,MERON TAREKEGN AYTENFESU
u3s2f,Grade 10,4,MIHIRET HABTAMU TAFESE
g7l0b,Grade 10,4,MISTIR ASHENAFI LENGISA
p5w9v,Grade 10,4,MULUKEN SETU DAGIFA
d0q3i,Grade 10,4,NATNAEL ABRHAM WEGAYE
x2a7n,Grade 10,4,RAHEMET MENUTA KEBIA
a4h1s,Grade 10,4,SAMUEL KASAHUN SHEWAREGED
n6y5g,Grade 10,4,SINTAYHU ALAYU TESFAYE
o9q2c,Grade 10,4,TAWODROS DEMEKE YEHULESHET
l1z8u,Grade 10,4,TIGIST HAILU BERECHA
h3s6i,Grade 10,4,TIGIST ZAMEDKUN KASA
w7d1b,Grade 10,4,YEABSIRA MELAKE SHIBESHI
i5x4l,Grade 10,4,YEGISHENWORK ALEMAYEHU GAR
c2r0q,Grade 10,4,YORDANOS BAHIRU GEBRE
y1n6a,Grade 10,5,ABDULHAKIM DINSEFA LEDI
t7h8k,Grade 10,5,ABEL GETACHEW MELESE
p4b2y,Grade 10,5,ASHENAFI DAGIM TADESE
x9u1q,Grade 10,5,AYELE SITOTAW ATLABACHEW
g0l5z,Grade 10,5,BEREKET ENDALKACHEW GOREMS
k6v9t,Grade 10,5,BEREKET LEMA NUGUS
f2n3s,Grade 10,5,BESUFKAD ZENEBE MOGES
h8d1p,Grade 10,5,BETHELHEM HAILEKRISTOS YIGEZU
w5i6u,Grade 10,5,BINIAM TILAHUN BELAY
l0z4c,Grade 10,5,BIRUK ABABUYE GETAW
a9x8i,Grade 10,5,BIRUK KASE DESSIE
q3v7r,Grade 10,5,BITANYA AYTENFSU ENDASHAW
o1k5p,Grade 10,5,DAGIM SOLOMON SEYUM
b4t9z,Grade 10,5,EDILAWIT ENYEW TEREFE
u7n2f,Grade 10,5,ENATU TEMESGEN DESALGN
r1a6l,Grade 10,5,ESUBALEW TESFAYE GEBREMEDIHEN
m8g0q,Grade 10,5,HAFIZA MOHAMMED AHMED
i5e3b,Grade 10,5,HANANA HASEN UMER
y2x1t,Grade 10,5,HANNA SOLOMON ASMAMAW
d9j8q,Grade 10,5,HAWI TAMERU BEREHE
c0q5k,Grade 10,5,HAYLEMIKAEL HABTAMU AFNE
s3u7i,Grade 10,5,HERMELA YERGA DEMSE
z8w4p,Grade 10,5,HIWOT BIRHANU GENET
f6n1x,Grade 10,5,KALKIDAN ENGDASHET BEYENE
w2b9a,Grade 10,5,LIDIA GEBRU MEKONNEN
q5j3m,Grade 10,5,LINGERSH WENDMNEH AYELE
k9i7c,Grade 10,5,MAHILET GETASETEGN TEFERA
u0p4h,Grade 10,5,MARTA GETU ABABUYE
l7y8q,Grade 10,5,MEDANIT GERESU DEMISE
b1a5v,Grade 10,5,MEKDELAWIT YONAS ALIGAZ
e3n2i,Grade 10,5,MERON GETU TSEGAW
o4h0w,Grade 10,5,MIHRET MEBRETU TADESSE
z9r7j,Grade 10,5,MIKIYAS BELAY MENGESH
s6d3a,Grade 10,5,ROBEL TSEGASEW WORKNEH
y1p5l,Grade 10,5,SELAM DEMISS GEBREMIKAEL
c8v2x,Grade 10,5,SOLIANA YONAS BURAK
g5i9n,Grade 10,5,YORDANOS ALAYE GUCHIYE
i2w6h,Grade 10,6,ABDUL SHIKUR TOFIK
o0t4s,Grade 10,6,AMANUEL CHIROTAW BIRU
u3r7v,Grade 10,6,AWEKE TSEGAYE MANDEFRO
a6g9l,Grade 10,6,BEMNET BEREKET BESHIR
z4h2w,Grade 10,6,BEREKET MASRESHA ASAMERE
q7k1y,Grade 10,6,BETHELHEM HAILE WERKE
x9b3i,Grade 10,6,BETSELOT TEMAM BESHIR
s0e5n,Grade 10,6,BEZAWIT GETNET ZERGAW
d1g8k,Grade 10,6,BINIYAM TAMIRU DEMISE
p8a6m,Grade 10,6,BIRTUKAN KIDANU GETACHEW
l2h9v,Grade 10,6,BIZUWORK TISASU ASFAW
w5c4b,Grade 10,6,DANIEL TAMIRU MULUGETA
r0q7z,Grade 10,6,DAWIT BIRHANU GUDIEBO
g4i1s,Grade 10,6,DEMEKCHE WONDEY TAYE
e9p3h,Grade 10,6,DINKINESH SHIFERAW ASSEFA
o7a5b,Grade 10,6,EFRATA BELETE ZEWUDE
y1l8n,Grade 10,6,FEVEN BENYAM ALEMNEW
j3v0w,Grade 10,6,FIKREMARIAM ABAYE DEMISSIE
b6h2q,Grade 10,6,GETAHUN ESHETU MENBERU
k8c5i,Grade 10,6,HAMELMAL TESFAYE TESHOME
z0p9w,Grade 10,6,HANA FIDA FINDE
q5u3l,Grade 10,6,HAYMANOT TSEGAW AMANUEL
h7g1n,Grade 10,6,HERMELA ALEMU TOLOSA
s3e6w,Grade 10,6,HYWOT WORKALEMAHU ALAYE
y4j9a,Grade 10,6,MAHDER ABEBE KASAHUN
o1l5d,Grade 10,6,MARTA ENDALE ENGIDA
c8p2r,Grade 10,6,MEKEDES NUGUSSE MULATU
x0w3q,Grade 10,6,MIHRET FIKADU LEMA
f9u6y,Grade 10,6,MIKIYAS HABTAMU WORKU
t1a7k,Grade 10,6,MIKIYAS MILKESA LELISA
p5j8h,Grade 10,6,NIBRET BELETE BELAYNEH
b2q1w,Grade 10,6,REDIET SHANBEL WESENE
l9c5i,Grade 10,6,SAMUEL ADMASU ASEFA
e4k2r,Grade 10,6,SAMUEL ZENEBE ASCHALEW
h1p9z,Grade 10,6,SIMRET ASHENAFI MINDA
u6s0f,Grade 10,6,TSIGE HABTAMU SHUBULO
v7a3y,Grade 10,6,YEMIYAMREW AMARE AGEZE
i5q2o,Grade 10,7,ABEL TAMIRU TADESSE
a9d1x,Grade 10,7,ABRHAM ABIYE ABEBE
k3z4u,Grade 10,7,AREGAHEGN ADDIS ESHETE
r1e8t,Grade 10,7,BETELHEM BELETE BAYE
p6h7q,Grade 10,7,EFIRATA SISAY KEBEDE
w0b9l,Grade 10,7,EMEBET ASCHALEW BOGALE
y4k5h,Grade 10,7,ESTIFANOS MESFIN GULE
f7u1d,Grade 10,7,FITSUM GETASETEGN BIRHANU
q2n0a,Grade 10,7,GENET SOYSO SOLBE
t5p8w,Grade 10,7,GETASETEGN SOLOMON BOGALE
o8i6g,Grade 10,7,HANA DASALEGN NIREA
s1y3k,Grade 10,7,HASET AMARE SHUME
b3l9a,Grade 10,7,HERMELA ALENE MOLLA
z9t5u,Grade 10,7,HEWAN AWGECHEW LEMA
h0n8c,Grade 10,7,KASSA DEMTSE WOLDEMICHAEL
w5q2p,Grade 10,7,KIDUS BALKEW BIYASALF
d1x7r,Grade 10,7,MAHLET ZEWDU DELELEGN
a4g0v,Grade 10,7,MIHRET ASHENAFI ZEWEDA
r9s1l,Grade 10,7,NAHOM AYALEW ABABYE
k6y3q,Grade 10,7,NEBIYATE ASRATE KOSTE
o2u7b,Grade 10,7,NETSANET WENDIMU ESHETE
e7h4m,Grade 10,7,NIJAT BIRAHANU KAMIL
x0p1s,Grade 10,7,NUHAMIN HABTAMU TACHBEL
q5i2n,Grade 10,7,RAWDA BEDLU KEDIR
v8a6k,Grade 10,7,RUTH EYOB MELAKU
j3y9c,Grade 10,7,SAMUEL YESHAW TSEGAW
u1l5r,Grade 10,7,SEADA JUHAR EBRAHIM
p7n8g,Grade 10,7,SELAMAWIT MISGANAW ALEMNEH
z0k4i,Grade 10,7,SELHADIN KEDIR IBRAHIM
w2q1a,Grade 10,7,SUMEYA SEIFU MUZEMIL
i9x5w,Grade 10,7,TIGIST GUADE ANTENEH
b3j8p,Grade 10,7,TIRUEDILI HAYEMRO BEZE
s6a2d,Grade 10,7,TSIGU TOLA TADESSE
y4p9q,Grade 10,7,TSION DEREJE BELETE
c5u1k,Grade 10,7,YEABSERA MAMUSHET KEBEDE
h8n0r,Grade 10,7,YESHIMEBET NAKE SHEWATATEK
l1w6p,Grade 10,7,YOSEF ADIMKACHEW DEMSE
g5b9z,Grade 10,8,ABEBA WEGESE SHOTE
e2p7n,Grade 10,8,ABENEZER NEGA HAILE
u9i4x,Grade 10,8,ABRHAM BELETE ENGDASHET
r3w1a,Grade 10,8,AMANUEL SHIMELIS TADDESE
b8l6i,Grade 10,8,BETELHEM ADDISU KUMBI
k0a2q,Grade 10,8,BINIYAM BELACHEW ABIYE
p1y5g,Grade 10,8,DANIEL ESHETU ESHAHENEBER
o4v3b,Grade 10,8,EBRAHIM CHEKOL SEID
z7q9t,Grade 10,8,EDEN TSEGAYE ALEMAYEW
s6i1u,Grade 10,8,EFRATA GEBEYEHU NUGUSU
w8a5z,Grade 10,8,EPHREM GETACHEW ASSEFA
q0p2n,Grade 10,8,ESRAEL ABRHAM MALDAYE
f2y6h,Grade 10,8,EYASU ABREHAM KORA
j5u9i,Grade 10,8,EYOB HABTEWOLD SHENKUTE
h9k3x,Grade 10,8,FIKIR DEREJE MEKONEN
c1n0r,Grade 10,8,GENET MISSA ATNAFE
a7v4w,Grade 10,8,GODADA FENTAW MOTBAYNOR
u3o6k,Grade 10,8,HANA TESHOME TSEGAW
l5z9b,Grade 10,8,KIRUBEL TSEGAYE MAMUYE
n0y7g,Grade 10,8,LEUL ASFAWOSEN MULATU
r4j1x,Grade 10,8,MEKDELAWIT SOLOMON TADESSE
q8f3c,Grade 10,8,MESKEREM CHALEW HAILEMARIAM
p2u9a,Grade 10,8,NAOL DEREJE GIZAW
k1h5q,Grade 10,8,REDIET MESAW AYNALEM
z6v4g,Grade 10,8,ROBEL ASHENAFI KEBEDE
t9j0i,Grade 10,8,SEID MOHAMED ADEM
b0a3p,Grade 10,8,SELAM ALEM DAGNACHEW
o8s5w,Grade 10,8,SOLOMON BIRHANU WORKU
f3k7b,Grade 10,8,SUALI AWOL ASFAW
i6h9c,Grade 10,8,TIGIST BOJA ABERA
a1w0y,Grade 10,8,WBALEM DRESE KEBEDE
u7d2n,Grade 10,8,WENDIMAGEGN EYASU MANDEYE
r4s9h,Grade 10,8,YOHANES ZEWEDAY WEBISHET
j8a6k,Grade 10,8,YOHANNES TIBEBU ESHETA
e0v3m,Grade 10,8,YONAS SELESHI MAMUYE
q9l5x,Grade 10,8,ZELALEM KANBO KETA
k1i8c,Grade 10,8,NEBA MEHAMED YESUS
b4j3y,Grade 10,9,ABREHAM ABABU TESFAYA
s8h1x,Grade 10,9,ABREHAM SHIBRU MITKU
a0k5w,Grade 10,9,BEREKET GUCHALE TEFERA
r5g2z,Grade 10,9,BEREKET LEMA NIGUS
q9n3h,Grade 10,9,BIRHANU TILAHUN DELELU
v2p6k,Grade 10,9,BIRUK CHOLBO CHORZHA
c1t7u,Grade 10,9,BLEN GEBREMIKAEL SEIFU
l0y8n,Grade 10,9,DAGEME YOHANESE MUSE
u4d5p,Grade 10,9,DAGMAWI ABAY FIKIR
x6s1q,Grade 10,9,EDILAWIT TADESSE HABTAMU
j7b9o,Grade 10,9,ETALEMHU TARIKU BAYELGN
w5a2i,Grade 10,9,GENET ABAYU GASHAW
i8l4x,Grade 10,9,GIRMAYENEH ASFAW NIGATU
p3c7y,Grade 10,9,HANA BOLE BONCHE
o9g1q,Grade 10,9,HANA DARGE DELENCHA
s2v5j,Grade 10,9,HERMELA ABEBE GETACHEW
x1u8h,Grade 10,9,KALKIDAN KELEFELEGN DAGNACHEW
t5d0q,Grade 10,9,MAHLET DEREJE WORKU
a7q6c,Grade 10,9,MASINKE ONO AMANO
r9p2i,Grade 10,9,MEKDES SINTAYEHU WERKU
k1u5z,Grade 10,9,MEKILIT NIGUSU ALEMU
f6c8n,Grade 10,9, NEGUSU ALEMU
n0h2x,Grade 10,9,MESERET MAMULA HAILU
b3i5q,Grade 10,9,MINTESNOT ADUGNA KEBEDE
d9p8c,Grade 10,9,MUKEREM WABA HAMDETO
q2r1n,Grade 10,9,RABIYA MUHAMMED SHAFRO
y6l7b,Grade 10,9,REDIET YILMA FENTA
w0c4i,Grade 10,9,SAMUEL ADMASU ASEFA
i5q8u,Grade 10,9,SINTAYEHU NELEHU MELKU
z2l6a,Grade 10,9,SITOTAW GIZACHEW GONDALE
o8w1z,Grade 10,9,TEFERA MOGES GEDAMU
c3p4r,Grade 10,9,TENSAYE TESFAYE AYELE
j7n5o,Grade 10,9,TESFAYE TAREKEGN ABRDO
u9k2a,Grade 10,9,TIGIST TEFEREDEGN ASFAW
h1x6r,Grade 10,9,WORKENEH ABAYE BEYENE
r5d9l,Grade 10,9,YOHANIS GEZAHEGN TADESSE
v3a0h,Grade 10,9,YOHANNES AMARE ALAYE
e8p6s,Grade 10,10,BEREKET BESUFKAD TADESE
t0w2f,Grade 10,10,ABDURAZAK MEHAMED MUKTAR
q7a4h,Grade 10,10,AMEN ASSEFA MESHA
o3y1n,Grade 10,10,BEREKET KEFALE DEMISSE
g6k8x,Grade 10,10,BILEN SAMUEL GETU
b5l7i,Grade 10,10,BINIYAM MESFIN YIGEZU
p9v2s,Grade 10,10,BIRHANU ZERIHUN ABIYE
n1h0o,Grade 10,10,BIRTUKAN GETU TESEMA
k2q5w,Grade 10,10,EDLAWIT GETANEH ASRADE
u0c8j,Grade 10,10,EMEBET ZEMENE AYALEW
a7x4p,Grade 10,10,ERMIYAS TADELE DEMISS
z3p1r,Grade 10,10,EYOB ABABU GEZAHGN
h5n6w,Grade 10,10,EYOB ENDASHEW ZEGEYE
c8b9u,Grade 10,10,FASIKA GEZAHGN TESHOME
j1o4s,Grade 10,10,FIKREMARIAM ZEMENE ABIYE
q6d7l,Grade 10,10,FIREHIWET ALEMAYEHU KELKAY
x2y5n,Grade 10,10,GETAW BIRHAN BEIAY
s9a0i,Grade 10,10,HADRA MURAD YASIN
w1v3p,Grade 10,10,LIYU DAGNACHEW AYELE
g0q7z,Grade 10,10,MAHLET ENJUBAN NIGUSIE
n5h8c,Grade 10,10,MARTA GEBREYOHANNES RETA
l7u1y,Grade 10,10,MEKDELAWIT TANU MULU
p3a4x,Grade 10,10,MICHAEL GETAHUN WOLDEYOHANS
z9i6r,Grade 10,10,MUSTEFA MUNIR KEMAL
y4c2l,Grade 10,10,REDIET WORKU MEKU-e 

===== static/app.txt =====
# --- Imports ---
import logging
import os
from collections import defaultdict # Keep if used elsewhere, not directly by this phase's frontend
from datetime import datetime, timedelta, timezone
from functools import wraps
import uuid # Keep if used elsewhere
from logging.handlers import RotatingFileHandler
import humanize # <<<< ADD THIS LINE
from markupsafe import Markup # <<<< ADD THIS LINE

from flask import (
    Flask,
    abort,
    flash,
    redirect,
    render_template,
    request,
    session,
    url_for,
    make_response,
    jsonify, # Keep for future AJAX
    send_from_directory,
    current_app
)
from flask_login import (
    LoginManager,
    UserMixin,
    current_user,
    login_required,
    login_user,
    logout_user,
)
from flask_migrate import Migrate
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy
from flask_wtf import FlaskForm
from flask_wtf.file import FileAllowed, FileField # Keep for future forms
from flask_socketio import SocketIO # Keep if you plan to use SocketIO
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.routing import BuildError # Keep for error handling
from werkzeug.utils import secure_filename # For file uploads
from werkzeug.urls import url_parse # For safe redirects
from werkzeug.exceptions import NotFound # For send_from_directory
from flask_wtf.csrf import CSRFProtect, generate_csrf as wtf_generate_csrf # For CSRF protection & token generation
from sqlalchemy import (
    desc,
    exc,
    func,
    select,
    over,
    event,
    UniqueConstraint,
    Index,
    or_,
    text,
    Column,
    Integer,
    String,
    ForeignKey,
    Date,
    Boolean,
    Text,
    case
)
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import joinedload, relationship
from sqlalchemy.ext.associationproxy import association_proxy

from wtforms import (
    BooleanField,
    DateField,
    FieldList,
    FormField,
    PasswordField,
    SelectField,
    StringField,
    SubmitField,
    TextAreaField,
    IntegerField, # Keep this
    FloatField,   # Keep this
    HiddenField,  # Keep this
    RadioField    # Keep this
    # FileField is already imported via flask_wtf.file
)
from wtforms.validators import (
    DataRequired,
    Email,
    EqualTo,
    Length,
    Optional,
    Regexp,
    ValidationError,
    NumberRange,
    URL
)

# --- Your Model Imports ---
# Ensure all your models (User, Role, SecretCode, Asset, AssetCategory, etc.) are imported here
# Example:
# from .models import User, Role, SecretCode, AssetCategory, Lab, Message, Notification # If models are in models.py
# If models are in app.py itself, no further model imports needed here.

# --- Your Form Imports ---
# Ensure all your forms (LoginForm, PreForm, CompleteRegistrationForm, etc.) are imported here
# Example:
# from .forms import LoginForm, PreForm # If forms are in forms.py
# If forms are in app.py itself, no further form imports needed here.

# --- Application Setup ---
app = Flask(__name__)
# --- (Your Session Configuration) ---
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)
socketio = SocketIO(app)
csrf = CSRFProtect(app) #

# --- (Your General Application Configuration - SECRET_KEY, SQLALCHEMY_DATABASE_URI) ---
app.config["ENV_MODE"] = os.getenv("APP_ENV", "development")
if app.config["ENV_MODE"] == "development":
    app.config["SECRET_KEY"] = "your_strong_development_secret_key_here" # CHANGE THIS IN PRODUCTION
    app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 0
    app.config["TEMPLATES_AUTO_RELOAD"] = True
    app.debug = True
    print("Running in development mode")
else:
    app.config["SECRET_KEY"] = os.getenv("SECRET_KEY")
    if not app.config["SECRET_KEY"]:
        raise ValueError("No SECRET_KEY set for Flask application in production")
    app.debug = False
    print(f"Running in {app.config['ENV_MODE']} mode")

# NOTE: SQLALCHEMY_DATABASE_URI and TRACK_MODIFICATIONS are now set *before* db initialization
app.config["SQLALCHEMY_DATABASE_URI"] = "postgresql://classicboy0781:nexus@localhost/nexus" # CHANGE THIS IN PRODUCTION
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False


# --- Initialize SQLAlchemy WITHOUT the app initially ---
# This creates the 'db' object so models can inherit from db.Model
db = SQLAlchemy()


# Development-specific settings (already mostly covered above, but ensures clarity)
if app.config["ENV_MODE"] == "development":
    app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 0
    app.config["TEMPLATES_AUTO_RELOAD"] = True
    app.debug = True
    print("Running in development mode")
else:
    app.debug = False
    print(f"Running in {app.config['ENV_MODE']} mode")

# --- ADDED: Social Media File Upload Configuration ---
# Define directory for uploaded files (create if it doesn't exist)
UPLOAD_FOLDER = os.path.join(app.root_path, 'uploads', 'social_files')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Optional: Configure max file size (e.g., 16MB)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 megabytes
# --- END ADDED ---


# --- ADDED THIS LOGGING SETUP SECTION ---
# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')
app.logger.setLevel(logging.INFO)

# Optional: Configure file handler for production logging
if not app.debug:
    file_handler = RotatingFileHandler('app.log', maxBytes=1024000, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.info('Nexus school management system startup')

# --- PART 1 END ---
# --- PART 2 START: Model Definitions ---

class Role(db.Model):
    __tablename__ = "role"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)

    users = db.relationship("User", back_populates="role", lazy="dynamic")
    secret_codes = db.relationship("SecretCode", back_populates="role", lazy=True)

    def __repr__(self):
        return f"<Role {self.name}>"

class Lab(db.Model):
    __tablename__ = "lab"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)

    lab_assignments = db.relationship("User", back_populates="lab", lazy="dynamic")

    def __repr__(self):
        return f"<Lab {self.name}>"

class AssetCategory(db.Model):
    __tablename__ = 'asset_category'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    description = db.Column(db.Text)

    assets = db.relationship("Asset", back_populates="category", lazy="dynamic")
    # channels = db.relationship('Channel', back_populates='category', lazy='dynamic')

    def __repr__(self):
        return f"<AssetCategory {self.name}>"

# ADD THIS NEW MODEL DEFINITION:
class SocialCategory(db.Model):
    __tablename__ = 'social_category'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    description = db.Column(db.Text)

    channels = db.relationship('Channel', back_populates='social_category', lazy='dynamic')

    def __repr__(self):
        return f"<SocialCategory {self.name}>"

class Message(db.Model):
    __tablename__ = "message"
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    receiver_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    sender_role = db.Column(db.String(50))
    receiver_role = db.Column(db.String(50))
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), index=True)
    is_read = db.Column(db.Boolean, default=False, index=True)

    sender = db.relationship("User", foreign_keys=[sender_id], back_populates="sent_messages")
    receiver = db.relationship("User", foreign_keys=[receiver_id], back_populates="received_messages")

    def __repr__(self):
        return f"<Message from {self.sender_id} to {self.receiver_id} at {self.timestamp}>"

    __table_args__ = (
        db.Index('idx_message_pair', 'sender_id', 'receiver_id'),
        db.Index('idx_message_status', 'is_read'),
        db.Index('idx_message_timestamp', 'timestamp'),
    )

# --- NEW MODELS: Task System (Ordered correctly) ---

# Define UserTask first as Task depends on it for relationship definition
class UserTask(db.Model):
    __tablename__ = 'user_task'
    id = db.Column(db.Integer, primary_key=True)
    task_id = db.Column(db.Integer, db.ForeignKey('task.id'), nullable=False, index=True) # <-- FK to task
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # <-- FK to assigned user

    assigned_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    assigned_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # <-- FK to assigning user

    # Status specific to THIS user's assignment
    status = db.Column(db.String(30), nullable=False, default='Open', index=True) # e.g., 'Open', 'In Progress', 'Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Accepted', 'Review Rejected'
    completion_notes = db.Column(db.Text, nullable=True) # Notes from assigned user (Completed, Delayed, Rejected)
    last_status_update_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)

    reviewed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True) # <-- FK to the reviewer

    reviewed_at = db.Column(db.DateTime, nullable=True)
    reviewer_notes = db.Column(db.Text, nullable=True) # Notes from creator during review

    # Relationships
    # Note: task relationship must be defined *after* Task class is defined, but SQLAlchemy allows string name
    task = db.relationship('Task', back_populates='user_assignments')

    # Specify the foreign_keys for the 'user' relationship to point to user_id
    user = db.relationship(
        'User',
        foreign_keys=[user_id],  # Use the user_id column
        back_populates='assigned_tasks' # Ensure this back_populates exists on User model
    )

    # Specify the foreign_keys for the 'assigned_by' relationship to point to assigned_by_id
    assigned_by = db.relationship(
        'User',
        foreign_keys=[assigned_by_id], # Use the assigned_by_id column
        back_populates='assigned_tasks_instances' # Ensure this back_populates exists on User model
    )

    # ADD a new relationship for the 'reviewed_by' foreign key (Fix from previous exchange)
    reviewed_by = db.relationship(
        'User',
        foreign_keys=[reviewed_by_id], # Use the reviewed_by_id column
        back_populates='reviewed_tasks_instances' # This will be defined on the User model
    )


    history = db.relationship('TaskHistory', back_populates='user_task', lazy='dynamic', cascade='all, delete-orphan')

    __table_args__ = (
        db.UniqueConstraint('task_id', 'user_id', name='_task_user_uc'), # A user gets one instance per task instruction
        db.Index('idx_user_task_user_status', 'user_id', 'status'),
        db.Index('idx_user_task_task_status', 'task_id', 'status'),
        db.Index('idx_user_task_reviewed_by', 'reviewed_by_id'), # Optional: Add index for reviewed_by
    )


    def __repr__(self):
        return f"<UserTask ID:{self.id} Task:{self.task_id} User:{self.user_id} Status:'{self.status}'>"

# Define Task after UserTask
class Task(db.Model):
    __tablename__ = 'task'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    urgency = db.Column(db.String(20), nullable=False, default='Medium') # e.g., 'Low', 'Medium', 'High', 'Critical'
    due_date = db.Column(db.Date, nullable=True) # Overall task due date

    created_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    last_updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    created_by = db.relationship('User', back_populates='created_tasks')
    # UserTask is defined BEFORE Task now, so the string name 'UserTask' is resolvable
    user_assignments = db.relationship('UserTask', back_populates='task', lazy='dynamic', cascade='all, delete-orphan')

    __table_args__ = (
        db.Index('idx_task_creator', 'created_by_id'),
        db.Index('idx_task_created_at', 'created_at'),
    )

    def __repr__(self):
        return f"<Task ID:{self.id} Title:'{self.title}' CreatedBy:{self.created_by_id}>"

# Define TaskHistory after UserTask (as it depends on UserTask)
class TaskHistory(db.Model):
    __tablename__ = 'task_history'
    id = db.Column(db.Integer, primary_key=True)
    user_task_id = db.Column(db.Integer, db.ForeignKey('user_task.id'), nullable=False, index=True)
    changed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # User who initiated the change

    old_status = db.Column(db.String(30), nullable=True) # Can be null for initial assignment
    new_status = db.Column(db.String(30), nullable=False)
    action = db.Column(db.String(50), nullable=False) # e.g., 'Assigned', 'Status Update', 'Review Accepted', 'Review Rejected'
    notes = db.Column(db.Text, nullable=True) # Notes relevant to this history entry (e.g., copied from completion_notes or reviewer_notes)

    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)

    # Relationships
    user_task = db.relationship('UserTask', back_populates='history')
    changed_by = db.relationship('User', back_populates='task_history_entries')

    __table_args__ = (
        db.Index('idx_task_history_usertask_ts', 'user_task_id', 'timestamp'),
    )

    def __repr__(self):
        return f"<TaskHistory ID:{self.id} UserTask:{self.user_task_id} Action:'{self.action}' New Status:'{self.new_status}'>"


# Define User Model (includes all previous relationships + the fix)
class User(db.Model, UserMixin):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=True, index=True)
    password_hash = db.Column(db.String(128), nullable=False)
    first_name = db.Column(db.String(50), nullable=True)
    last_name = db.Column(db.String(50), nullable=True)
    full_name = db.Column(db.String(120), nullable=False, index=True)
    date_of_birth = db.Column(db.Date, nullable=True)
    gender = db.Column(db.String(20), nullable=True)
    phone = db.Column(db.String(20), nullable=True)
    address = db.Column(db.Text, nullable=True)
    is_active = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    last_login = db.Column(db.DateTime, nullable=True)
    is_leader = db.Column(db.Boolean, default=False, nullable=False)
    force_password_change = db.Column(db.Boolean, default=False, nullable=False)
    is_tc_leader = db.Column(db.Boolean, default=False, nullable=False)
    is_tc_member = db.Column(db.Boolean, default=False, nullable=False)
    leader_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True)
    age = db.Column(db.Integer, nullable=True)
    sex = db.Column(db.String(20), nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)
    grade = db.Column(db.String(10), nullable=True, index=True)
    section = db.Column(db.String(10), nullable=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('role.id'), nullable=False)
    lab_id = db.Column(db.Integer, db.ForeignKey('lab.id'), nullable=True)

    # Relationships
    role = db.relationship("Role", back_populates="users")
    lab = db.relationship("Lab", back_populates="lab_assignments")
    leader = db.relationship('User', remote_side=[id], backref=db.backref('followers', lazy='dynamic'))

    # Message relationships using Column objects
    sent_messages = db.relationship("Message", foreign_keys=[Message.sender_id], back_populates="sender", lazy="dynamic")
    received_messages = db.relationship("Message", foreign_keys=[Message.receiver_id], back_populates="receiver", lazy="dynamic")

    # Other relationships (using string references)
    submitted_requests = db.relationship('Request', foreign_keys='Request.requester_id', back_populates='requester', lazy='dynamic')
    assigned_requests = db.relationship('Request', foreign_keys='Request.current_handler_id', back_populates='current_handler', lazy='dynamic')
    forwarded_requests = db.relationship('Request', foreign_keys='Request.last_forwarded_by_id', back_populates='last_forwarded_by', lazy='dynamic')
    request_history_entries = db.relationship('RequestHistory', back_populates='changed_by', lazy='dynamic')
    staff_attendance_records = db.relationship("StaffAttendance", back_populates="user", lazy="dynamic")
    attendance_entries = db.relationship("Attendance", back_populates="student", lazy="dynamic")
    parent_profile = db.relationship("Parent", back_populates="user", uselist=False)
    teacher_profiles = db.relationship("TeacherProfile", back_populates="user", lazy="dynamic")
    sent_notifications = db.relationship("Notification", foreign_keys="Notification.sender_id", back_populates="sender", lazy="dynamic")
    received_notifications = db.relationship("Notification", foreign_keys="Notification.receiver_id", back_populates="receiver", lazy="dynamic")
    marks = db.relationship('Mark', back_populates='student', lazy="dynamic")
    added_assets = db.relationship("Asset", back_populates="added_by_user", lazy="dynamic")
    submitted_reports = db.relationship("AssetReport", foreign_keys="AssetReport.reported_by_id", back_populates="reporter", lazy="dynamic")
    resolved_reports = db.relationship("AssetReport", foreign_keys="AssetReport.resolved_by_id", back_populates="resolver", lazy="dynamic")
    book_checkouts = db.relationship("BookCheckout", back_populates="user", lazy="dynamic")
    borrowed_assets = db.relationship('BorrowedAsset', back_populates='user', lazy='dynamic')
    channel_posts = db.relationship("ChannelPost", back_populates="author", lazy="dynamic")
    channel_comments = db.relationship("ChannelComment", back_populates="author", lazy="dynamic")
    channel_reactions = db.relationship("ChannelReaction", back_populates="user", lazy="dynamic")
    group_messages = db.relationship("GroupMessage", back_populates="author", lazy="dynamic")
    social_group_memberships = db.relationship("SocialGroupMember", back_populates="user", lazy="dynamic")
    owned_channels = db.relationship("Channel", back_populates="owner", lazy="dynamic")
    owned_social_groups = db.relationship("SocialGroup", foreign_keys="SocialGroup.owner_id", back_populates="owner", lazy="dynamic")
    uploaded_social_files = db.relationship("File", back_populates="uploader", lazy="dynamic")
    parent_associations = db.relationship("ParentStudent", back_populates="student")
    behavior_records = db.relationship("BehaviorRecord", foreign_keys="BehaviorRecord.student_id", back_populates="student", lazy="dynamic")
    recorded_behavior_records = db.relationship("BehaviorRecord", foreign_keys="BehaviorRecord.recorded_by_id", back_populates="recorded_by", lazy="dynamic")
    channel_subscriptions = db.relationship('ChannelSubscriber', back_populates='user', lazy='dynamic')
    tc_memberships = db.relationship('TalentClubMembership', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    tc_follows = db.relationship('TalentClubFollow', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')
    owned_talent_clubs = db.relationship('TalentClub', back_populates='owner', lazy='dynamic')
    tc_leader_election_initiated = db.relationship(
        'TalentClubLeaderElection',
        foreign_keys='TalentClubLeaderElection.initiated_by_id',
        back_populates='initiated_by',
        lazy='dynamic'
    )
    tc_leader_votes_cast = db.relationship(
        'TalentClubLeaderVote',
        foreign_keys='TalentClubLeaderVote.voter_id',
        back_populates='voter',
        lazy='dynamic'
    )
    tc_bans_issued = db.relationship('TalentClubBan', foreign_keys='TalentClubBan.issued_by_id', back_populates='issued_by', lazy='dynamic')
    tc_bans_received = db.relationship('TalentClubBan', foreign_keys='TalentClubBan.user_id', back_populates='user', lazy='dynamic')
    tc_penalties_issued = db.relationship('TalentClubPenalty', foreign_keys='TalentClubPenalty.issued_by_id', back_populates='issued_by', lazy='dynamic')
    tc_penalties_received = db.relationship('TalentClubPenalty', foreign_keys='TalentClubPenalty.user_id', back_populates='user', lazy='dynamic')
    tc_proposals_created = db.relationship(
        'TalentClubProposal',
        foreign_keys='TalentClubProposal.creator_id',
        back_populates='creator',
        lazy='dynamic',
        cascade='all, delete-orphan'
    )
    tc_mentions_received = db.relationship('TalentClubMention', back_populates='user', lazy='dynamic', cascade='all, delete-orphan')

    # Task System Relationships
    created_tasks = db.relationship('Task', back_populates='created_by', lazy='dynamic') # Tasks created by this user
    assigned_tasks_instances = db.relationship('UserTask', foreign_keys='UserTask.assigned_by_id', back_populates='assigned_by', lazy='dynamic') # UserTask instances assigned by this user
    assigned_tasks = db.relationship('UserTask', foreign_keys='UserTask.user_id', back_populates='user', lazy='dynamic') # UserTask instances assigned *to* this user
    task_history_entries = db.relationship('TaskHistory', back_populates='changed_by', lazy='dynamic') # History entries created by this user

    # *** FIX: ADDED THE MISSING RELATIONSHIP *** (Confirmed this is present)
    reviewed_tasks_instances = db.relationship(
        'UserTask',
        foreign_keys='UserTask.reviewed_by_id',
        back_populates='reviewed_by',
        lazy='dynamic'
    )

    # --- METHODS ---

    def set_password(self, password):
        # Assumes generate_password_hash is available globally
        from werkzeug.security import generate_password_hash # Local import for method
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        # Assumes check_password_hash is available globally
        from werkzeug.security import check_password_hash # Local import for method
        return check_password_hash(self.password_hash, password)

    # --- FLASK-LOGIN PROPERTIES ---
    # These properties are handled by inheriting from UserMixin

    # @property
    # def is_authenticated(self):
    #     return True

    # @property
    # def is_active(self):
    #     # Refers to the is_active column
    #     return self.is_active # This should likely return self.is_active

    # @property
    # def is_anonymous(self):
    #     return False

    # def get_id(self):
    #     # Returns the primary key as a string
    #     return str(self.id)

    # --- SOCIAL MEDIA HELPERS ---
    # These should ideally be methods of the User model

    def is_channel_member(self, channel):
        # Assumes select, ChannelSubscriber are available globally
        if not channel or not self.is_authenticated:
            return False
        # Ensure context is available if called outside a request
        try:
            return db.session.scalar(
                select(ChannelSubscriber).where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.user_id == self.id
                )
            ) is not None
        except Exception as e:
            current_app.logger.error(f"Error in is_channel_member for user {self.id}, channel {channel.id}: {e}", exc_info=True)
            return False


    def get_channel_role(self, channel):
        # Assumes select, ChannelSubscriber, joinedload are available globally
        if not channel or not self.is_authenticated:
            return None
        try:
            subscription = db.session.scalar(
                select(ChannelSubscriber).where(
                    ChannelSubscriber.channel_id == channel.id,
                    ChannelSubscriber.user_id == self.id
                ).options(joinedload(ChannelSubscriber.user), joinedload(ChannelSubscriber.channel))
            )
            return subscription.role if subscription else None
        except Exception as e:
            current_app.logger.error(f"Error in get_channel_role for user {self.id}, channel {channel.id}: {e}", exc_info=True)
            return None


    def is_group_member(self, group):
        # Assumes select, SocialGroupMember are available globally
        if not group or not self.is_authenticated:
            return False
        try:
            return db.session.scalar(
                select(SocialGroupMember).where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.user_id == self.id
                )
            ) is not None
        except Exception as e:
            current_app.logger.error(f"Error in is_group_member for user {self.id}, group {group.id}: {e}", exc_info=True)
            return False


    def get_group_role(self, group):
        # Assumes select, SocialGroupMember, joinedload are available globally
        if not group or not self.is_authenticated:
            return None
        try:
            membership = db.session.scalar(
                select(SocialGroupMember).where(
                    SocialGroupMember.group_id == group.id,
                    SocialGroupMember.user_id == self.id
                ).options(joinedload(SocialGroupMember.user), joinedload(SocialGroupMember.group))
            )
            return membership.role if membership else None
        except Exception as e:
            current_app.logger.error(f"Error in get_group_role for user {self.id}, group {group.id}: {e}", exc_info=True)
            return None


    def __repr__(self):
        return f"<User ID:{self.id} Username:'{self.username}' Role:'{self.role.name if self.role else 'N/A'}'>"

    # __table_args__ (optional, indexes already defined on columns or via tuple)

# Social Media Group Model (The correct one)
class SocialGroup(db.Model):
    __tablename__ = 'social_groups'
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False, unique=True, index=True)
    description = Column(String(255))
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True)
    is_active = db.Column(db.Boolean, default=True, nullable=False)

    owner = db.relationship('User', foreign_keys=[owner_id], back_populates='owned_social_groups')
    members = db.relationship("SocialGroupMember", back_populates="group", lazy="dynamic", cascade="all, delete-orphan")
    messages = db.relationship('GroupMessage', back_populates='group', lazy='dynamic', cascade='all, delete-orphan') # Reciprocal

    def __repr__(self):
        return f"<SocialGroup(name='{self.name}')>"

# Social Media Group Membership (The correct one)
class SocialGroupMember(db.Model):
    __tablename__ = 'social_group_members'
    group_id = db.Column(db.Integer, db.ForeignKey('social_groups.id'), primary_key=True) # Correct FK to social_groups
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)

    role = db.Column(db.String(20), default='member', nullable=False)
    joined_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    group = db.relationship('SocialGroup', back_populates='members') # Correct back_populates name
    user = db.relationship('User', back_populates='social_group_memberships', foreign_keys=[user_id]) # Correct back_populates name and add FK

    __table_args__ = (UniqueConstraint('group_id', 'user_id', name='_group_user_uc'),)

    def __repr__(self):
         return f"<SocialGroupMember UserID:{self.user_id} in GroupID:{self.group_id} as {self.role}>"


# Other Supporting Models
class SecretCode(db.Model):
    __tablename__ = "secret_code"
    id = db.Column(db.Integer, primary_key=True)
    code = db.Column(db.String(20), unique=True, nullable=False, index=True)
    full_name = db.Column(db.String(120), nullable=False)
    role_id = db.Column(db.Integer, db.ForeignKey('role.id'), nullable=False)
    is_used = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    teacher_profiles = db.relationship('TeacherProfile', back_populates='secret_code')

    role = db.relationship('Role', back_populates='secret_codes')

    def __repr__(self):
        return f"<SecretCode {self.code} (Role: {self.role.name if self.role else 'N/A'}) Used: {self.is_used}>"

class TeacherProfile(db.Model):
    __tablename__ = "teacher_profile"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    secret_code_id = db.Column(db.Integer, db.ForeignKey('secret_code.id'), nullable=True, index=True)

    subject = db.Column(db.String(100), nullable=False)
    salary = db.Column(db.Float, nullable=True)
    grade = db.Column(db.String(10), nullable=True)
    section = db.Column(db.String(10), nullable=True)

    secret_code = db.relationship('SecretCode', back_populates='teacher_profiles')
    user = db.relationship("User", back_populates="teacher_profiles")

    __table_args__ = (
        db.UniqueConstraint('user_id', 'secret_code_id', 'grade', 'section', name='uq_teacher_profile_assignment'),
        db.Index('idx_teacher_profile_user', 'user_id'),
        db.Index('idx_teacher_profile_secret_code', 'secret_code_id'),
        db.Index('idx_teacher_profile_grade_section', 'grade', 'section'),
    )

    def __repr__(self):
        return f"<TeacherProfile UserID: {self.user_id}, Subject: {self.subject}, Grade/Section: {self.grade}/{self.section}>"

class Student(db.Model):
    __tablename__ = 'students'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True)
    grade = db.Column(db.String(10))
    section = db.Column(db.Integer)
    # Add other student-specific fields
    
    # Relationship to User
    user = db.relationship('User', backref=db.backref('student', uselist=False))


# ... (rest of your app.py code) ...
class ParentStudent(db.Model):
    """Association table between parents and their students"""
    __tablename__ = 'parent_student'
    parent_id = db.Column(db.Integer, db.ForeignKey('parent.id'), primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    verification_status = db.Column(db.String(20), default='pending')
    relationship = db.Column(db.String(50))
    verified_at = db.Column(db.DateTime, nullable=True)

    parent = db.relationship('Parent', back_populates='student_associations')
    student = db.relationship('User', back_populates='parent_associations')

class Parent(db.Model):
    __tablename__ = 'parent'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True, nullable=False)

    preferred_contact_method = db.Column(db.String(20), default='email')
    receive_grade_updates = db.Column(db.Boolean, default=True)
    receive_behavior_updates = db.Column(db.Boolean, default=True)

    user = db.relationship('User', back_populates='parent_profile')
    student_associations = db.relationship('ParentStudent', back_populates='parent', cascade='all, delete-orphan')
    students = association_proxy('student_associations', 'student',
                                creator=lambda student: ParentStudent(student=student))
                                
class BehaviorRecord(db.Model):
    __tablename__ = "behavior_record"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    recorded_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    date = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    behavior_type = db.Column(db.String(50), nullable=False)
    description = db.Column(db.Text, nullable=False)
    severity = db.Column(db.String(20), default='Medium', nullable=False)
    resolution = db.Column(db.Text, nullable=True)
    is_resolved = db.Column(db.Boolean, default=False, nullable=False, index=True)

    student = db.relationship('User', foreign_keys=[student_id], back_populates='behavior_records')
    recorded_by = db.relationship('User', foreign_keys=[recorded_by_id], back_populates='recorded_behavior_records')

    __table_args__ = (
        db.Index('idx_behavior_student_date', 'student_id', 'date'),
    )

    def __repr__(self):
        return f"<BehaviorRecord ID:{self.id} Student:{self.student_id} Type:{self.behavior_type} Date:{self.date.strftime('%Y-%m-%d')}>"

# --- NEW MODELS: Request System ---

class Request(db.Model):
    __tablename__ = 'request'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    request_type = db.Column(db.String(50), nullable=False) # e.g., 'Deficiency', 'Purchase', 'General'
    urgency = db.Column(db.String(20), nullable=False, default='Medium') # e.g., 'Low', 'Medium', 'High', 'Critical'

    requester_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    current_handler_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True)
    last_forwarded_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True) # Who last forwarded it

    status = db.Column(db.String(20), nullable=False, default='Pending', index=True) # e.g., 'Pending', 'Approved', 'On Progress', 'Denied', 'Resolved'
    tier = db.Column(db.Integer, nullable=False, default=1, index=True) # 1: HR/CEO, 2: School Exec, 3: Government

    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    last_updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)

    resolution_notes = db.Column(db.Text, nullable=True) # Notes from handlers during review/resolution
    denial_reason = db.Column(db.Text, nullable=True) # Reason for denial, if status is 'Denied'

    # Relationships
    requester = db.relationship('User', foreign_keys=[requester_id], back_populates='submitted_requests')
    current_handler = db.relationship('User', foreign_keys=[current_handler_id], back_populates='assigned_requests')
    last_forwarded_by = db.relationship('User', foreign_keys=[last_forwarded_by_id], back_populates='forwarded_requests')

    history = db.relationship('RequestHistory', back_populates='request', lazy='dynamic', cascade='all, delete-orphan')

    __table_args__ = (
        db.Index('idx_request_status_tier', 'status', 'tier'),
        db.Index('idx_request_requester_status', 'requester_id', 'status'),
    )

    def __repr__(self):
        return f"<Request ID:{self.id} Title:'{self.title}' Status:'{self.status}' Tier:{self.tier}>"

class RequestHistory(db.Model):
    __tablename__ = 'request_history'
    id = db.Column(db.Integer, primary_key=True)
    request_id = db.Column(db.Integer, db.ForeignKey('request.id'), nullable=False, index=True)
    changed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    old_status = db.Column(db.String(20), nullable=True) # Can be null if first entry (Submitted)
    new_status = db.Column(db.String(20), nullable=False)
    action = db.Column(db.String(50), nullable=False) # e.g., 'Submitted', 'Reviewed', 'Forwarded', 'Resolved', 'Denied', 'Edited'
    notes = db.Column(db.Text, nullable=True) # Specific notes for this history entry
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    request = db.relationship('Request', back_populates='history')
    changed_by = db.relationship('User', back_populates='request_history_entries')

    __table_args__ = (
        db.Index('idx_request_history_request_ts', 'request_id', 'timestamp'),
    )

    def __repr__(self):
        return f"<RequestHistory ID:{self.id} Request:{self.request_id} Action:'{self.action}' New Status:'{self.new_status}'>"

# --- END NEW MODELS ---

class Asset(db.Model):
    __tablename__ = "asset"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, index=True)
    description = db.Column(db.Text, nullable=True)
    quantity = db.Column(db.Integer, nullable=False, default=1)
    purchase_cost = db.Column(db.Float, nullable=True)
    condition = db.Column(db.String(50), nullable=False, default='New')
    is_consumable = db.Column(db.Boolean, nullable=False, default=False)
    expiry_date = db.Column(db.Date, nullable=True)
    last_maintenance_date = db.Column(db.Date, nullable=True)
    status = db.Column(db.String(50), nullable=False, default="Pending Review", index=True)
    location_description = db.Column(db.String(255), nullable=True)

    added_by_user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True, index=True)
    category_id = db.Column(db.Integer, db.ForeignKey("asset_category.id"), nullable=True, index=True)
    lab_id = db.Column(db.Integer, db.ForeignKey("lab.id"), nullable=True, index=True)

    category = db.relationship("AssetCategory", back_populates="assets")
    added_by_user = db.relationship("User", foreign_keys=[added_by_user_id], back_populates="added_assets")
    lab = db.relationship("Lab", backref=db.backref("assets", lazy="dynamic"))

    reports = db.relationship("AssetReport", back_populates="asset", lazy="dynamic", cascade="all, delete-orphan")
    book_checkouts = db.relationship("BookCheckout", back_populates="asset", lazy="dynamic", cascade="all, delete-orphan")
    borrowed_by = db.relationship('BorrowedAsset', back_populates='asset', lazy='dynamic')

    def __repr__(self):
        return f"<Asset ID:{self.id} Name:{self.name} Status:{self.status}>"

class AssetReport(db.Model):
    __tablename__ = "asset_reports"
    id = db.Column(db.Integer, primary_key=True)
    asset_id = db.Column(db.Integer, db.ForeignKey("asset.id"), nullable=True, index=True)
    reported_by_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    report_date = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    damage_description = db.Column(db.Text, nullable=False)
    date_of_damage = db.Column(db.Date, nullable=True)
    quantity_damaged = db.Column(db.Integer, default=1, nullable=False)
    status = db.Column(db.String(50), default="Pending", nullable=False, index=True)
    resolution_notes = db.Column(db.Text, nullable=True)
    resolved_by_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    resolved_date = db.Column(db.DateTime, nullable=True)

    asset = db.relationship("Asset", back_populates="reports")
    reporter = db.relationship("User", foreign_keys=[reported_by_id], back_populates="submitted_reports")
    resolver = db.relationship("User", foreign_keys=[resolved_by_id], back_populates="resolved_reports")

    __table_args__ = (
        db.Index('idx_asset_report_status', 'status'),
        db.Index('idx_asset_report_asset', 'asset_id'),
        db.Index('idx_asset_report_reporter', 'reported_by_id'),
        db.Index('idx_asset_report_date', 'report_date'),
        db.Index('idx_asset_report_resolver', 'resolved_by_id'),
    )

    def __repr__(self):
        return f"<AssetReport ID:{self.id} for Asset:{self.asset_id} Status:{self.status}>"

class BookCheckout(db.Model):
    __tablename__ = "book_checkout"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    asset_id = db.Column(db.Integer, db.ForeignKey("asset.id"), nullable=False, index=True)
    checkout_date = db.Column(db.Date, nullable=False, default=lambda: datetime.now(timezone.utc).date())
    due_date = db.Column(db.Date, nullable=False)
    return_date = db.Column(db.Date, nullable=True)
    returned = db.Column(db.Boolean, default=False, nullable=False, index=True)

    user = db.relationship("User", back_populates="book_checkouts")
    asset = db.relationship("Asset", back_populates="book_checkouts")

    __table_args__ = (
         db.Index('idx_book_checkout_dates', 'checkout_date', 'due_date', 'return_date'),
    )

    def __repr__(self):
        return f"<BookCheckout UserID: {self.user_id}, AssetID: {self.asset_id}, Due: {self.due_date}, Returned: {self.returned}>"

# --- START ADDITION: TalentClub Model ---
# --- NEW MODELS: Talent Club Subsystem ---

class TalentClub(db.Model):
    __tablename__ = 'talent_club_instances' # Renamed for clarity
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False, index=True)
    description = db.Column(db.Text, nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True) # Added for club photo
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The creator/primary manager of THIS club instance
    social_category_id = db.Column(db.Integer, db.ForeignKey('social_category.id'), nullable=False, index=True) # Category of the club
    level = db.Column(db.Integer, default=1, nullable=False) # Club level
    warning_count = db.Column(db.Integer, default=0, nullable=False) # Warning count
    is_active = db.Column(db.Boolean, default=True, nullable=False) # For soft deletion (e.g., after too many warnings)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    owner = db.relationship('User', back_populates='owned_talent_clubs') # Link back to User owner
    social_category = db.relationship('SocialCategory') # Link to category

    # Relationships to new associated models
    memberships = db.relationship('TalentClubMembership', back_populates='club', lazy='dynamic', cascade='all, delete-orphan')
    follows = db.relationship('TalentClubFollow', back_populates='club', lazy='dynamic', cascade='all, delete-orphan')
    feed = db.relationship('TalentClubFeed', back_populates='talent_club', uselist=False, cascade='all, delete-orphan') # Link to its content feed
    warnings = db.relationship('TalentClubWarning', back_populates='club', lazy='dynamic', cascade='all, delete-orphan')


    def __repr__(self):
        return f"<TalentClub ID:{self.id} Name:'{self.name}' Level:{self.level} Active:{self.is_active}>"

class TalentClubMembership(db.Model):
    __tablename__ = 'talent_club_memberships' # Link users to specific clubs (official members)
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    role = db.Column(db.String(20), default='member', nullable=False) # Role within THIS club (creator, admin, member)
    joined_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    is_active = db.Column(db.Boolean, default=True, nullable=False) # Allow suspending membership within a club

    # Relationships
    club = db.relationship('TalentClub', back_populates='memberships')
    user = db.relationship('User', back_populates='tc_memberships', foreign_keys=[user_id])

    __table_args__ = (UniqueConstraint('talent_club_id', 'user_id', name='_tc_membership_uc'),)

    def __repr__(self):
        return f"<TalentClubMembership ClubID:{self.talent_club_id} UserID:{self.user_id} as {self.role}>"

class TalentClubFollow(db.Model):
    __tablename__ = 'talent_club_follows' # Link users to specific clubs they follow (not members)
    id = db.Column(db.Integer, primary_key=True) # Added ID as PK
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    followed_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    receive_notifications = db.Column(db.Boolean, default=True, nullable=False) # Toggle for content notifications

    # Relationships
    club = db.relationship('TalentClub', back_populates='follows')
    user = db.relationship('User', back_populates='tc_follows', foreign_keys=[user_id])

    __table_args__ = (UniqueConstraint('talent_club_id', 'user_id', name='_tc_follow_uc'),)
    __mapper_args__ = {'confirm_deleted_rows': False} # Avoids a warning with bulk updates

    def __repr__(self):
        return f"<TalentClubFollow ClubID:{self.talent_club_id} UserID:{self.user_id}>"


class TalentClubFeed(db.Model):
    __tablename__ = 'talent_club_feeds' # Content feed for a specific TalentClub instance
    id = db.Column(db.Integer, primary_key=True)
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), unique=True, nullable=False) # Link to the club

    allow_comments = db.Column(db.Boolean, default=True, nullable=False) # Feed settings
    allow_reactions = db.Column(db.Boolean, default=True, nullable=False)

    # Relationships
    talent_club = db.relationship('TalentClub', back_populates='feed')
    posts = db.relationship('TalentClubFeedPost', back_populates='feed', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubFeed ID:{self.id} for Club ID:{self.talent_club_id}>"

class TalentClubFeedPost(db.Model):
    __tablename__ = 'talent_club_feed_posts' # Posts within a TalentClub feed
    id = db.Column(db.Integer, primary_key=True)
    feed_id = db.Column(db.Integer, db.ForeignKey('talent_club_feeds.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # Must be a club member with posting rights
    content = db.Column(db.Text, nullable=True) # Text content
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), unique=True, nullable=True, index=True) # Link to existing File model
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    # Relationships
    feed = db.relationship('TalentClubFeed', back_populates='posts')
    author = db.relationship('User') # Link to the user who posted
    file = db.relationship('File', uselist=False) # Link to attached file

    comments = db.relationship('TalentClubFeedComment', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')
    reactions = db.relationship('TalentClubFeedReaction', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubFeedPost ID:{self.id} FeedID:{self.feed_id} AuthorID:{self.author_id}>"

class TalentClubFeedComment(db.Model):
    __tablename__ = 'talent_club_feed_comments' # Comments on a TalentClub feed post
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('talent_club_feed_posts.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)

    # Relationships
    post = db.relationship('TalentClubFeedPost', back_populates='comments')
    author = db.relationship('User')

    def __repr__(self):
        return f"<TalentClubFeedComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"

class TalentClubFeedReaction(db.Model):
    __tablename__ = 'talent_club_feed_reactions' # Reactions on a TalentClub feed post
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('talent_club_feed_posts.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # User who reacted
    emoji = db.Column(db.String(50), nullable=False) # The emoji string
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    post = db.relationship('TalentClubFeedPost', back_populates='reactions')
    user = db.relationship('User')

    __table_args__ = (UniqueConstraint('post_id', 'user_id', 'emoji', name='_tc_post_user_emoji_uc'),)

    def __repr__(self):
        return f"<TalentClubFeedReaction ID:{self.id} PostID:{self.post_id} UserID:{self.user_id} Emoji:{self.emoji}>"


class TalentClubCommunity(db.Model):
    __tablename__ = 'talent_club_community' # The single global TC Community group
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False) # e.g. "TC Community Group"
    description = db.Column(db.String(255), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    messages = db.relationship('TalentClubCommunityMessage', back_populates='community', lazy='dynamic', cascade='all, delete-orphan')
    members = db.relationship('TalentClubCommunityMember', back_populates='community', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubCommunity ID:{self.id} Name:'{self.name}'>"

class TalentClubCommunityMember(db.Model):
    __tablename__ = 'talent_club_community_members' # Users in the TC Community group
    community_id = db.Column(db.Integer, db.ForeignKey('talent_club_community.id'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True) # Must be is_tc_member = TRUE
    role = db.Column(db.String(20), default='member', nullable=False) # e.g. 'admin', 'member'
    joined_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    community = db.relationship('TalentClubCommunity', back_populates='members')
    user = db.relationship('User') # Link to user

    __table_args__ = (UniqueConstraint('community_id', 'user_id', name='_tcc_membership_uc'),)

    def __repr__(self):
        return f"<TalentClubCommunityMember CommID:{self.community_id} UserID:{self.user_id} as {self.role}>"

class TalentClubCommunityMessage(db.Model):
    __tablename__ = 'talent_club_community_messages' # Messages in the TC Community group
    id = db.Column(db.Integer, primary_key=True)
    community_id = db.Column(db.Integer, db.ForeignKey('talent_club_community.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # Must be a TCC member
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), unique=True, nullable=True, index=True) # Link to existing File model
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    # Relationships
    community = db.relationship('TalentClubCommunity', back_populates='messages')
    author = db.relationship('User') # Link to author
    file = db.relationship('File', uselist=False) # Link to attached file

    def __repr__(self):
        return f"<TalentClubCommunityMessage ID:{self.id} CommID:{self.community_id} AuthorID:{self.author_id}>"


class TalentClubProposal(db.Model):
    __tablename__ = 'talent_club_proposals' # Proposal for a new club instance
    id = db.Column(db.Integer, primary_key=True)
    creator_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The user initiating the proposal
    name = db.Column(db.String(100), nullable=False) # Proposed name
    description = db.Column(db.Text, nullable=False) # Proposed description
    social_category_id = db.Column(db.Integer, db.ForeignKey('social_category.id'), nullable=False, index=True) # Proposed category
    proposal_file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), unique=True, nullable=True) # Optional attachment (reusing File model)
    status = db.Column(db.String(30), default='pending_leader_review', nullable=False, index=True) # pending_leader_review, pending_members_accept, accepted, rejected
    leader_review_notes = db.Column(db.Text, nullable=True) # Notes from TC Leader review
    reviewed_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True) # The TC Leader who reviewed
    reviewed_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    creator = db.relationship('User', back_populates='tc_proposals_created', foreign_keys=[creator_id])
    social_category = db.relationship('SocialCategory')
    proposal_file = db.relationship('File', uselist=False)
    mentioned_members = db.relationship('TalentClubMention', back_populates='proposal', lazy='dynamic', cascade='all, delete-orphan') # Students mentioned in the proposal
    reviewed_by = db.relationship('User', foreign_keys=[reviewed_by_id])


    def __repr__(self):
        return f"<TalentClubProposal ID:{self.id} Name:'{self.name}' Status:'{self.status}' Creator:{self.creator_id}>"


class TalentClubMention(db.Model):
    __tablename__ = 'talent_club_proposal_mentions' # Students mentioned in a proposal
    id = db.Column(db.Integer, primary_key=True) # Added PK for notification linking
    proposal_id = db.Column(db.Integer, db.ForeignKey('talent_club_proposals.id'), nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The student user being mentioned
    status = db.Column(db.String(20), default='pending', nullable=False, index=True) # pending, accepted, rejected
    responded_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    proposal = db.relationship('TalentClubProposal', back_populates='mentioned_members')
    user = db.relationship('User', back_populates='tc_mentions_received', foreign_keys=[user_id])

    __table_args__ = (UniqueConstraint('proposal_id', 'user_id', name='_tc_proposal_mention_uc'),)

    def __repr__(self):
        return f"<TalentClubMention ID:{self.id} ProposalID:{self.proposal_id} UserID:{self.user_id} Status:'{self.status}'>"

class TalentClubWarning(db.Model):
    __tablename__ = 'talent_club_warnings' # Warnings issued to a TalentClub instance
    id = db.Column(db.Integer, primary_key=True)
    talent_club_id = db.Column(db.Integer, db.ForeignKey('talent_club_instances.id'), nullable=False, index=True)
    issued_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # Should be the TC Leader
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    club = db.relationship('TalentClub', back_populates='warnings')
    issued_by = db.relationship('User')

    def __repr__(self):
        return f"<TalentClubWarning ID:{self.id} ClubID:{self.talent_club_id} IssuedBy:{self.issued_by_id} at {self.issued_at}>"

# Optional Models for more detailed Ban/Penalty tracking
class TalentClubBan(db.Model):
    __tablename__ = 'talent_club_bans' # System-wide TC bans/mutes
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Member banned/muted
    issued_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Leader or Admin
    type = db.Column(db.String(20), nullable=False) # e.g., 'ban', 'mute'
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=True) # Null for permanent ban

    # Relationships
    user = db.relationship('User', foreign_keys=[user_id], back_populates='tc_bans_received')
    issued_by = db.relationship('User', foreign_keys=[issued_by_id], back_populates='tc_bans_issued')

    def __repr__(self):
        return f"<TalentClubBan ID:{self.id} User:{self.user_id} Type:'{self.type}' IssuedBy:{self.issued_by_id}>"

class TalentClubPenalty(db.Model):
    __tablename__ = 'talent_club_penalties' # System-wide TC penalties (if needed, distinct from bans/warnings)
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Member penalized
    issued_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The TC Leader or Admin
    type = db.Column(db.String(50), nullable=False) # e.g., 'points_deduction', 'feature_restriction'
    reason = db.Column(db.Text, nullable=False)
    issued_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=True) # For temporary penalties

    # Relationships
    user = db.relationship('User', foreign_keys=[user_id], back_populates='tc_penalties_received')
    issued_by = db.relationship('User', foreign_keys=[issued_by_id], back_populates='tc_penalties_issued')

    def __repr__(self):
        return f"<TalentClubPenalty ID:{self.id} User:{self.user_id} Type:'{self.type}' IssuedBy:{self.issued_by_id}>"


class TalentClubLeaderElection(db.Model):
    __tablename__ = 'tc_leader_elections' # Tracks elections for the system-wide TC Leader
    id = db.Column(db.Integer, primary_key=True)
    initiated_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # HR/CEO who started it
    initiated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    concluded_at = db.Column(db.DateTime, nullable=True)
    status = db.Column(db.String(20), default='active', nullable=False, index=True) # active, concluded, cancelled
    elected_leader_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True, index=True) # The user who won

    # Relationships
    initiated_by = db.relationship('User', foreign_keys=[initiated_by_id], back_populates='tc_leader_election_initiated')
    elected_leader = db.relationship('User', foreign_keys=[elected_leader_id]) # User who won
    votes = db.relationship('TalentClubLeaderVote', back_populates='election', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f"<TalentClubLeaderElection ID:{self.id} Status:'{self.status}' Initiated:{self.initiated_at.strftime('%Y-%m-%d')}>"

class TalentClubLeaderVote(db.Model):
    __tablename__ = 'tc_leader_votes' # Individual votes in a TC Leader election
    id = db.Column(db.Integer, primary_key=True) # Added PK
    election_id = db.Column(db.Integer, db.ForeignKey('tc_leader_elections.id'), nullable=False, index=True)
    voter_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The user who voted (must be is_tc_member)
    candidate_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True) # The user they voted for (must be is_tc_member)
    voted_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    # Relationships
    election = db.relationship('TalentClubLeaderElection', back_populates='votes')
    voter = db.relationship('User', foreign_keys=[voter_id], back_populates='tc_leader_votes_cast')
    candidate = db.relationship('User', foreign_keys=[candidate_id]) # The candidate user

    __table_args__ = (UniqueConstraint('election_id', 'voter_id', name='_tc_leader_vote_uc'),) # Each voter gets one vote per election

    def __repr__(self):
        return f"<TalentClubLeaderVote ID:{self.id} Election:{self.election_id} Voter:{self.voter_id} Candidate:{self.candidate_id}>"
class BorrowedAsset(db.Model): # Added BorrowedAsset model
    __tablename__ = 'borrowed_asset'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    asset_id = db.Column(db.Integer, db.ForeignKey('asset.id'), nullable=False, index=True)
    checkout_date = db.Column(db.Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False)
    due_date = db.Column(db.Date, nullable=False)
    return_date = db.Column(db.Date, nullable=True)
    returned = db.Column(db.Boolean, default=False, nullable=False, index=True)

    user = db.relationship('User', back_populates='borrowed_assets')
    asset = db.relationship('Asset', back_populates='borrowed_by')

    def __repr__(self):
        return f"<BorrowedAsset UserID: {self.user_id}, AssetID: {self.asset_id}, Due: {self.due_date}, Returned: {self.returned}>"


class Notification(db.Model):
    __tablename__ = "notification"
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    receiver_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), index=True)
    is_read = db.Column(db.Boolean, default=False, nullable=False, index=True)
    link_url = db.Column(db.String(255), nullable=True)

    sender = db.relationship("User", foreign_keys=[sender_id], back_populates="sent_notifications")
    receiver = db.relationship("User", foreign_keys=[receiver_id], back_populates="received_notifications")
    notification_type = db.Column(db.String(50), nullable=True) # e.g., 'chat', 'general', 'request', 'tc_invite', 'tc_warning', 'tc_level_change', 'tc_vote_open', 'tc_vote_result'
    related_object_id = db.Column(db.Integer, nullable=True, index=True) # ID of related object (e.g., TalentClubMention ID for invite, TalentClub ID for warning/level, Election ID for vote)
    __table_args__ = (
        db.Index('idx_notification_receiver_read', 'receiver_id', 'is_read'),
    )

    def __repr__(self):
        return f"<Notification from {self.sender_id} to {self.receiver_id} at {self.timestamp}>"

class Attendance(db.Model): # Student Attendance
    __tablename__ = "student_attendance"
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    date = db.Column(db.Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False, index=True)
    status = db.Column(db.String(10), default="Present", nullable=False)
    notes = db.Column(db.Text)

    student = db.relationship("User", back_populates="attendance_entries")

    __table_args__ = (
        db.UniqueConstraint("student_id", "date", name="_student_date_uc"),
    )

    def __repr__(self):
        return f"<StudentAttendance StudentID: {self.student_id}, Date: {self.date}, Status: {self.status}>"

class StaffAttendance(db.Model): # Staff Attendance
    __tablename__ = "staff_attendance"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False, index=True)
    date = Column(Date, default=lambda: datetime.now(timezone.utc).date(), nullable=False, index=True)
    present = Column(Boolean, default=False, nullable=False)
    notes = Column(Text)

    user = relationship("User", back_populates="staff_attendance_records")

    __table_args__ = (db.UniqueConstraint("user_id", "date", name="_staff_attendance_uc"),)

    def __repr__(self):
        status = "Present" if self.present else "Absent"
        return f"<StaffAttendance UserID: {self.user_id}, Date: {self.date}, Status: {status}>"

class File(db.Model):
    __tablename__ = 'social_files'
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(255), nullable=False)
    original_filename = db.Column(db.String(255), nullable=False)
    mimetype = db.Column(db.String(100), nullable=True)
    filepath = db.Column(db.String(255), unique=True, nullable=False)
    size = db.Column(db.BigInteger, nullable=False)
    uploaded_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    uploaded_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    uploader = db.relationship('User', back_populates='uploaded_social_files')
    channel_post = db.relationship('ChannelPost', back_populates='file', uselist=False)
    group_message = db.relationship('GroupMessage', back_populates='file', uselist=False)

    def get_download_url(self):
        try:
            from flask import url_for
            return url_for('download_social_file', file_id=self.id, _external=True)
        except RuntimeError:
            print(f"Warning: url_for called outside application context for File {self.id}")
            return f"/social/files/download/{self.id}"


# --- NEW FORMS: Task System ---

class CreateTaskForm(FlaskForm):
    """Form for creating a new task."""
    title = StringField("Task Title", validators=[DataRequired(), Length(max=255)])
    description = TextAreaField("Detailed Description", validators=[DataRequired(), Length(min=10, max=2000)])
    due_date = DateField("Due Date (YYYY-MM-DD) (Optional)", format='%Y-%m-%d', validators=[Optional()])
    urgency = SelectField("Urgency", choices=[
        ('Low', 'Low'),
        ('Medium', 'Medium'),
        ('High', 'High'),
        ('Critical', 'Critical')
    ], default='Medium', validators=[DataRequired()])

    # Field to select assignment type - will control visibility of subsequent fields via JS
    assignment_type = RadioField(
        "Assign To",
        choices=[('individual', 'Individual User(s)'), ('group', 'Group(s)')],
        validators=[DataRequired()],
        default='individual' # Default to individual
    )

    # Fields for assignment targets (populated dynamically/via JS)
    # Individual User IDs will be sent via a hidden field populated by a JS picker
    individual_user_ids = HiddenField("Individual User IDs") # No validator here, validation in route logic

    # Group assignments - These will likely be selected via separate dropdowns/checkboxes in the template,
    # controlled by `assignment_type`. The selected values will be sent in `request.form`.
    # We *could* add SelectMultipleFields here if WTForms handles the rendering better, but given
    # the dynamic nature (list of roles, dynamic list of grades/sections), reading directly from request.form
    # might be simpler alongside JS.
    # Placeholder for validation in route:
    # group_roles = FieldList(StringField('Role Name')) # Not used directly for data, more for validation structure
    # group_grade_sections = FieldList(StringField('Grade Section')) # Not used directly

    submit = SubmitField("Create Task")

    def validate_due_date(self, field):
        # Allow empty date if Optional
        if field.data and field.data < datetime.now(timezone.utc).date():
            raise ValidationError("Due date cannot be in the past.")

    # Custom validation for assignment target based on type will be in the route

class UpdateUserTaskStatusForm(FlaskForm):
    """Form for an assigned user to update their task status."""
    status = SelectField("Update Status", validators=[DataRequired()], choices=[
        ('In Progress', 'In Progress'),
        ('Completed (Pending Review)', 'Completed'),
        ('Delayed (Pending Review)', 'Delayed'),
        ('Rejected (Pending Review)', 'Cannot Complete') # Renamed to clarify user cannot/will not do it
    ]) # 'Open' status is default, not a choice here

    completion_notes = TextAreaField(
        "Notes / Reason for Status",
        validators=[Optional(), Length(max=1000)]
    )
    submit = SubmitField("Submit Status Update")

    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        # Custom validation: Require notes if status is Delayed or Rejected
        if self.status.data in ['Delayed (Pending Review)', 'Rejected (Pending Review)'] and not self.completion_notes.data:
            self.completion_notes.errors.append("Reason/notes are required for Delayed or Cannot Complete statuses.")
            return False

        return True


class ReviewUserTaskForm(FlaskForm):
    """Form for the task creator to review a user's status update."""
    review_outcome = SelectField("Review Outcome", validators=[DataRequired()], choices=[
        ('Accepted', 'Accept Completion/Status'),
        ('Review Rejected', 'Reject Completion/Status')
    ])
    reviewer_notes = TextAreaField(
        "Reviewer Notes (Optional)",
        validators=[Optional(), Length(max=1000)]
    )
    submit = SubmitField("Submit Review")

    # Custom validation: Require notes if review is Rejected
    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        if self.review_outcome.data == 'Review Rejected' and not self.reviewer_notes.data:
             self.reviewer_notes.errors.append("Reviewer notes are required if the review is rejected.")
             return False

        return True

# Channel Models
# START MODIFICATION (Channel Model)
# START MODIFICATION (Channel Model - REMOVING TC Link)
class Channel(db.Model):
    __tablename__ = 'social_channels'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True, index=True)
    bio = db.Column(db.Text, nullable=True)
    profile_photo_url = db.Column(db.String(255), nullable=True)
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    social_category_id = db.Column(db.Integer, db.ForeignKey('social_category.id'), nullable=False, index=True)
    type = db.Column(db.String(20), default='private', nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    allow_comments = db.Column(db.Boolean, default=True, nullable=False)
    allow_reactions = db.Column(db.Boolean, default=True, nullable=False)

    # REMOVED: talent_club_id foreign key no longer exists here
    # REMOVED: talent_club relationship no longer exists here

    owner = db.relationship('User', foreign_keys=[owner_id], back_populates='owned_channels')
    social_category = db.relationship('SocialCategory', back_populates='channels')
    subscribers = db.relationship('ChannelSubscriber', back_populates='channel', lazy='dynamic', cascade='all, delete-orphan')
    posts = db.relationship('ChannelPost', back_populates='channel', lazy='dynamic', cascade='all, delete-orphan')

    # REMOVED: back_populates='linked_channel' is gone because the relationship is gone

    def __repr__(self):
        return f"<Channel ID:{self.id} Name:'{self.name}' Type:'{self.type}'>"
# END MODIFICATION (Channel Model - REMOVING TC Link)
    
# END MODIFICATION (Channel Model)
class ChannelSubscriber(db.Model):
    __tablename__ = 'social_channel_subscribers'
    channel_id = db.Column(db.Integer, db.ForeignKey('social_channels.id'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    role = db.Column(db.String(20), default='subscriber', nullable=False)
    subscribed_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    user = db.relationship('User', back_populates='channel_subscriptions')
    channel = db.relationship('Channel', back_populates='subscribers')

    __table_args__ = (UniqueConstraint('channel_id', 'user_id', name='_channel_user_uc'),)

    def __repr__(self):
        return f"<ChannelSubscriber UserID: {self.user_id} in ChannelID: {self.channel_id} as {self.role}>"


class ChannelPost(db.Model):
    __tablename__ = 'social_channel_posts'
    id = db.Column(db.Integer, primary_key=True)
    channel_id = db.Column(db.Integer, db.ForeignKey('social_channels.id'), nullable=False, index=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), nullable=True, unique=True, index=True)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    channel = db.relationship('Channel', back_populates='posts', foreign_keys=[channel_id])
    author = db.relationship('User', foreign_keys=[author_id], back_populates='channel_posts')
    file = db.relationship('File', back_populates='channel_post', uselist=False)

    comments = db.relationship('ChannelComment', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')
    reactions = db.relationship('ChannelReaction', back_populates='post', lazy='dynamic', cascade='all, delete-orphan')


    def get_share_url(self):
         try:
              from flask import url_for
              return url_for('view_social_channel_post_redirect', post_id=self.id, _external=True)
         except RuntimeError:
              print(f"Warning: url_for called outside application context for ChannelPost {self.id}")
              return f"/social/posts/{self.id}/view"

    def __repr__(self):
         return f"<ChannelPost ID:{self.id} ChannelID:{self.channel_id} AuthorID:{self.author_id}>"


class ChannelComment(db.Model):
    __tablename__ = 'social_channel_comments'
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('social_channel_posts.id'), nullable=False)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)

    post = db.relationship('ChannelPost', back_populates='comments')
    author = db.relationship('User', back_populates='channel_comments', foreign_keys=[author_id])

    def __repr__(self):
         return f"<ChannelComment ID:{self.id} PostID:{self.post_id} AuthorID:{self.author_id}>"


class ChannelReaction(db.Model):
    __tablename__ = 'social_channel_reactions'
    id = db.Column(db.Integer, primary_key=True)
    post_id = db.Column(db.Integer, db.ForeignKey('social_channel_posts.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    emoji = db.Column(db.String(50), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)

    post = db.relationship('ChannelPost', back_populates='reactions')
    user = db.relationship('User', back_populates='channel_reactions')

    __table_args__ = (UniqueConstraint('post_id', 'user_id', 'emoji', name='_post_user_emoji_uc'),)

    def __repr__(self):
         return f"<ChannelReaction ID:{self.id} PostID:{self.post_id} UserID:{self.user_id} Emoji:{self.emoji}>"


class GroupMessage(db.Model): # Corrected model name
    __tablename__ = 'social_group_messages'
    id = db.Column(db.Integer, primary_key=True)
    group_id = db.Column(db.Integer, db.ForeignKey('social_groups.id'), nullable=False, index=True) # FK points to social_groups
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    file_id = db.Column(db.Integer, db.ForeignKey('social_files.id'), nullable=True, unique=True, index=True)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False, index=True)
    is_edited = db.Column(db.Boolean, default=False, nullable=False)

    group = db.relationship('SocialGroup', back_populates='messages', foreign_keys=[group_id]) # Corrected relationship target and added FK
    author = db.relationship('User', foreign_keys=[author_id], back_populates='group_messages')
    file = db.relationship('File', back_populates='group_message', uselist=False)

    def get_share_url(self):
         try:
              from flask import url_for
              return url_for('view_social_group_message_redirect', message_id=self.id, _external=True)
         except RuntimeError:
              print(f"Warning: url_for called outside application context for GroupMessage {self.id}")
              return f"/social/messages/{self.id}/view"

    def __repr__(self):
         return f"<GroupMessage ID:{self.id} GroupID:{self.group_id} AuthorID:{self.author_id}>"


class Mark(db.Model):
    __tablename__ = 'mark'
    id = db.Column(db.Integer, primary_key=True)
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False, index=True)
    subject = db.Column(db.String(100), nullable=False, index=True)
    semester_1 = db.Column(db.Float, nullable=True)
    semester_2 = db.Column(db.Float, nullable=True)
    total = db.Column(db.Float, nullable=True)
    average = db.Column(db.Float, nullable=True, index=True)
    rank = db.Column(db.Integer, nullable=True)

    student = db.relationship('User', back_populates='marks')

    __table_args__ = (
        db.UniqueConstraint('student_id', 'subject', name='_student_subject_uc'),
        db.Index('idx_mark_subject_average', 'subject', 'average'),
    )

    def __repr__(self):
        return f"<Mark StudentID: {self.student_id}, Subject: {self.subject}, Avg: {self.average}>"
        
# --- PART 2 END: Model Definitions ---

# --- PART 3 START: SQLAlchemy Init, LoginManager, Core Helpers & Context ---

# # --- PART 3 START: SQLAlchemy Init, LoginManager, Core Helpers & Context ---

# Initialize db *AFTER* models have been defined by associating it with the app
# The 'db' object itself was created BEFORE model definitions (db = SQLAlchemy())
# Correct way to bind the existing db instance to the app after models are defined:
db.init_app(app)

# Initialize Migrate *AFTER* db has been initialized with the app
migrate = Migrate(app, db)

# Initialize LoginManager *AFTER* the User model is defined and db is initialized
login_manager = LoginManager(app)
login_manager.login_view = "login"
login_manager.login_message_category = "info"

# ... rest of PART 3 ...
@login_manager.user_loader
def load_user(user_id):
    """Required by Flask-Login to load a user from the user ID stored in the session."""
    if user_id is not None:
        # Use db.session.get for retrieving by primary key
        # Ensure user is active before loading
        user = db.session.get(User, int(user_id))
        if user and user.is_active:
            return user
    return None # Return None if user_id is invalid or user is not found/inactive

# --- Helper Functions (Consolidated and placed here) ---

# Helper to get roles a given role can send to or receive from (used by Notification & Chat helpers)
# --- Helper Functions (Consolidated and placed here) ---

# Helper to get roles a given role can send to or receive from (used by Notification & Chat helpers)
# UPDATED: Now takes a 'user' object instead of separate 'role_name' and 'is_leader'
def get_allowed_roles_helper(config_dict, direction, user):
    """Helper to get roles a given role can send to or receive from based on a config dictionary."""
    if not user or not user.is_authenticated or not user.role:
        return [] # No permissions for unauthenticated or rol-less users

    role_name_lower = user.role.name.lower()
    perms = config_dict.get(role_name_lower, {})

    # --- NEW TC Leader Send Override (Applies only to 'send_to') ---
    if direction == 'send_to':
        if user.is_tc_leader:
            # If the user is the system-wide TC Leader, they can send chat/notifications to:
            # 1. Other Talent Club members (primary role 'student', is_tc_member=True) -> target role 'student'
            # 2. Other Talent Club role users (e.g. coordinators, other leaders) -> target role 'talent_club'
            # 3. HR/CEO users -> target role 'hr_ceo'
            # This overrides any more restrictive send_to rules for the specific roles listed here.
            return ['student', 'talent_club', 'hr_ceo'] # Specific roles the leader can send *to*.

    # --- Logic for other users OR for the 'receive_from' direction ---

    # Resolve specific permissions based on primary role and exceptions (if applicable)
    specific_perms = perms
    if 'exceptions' in perms:
        # Check for role-specific exceptions based on boolean flags on the user object
        # Order matters: prioritize the most specific exception if multiple apply
        # Assuming tc_leader and tc_member on a student use the 'tc_member' exception primarily,
        # unless a nested exception is defined. For simplicity, let's rely on the config.
        # The helper as written looks for a direct match in the 'exceptions' dictionary key.

        # Prioritize 'tc_member' exception for 'student' role
        if role_name_lower == 'student' and user.is_tc_member and 'tc_member' in perms['exceptions']:
             specific_perms = perms['exceptions']['tc_member']
        # Check 'leader' exception for 'student' role (applies if is_leader is True and tc_member isn't primary exception)
        elif role_name_lower == 'student' and user.is_leader and 'leader' in perms['exceptions']:
            specific_perms = perms['exceptions']['leader']
        # Check 'tc_leader' exception for 'talent_club' role
        elif role_name_lower == 'talent_club' and user.is_tc_leader and 'tc_leader' in perms['exceptions']:
            specific_perms = perms['exceptions']['tc_leader']
        # Add more exception checks here for other roles/leader types if they emerge
        # E.g., if a 'teacher' could also be 'is_tc_member', you'd need an exception for that.


    # Get the permissions dictionary for the determined direction (send_to or receive_from)
    direction_perms = specific_perms.get(direction, {})

    # Resolve the final list of allowed roles based on 'all', 'specific', or 'none'
    if direction_perms.get('all'):
        exceptions = [exc.lower() for exc in direction_perms.get('exceptions', [])]
        # Use the global VALID_ROLE_NAMES defined earlier (assumed to exist)
        # from flask import current_app # Need current_app if VALID_ROLE_NAMES is in app.config
        return [r.lower() for r in VALID_ROLE_NAMES if r.lower() not in exceptions]
    elif direction_perms.get('specific'):
        return [r.lower() for r in direction_perms.get('specific', [])]
    else: # 'none' or not defined
        return []
# Specific helper for Chat permissions
# UPDATED: Now takes a 'user' object
def get_allowed_chat_roles(direction, user):
     # Access app config within the function if needed
     from flask import current_app # This import is often needed if run standalone or in contexts.
     # Pass the user object directly to the general helper
     return get_allowed_roles_helper(CHAT_PERMISSIONS, direction, user)


# Specific helper for Notification permissions
# UPDATED: Now takes a 'user' object
def get_allowed_notification_roles(direction, user):
     # Access app config within the function if needed
     from flask import current_app # This import is often needed if run standalone or in contexts.
     # Pass the user object directly to the general helper
     return get_allowed_roles_helper(NOTIFICATION_PERMISSIONS, direction, user)

# --- NEW HELPER FUNCTIONS: Talent Club Subsystem ---

def is_tc_leader(user):
    """Checks if the given user is the current system-wide Talent Club Leader."""
    if not user or not user.is_authenticated:
        return False
    # Direct check on the flag on the user object is sufficient
    return user.is_tc_leader

def get_tc_community_group():
    """Fetches the single Talent Club Community group instance."""
    # This group should be created during initial setup/seeding
    return db.session.scalar(select(TalentClubCommunity).limit(1))

def is_tc_community_member(user):
    """Checks if a user is a member of the main TC Community group."""
    if not user or not user.is_authenticated or not user.is_tc_member:
        return False # Must be a TC member to be in the community group

    community_group = get_tc_community_group()
    if not community_group:
         app.logger.warning("Talent Club Community group not found in DB.")
         return False

    # Check for membership in the TalentClubCommunityMember association table
    is_member = db.session.scalar(
        select(TalentClubCommunityMember).where(
            TalentClubCommunityMember.community_id == community_group.id,
            TalentClubCommunityMember.user_id == user.id
        ).exists() # Use exists() for efficiency
    )
    return is_member or False # Return boolean


def add_to_tc_community_group(user):
    """Adds a user to the TC Community group if they are a TC member and not already added."""
    if not user or not user.is_tc_member:
        app.logger.warning(f"Attempted to add non-TC member user {user.id if user else 'N/A'} to TC Community.")
        return False

    community_group = get_tc_community_group()
    if not community_group:
        app.logger.error("Talent Club Community group not found. Cannot add member.")
        return False

    # Check if already a member
    if is_tc_community_member(user):
        app.logger.debug(f"User {user.id} already in TC Community group.")
        return True # Already done

    try:
        member_entry = TalentClubCommunityMember(
            community=community_group,
            user=user,
            role='member', # Default role
            joined_at=datetime.now(timezone.utc)
        )
        db.session.add(member_entry)
        db.session.commit()
        app.logger.info(f"User {user.id} added to TC Community group ID {community_group.id}.")
        return True
    except IntegrityError:
        db.session.rollback()
        app.logger.warning(f"IntegrityError adding user {user.id} to TC Community group {community_group.id} (already member?).")
        # This might happen if is_tc_community_member check failed due to cache, or concurrent op
        return False # Or True if you assume the exception means they are already in
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error adding user {user.id} to TC Community group {community_group.id}: {e}", exc_info=True)
        return False


def notify_tc_member(receiver_user, sender_user, content, notification_type, related_object_id=None, link_url=None):
    """
    Sends a notification specifically within the Talent Club subsystem.
    Checks if receiver is a TC member and if notification type/sender is allowed within TC context (optional check).
    """
    if not receiver_user or not receiver_user.is_tc_member:
        # Cannot notify non-TC members via this helper
        app.logger.warning(f"Attempted to send TC notification to non-TC member user {receiver_user.id if receiver_user else 'N/A'}.")
        return False

    # Optional: Add specific checks based on TC notification types and sender roles
    # For now, assume if you are allowed to send TC notifications, you can use this.
    # The main NOTIFICATION_PERMISSIONS config can be updated to reflect TC-specific flows.
    # E.g., TC Leader can send tc_warning/tc_level_change to TC Members.
    # A proposal creator can send tc_invite to mentioned members.

    # Let's use the general notification permission checks, assuming sender is allowed to notify the receiver's role.
    # The `notification_type` adds context but doesn't automatically bypass role permissions.

    # Use 'system' user as sender if sender_user is None (e.g., automated warnings)
    sender = sender_user
    if not sender:
         sender = db.session.scalar(select(User).filter_by(username='system'))
         if not sender:
             app.logger.error("System user not found for TC notification sender.")
             return False

    # Re-use the existing notification permission check
    if not is_notification_allowed(sender, receiver_user):
         app.logger.warning(f"TC Notification not allowed: Sender {sender.username} ({sender.role.name if sender.role else 'N/A'}) to Receiver {receiver_user.username} ({receiver_user.role.name if receiver_user.role else 'N/A'}).")
         return False


    try:
        notification = Notification(
            sender_id=sender.id,
            receiver_id=receiver_user.id,
            content=content,
            link_url=link_url,
            timestamp=datetime.now(timezone.utc),
            is_read=False,
            notification_type=notification_type, # Store the specific type
            related_object_id=related_object_id # Store related object ID
        )
        db.session.add(notification)
        db.session.commit() # Commit immediately for notifications
        app.logger.info(f"TC Notification sent (Type: {notification_type}, Related ID: {related_object_id}) to user {receiver_user.id} by sender {sender.id}.")
        return True

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error sending TC notification (Type: {notification_type}, Related ID: {related_object_id}) to user {receiver_user.id}: {e}", exc_info=True)
        return False


# Helper for TC Leader to check if a user is eligible to be banned/muted
def is_eligible_for_tc_ban_mute(user_to_check):
    """Checks if a user is a TC member and thus eligible for TC-specific bans/mutes."""
    # Only TC members can receive TC-specific bans/mutes applied by the TC Leader
    return user_to_check and user_to_check.is_tc_member

# Helper for TC Leader to check if a user is currently banned/muted
def is_currently_banned_muted(user):
    """Checks if a user has an active TC ban or mute."""
    if not user:
        return False

    # Check for active bans/mutes (expires_at is null or in the future)
    active_ban = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == user.id,
            or_(
                TalentClubBan.expires_at.is_(None),
                TalentClubBan.expires_at > datetime.now(timezone.utc)
            )
        ).limit(1) # Just need to find one
    )
    return active_ban is not None

# Helper to get eligible candidates for TC Leader election (users who are is_tc_member = True)
def get_tc_leader_candidates():
    """Fetches all active users who are Talent Club members."""
    return db.session.scalars(
        select(User)
        .where(User.is_tc_member == True, User.is_active == True)
        .order_by(User.full_name)
    ).all()

# Helper to find the active TC Leader election
def get_active_tc_leader_election():
    """Finds the current active Talent Club Leader election."""
    return db.session.scalar(
        select(TalentClubLeaderElection)
        .where(TalentClubLeaderElection.status == 'active')
        .order_by(TalentClubLeaderElection.initiated_at.desc())
        .limit(1) # Should be only one active at a time
    )



# Specific helper for Chat permissions check
# UPDATED: Now takes sender_user and receiver_user objects
def is_chat_allowed(sender_user, receiver_user):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    if not receiver_user or not receiver_user.role:
        return False

    allowed_to_send = get_allowed_chat_roles('send_to', sender_user)
    allowed_to_receive = get_allowed_chat_roles('receive_from', receiver_user)

    return receiver_user.role.name.lower() in allowed_to_send and sender_user.role.name.lower() in allowed_to_receive


# Specific helper for Notification permissions check
# UPDATED: Now takes sender_user and receiver_user objects
def is_notification_allowed(sender_user, receiver_user):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    if not receiver_user or not receiver_user.role:
        return False

    allowed_to_send = get_allowed_notification_roles('send_to', sender_user)
    allowed_to_receive = get_allowed_notification_roles('receive_from', receiver_user)

    return receiver_user.role.name.lower() in allowed_to_send and sender_user.role.name.lower() in allowed_to_receive


# Helper to check if sender is allowed to send notifications to receiver role (Used in send_notification_to_user)
# UPDATED: Now takes sender_user object and receiver_role_name (string)
def can_send(sender_user, receiver_role_name):
    if not sender_user or not sender_user.is_authenticated or not sender_user.role:
        return False
    allowed_roles = get_allowed_notification_roles('send_to', sender_user)
    return receiver_role_name.lower() in allowed_roles

# Helper to check if receiver is allowed to receive notifications from sender role (Used in send_notification_to_user)
# UPDATED: Now takes receiver_user object and sender_role_name (string)
def can_receive(receiver_user, sender_role_name):
    if not receiver_user or not receiver_user.role:
        return False
    allowed_roles = get_allowed_notification_roles('receive_from', receiver_user)
    return sender_role_name.lower() in allowed_roles


# Helper to determine which assets a user should see based on their role (Implemented in Part 2/Previous block)
# Keeping the definition here for reference, but the function body was already provided.
# def get_user_assets_query(user):
#     pass # Body is in Part 2

# Placeholder Notification Helpers (These now need actual implementations or placeholders)
# ADDING SIMPLE PLACEHOLDERS HERE
def notify_hr_ceo_new_asset(asset):
    """Placeholder to notify HR/CEO about a new asset."""
    try:
        with app.app_context(): # Ensure context if called outside a request handler
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            if not hr_ceo_role:
                 app.logger.warning("HR/CEO role not found for new asset notification.")
                 return # Cannot notify if role doesn't exist

            hr_ceos = db.session.scalars(
                 select(User)
                 .where(User.role == hr_ceo_role, User.is_active == True)
             ).all()

            if not hr_ceos:
                app.logger.warning("No active HR/CEO users found for new asset notification.")
                return # Cannot notify if no HR/CEOs exist

            message_content = f"A new asset '{asset.name}' (ID: {asset.id}) has been added and is pending review."
            link_url = url_for('edit_asset', asset_id=asset.id) # Link to the edit page

            # Create a notification for each HR/CEO
            notifications = []
            for hr_ceo in hr_ceos:
                 # Check if notification is allowed based on permission config (HR/CEO can receive from any role that can add assets)
                 # Sender role is the role of the user who added the asset (asset.added_by_user.role)
                 sender_role_name = asset.added_by_user.role.name.lower() if asset.added_by_user and asset.added_by_user.role else 'unknown'
                 receiver_role_name = hr_ceo_role.name.lower()

                 if is_notification_allowed(asset.added_by_user, hr_ceo):
                     notification = Notification(
                         sender_id=asset.added_by_user_id or db.session.scalar(select(User.id).filter_by(username='system')), # Link sender to user who added, or a system user if not linked
                         receiver_id=hr_ceo.id,
                         content=message_content,
                         link_url=link_url,
                         timestamp=datetime.now(timezone.utc),
                         is_read=False
                     )
                     notifications.append(notification)

            if notifications:
                 db.session.add_all(notifications)
                 db.session.commit()
                 app.logger.info(f"Notified {len(notifications)} HR/CEO(s) about new asset ID {asset.id}.")

    except Exception as e:
         # Log the error but don't roll back the main transaction that added the asset
         app.logger.error(f"Error sending new asset notification for asset ID {asset.id}: {e}", exc_info=True)
         db.session.rollback() # Rollback only the notification transaction if any commits happened here


def notify_hr_ceo_new_report(report):
    """Placeholder to notify HR/CEO about a new asset report."""
    try:
        with app.app_context(): # Ensure context
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            if not hr_ceo_role:
                 app.logger.warning("HR/CEO role not found for new report notification.")
                 return

            hr_ceos = db.session.scalars(
                 select(User)
                 .where(User.role == hr_ceo_role, User.is_active == True)
             ).all()

            if not hr_ceos:
                app.logger.warning("No active HR/CEO users found for new report notification.")
                return

            asset_name = report.asset.name if report.asset else "General Asset"
            message_content = f"A new asset report (ID: {report.id}) has been submitted for '{asset_name}'. Status: {report.status}."
            link_url = url_for('resolve_asset_report', report_id=report.id) # Link to the resolve page

            notifications = []
            for hr_ceo in hr_ceos:
                 # Check if notification is allowed
                 sender_role_name = report.reporter.role.name.lower() if report.reporter and report.reporter.role else 'unknown'
                 receiver_role_name = hr_ceo_role.name.lower()

                 if is_notification_allowed(sender_role_name, receiver_role_name):
                     notification = Notification(
                         sender_id=report.reported_by_id or db.session.scalar(select(User.id).filter_by(username='system')), # Link sender to reporter, or system user
                         receiver_id=hr_ceo.id,
                         content=message_content,
                         link_url=link_url,
                         timestamp=datetime.now(timezone.utc),
                         is_read=False
                     )
                     notifications.append(notification)

            if notifications:
                 db.session.add_all(notifications)
                 db.session.commit()
                 app.logger.info(f"Notified {len(notifications)} HR/CEO(s) about new report ID {report.id}.")

    except Exception as e:
         app.logger.error(f"Error sending new report notification for report ID {report.id}: {e}", exc_info=True)
         db.session.rollback()


def notify_reporter_report_update(report):
    """Placeholder to notify the reporter when their asset report is updated."""
    try:
        with app.app_context(): # Ensure context
            reporter = report.reporter # Get the user who reported
            if not reporter or not reporter.is_active:
                 app.logger.warning(f"Reporter user {report.reported_by_id} not found or inactive for report update notification (Report ID: {report.id}).")
                 return # Cannot notify if reporter is missing or inactive

            # Prevent notifying the reporter if the updater is the reporter themselves (e.g., admin editing their own test report)
            if current_user and current_user.id == reporter.id:
                 app.logger.debug(f"Skipping reporter notification for report ID {report.id}: updater is the reporter ({reporter.username}).")
                 return

            # Check if notification is allowed
            sender_role_name = current_user.role.name.lower() if current_user.role else 'unknown'
            receiver_role_name = reporter.role.name.lower() if reporter.role else 'unknown'

            if not is_notification_allowed(sender_role_name, receiver_role_name):
                 app.logger.warning(f"Notification not allowed for report update (Report ID: {report.id}): {sender_role_name} cannot send to {receiver_role_name}.")
                 return

            asset_name = report.asset.name if report.asset else "General Asset"
            message_content = f"Your report (ID: {report.id}) for '{asset_name}' has been updated. New status: {report.status}."
            if report.resolution_notes:
                 message_content += f" Notes: {report.resolution_notes[:100]}..." # Truncate notes for notification

            link_url = url_for('list_asset_reports') # Link to the reports list (reporter might not have resolve access)
            # Or link to a specific report detail page if one exists for non-admin users

            notification = Notification(
                 sender_id=current_user.id, # The user resolving the report is the sender
                 receiver_id=reporter.id,
                 content=message_content,
                 link_url=link_url,
                 timestamp=datetime.now(timezone.utc),
                 is_read=False
            )
            db.session.add(notification)
            db.session.commit()
            app.logger.info(f"Notified reporter {reporter.username} about update to report ID {report.id}.")

    except Exception as e:
         app.logger.error(f"Error sending reporter notification for report ID {report.id}: {e}", exc_info=True)
         db.session.rollback()


# Unread counts (These now need actual implementations or placeholders)
# ADDING SIMPLE PLACEHOLDERS HERE that query the database
def get_unread_message_count(user_id):
    """Returns the count of unread messages for a user."""
    try:
        with app.app_context(): # Ensure context if called outside request
            # Use db.session.scalar(select(func.count())...) for counting
            count = db.session.scalar(
                select(func.count(Message.id))
                .where(Message.receiver_id == user_id, Message.is_read == False)
            )
            return count if count is not None else 0 # Return 0 if no messages found
    except Exception as e:
        app.logger.error(f"Error fetching unread message count for user {user_id}: {e}", exc_info=True)
        return 0 # Return 0 on error

def get_unread_notifications_count(user_id):
    """Returns the count of unread notifications for a user."""
    try:
        with app.app_context(): # Ensure context if called outside request
            # Use db.session.scalar(select(func.count())...) for counting
            count = db.session.scalar(
                select(func.count(Notification.id))
                .where(Notification.receiver_id == user_id, Notification.is_read == False)
            )
            return count if count is not None else 0 # Return 0 if no notifications found
    except Exception as e:
        app.logger.error(f"Error fetching unread notification count for user {user_id}: {e}", exc_info=True)
        return 0 # Return 0 on error


# Save uploaded file (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def save_uploaded_file(file_storage):
    """
    Placeholder to save an uploaded file securely to disk and create a File DB entry.
    Returns the File object (not committed) or None on failure.
    """
    if not file_storage:
        flash("No file provided for upload.", "warning")
        return None

    # Get filename securely
    original_filename = secure_filename(file_storage.filename)
    if not original_filename:
         flash("Invalid filename.", "danger")
         return None

    # Generate a unique internal filename using UUID
    # Keep the original extension (or attempt to guess mimetype)
    file_extension = os.path.splitext(original_filename)[1].lower()
    unique_filename = str(uuid.uuid4()) + file_extension

    # Build the full path to save the file within the UPLOAD_FOLDER configured in app.py
    # Assumes app.config['UPLOAD_FOLDER'] is correctly set
    if not app.config.get('UPLOAD_FOLDER'):
        app.logger.error("UPLOAD_FOLDER not configured in app.py")
        flash("File upload failed: Server configuration error.", "danger")
        return None

    save_directory = app.config['UPLOAD_FOLDER']
    save_path_full = os.path.join(save_directory, unique_filename)

    # Check max file size (optional, but good practice)
    file_storage.seek(0, os.SEEK_END) # Move cursor to end to get size
    file_size = file_storage.tell() # Get file size
    file_storage.seek(0) # Reset cursor to beginning for saving

    max_size = app.config.get('MAX_CONTENT_LENGTH', 16 * 1024 * 1024) # Default to 16MB
    if file_size > max_size:
         flash(f"File size exceeds the maximum allowed size ({max_size / (1024 * 1024):.0f} MB).", "danger")
         return None

    # Basic allowed file type check (optional, but recommended)
    # Could inspect mimetype or check extensions
    # Example extension check:
    ALLOWED_SOCIAL_EXTENSIONS = {'txt', 'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip', 'rar', 'jpg', 'jpeg', 'png', 'gif', 'mp4', 'mp3', 'wav', 'odt', 'ods', 'odp'}
    if file_extension.strip('.') not in ALLOWED_SOCIAL_EXTENSIONS:
        flash(f"File type '{file_extension}' is not allowed for upload. Allowed types: {', '.join(ALLOWED_SOCIAL_EXTENSIONS)}", "danger")
        return None


    try:
        # Save the file to the filesystem
        file_storage.save(save_path_full)

        # Get mimetype (optional, can be None)
        mimetype = file_storage.mimetype

        # Create a new File database record
        new_file = File(
            filename=unique_filename, # Store the unique server-side filename
            original_filename=original_filename, # Store the user's original filename
            mimetype=mimetype,
            # Store the filepath relative to the app root for portability
            # This path will be used by send_from_directory
            filepath=os.path.join('uploads', 'social_files', unique_filename),
            size=file_size,
            uploaded_by_id=current_user.id, # Link to the user who uploaded
            uploaded_at=datetime.now(timezone.utc)
        )

        # Do NOT commit here. The calling route is responsible for adding and committing
        # this File object along with the associated message/post.
        # db.session.add(new_file) # The calling route will add it
        app.logger.info(f"File '{original_filename}' saved to '{save_path_full}' by user {current_user.id}. Size: {file_size} bytes.")
        return new_file # Return the uncommitted DB object

    except Exception as e:
        # Log the error and cleanup the saved file if it exists
        app.logger.error(f"Error saving uploaded file '{original_filename}' for user {current_user.id}: {e}", exc_info=True)
        if os.path.exists(save_path_full):
             try: os.remove(save_path_full)
             except Exception as cleanup_e: app.logger.error(f"Error cleaning up failed upload file {save_path_full}: {cleanup_e}")

        flash("File upload failed due to an internal error. Please try again.", "danger")
        return None


# Can access social media file (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def can_access_file(user, file):
    """
    Placeholder to check if a user has permission to access a specific social file.
    Logic depends on where the file is linked (channel, group) and user's membership/role.
    """
    if not user or not user.is_authenticated or not file:
        return False # Must be logged in and file must exist

    # Check if the user uploaded the file
    if file.uploaded_by_id == user.id:
        return True

    # Check if the file is linked to a Channel Post
    if file.channel_post:
        # User can access if they are a member of the channel the post is in
        return user.is_channel_member(file.channel_post.channel)

    # Check if the file is linked to a Group Message
    if file.group_message:
        # User can access if they are a member of the group the message is in
        return user.is_group_member(file.group_message.group)

    # If the file is not linked to any post/message, maybe only the uploader or admin can access?
    # For now, assume unlinked files are not publicly accessible unless uploaded by the user.
    # Add administrative bypass for system_admin, hr_ceo etc.
    if user.role and user.role.name.lower() in ['system_admin', 'hr_ceo']:
         return True


    # If none of the above conditions are met, access is denied
    return False

# Can view behavior records (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
# In Part 3, the can_view_behavior_records helper function remains as previously updated:
def can_view_behavior_records(viewer, student):
    """
    Determines if a 'viewer' user has permission to view the
    behavior records of a 'student' user.
    (All authenticated users can view behavior records).
    """
    if not viewer or not viewer.is_authenticated or not student:
        return False
    return True # All authenticated users can view behavior records

# Notify student and parents of behavior record (Needs actual implementation or placeholder)
# ADDING SIMPLE PLACEHOLDER HERE
def notify_student_and_parents(student, behavior_record):
    """
    Placeholder to send notifications about a new behavior record to the student and their verified parents.
    """
    try:
        with app.app_context(): # Ensure context
            # Build the notification content
            message_content = f"A new behavior record has been added for you. Type: {behavior_record.behavior_type}, Severity: {behavior_record.severity}."
            # Optional: Add a link to view the behavior record details page (if one exists for students/parents)
            # link_url = url_for('view_behavior_record', record_id=behavior_record.id) # Example link

            # Notify the student
            # Check if notification is allowed (e.g. 'teacher'/'hr_ceo'/etc. sending to 'student')
            sender_role_name = behavior_record.recorded_by.role.name.lower() if behavior_record.recorded_by and behavior_record.recorded_by.role else 'unknown'
            receiver_role_name = student.role.name.lower() if student.role else 'unknown'

            if is_notification_allowed(sender_role_name, receiver_role_name):
                notification_student = Notification(
                    sender_id=behavior_record.recorded_by_id, # The user who recorded it
                    receiver_id=student.id,
                    content=message_content,
                    link_url=None, # Add link_url if applicable
                    timestamp=datetime.now(timezone.utc),
                    is_read=False
                )
                db.session.add(notification_student)
                app.logger.info(f"Notified student {student.username} about new behavior record ID {behavior_record.id}.")
            else:
                 app.logger.warning(f"Notification not allowed for student {student.username} about behavior record {behavior_record.id} from sender role {sender_role_name}.")


            # Notify verified parents of the student
            if student.parent_associations: # Check if the student has parent associations
                 parent_associations = db.session.scalars(select(ParentStudent).filter_by(student_id=student.id, verification_status='verified')).all()

                 parent_message_content = f"A new behavior record has been added for your child, {student.full_name or student.username}. Type: {behavior_record.behavior_type}, Severity: {behavior_record.severity}."
                 # Optional: Add a link to view the behavior record from the parent dashboard/student profile
                 # link_url_parent = url_for('parent_view_student_behavior', student_id=student.id) # Example link

                 for assoc in parent_associations:
                      parent = assoc.parent.user # Get the Parent User object from the association
                      if parent and parent.is_active and parent.role and parent.role.name.lower() == 'parent':
                           # Check if notification is allowed (e.g. 'teacher'/'hr_ceo'/etc. sending to 'parent')
                           # Sender role is the role of the user who recorded it
                           receiver_role_name_parent = parent.role.name.lower()

                           if is_notification_allowed(sender_role_name, receiver_role_name_parent):
                                notification_parent = Notification(
                                     sender_id=behavior_record.recorded_by_id, # The user who recorded it
                                     receiver_id=parent.id,
                                     content=parent_message_content,
                                     link_url=None, # Add link_url_parent if applicable
                                     timestamp=datetime.now(timezone.utc),
                                     is_read=False
                                )
                                db.session.add(notification_parent)
                                app.logger.info(f"Notified parent {parent.username} about new behavior record ID {behavior_record.id} for child {student.username}.")
                           else:
                                app.logger.warning(f"Notification not allowed for parent {parent.username} about behavior record {behavior_record.id} from sender role {sender_role_name}.")


            db.session.commit() # Commit all notifications (student and parents)

    except Exception as e:
         # Log the error but don't roll back the main transaction that added the behavior record
         app.logger.error(f"Error sending behavior record notifications for student {student.id}, record ID {behavior_record.id}: {e}", exc_info=True)
         db.session.rollback() # Rollback only the notification transaction


# Helper to save social media files (distinct from profile photos, defined in Part 12)
# Keeping definition here for reference, but the actual function body was provided in Part 12.
# def save_uploaded_file(file_storage):
#      pass # Body is in Part 12


# Helper to save profile photos (defined in Part 12)
# Keeping definition here for reference, but the actual function body was provided in Part 12.
# def save_profile_photo(file_storage):
#      pass # Body is in Part 12


# --- END PART 3 ---

# --- PART 4 START: WTForms Definitions ---
# ... (WTForms definitions from your code) ...
# --- END PART 4 ---

# --- PART 5 START: Authentication Routes ---
# ... (Authentication routes from your code) ...
# --- END PART 5 ---

# --- PART 6 START: Role Dashboards & Core Navigation ---
# ... (Role Dashboards & Core Navigation routes from your code) ...
# --- END PART 6 ---

# --- PART 7 START: Teacher/Librarian Specific Features ---
# ... (Teacher/Librarian Specific Features routes from your code) ...
# --- END PART 7 ---

# --- PART 8 START: HR/CEO & System Admin Management Features ---
# ... (HR/CEO & System Admin Management Features routes from your code) ...
# --- END PART 8 ---

# --- PART 9 START: Book Checkout & Management ---
# ... (Book Checkout & Management routes from your code) ...
# --- END PART 9 ---

# --- PART 10 START: Chat and Contacts ---
# ... (Chat and Contacts routes from your code) ...
# --- END PART 10 ---

# --- PART 11 START: Notifications ---
# ... (Notifications routes from your code) ...
# --- END PART 11 ---

# --- Group Routes ---
# ... (Group routes from your code) ...
# --- PART 12 END: Social Media Features ---

# --- PART 13 START: Settings ---
# ... (Settings routes from your code) ...
# --- PART 13 END: Settings ---

# --- PART 14 START: Analytics (Placeholder/Basic) ---
# ... (Analytics routes from your code) ...
# --- PART 14 END: Analytics (Placeholder/Basic) ---

# --- PART 15 START: CLI Commands, Error Handlers, and Main Execution ---
# ... (CLI Commands, Error Handlers, and Main Execution from your code) ...
# --- PART 15 END ---

# --- PART 4 START: WTForms Definitions ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models like User, AssetCategory, Lab are defined.
# - Helpers like get_social_categories are defined.
# - SQLAlchemy imports (select, func, etc.) and WTForms imports are available.

# START MODIFICATION (get_social_categories helper)
def get_social_categories():
    """Helper to query and format social categories for select fields."""
    # Requires an active application context and initialized db
    try:
        with app.app_context(): # Ensure context if called during app setup
             return db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all() # MODIFIED: Query SocialCategory
    except Exception as e:
        # Log or handle the error appropriately
        app.logger.error(f"Error fetching social categories: {e}")
        return [] # Return empty list on error
# END MODIFICATION (get_social_categories helper)

# Add this new helper function
def get_asset_categories():
    """Helper to query and format asset categories for select fields."""
    try:
        with app.app_context(): # Ensure context if called during app setup
             return db.session.scalars(select(AssetCategory).order_by(AssetCategory.name)).all()
    except Exception as e:
        app.logger.error(f"Error fetching asset categories: {e}")
        return []

# ... (rest of get_social_categories and @app.context_processor) ...

# --- Custom Jinja Filters ---
@app.template_filter("datetimeformat")
def datetimeformat(value, format="%Y-%m-%d %H:%M"):
    """Formats a datetime object to a string."""
    if isinstance(value, datetime):
        # Ensure timezone-aware conversion if needed, or assume UTC as per model defaults
        # For simplicity, direct format assuming UTC or naive UTC objects
        return value.strftime(format)
    if isinstance(value, str):  # Basic attempt to handle string dates
        try:
            # Handle common ISO format with Z or offset
            dt_obj = datetime.fromisoformat(value.replace("Z", "+00:00"))
            return dt_obj.strftime(format)
        except ValueError:
            pass  # Fall through if parsing fails
    return value if value is not None else "" # Return original value or empty string if None


@app.template_filter('dateformat')
def dateformat_filter(value, format='%Y-%m-%d'):
    """Formats a date or datetime object to a date string."""
    if isinstance(value, (datetime, Date)):
        return value.strftime(format)
    return value if value is not None else ""


# --- Role Management Decorator ---
def role_required(*required_roles):
    """Decorator to restrict access to routes based on user roles."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash("Please log in to access this page.", "warning")
                return redirect(url_for("login", next=request.url))

            user_role_name = (
                current_user.role.name.lower() if current_user.role else None
            )
            normalized_required_roles = [role.lower() for role in required_roles]

            if user_role_name not in normalized_required_roles:
                app.logger.warning(
                    f"User {current_user.username} (Role: {user_role_name}) "
                    f"attempted to access restricted route requiring roles: {required_roles}"
                )
                abort(403)  # Forbidden
            return f(*args, **kwargs)

        return decorated_function

    return decorator

def tc_member_required(f):
    """Decorator to restrict access to routes to users who are Talent Club members."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check if the user is marked as a Talent Club member
        if not current_user.is_tc_member:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC restricted route {request.path} but is not a TC member."
            )
            flash("You must be a Talent Club member to access this area.", "warning")
            # Redirect them back to their dashboard or a page prompting them to join TC
            # Redirect to a generic TC join page if it exists, or fallback
            return redirect(url_for('student_dashboard')) # Assuming students start here

        return f(*args, **kwargs)

    return decorated_function

# --- Define VALID_ROLES GLOBALLY (Needed for permission configs and helpers) ---
VALID_ROLES = [
    ('system_admin', 'System Administrator (Full Access)'),
    ('school_executive', 'School Executive Board Member'),
    ('government', 'Government Compliance Officer'),
    ('hr_ceo', 'HR & Academic CEO'),
    ('teacher', 'Teaching Staff'),
    ('librarian', 'Library Management'),
    ('talent_club', 'Talent Club Coordinator'),
    ('student', 'Enrolled Student'),
    ('parent', 'Student Parent/Guardian')
]
# Make VALID_ROLES available in the app config for easier access in helpers
app.config['VALID_ROLES'] = VALID_ROLES
# Extract just the role names for easier lookup
VALID_ROLE_NAMES = [role[0] for role in VALID_ROLES]


# --- Permission Configurations (Chat & Notification) ---

# --- Permission Configurations (Chat & Notification) ---

# Updated CHAT_PERMISSIONS configuration
CHAT_PERMISSIONS = {
    # Role: { 'send_to': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'receive_from': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'exceptions': {'leader': {'send_to': {...}, 'receive_from': {...}}} }
    'government': {
        'send_to': {'specific': ['hr_ceo', 'school_executive']}, # UPDATED
        'receive_from': {'specific': ['school_executive', 'government']}
    },
    'school_executive': {
        'send_to': {'all': True, 'exceptions': ['student', 'talent_club']}, # UPDATED (added 'student')
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
    'system_admin': { # No explicit rules provided for System Admin, keeping previous configuration
        'send_to': {'all': True, 'exceptions': ['government', 'talent_club']},
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
    'student': {
        'send_to': {'none': True}, # Default students cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'teacher', 'librarian', 'talent_club']}, # Receives from relevant staff roles and Talent Club leaders
        'exceptions': {
            'tc_member': { # Talent Club Member Exception (Students who opted-in)
                'send_to': {'specific': ['student', 'talent_club']}, # MODIFIED: Can send general chat to other students (who are TC members) and Talent Club role users (TC Leader, coordinators)
                'receive_from': {'specific': ['student', 'talent_club', 'hr_ceo', 'teacher', 'librarian', 'school_executive', 'system_admin']}, # MODIFIED: Can receive from TC network, HR/CEO, and other relevant staff roles. Explicitly listing allows more control than 'all' with exceptions.
            },
            'leader': { # Student Leaders Exception (keep existing if any)
                'send_to': {'specific': ['student', 'hr_ceo', 'system_admin']},
                'receive_from': {'all': True, 'exceptions': ['government', 'talent_club', 'school_executive', 'parent']}, # Keep as is or adjust
             }
        }
    },
    'teacher': {
        'send_to': {'all': True, 'exceptions': ['government', 'talent_club']}, # UPDATED (removed 'student')
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
    'hr_ceo': {
        'send_to': {'all': True, 'exceptions': ['government', 'student', 'talent_club']}, # UPDATED (added 'student')
        'receive_from': {'all': True, 'exceptions': ['government', 'student', 'talent_club']} # UPDATED (added 'student')
    },
    'parent': {
        'send_to': {'specific': ['teacher', 'hr_ceo', 'parent']},
        'receive_from': {'specific': ['teacher', 'hr_ceo', 'parent', 'school_executive', 'system_admin']},
    },
    'librarian': {
        'send_to': {'all': True, 'exceptions': ['government', 'talent_club', 'student', 'parent']}, # UPDATED (added 'parent')
        'receive_from': {'all': True, 'exceptions': ['government', 'talent_club']}
    },
        'talent_club': { # Talent Club Role (e.g. System-wide Coordinators, or the Leader's role)
        'send_to': {'none': True}, # MODIFIED: Default Talent Club role users (non-leader) CANNOT send chat
        'receive_from': {'specific': ['student', 'talent_club', 'hr_ceo', 'teacher', 'librarian', 'school_executive', 'system_admin']}, # MODIFIED: Can receive from TC network and relevant staff/admin
        'exceptions': {
            'tc_leader': { # Talent Club Leaders Exception (users with talent_club role AND is_tc_leader=True)
                # NOTE: 'send_to' here is LESS important now because the helper overrides it globally
                # if user.is_tc_leader is True. Keeping it here for documentation/clarity.
                'send_to': {'specific': ['student', 'talent_club', 'hr_ceo']},
                'receive_from': {'specific': ['student', 'talent_club', 'hr_ceo', 'teacher', 'librarian', 'school_executive', 'system_admin']} # MODIFIED: Same broad receiving as default Talent Club role user
            }
        }
    }
}
NOTIFICATION_PERMISSIONS = {
    # Role: { 'send_to': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]},
    #         'receive_from': {'all': True / 'none': True / 'specific': ['role1', ...], 'exceptions': ['role_excl1', ...]} }

    'government': {
        'send_to': {'all': True}, # Full permission to send
        'receive_from': {'none': True} # Government receives no notifications
    },
    'school_executive': {
        'send_to': {'all': True, 'exceptions': ['government']}, # Can send to all except government
        'receive_from': {'all': True, 'exceptions': ['student', 'parent', 'talent_club']} # Receives from all who can send (except non-senders)
    },
    'system_admin': {
        'send_to': {'all': True}, # Can send to all
        'receive_from': {'all': True, 'exceptions': ['student', 'parent', 'talent_club']} # Receives from all who can send (except non-senders)
    },
    'hr_ceo': {
        'send_to': {'all': True, 'exceptions': ['school_executive', 'government']}, # Can send to all except school_executive and government
        'receive_from': {'all': True, 'exceptions': ['student', 'parent', 'talent_club']} # Receives from all who can send (except non-senders)
    },
    'teacher': {
        'send_to': {'specific': ['student', 'parent']}, # Teachers notify students and parents
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive']} # Receives from these staff roles
    },
    'librarian': {
        'send_to': {'specific': ['student']}, # Librarian notifies students
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive']} # Receives from these staff roles
    },
    'talent_club': {
        'send_to': {'none': True}, # Regular Talent Club members cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'talent_club']}, # Receives from relevant staff and other Talent Club members (leaders)
        'exceptions': {
            'tc_leader': { # Talent Club Leaders Exception (uses is_tc_leader)
                'send_to': {'specific': ['talent_club']} # Leader can send to other Talent Club members
            }
        }
    },
    'student': {
        'send_to': {'none': True}, # Students cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'teacher', 'librarian', 'talent_club']} # Receives from relevant staff roles and Talent Club leaders
    },
    'parent': {
        'send_to': {'none': True}, # Parents cannot send notifications
        'receive_from': {'specific': ['system_admin', 'government', 'hr_ceo', 'school_executive', 'teacher']} # Receives from relevant staff roles
    }
}

# --- NEW CONFIGURATIONS: Talent Club Subsystem ---

# Configuration for allowed roles/members to post in a specific Talent Club's feed channel
# Key is the TalentClubMembership role name (lowercase)
TALENT_CLUB_POSTING_PERMISSIONS = {
    'creator': True,
    'admin': True,
    'member': False, # Default members cannot post
}

# --- NEW CONFIGURATIONS: Task System ---

TASK_CREATOR_ROLES = ['hr_ceo', 'system_admin', 'school_executive'] # Define which roles can create tasks
# You can add other roles here if needed, e.g., 'teacher' for class tasks.

# Define valid statuses for UserTask for clarity
USER_TASK_STATUSES = [
    'Open',
    'In Progress',
    'Completed (Pending Review)',
    'Delayed (Pending Review)',
    'Rejected (Pending Review)',
    'Accepted', # Creator accepted completion/status update
    'Review Rejected' # Creator rejected status update, task is sent back
]

TASK_HISTORY_ACTIONS = [
    'Assigned',
    'Status Update', # User updated status to In Progress, Completed, Delayed, Rejected
    'Review Accepted', # Creator accepted user's status update
    'Review Rejected' # Creator rejected user's status update
]

# --- NEW HELPER FUNCTIONS: Task System ---

def get_allowed_task_creators():
    """Fetches User objects for roles allowed to create tasks."""
    with app.app_context(): # Ensure context
        return db.session.scalars(
            select(User).join(Role).where(Role.name.in_(TASK_CREATOR_ROLES), User.is_active == True).order_by(User.full_name)
        ).all()

def get_assignable_users():
    """Fetches User objects eligible for individual task assignment (e.g., all active users except creators?)."""
    # For simplicity, let's allow assigning to all active users except system admins
    with app.app_context(): # Ensure context
         system_admin_role = db.session.scalar(select(Role).filter_by(name='system_admin'))
         query = select(User).where(User.is_active == True)
         if system_admin_role:
              query = query.where(User.role != system_admin_role)
         return db.session.scalars(query.order_by(User.full_name)).all()
    # You might want more granular control here based on roles that can receive tasks

def get_assignable_roles():
    """Returns a list of valid role names that can be targets for group assignment."""
    # For V1, let's make all standard roles assignable as groups, maybe exclude admins?
    # Or, keep it simple and allow assigning to any defined role in VALID_ROLE_NAMES
    return [role_name for role_name, _ in VALID_ROLES] # Use the global VALID_ROLES defined earlier


def get_assignable_grade_sections():
    """Fetches distinct grade-section pairs for student group assignment."""
    with app.app_context(): # Ensure context
        # Query active students for their grade/section pairs
        stmt = (
            select(User.grade, User.section)
            .join(Role).filter(Role.name == 'student')
            .where(User.is_active == True, User.grade.isnot(None), User.section.isnot(None))
            .distinct()
            .order_by(User.grade, User.section)
        )
        return db.session.execute(stmt).all() # Returns list of (grade, section) tuples


def log_user_task_history(user_task, changed_by_user, old_status, new_status, action, notes=None):
    """
    Logs an action to the TaskHistory for a given UserTask.
    This function should be called within a database session.
    """
    history_entry = TaskHistory(
        user_task=user_task, # Link to the UserTask object
        changed_by=changed_by_user, # Link to the User who made the change
        old_status=old_status,
        new_status=new_status,
        action=action,
        notes=notes,
        timestamp=datetime.now(timezone.utc)
    )
    db.session.add(history_entry)
    # Note: Commit should be handled by the calling route, not here.


def notify_task_assigned(user_task):
    """Sends a notification to a user that a task has been assigned to them."""
    with app.app_context(): # Ensure context
        try:
            receiver = user_task.user # The assigned user
            sender = user_task.assigned_by # The user who assigned this instance (usually creator)
            if not receiver or not receiver.is_active:
                 app.logger.warning(f"Cannot notify inactive user {receiver.id if receiver else 'N/A'} about assigned task {user_task.task_id}.")
                 return
            if not sender:
                 sender = db.session.scalar(select(User).filter_by(username='system')) # Fallback to system user
                 if not sender:
                      app.logger.error("System user not found for task assignment notification sender.")
                      return

            notification_content = f"You have been assigned a new task: '{user_task.task.title}'."
            link_url = url_for('view_user_task', user_task_id=user_task.id) # Link to the user's task detail page

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(sender, receiver):
                 notification = Notification(
                     sender_id=sender.id,
                     receiver_id=receiver.id,
                     content=notification_content,
                     link_url=link_url,
                     timestamp=datetime.now(timezone.utc),
                     is_read=False,
                     notification_type='task_assigned', # Specific type
                     related_object_id=user_task.id # Link to the UserTask instance
                 )
                 db.session.add(notification)
                 db.session.commit() # Commit notification immediately
                 app.logger.info(f"Notification sent to user {receiver.id} about assigned task {user_task.id}.")
            else:
                 app.logger.warning(f"Notification not allowed for task assignment: Sender '{sender.role.name if sender.role else 'N/A'}' to Receiver '{receiver.role.name if receiver.role else 'N/A'}'.")

        except Exception as e:
            db.session.rollback() # Rollback only the notification transaction
            app.logger.error(f"Error sending task assigned notification for UserTask {user_task.id}: {e}", exc_info=True)


def notify_user_task_status_update(user_task):
    """Sends a notification to the task creator when an assigned user updates status."""
    with app.app_context(): # Ensure context
        try:
            creator = user_task.task.created_by # The task creator (receiver)
            assigned_user = user_task.user # The user who updated status (sender)
            if not creator or not creator.is_active:
                 app.logger.warning(f"Cannot notify inactive creator {creator.id if creator else 'N/A'} about status update for UserTask {user_task.id}.")
                 return
            # Assigned user must be active to be the sender
            if not assigned_user or not assigned_user.is_active:
                app.logger.warning(f"Assigned user {assigned_user.id if assigned_user else 'N/A'} for UserTask {user_task.id} is inactive. Cannot use as notification sender.")
                assigned_user = db.session.scalar(select(User).filter_by(username='system')) # Fallback sender


            notification_content = f"Status update for task '{user_task.task.title}' by {assigned_user.full_name or assigned_user.username}: '{user_task.status}'."
            link_url = url_for('review_user_task', user_task_id=user_task.id) # Link to the review page for this UserTask instance

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(assigned_user, creator):
                 notification = Notification(
                     sender_id=assigned_user.id,
                     receiver_id=creator.id,
                     content=notification_content,
                     link_url=link_url,
                     timestamp=datetime.now(timezone.utc),
                     is_read=False,
                     notification_type='task_status_update', # Specific type
                     related_object_id=user_task.id # Link to the UserTask instance
                 )
                 db.session.add(notification)
                 db.session.commit() # Commit notification immediately
                 app.logger.info(f"Notification sent to creator {creator.id} about status update for UserTask {user_task.id}.")
            else:
                app.logger.warning(f"Notification not allowed for task status update: Sender '{assigned_user.role.name if assigned_user.role else 'N/A'}' to Receiver '{creator.role.name if creator.role else 'N/A'}'.")


        except Exception as e:
            db.session.rollback() # Rollback only the notification transaction
            app.logger.error(f"Error sending task status update notification for UserTask {user_task.id}: {e}", exc_info=True)


def notify_user_task_review_result(user_task):
    """Sends a notification to the assigned user about the creator's review outcome."""
    with app.app_context(): # Ensure context
        try:
            assigned_user = user_task.user # The assigned user (receiver)
            creator = user_task.task.created_by # The task creator (sender/reviewer)
            if not assigned_user or not assigned_user.is_active:
                 app.logger.warning(f"Cannot notify inactive user {assigned_user.id if assigned_user else 'N/A'} about review result for UserTask {user_task.id}.")
                 return
            # Creator must be active to be the sender
            if not creator or not creator.is_active:
                 app.logger.warning(f"Creator {creator.id if creator else 'N/A'} for UserTask {user_task.id} is inactive. Cannot use as notification sender.")
                 creator = db.session.scalar(select(User).filter_by(username='system')) # Fallback sender


            review_outcome_text = user_task.status # e.g., 'Accepted', 'Review Rejected'
            notification_content = f"Review for your task assignment '{user_task.task.title}': Status is now '{review_outcome_text}'."
            if user_task.reviewer_notes:
                 notification_content += f" Notes: {user_task.reviewer_notes[:100]}..."

            link_url = url_for('view_user_task', user_task_id=user_task.id) # Link back to the user's task detail page

            # Check notification permissions (sender role vs receiver role)
            if is_notification_allowed(creator, assigned_user):
                 notification = Notification(
                     sender_id=creator.id,
                     receiver_id=assigned_user.id,
                     content=notification_content,
                     link_url=link_url,
                     timestamp=datetime.now(timezone.utc),
                     is_read=False,
                     notification_type='task_review_result', # Specific type
                     related_object_id=user_task.id # Link to the UserTask instance
                 )
                 db.session.add(notification)
                 db.session.commit() # Commit notification immediately
                 app.logger.info(f"Notification sent to user {assigned_user.id} about review result for UserTask {user_task.id}.")
            else:
                app.logger.warning(f"Notification not allowed for task review result: Sender '{creator.role.name if creator.role else 'N/A'}' to Receiver '{assigned_user.role.name if assigned_user.role else 'N/A'}'.")


        except Exception as e:
            db.session.rollback() # Rollback only the notification transaction
            app.logger.error(f"Error sending task review result notification for UserTask {user_task.id}: {e}", exc_info=True)


# Assignment helpers that create UserTask instances and trigger initial notifications/history
def assign_task_to_users(task, user_ids, assigned_by_user, assignment_type='individual', assignment_detail=None):
    """Assigns a Task to a list of specific user IDs."""
    assigned_count = 0
    # Fetch actual user objects to ensure they exist and are active
    users_to_assign = db.session.scalars(
        select(User).where(User.id.in_(user_ids), User.is_active == True)
    ).all()

    if not users_to_assign:
        app.logger.warning(f"No active users found for assignment to task {task.id} with IDs {user_ids}.")
        return 0 # No users assigned

    try:
        for user in users_to_assign:
            # Check if a UserTask already exists for this specific task and user
            existing_assignment = db.session.scalar(select(UserTask).filter_by(task=task, user=user).limit(1))
            if existing_assignment:
                app.logger.warning(f"User {user.username} already has an assignment for task {task.id}. Skipping duplicate assignment.")
                continue # Skip if already assigned

            new_assignment = UserTask(
                task=task,
                user=user,
                assigned_by=assigned_by_user,
                assignment_type=assignment_type,
                assignment_detail=assignment_detail,
                status='Open', # Initial status
                assigned_at=datetime.now(timezone.utc),
                last_status_update_at=datetime.now(timezone.utc)
            )
            db.session.add(new_assignment)
            db.session.flush() # Flush to get UserTask ID for history

            # Log initial assignment history
            log_user_task_history(new_assignment, assigned_by_user, None, 'Open', 'Assigned', task.description[:100] + '...' if task.description else None)

            assigned_count += 1
            # Notify user after assignment (each notification commit is separate)
            notify_task_assigned(new_assignment)

        db.session.commit() # Commit all new UserTask entries and history entries added in this function call

        app.logger.info(f"Task {task.id} assigned to {assigned_count} users by {assigned_by_user.username}.")
        return assigned_count # Return count of successfully assigned users

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error assigning task {task.id} to users by {assigned_by_user.username}: {e}", exc_info=True)
        return 0 # Return 0 on error


def assign_task_to_role(task, role_name, assigned_by_user):
    """Assigns a Task to all active users in a specific role."""
    role = db.session.scalar(select(Role).filter_by(name=role_name))
    if not role:
        app.logger.warning(f"Role '{role_name}' not found for task assignment.")
        return 0 # No users assigned

    # Find all active users in this role
    users_in_role = db.session.scalars(
        select(User).where(User.role == role, User.is_active == True)
    ).all()

    if not users_in_role:
        app.logger.info(f"No active users found in role '{role_name}' for task assignment {task.id}.")
        return 0 # No users to assign

    user_ids = [user.id for user in users_in_role]
    return assign_task_to_users(task, user_ids, assigned_by_user, assignment_type='group_role', assignment_detail=role_name)


def assign_task_to_grade_section(task, grade, section, assigned_by_user):
    """Assigns a Task to all active students in a specific grade and section."""
    # Find all active students in this grade and section
    student_role = db.session.scalar(select(Role).filter_by(name='student'))
    if not student_role:
        app.logger.error("Student role not found for grade/section assignment.")
        return 0

    users_in_class = db.session.scalars(
        select(User).where(
            User.role == student_role,
            User.grade == grade,
            User.section == section,
            User.is_active == True
        )
    ).all()

    if not users_in_class:
        app.logger.info(f"No active students found in grade {grade}, section {section} for task assignment {task.id}.")
        return 0 # No users to assign

    user_ids = [user.id for user in users_in_class]
    return assign_task_to_users(task, user_ids, assigned_by_user, assignment_type='group_section', assignment_detail=f"{grade}-{section}")

# --- END NEW HELPER FUNCTIONS ---

# Configuration for Talent Club levels
TALENT_CLUB_LEVELS = [
    1, 2, 3, 4, 5, # Example levels
    # Define level names if using strings instead of integers:
    # ('Level 1', 1), ('Level 2', 2), ...
]

# Configuration for ban/mute types if using the models
TALENT_CLUB_BAN_TYPES = ['ban', 'mute'] # Corresponds to TalentClubBan.type

# Configuration for penalty types if using the models
TALENT_CLUB_PENALTY_TYPES = ['warning_points', 'temporary_restriction'] # Corresponds to TalentClubPenalty.type

# Constant for the name of the main Talent Club Community group
TC_COMMUNITY_GROUP_NAME = "Talent Club Community"


# --- NEW: Request System Permissions Configuration ---
REQUEST_SYSTEM_PERMISSIONS = {
    'can_initiate': ['librarian', 'student_leader', 'teacher', 'talent_club_leader'], # Roles that can start a request
    'tier_handlers': { # Maps tier to the role responsible for handling that tier
        1: 'hr_ceo',
        2: 'school_executive',
        3: 'government',
    },
    'forward_paths': { # Maps current handler role to next handler role for forwarding
        'hr_ceo': 'school_executive',
        'school_executive': 'government',
    },
    'final_tiers': ['government'], # Roles that cannot forward further
    'resolver_roles': ['hr_ceo', 'school_executive'], # Roles that can mark a request as 'Resolved' at their tier
}

# --- END NEW: Request System Permissions Configuration ---

# --- NEW: Request System Helper Functions ---

def log_request_history(request_obj, changed_by_user, old_status, new_status, action, notes=None):
    """
    Logs an action to the RequestHistory for a given request.
    This function should be called within a database session.
    """
    history_entry = RequestHistory(
        request_id=request_obj.id,
        changed_by_id=changed_by_user.id,
        old_status=old_status,
        new_status=new_status,
        action=action,
        notes=notes,
        timestamp=datetime.now(timezone.utc)
    )
    db.session.add(history_entry)
    # Note: Commit should be handled by the calling route, not here,
    # so that the history entry is committed along with the request changes.


def notify_request_event(request_obj, event_type, old_status=None, changed_by_user=None):
    """
    Sends notifications related to a request event (submission, status change, forward).
    Leverages the existing Notification model and `send_notification_to_user` logic.
    Assumes `send_notification_to_user` (or `Notification` creation) handles permissions
    between sender/receiver roles based on NOTIFICATION_PERMISSIONS.
    """
    with app.app_context(): # Ensure app context for DB operations and url_for
        try:
            sender = changed_by_user if changed_by_user else db.session.scalar(select(User).filter_by(username='system')) # Use a 'system' user if no specific changed_by
            if not sender:
                app.logger.error("System user not found for request notification sender.")
                return

            notification_content = ""
            receiver_user_id = None
            link_url = url_for('view_request_detail', request_id=request_obj.id) # Link to the request detail page

            if event_type == 'Submitted':
                notification_content = f"A new request '{request_obj.title}' (ID: {request_obj.id}) has been submitted by {request_obj.requester.full_name or request_obj.requester.username} and is awaiting your review."
                receiver_user_id = request_obj.current_handler_id # Notify the assigned handler
            elif event_type == 'Status_Updated':
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been updated. New status: '{request_obj.status}'."
                receiver_user_id = request_obj.requester_id # Notify the original requester
            elif event_type == 'Forwarded':
                notification_content = f"A request '{request_obj.title}' (ID: {request_obj.id}) has been forwarded to you for review by {sender.full_name or sender.username}."
                receiver_user_id = request_obj.current_handler_id # Notify the new handler
            elif event_type == 'Resolved':
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been successfully resolved."
                receiver_user_id = request_obj.requester_id # Notify requester of resolution
            elif event_type == 'Denied':
                notification_content = f"Your request '{request_obj.title}' (ID: {request_obj.id}) has been denied. Reason: {request_obj.denial_reason[:100]}..." if request_obj.denial_reason else "Your request has been denied."
                receiver_user_id = request_obj.requester_id # Notify requester of denial

            if receiver_user_id:
                receiver = db.session.get(User, receiver_user_id)
                if receiver and receiver.is_active and receiver.role:
                    # Check permission using the can_send / can_receive helpers
                    # These helpers are already defined in Part 3 and use NOTIFICATION_PERMISSIONS
                    # The `send_notification_to_user` route implicitly handles permission checks when creating the notification.
                    # Here, we are constructing the notification object directly.
                    # So, we should check `can_send` and `can_receive` here or trust the overall permission config.
                    # For simplicity, we'll assume the notification config dictates who should *get* these, and the sender is typically a system/admin or authorized handler.

                    # It's better to explicitly check if the sender can send to the receiver's role
                    # This check is crucial for ensuring valid notifications are created.
                    if can_send(sender, receiver.role.name) and can_receive(receiver, sender.role.name):
                        notification = Notification(
                            sender_id=sender.id,
                            receiver_id=receiver.id,
                            content=notification_content,
                            link_url=link_url,
                            timestamp=datetime.now(timezone.utc),
                            is_read=False
                        )
                        db.session.add(notification)
                        db.session.commit()
                        app.logger.info(f"Notification '{event_type}' sent for request ID {request_obj.id} to user {receiver.id}.")
                    else:
                        app.logger.warning(f"Notification not allowed for request ID {request_obj.id}: Sender '{sender.role.name}' to Receiver '{receiver.role.name}'.")
                else:
                    app.logger.warning(f"Receiver user (ID: {receiver_user_id}) for request ID {request_obj.id} notification not found or inactive.")
            else:
                app.logger.warning(f"No valid receiver_user_id for request ID {request_obj.id} event '{event_type}'.")

        except Exception as e:
            db.session.rollback() # Rollback notification creation if it fails
            app.logger.error(f"Error in notify_request_event for request ID {request_obj.id}, event '{event_type}': {e}", exc_info=True)


def get_request_permissions(user_obj, request_obj=None):
    """
    Determines detailed permissions for a user regarding the request system or a specific request.
    Returns a dictionary of boolean flags.
    """
    permissions = {
        'can_create_request': False,
        'can_review': False,        # Can review requests in their inbox
        'can_forward': False,       # Can forward to next tier
        'can_resolve': False,       # Can mark as 'Resolved'
        'can_deny': False,          # Can mark as 'Denied'
        'can_see_history': False,   # Can view full history of a request
        'is_handler_for_request': False, # True if request_obj.current_handler_id == user_obj.id
        'is_requester_of_request': False, # True if request_obj.requester_id == user_obj.id
    }

    if not user_obj or not user_obj.is_authenticated or not user_obj.role:
        return permissions # No permissions for unauthenticated or rol-less users

    user_role_name = user_obj.role.name.lower()

    # Determine can_create_request (initial submission)
    # Check for student leader and talent club leader roles
    if user_role_name == 'student' and user_obj.is_leader:
        permissions['can_create_request'] = True
    elif user_role_name == 'talent_club' and user_obj.is_tc_leader:
        permissions['can_create_request'] = True
    elif user_role_name in REQUEST_SYSTEM_PERMISSIONS['can_initiate']:
        # This will cover 'librarian', 'teacher'
        permissions['can_create_request'] = True

    # Global admin override for review/management (System Admin has full control)
    is_global_admin = user_role_name in ['system_admin', 'hr_ceo'] # HR/CEO can also manage (Tier 1 handler)

    # Permissions related to a specific request
    if request_obj:
        permissions['is_requester_of_request'] = (request_obj.requester_id == user_obj.id)
        permissions['is_handler_for_request'] = (request_obj.current_handler_id == user_obj.id)

        # Anyone related to the request can see its history
        if permissions['is_requester_of_request'] or permissions['is_handler_for_request'] or is_global_admin:
            permissions['can_see_history'] = True

        # Reviewer permissions
        if permissions['is_handler_for_request'] or is_global_admin:
            # A user can review if they are the current handler or a global admin.
            # However, if it's already Denied/Resolved at the current tier, they can't 'review' further directly.
            if request_obj.status not in ['Denied', 'Resolved']:
                permissions['can_review'] = True
                permissions['can_deny'] = True # Handlers can always deny at their tier

                # Specific actions based on tier
                if request_obj.tier == 1 and user_role_name == 'hr_ceo':
                    permissions['can_forward'] = True # Can forward to School Exec
                    permissions['can_resolve'] = True # Can resolve (final for HR/CEO)
                elif request_obj.tier == 2 and user_role_name == 'school_executive':
                    permissions['can_forward'] = True # Can forward to Government
                    permissions['can_resolve'] = True # Can resolve (final for School Exec)
                elif request_obj.tier == 3 and user_role_name == 'government':
                    # Government can only approve/deny (no 'On Progress' or 'Resolve' in the same sense, 'Approved' is final)
                    # And they cannot forward
                    permissions['can_resolve'] = True # Denotes 'Approved' as final action
                    permissions['can_forward'] = False # Explicitly cannot forward

        # HR/CEO and School Exec can initiate requests directly to the next tier
        if user_role_name == 'hr_ceo' and not request_obj.id: # Not editing an existing request, initiating new
            permissions['can_create_request'] = True
        elif user_role_name == 'school_executive' and not request_obj.id: # Not editing an existing request, initiating new
            permissions['can_create_request'] = True

    return permissions

# Helper to get users of a specific role (re-using existing pattern)
# This was implicitly assumed to be available. If not, add this:
def get_users_in_role(role_name):
    """Fetches all active users belonging to a specific role."""
    with app.app_context():
        role = db.session.scalar(select(Role).filter_by(name=role_name))
        if role:
            return db.session.scalars(select(User).where(User.role == role, User.is_active == True).order_by(User.full_name)).all()
    return []

# --- END NEW: Request System Helper Functions ---

# --- NEW FORMS: Talent Club Subsystem ---

class CreateTalentClubProposalForm(FlaskForm):
    """Form for submitting a proposal to create a new Talent Club instance."""
    name = StringField("Club Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[DataRequired(), Length(min=10, max=500)])
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # Reuse SocialCategory
    proposal_file = FileField("Proposal Document (Optional)", validators=[Optional(), FileAllowed(['pdf', 'doc', 'docx', 'txt', 'odt'], 'Documents only!')])

    # mentioned_members field is handled dynamically via JavaScript for searching/selecting users.
    # We will receive the list of IDs in request.form or request.json on POST.
    # Add a hidden field or similar if needed for form submission structure, but validation is manual.
    # Example: mentioned_member_ids = HiddenField("mentioned_member_ids", validators=[DataRequired()]) # Requires JS to populate value


    submit = SubmitField("Submit Proposal")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices dynamically
        # Assuming get_social_categories() helper exists and queries SocialCategory
        self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
        if not self.social_category_id.choices:
             self.social_category_id.choices = [('', 'No categories available')]

    # Custom validation for minimum mentioned members will happen in the route handler

class EditTalentClubProfileForm(FlaskForm):
    """Form for editing an existing Talent Club instance profile."""
    name = StringField("Club Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!')]) # Reuse photo helper logic
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()])

    # Options from TalentClubFeed linked settings (will be edited via the linked channel's settings if implemented)
    # For simplicity, we won't include linked channel settings here unless explicitly needed.
    # allow_comments = BooleanField("Allow Comments on Posts") # These fields belong on the linked Channel/Feed

    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
        if not self.social_category_id.choices:
            self.social_category_id.choices = [('', 'No categories available')]

    # Add custom validation for name uniqueness if needed (excluding self)

class TalentClubLeaderVoteForm(FlaskForm):
    """Form for TC Members to vote for the System-wide TC Leader."""
    candidate_id = SelectField("Select Your Candidate", coerce=int, validators=[DataRequired()])
    submit = SubmitField("Cast Vote")

    def __init__(self, *args, candidates=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate candidate choices with eligible users (is_tc_member=True)
        if candidates is not None:
             self.candidate_id.choices = [(u.id, f"{u.full_name} ({u.username})") for u in candidates]
        else:
             self.candidate_id.choices = [(0, 'No candidates available')]

class TalentClubWarningForm(FlaskForm):
    """Form for the TC Leader to issue a warning to a Talent Club."""
    reason = TextAreaField("Reason for Warning", validators=[DataRequired(), Length(min=10, max=500)])
    submit = SubmitField("Issue Warning")

class TalentClubLevelForm(FlaskForm):
    """Form for the TC Leader to change a Talent Club's level."""
    # Levels could be integer input or select from predefined levels
    level = IntegerField("New Level", validators=[DataRequired(), NumberRange(min=1)]) # Assuming minimum level 1
    # Alternatively, if levels are tiered strings:
    # level = SelectField("New Level", choices=[('Level 1', 'Level 1'), ('Level 2', 'Level 2'), ...], validators=[DataRequired()])
    submit = SubmitField("Set Level")

# Optional forms for Ban/Penalty (basic versions)
class TalentClubBanMuteForm(FlaskForm):
    """Form for the TC Leader to ban or mute a TC Member."""
    ban_type = SelectField("Action Type", choices=[('ban', 'Ban (Remove from TC)'), ('mute', 'Mute (Restrict Posting)')], validators=[DataRequired()])
    reason = TextAreaField("Reason", validators=[DataRequired(), Length(min=10, max=500)])
    duration_days = IntegerField("Duration (days, leave empty for permanent)", validators=[Optional(), NumberRange(min=1)])
    submit = SubmitField("Apply Action")

# Placeholder for a Penalty form if different from Ban/Mute
# class TalentClubPenaltyForm(FlaskForm):
#      pass

# --- Authentication Forms ---

class PreForm(FlaskForm):
    """Form for initial registration code verification."""
    code = StringField(
        "Registration Code",
        validators=[DataRequired()]
    )
    submit = SubmitField("Verify Code")

class CompleteRegistrationForm(FlaskForm):
    """Form for completing user registration after code verification."""
    # Use the full_name field added to the User model in Part 2
    full_name = StringField("Full Name", validators=[DataRequired(), Length(max=120)])
    username = StringField(
        "Username",
        validators=[
            DataRequired(),
            Length(min=4, max=80),
            Regexp(
                "^[A-Za-z0-9_]+$",
                message="Username can only contain letters, numbers, and underscores.",
            ),
        ],
    )
    # Email is now nullable on User model, but required by this form
    email = StringField("Email", validators=[DataRequired(), Email(), Length(max=120)])

    password = PasswordField(
        "Password",
        validators=[
            DataRequired(),
            Length(min=8, message="Password must be at least 8 characters long."),
            # Optional: Add complexity validators here
            # Example: Regexp('^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\W_]).+$', message="Password must include uppercase, lowercase, number, and special character.")
        ],
    )
    password2 = PasswordField(
        "Confirm Password",
        validators=[
            DataRequired(),
            EqualTo("password", message="Passwords must match."),
        ],
    )

    # --- Fields Corresponding to User Model Additions ---
    # These match nullable columns added to User in Part 2
    age = IntegerField("Age", validators=[Optional(), NumberRange(min=5, max=100, message="Please enter a valid age.")])
    sex = SelectField("Sex", choices=[('', 'Select...'), ('Male', 'Male'), ('Female', 'Female'), ('Other', 'Other'), ('Prefer Not to Say', 'Prefer Not to Say')], validators=[Optional()])
    profile_photo_url = StringField("Profile Photo URL (Optional)", validators=[Optional(), Length(max=255)])
    # If you added grade/section to User model for students in Part 2, add fields here if needed
    # grade = StringField("Grade", validators=[Optional(), Length(max=10)])
    # section = StringField("Section", validators=[Optional(), Length(max=10)])


    submit = SubmitField("Complete Registration")


    # Custom validation for username and email uniqueness
    def validate_username(self, username_field):
        # Check if the chosen username already exists in the database (case-insensitive)
        user = db.session.scalar(
            select(User).filter(
                func.lower(User.username) == func.lower(username_field.data.strip())
            )
        )
        if user:
            raise ValidationError(
                "This username is already taken. Please choose a different one."
            )

    def validate_email(self, email_field):
        # Check if email exists (case-insensitive), assuming email is required by this form
        if email_field.data: # Only validate if email is provided
             user = db.session.scalar(
                 select(User).filter(
                     func.lower(User.email) == func.lower(email_field.data.strip())
                 )
             )
             if user:
                 raise ValidationError(
                     "This email address is already used. Please use a different one."
                 )


class LoginForm(FlaskForm):
    """Form for user login."""
    username = StringField(
        "Username", validators=[DataRequired(), Length(min=3, max=80)]
    )
    password = PasswordField("Password", validators=[DataRequired()])
    submit = SubmitField("Login")

class ChangePasswordForm(FlaskForm):
    """Form for a logged-in user to change their password (requires current password)."""
    current_password = PasswordField("Current Password", validators=[DataRequired()])
    new_password = PasswordField(
        "New Password",
        validators=[
            DataRequired(),
            Length(min=8, message="New password must be at least 8 characters long."),
            # Optional: Add custom complexity validators here
        ],
    )
    confirm_new_password = PasswordField(
        "Confirm New Password",
        validators=[
            DataRequired(),
            EqualTo("new_password", message="Passwords must match."),
        ],
    )
    submit = SubmitField("Change Password")

class ForcedChangePasswordForm(FlaskForm):
     """Form for a user forced to change their password (does not require current password)."""
     new_password = PasswordField(
        "New Password",
        validators=[
            DataRequired(),
            Length(min=8, message="New password must be at least 8 characters long."),
            # Optional: Add complexity validators here
        ],
    )
     confirm_new_password = PasswordField(
        "Confirm New Password",
        validators=[
            DataRequired(),
            EqualTo("new_password", message="Passwords must match."),
        ],
    )
     submit = SubmitField("Set New Password")


# --- Settings Form ---
class UniversalSettingsForm(FlaskForm):
    """Form for editing universal user profile and settings."""

    # Profile Fields (from User model)
    full_name = StringField("Full Name", validators=[DataRequired(), Length(max=120)])
    username = StringField(
        "Username",
        validators=[
            DataRequired(),
            Length(min=4, max=80),
            Regexp("^[A-Za-z0-9_]+$", message="Username can only contain letters, numbers, and underscores."),
        ],
    )
    email = StringField("Email", validators=[Optional(), Email(), Length(max=120)])

    # Additional Profile Fields (from User model - matching nullable columns)
    age = IntegerField("Age", validators=[Optional(), NumberRange(min=5, max=100, message="Please enter a valid age.")])
    sex = SelectField("Sex", choices=[('', 'Select...'), ('Male', 'Male'), ('Female', 'Female')], validators=[Optional()])

    # Talent Club Status (Display only - handled by join/leave button elsewhere)
    is_tc_member_display = BooleanField("Talent Club Member", render_kw={'disabled': 'disabled'})  # Display status, not editable here

    profile_visibility = SelectField(
        "Profile Visibility",
        choices=[("everyone", "Everyone"), ("teachers", "Teachers Only"), ("students", "Students Only"), ("private", "Only Me")],
        validators=[Optional()],  # If profile_visibility is nullable
    )
    data_analytics = BooleanField("Allow anonymous usage data collection")
    data_research = BooleanField("Allow academic research participation")
    profile_photo = FileField(
        "Update Profile Photo",
        validators=[
            Optional(),
            FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!'),
        ],
    )

    submit = SubmitField("Save Changes")

    def __init__(self, original_username=None, original_email=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.original_username = original_username
        self.original_email = original_email

    def validate_username(self, username_field):
        if username_field.data.lower() != (self.original_username or "").lower():  # Handle case where original_username is None
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.username) == func.lower(username_field.data.strip()),
                    User.id != current_user.id,
                )
            )
            if user:
                raise ValidationError("This username is already taken.")

    def validate_email(self, email_field):
        original_email_lower = (self.original_email or "").lower()
        submitted_email_lower = (email_field.data or "").lower()

        if submitted_email_lower and submitted_email_lower != original_email_lower:  # Check for change and not empty
            user = db.session.scalar(
                select(User).filter(
                    func.lower(User.email) == submitted_email_lower,
                    User.id != current_user.id,
                )
            )
            if user:
                raise ValidationError("This email address is already used by another account.")
# --- NEW FORMS: Request System ---

class CreateRequestForm(FlaskForm):
    """Form for submitting a new request."""
    title = StringField("Request Title", validators=[DataRequired(), Length(max=255)])
    description = TextAreaField("Detailed Description", validators=[DataRequired(), Length(min=10, max=2000)])
    request_type = SelectField("Request Type", choices=[
        ('Deficiency', 'Deficiency'),
        ('Purchase', 'Purchase'),
        ('General', 'General'),
        # Add more types if needed, e.g., 'Maintenance', 'Staffing', 'Curriculum'
    ], validators=[DataRequired()])
    urgency = SelectField("Urgency", choices=[
        ('Low', 'Low'),
        ('Medium', 'Medium'),
        ('High', 'High'),
        ('Critical', 'Critical')
    ], default='Medium', validators=[DataRequired()])
    submit = SubmitField("Submit Request")


class ReviewRequestForm(FlaskForm):
    """Form for handlers to review and process requests."""
    status = SelectField("Status", validators=[DataRequired()]) # Choices populated dynamically in route
    resolution_notes = TextAreaField("Resolution Notes (Optional)", validators=[Optional(), Length(max=1000)])
    denial_reason = TextAreaField("Reason for Denial (Required if 'Denied')", validators=[Optional(), Length(max=500)])
    forward_to_user_id = SelectField("Forward To (Optional)", coerce=int, validators=[Optional()]) # Choices populated dynamically

    submit = SubmitField("Update Request")

    def __init__(self, *args, current_user_role_name, request_tier, request_status, **kwargs):
        super().__init__(*args, **kwargs)
        self.current_user_role_name = current_user_role_name # Store for validation
        self.request_tier = request_tier
        self.request_status = request_status # Store for validation

        # Dynamically populate status choices based on current handler's role and request tier
        # These reflect the allowed transitions for each tier.
        if request_tier == 1 and current_user_role_name == 'hr_ceo':
            self.status.choices = [
                ('Approved', 'Approve'),
                ('On Progress', 'Mark On Progress'),
                ('Denied', 'Deny'),
                ('Resolved', 'Resolve (Final for HR/CEO)'),
                ('Forward', 'Forward to School Executive') # This is an action, not a status in DB, handled as transition
            ]
        elif request_tier == 2 and current_user_role_name == 'school_executive':
            self.status.choices = [
                ('Approved', 'Approve'),
                ('On Progress', 'Mark On Progress'),
                ('Denied', 'Deny'),
                ('Resolved', 'Resolve (Final for School Executive)'),
                ('Forward', 'Forward to Government')
            ]
        elif request_tier == 3 and current_user_role_name == 'government':
            self.status.choices = [
                ('Approved', 'Accept (Final for Government)'), # Equivalent to resolved
                ('Denied', 'Deny (Final for Government)')
            ]
        else: # Fallback or for global admins seeing the form
            self.status.choices = [
                ('Pending', 'Pending'),
                ('Approved', 'Approved'),
                ('On Progress', 'On Progress'),
                ('Denied', 'Denied'),
                ('Resolved', 'Resolved')
            ]

        # Conditionally make denial_reason required
        # This will be validated on form.validate_on_submit()
        if self.status.data == 'Denied':
            self.denial_reason.validators = [DataRequired(message="Denial reason is required if status is 'Denied'."), Length(max=500)]
        else:
            self.denial_reason.validators = [Optional(), Length(max=500)]

    def validate(self, extra_validators=None):
        # Perform standard WTForms validation first
        initial_validation = super().validate(extra_validators=extra_validators)
        if not initial_validation:
            return False

        # Custom validation for forwarding and denying
        if self.status.data == 'Forward':
            # Check if there are choices for forward_to_user_id (meaning populate was called)
            if not self.forward_to_user_id.choices or self.forward_to_user_id.data == 0:
                self.forward_to_user_id.errors.append("Please select a user to forward the request to.")
                return False
        
        if self.status.data == 'Denied' and not self.denial_reason.data:
            self.denial_reason.errors.append("Denial reason is required if status is 'Denied'.")
            return False

        return True


# --- END NEW FORMS ---

# --- Behavior Record Form ---
class BehaviorRecordForm(FlaskForm):
    """Form for adding/editing a student behavior record."""
    behavior_type = SelectField(
        "Behavior Type",
        choices=[
            ('Positive', 'Positive Behavior'),
            ('Needs Improvement', 'Needs Improvement'),
            ('Concern', 'Behavior Concern')
        ],
        validators=[DataRequired()]
    )
    description = TextAreaField(
        "Description",
        validators=[DataRequired(), Length(max=1000)]
    )
    severity = SelectField(
        "Severity",
        choices=[
            ('Low', 'Low'),
            ('Medium', 'Medium'),
            ('High', 'High')
        ],
        default='Medium',
        validators=[DataRequired()] # Added DataRequired
    )
    resolution = TextAreaField(
        "Resolution (if applicable)",
        validators=[Optional(), Length(max=1000)]
    )
    is_resolved = BooleanField("Mark as resolved") # Checkbox
    submit = SubmitField("Save Record")


# --- Attendance Form (for Teachers/Librarians marking student attendance) ---
# Helper form for FieldList in AttendanceForm - only used to structure the FieldList
class StudentAttendanceSubForm(FlaskForm):
    # No fields here. The actual status/notes fields are generated dynamically in the template
    # with names like status_{{ student.id }} and notes_{{ student.id }}
    pass

class AttendanceForm(FlaskForm):
    """Form structure for marking attendance for multiple students."""
    # FieldList to indicate that multiple student entries are expected.
    # The data for these entries is *not* automatically populated or validated by WTForms
    # in the typical way; it is read directly from request.form in the route.
    students = FieldList(FormField(StudentAttendanceSubForm), min_entries=0)

    # The date is typically passed via URL args or a hidden field, not a validated form field here
    # date = DateField("Date", format="%Y-%m-%d") # Not used with current route logic

    submit = SubmitField("Save Attendance")

    # __init__ is needed to dynamically add entries to the FieldList for rendering the template correctly
    def __init__(self, *args, students=None, **kwargs):
        super().__init__(*args, **kwargs)
        if students is not None:
             # Clear any existing entries added by default or previous processing
             while len(self.students.entries) > 0:
                  self.students.pop_entry()

             # Append a new entry (a subform) for each student object passed in
             for student in students:
                  # The 'data' dictionary here is just to conceptually link the subform
                  # entry to the student ID for rendering purposes, not for WTForms data processing.
                  self.students.append_entry(data={'student_id': student.id})


# --- Asset Management Forms ---

# Helper to get Labs for SelectFields
def get_labs():
    """Helper to query and format labs for select fields."""
    try:
        with app.app_context():
            return db.session.scalars(select(Lab).order_by(Lab.name)).all()
    except Exception as e:
        app.logger.error(f"Error fetching labs: {e}")
        return []

class AddAssetForm(FlaskForm):
    """Form for adding a new asset."""
    name = StringField("Asset Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    quantity = IntegerField("Quantity", default=1, validators=[DataRequired(), NumberRange(min=1)]) # Min quantity 1
    purchase_cost = FloatField("Purchase Cost (Optional)", validators=[Optional(), NumberRange(min=0)]) # Min cost 0
    condition = SelectField("Condition", choices=[
        ('New', 'New'), ('Good', 'Good'), ('Fair', 'Fair'),
        ('Poor', 'Poor'), ('Needs Repair', 'Needs Repair'), ('Broken', 'Broken') # Added Broken
    ], default='New', validators=[DataRequired()])
    is_consumable = BooleanField("Is Consumable?")
    expiry_date = DateField("Expiry Date (YYYY-MM-DD) (if consumable)", format='%Y-%m-%d', validators=[Optional()])
    last_maintenance_date = DateField("Last Maintenance Date (YYYY-MM-DD) (if applicable)", format='%Y-%m-%d', validators=[Optional()])
    # Suggested category is optional for the requester
    suggested_category_id = SelectField("Suggested Category (Optional)", coerce=int, validators=[Optional()])
    # Lab assignment is optional for the requester (e.g. teacher adding to their lab)
    # Added to allow teacher/librarian to suggest a lab
    suggested_lab_id = SelectField("Suggested Lab/Location (Optional)", coerce=int, validators=[Optional()])
    location_description = StringField("Specific Location Details (Optional)", validators=[Optional(), Length(max=255)]) # More specific location details

    submit = SubmitField("Add Asset")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices dynamically
        self.suggested_category_id.choices = [(0, '--- Select Category (Optional) ---')] + \
                                             [(c.id, c.name) for c in get_social_categories()] # Re-using social categories helper as it queries AssetCategory
        # Populate lab choices dynamically
        self.suggested_lab_id.choices = [(0, '--- Select Location (Optional) ---')] + \
                                       [(l.id, l.name) for l in get_labs()]

class ReportAssetForm(FlaskForm):
    """Form for reporting an issue with an asset (specific or general)."""
    damage_description = TextAreaField("Description of Damage/Issue", validators=[DataRequired(), Length(max=1000)]) # Increased length
    date_of_damage = DateField("Approximate Date of Damage/Issue (YYYY-MM-DD)", format='%Y-%m-%d', validators=[Optional()]) # Make date optional
    quantity_damaged = IntegerField("Quantity Damaged/Affected", default=1, validators=[DataRequired(), NumberRange(min=1)]) # Min quantity 1
    submit = SubmitField("Submit Report")

    def validate_date_of_damage(self, field):
        # Allow empty date if optional
        if field.data and field.data > datetime.now(timezone.utc).date():
            raise ValidationError("Date of damage cannot be in the future.")


class EditAssetForm(FlaskForm):
    """Form for HR/CEO/Admin to edit and review an asset."""
    # Name should probably be editable by admin
    name = StringField("Asset Name", validators=[DataRequired(), Length(max=100)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=500)])
    quantity = IntegerField("Quantity", validators=[DataRequired(), NumberRange(min=0)]) # Quantity can be 0
    purchase_cost = FloatField("Purchase Cost (Optional)", validators=[Optional(), NumberRange(min=0)])
    # Category and Status are key fields for HR/Admin to manage
    category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # Now required
    status = SelectField("Status", choices=[
        ('Pending Review', 'Pending Review'), ('Available', 'Available'), # Added Available
        ('CheckedOut', 'CheckedOut'), ('Under Maintenance', 'Under Maintenance'),
        ('Retired', 'Retired'), ('Lost', 'Lost')
    ], validators=[DataRequired()])
    condition = SelectField("Condition", choices=[
        ('New', 'New'), ('Good', 'Good'), ('Fair', 'Fair'),
        ('Poor', 'Poor'), ('Needs Repair', 'Needs Repair'), ('Broken', 'Broken')
    ], validators=[DataRequired()])
    is_consumable = BooleanField("Is Consumable?")
    expiry_date = DateField("Expiry Date (YYYY-MM-DD) (if consumable)", format='%Y-%m-%d', validators=[Optional()])
    last_maintenance_date = DateField("Last Maintenance Date (YYYY-MM-DD) (if applicable)", format='%Y-%m-%d', validators=[Optional()])
    # Lab assignment is managed by HR/Admin here
    lab_id = SelectField("Assigned Lab/Location (Optional)", coerce=int, validators=[Optional()])
    location_description = StringField("Specific Location Details (Optional)", validators=[Optional(), Length(max=255)])

    # added_by_user_id is informational, not editable here

    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate category choices (required for HR/Admin)
        self.category_id.choices = [(c.id, c.name) for c in get_social_categories()] # Re-using helper
        # Populate lab choices (optional for HR/Admin)
        self.lab_id.choices = [(0, '--- Select Location (Optional) ---')] + \
                             [(l.id, l.name) for l in get_labs()]

    def validate_expiry_date(self, field):
         # If the asset is consumable, the expiry date might be required or validated further
         # Basic validation: Ensure expiry date is in the future if set for a new/active consumable asset
         # This form can edit, so maybe only validate if setting a *future* date is required.
         pass # Add specific logic if needed


class ResolveReportForm(FlaskForm):
    """Form for HR/CEO/Admin to update the status and notes of an asset report."""
    status = SelectField("Report Status", choices=[
        ('Pending', 'Pending'), ('In Progress', 'In Progress'),
        ('Resolved', 'Resolved'), ('Rejected', 'Rejected')
    ], validators=[DataRequired()])
    resolution_notes = TextAreaField("Resolution Notes", validators=[Optional(), Length(max=1000)]) # Increased length
    # Option to link report to an asset if it was a general report (requires search/select field)
    # For V1, skip complex linking via this form. Linking happens when resolving.
    # link_to_asset_id = SelectField("Link to Asset (Optional)", coerce=int, validators=[Optional()]) # Example if implementing linking here
    submit = SubmitField("Update Report Status")

    # If linking is implemented, need __init__ to populate link_to_asset_id choices
    # def __init__(self, *args, **kwargs):
    #      super().__init__(*args, **kwargs)
    #      self.link_to_asset_id.choices = [(0, '--- Select Asset (Search not implemented) ---')] + [
    #          (a.id, f"{a.name} ({a.id})") for a in db.session.scalars(select(Asset)).limit(100).all() # Limit for large databases
    #      ]


# --- Asset Category Management Forms ---
class AddCategoryForm(FlaskForm):
    """Form for adding a new asset category."""
    name = StringField("Category Name", validators=[DataRequired(), Length(max=50)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=200)])
    submit = SubmitField("Add Category")

class EditCategoryForm(FlaskForm):
    """Form for editing an existing asset category."""
    name = StringField("Category Name", validators=[DataRequired(), Length(max=50)])
    description = TextAreaField("Description", validators=[Optional(), Length(max=200)])
    submit = SubmitField("Save Changes")

# --- Book Checkout Forms ---
class BookCheckoutForm(FlaskForm):
    """Form for checking out a book asset."""
    # Asset ID will be the book - filtered by category 'Books' and status 'Available'
    asset_id = SelectField("Select Book", coerce=int, validators=[DataRequired()])
    # User ID will be current_user for students, or selectable for librarian
    # This field is conditionally displayed/validated in the route
    user_id = SelectField(
        "Select User (for Librarians)", coerce=int, validators=[Optional()]
    )
    due_date = DateField("Due Date", format="%Y-%m-%d", validators=[DataRequired()])
    submit = SubmitField("Checkout Book")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate asset_id choices with available books
        with app.app_context(): # Ensure app context for DB query
            book_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
            # Get available book assets (category 'Books', status 'Available', quantity > 0)
            available_books = []
            if book_category:
                 available_books = db.session.scalars(
                     select(Asset)
                     .where(
                         Asset.category_id == book_category.id,
                         Asset.status == "Available", # Or status is null/default
                         Asset.quantity > 0 # Only show if there's stock
                     )
                     .order_by(Asset.name)
                 ).all()

            self.asset_id.choices = [
                 (a.id, f"{a.name} (Available: {a.quantity})")
                 for a in available_books
            ]
            # Add an empty option if no books are available but the list isn't empty due to other reasons
            if not self.asset_id.choices and available_books is not None: # Check if query ran but found nothing
                 self.asset_id.choices = [('', 'No books available')] # Use empty string for value if needed


            # Populate user_id choices for librarians
            # Check if current_user and role exist before trying to access them
            if current_user.is_authenticated and current_user.role and current_user.role.name.lower() == "librarian":
                # Librarians can select student or teacher users
                users_to_borrow = db.session.scalars(
                    select(User)
                    .join(Role)
                    .where(Role.name.in_(["student", "teacher"]), User.is_active == True) # Example: Students and Teachers can borrow
                    .order_by(User.full_name)
                ).all()
                self.user_id.choices = [(0, "--- Select User ---")] + [
                    (u.id, f"{u.full_name} ({u.username})") for u in users_to_borrow
                ]
            else:
                # For students, user_id field is not used/displayed. Set choices to empty.
                self.user_id.choices = []


    def validate_due_date(self, field):
        # Due date must be in the future
        if field.data and field.data < datetime.now(timezone.utc).date():
            raise ValidationError("Due date cannot be in the past.")


# --- Student Leader Assignment Form ---
class AssignLeaderForm(FlaskForm):
    """Form for assigning students to a student leader."""
    # SelectField for choosing a student leader from the list of existing leaders
    leader = SelectField("Select Leader", coerce=int, validators=[DataRequired()])
    # Students to assign are selected via checkboxes in the template, not defined as form fields here.
    submit = SubmitField("Assign Students")

    def __init__(self, *args, current_leaders=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate the leader dropdown with current student leaders
        # current_leaders should be a list of User objects who are leaders
        if current_leaders is not None: # Check if list was provided
             self.leader.choices = [(l.id, f"{l.full_name} (Grade {l.grade or 'N/A'}, Section {l.section or 'N/A'})") for l in current_leaders]
        else:
             # If no leaders are passed (e.g., empty DB), provide a default empty choice
             self.leader.choices = [(0, '--- No Leaders Found ---')] # Use 0 as a placeholder value


# --- Notification Form ---
class NotificationForm(FlaskForm):
    """Form for composing and sending a notification message."""
    content = TextAreaField(
        "Message Content", validators=[DataRequired(), Length(min=1, max=1000)]
    )
    # Receiver selection is handled outside this form (via route parameter)
    # link_url = StringField("Link URL (Optional)", validators=[Optional(), URL(), Length(max=255)]) # Optional field for a link
    submit = SubmitField("Send Notification")


# --- Social Media Forms --- (Copied from previous parts for completeness here)
# START MODIFICATION (CreateChannelForm)
class CreateChannelForm(FlaskForm):
    name = StringField("Channel Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    channel_type = SelectField("Channel Type", choices=[('public', 'Public'), ('private', 'Private')], validators=[DataRequired()])
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # MODIFIED: Field name changed to social_category_id and is required
    allow_comments = BooleanField("Allow Comments on Posts", default=True)
    allow_reactions = BooleanField("Allow Reactions on Posts", default=True)
    submit = SubmitField("Create Channel")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # MODIFIED: Removed optional '--- Select Category ---' as it's now required. Access social_category_id.
        self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
        # If no categories exist, add a dummy entry to prevent errors, but form will still be invalid due to DataRequired
        if not self.social_category_id.choices:
            self.social_category_id.choices = [('', 'No categories available')]
# END MODIFICATION (CreateChannelForm)
# START MODIFICATION (EditChannelForm)
class EditChannelForm(FlaskForm):
    name = StringField("Channel Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    social_category_id = SelectField("Category", coerce=int, validators=[DataRequired()]) # MODIFIED: Field name changed to social_category_id and is required
    allow_comments = BooleanField("Allow Comments on Posts")
    allow_reactions = BooleanField("Allow Reactions on Posts")
    submit = SubmitField("Save Changes")

    def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
         # MODIFIED: Removed optional '--- Select Category ---' as it's now required. Access social_category_id.
         self.social_category_id.choices = [(c.id, c.name) for c in get_social_categories()]
         if not self.social_category_id.choices:
            self.social_category_id.choices = [('', 'No categories available')]
# END MODIFICATION (EditChannelForm)
class CreateGroupForm(FlaskForm):
    name = StringField("Group Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    submit = SubmitField("Create Group")

class EditGroupForm(FlaskForm):
    name = StringField("Group Name", validators=[DataRequired(), Length(max=100)])
    bio = TextAreaField("Bio/Description", validators=[Optional(), Length(max=500)])
    profile_photo = FileField("Profile Photo (Optional)", validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif'], 'Images only!')])
    submit = SubmitField("Save Changes")

class PostContentForm(FlaskForm):
    """Form for posting content (text and/or file) in channels/groups."""
    content = TextAreaField("Your message", validators=[Optional(), Length(max=2000)])
    attached_file = FileField("Attach File (Optional)")
    submit = SubmitField("Send")

    # Custom validation: Require EITHER content OR file
    def validate(self, extra_validators=None):
         # Run standard WTForms validation first
         initial_validation = super().validate(extra_validators=extra_validators)

         # If standard validation fails, don't proceed with custom validation
         if not initial_validation:
             return False

         # Now, check our custom requirement: EITHER content OR attached_file
         # file.data will be a FileStorage object if a file was uploaded, otherwise None
         if not self.content.data and not self.attached_file.data:
              # Add an error message to a field, e.g., the content field
              # Using `self.content.errors` is standard practice
              self.content.errors.append("Message content or a file must be provided.")
              # Indicate that the form is now invalid due to custom validation
              return False

         # If standard validation passed AND at least one field has data, the form is valid
         return True


class CommentForm(FlaskForm):
    """Form for adding a comment to a post."""
    content = TextAreaField("Your comment", validators=[DataRequired(), Length(max=500)])
    submit = SubmitField("Comment")


# --- END PART 4 ---

# --- PART 5 START: Authentication Routes ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, SecretCode are defined.
# - Forms: PreForm, CompleteRegistrationForm, LoginForm, ChangePasswordForm, ForcedChangePasswordForm are defined.
# - Helpers: get_unread_message_count, get_unread_notifications_count are defined and potentially used in context processor.
# - role_required decorator is defined.
# - url_for is available.

# --- (After app = Flask(__name__) and before routes) ---

# Global Constants (if you want to access them in templates easily)
# TASK_CREATOR_ROLES was defined in your original app.py for backend logic.
# Making it available to templates if needed, e.g. to conditionally show a "Create Task" button.
TASK_CREATOR_ROLES = ['hr_ceo', 'system_admin', 'school_executive']

# This part enables CSRF protection for your forms
csrf = CSRFProtect(app) # Make sure this is initialized if not alread

@app.context_processor
def inject_global_vars():
    """Injects common variables into all Jinja2 templates."""
    unread_messages_count_val = 0
    unread_notifications_count_val = 0

    # Ensure current_user is available and authenticated before querying DB
    if hasattr(current_user, 'is_authenticated') and current_user.is_authenticated:
        try:
            unread_messages_count_val = get_unread_message_count(current_user.id)
            unread_notifications_count_val = get_unread_notifications_count(current_user.id)

        except Exception as e:
            # Use app.logger if available and configured
            logger = getattr(current_app, 'logger', None)
            if logger:
                logger.error(f"Error fetching counts/permissions for user {current_user.id} in context processor: {e}")
            else: # Fallback print if logger not set up on current_app
                print(f"ERROR in context_processor: Error fetching counts/permissions for user {current_user.id}: {e}")

            unread_messages_count_val = "Err"
            unread_notifications_count_val = "Err"

    # Define the lambda function here for clarity and correct scope
    # Ensure 'csrf' is your CSRFProtect instance (e.g., from flask_wtf.csrf import CSRFProtect; csrf = CSRFProtect(app))
    # and wtf_generate_csrf is imported correctly.
    csrf_token_value_lambda = lambda: wtf_generate_csrf() if csrf else ''

    return {
        "now": datetime.now(timezone.utc),
        "current_year": datetime.now(timezone.utc).year,
        "unread_messages_count": unread_messages_count_val,
        "unread_notifications_count": unread_notifications_count_val,
        "TASK_CREATOR_ROLES": TASK_CREATOR_ROLES, # Makes this list available in templates

        # This provides a function to get the CSRF token string
        "get_csrf_token_value": csrf_token_value_lambda
    }

@app.template_filter('humanize_time_diff')
def humanize_time_diff_filter(dt, default="just now"):
    """
    Converts a datetime object or a parsable datetime string to a human-readable relative time.
    e.g., "5 minutes ago", "2 hours ago", "3 days ago".
    """
    if not dt:
        return default
    
    # If dt is already a datetime object, ensure it's offset-aware (UTC)
    if isinstance(dt, datetime):
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
    # If dt is a string, try to parse it
    elif isinstance(dt, str):
        try:
            # Attempt to parse ISO format, common from JS new Date().toISOString()
            dt_parsed = datetime.fromisoformat(dt.replace("Z", "+00:00"))
            dt = dt_parsed # Use the parsed datetime object
        except ValueError:
            # Fallback for other potential string formats if necessary, or return default
            app.logger.warning(f"Could not parse datetime string for humanize_time_diff: {dt}")
            return default # Or format dt as string if parsing fails but it's a date
    else: # Not a datetime object or string
        return default

    now = datetime.now(timezone.utc)
    try:
        diff = now - dt
        if diff.total_seconds() < 0: # Datetime is in the future
             return f"in {humanize.naturaldelta(-diff)}" # "in 5 minutes"
        if diff.total_seconds() < 60: # Less than a minute
            return default # "just now"
        return humanize.naturaltime(diff)
    except (TypeError, ValueError) as e:
        app.logger.error(f"Error humanizing time diff for {dt}: {e}")
        return default

@app.template_filter('nl2br')
def nl2br_filter(s):
    """Converts newlines in a string to HTML <br> tags."""
    if not s:
        return ''
    return Markup(str(s).replace('\n', '<br>\n'))

@app.route("/")
def home():
    if current_user.is_authenticated:
        # This correctly redirects to role_redirect which then sends them to their dashboard
        return redirect(url_for("role_redirect"))
    else:
        # Instantiate LoginForm to pass to the index.html template
        form = LoginForm() # Make sure LoginForm is defined/imported in your app.py
        return render_template("index.html", 
                               title="Welcome to Nexus - Kechene Debre Selam G.S.S.", 
                               form=form)


@app.route("/pre_register", methods=["GET", "POST"])
def pre_register():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    form = PreForm() # Make sure PreForm is defined/imported

    if form.validate_on_submit():
        code_input = form.code.data.strip()
        # Using joinedload(SecretCode.role) to eager load the role
        secret_code = db.session.scalar(
            select(SecretCode).filter(
                func.lower(SecretCode.code) == func.lower(code_input),
                SecretCode.is_used == False
            ).options(joinedload(SecretCode.role)) 
        )

        if secret_code:
            session['pre_reg_code_id'] = secret_code.id
            session['pre_reg_full_name'] = secret_code.full_name
            session['pre_reg_role_id'] = secret_code.role_id
            session['pre_reg_code_value'] = secret_code.code 
            app.logger.info(f"Pre-registration code '{code_input[:2]}...{code_input[-2:]}' (ID: {secret_code.id}) found. Proceeding to confirmation.")
            return redirect(url_for('confirm_identity'))
        else:
            flash('Invalid or already used registration code.', 'danger')
            app.logger.warning(f"Failed pre-registration attempt with code '{code_input[:2]}...{code_input[-2:]}'.")
            # No need to return render_template here again, the final one handles GET and failed POST
            
    # For GET request or if form validation failed on POST
    return render_template('auth/pre_register.html', 
                           form=form, 
                           title="Pre-Register - Nexus")

@app.route("/confirm-identity")
def confirm_identity():
    if current_user.is_authenticated:
         flash("You are already logged in.", "info")
         return redirect(url_for("role_redirect"))

    code_id = session.get('pre_reg_code_id')
    full_name = session.get('pre_reg_full_name')
    role_id = session.get('pre_reg_role_id')
    code_value = session.get('pre_reg_code_value')

    if not all([code_id, full_name, role_id, code_value]): # Simplified check
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        # Clear potentially incomplete session data
        session.pop('pre_reg_code_id', None)
        session.pop('pre_reg_full_name', None)
        session.pop('pre_reg_role_id', None)
        session.pop('pre_reg_code_value', None)
        return redirect(url_for('pre_register'))

    secret_code = db.session.get(SecretCode, code_id)
    # Fetch the Role object to get its name
    role_obj = db.session.get(Role, role_id) if role_id else None

    if not secret_code or secret_code.is_used or \
       secret_code.full_name != full_name or \
       secret_code.role_id != role_id or \
       secret_code.code != code_value or not role_obj:
        flash("Pre-registration data mismatch, code used, or role invalid. Please start over.", "danger")
        session.pop('pre_reg_code_id', None)
        session.pop('pre_reg_full_name', None)
        session.pop('pre_reg_role_id', None)
        session.pop('pre_reg_code_value', None)
        return redirect(url_for('pre_register'))
    
    # Prepare role name for display
    display_role_name = role_obj.name.replace('_', ' ').title() if role_obj else "Unknown Role"

    return render_template('auth/confirm_identity.html',
                           full_name=full_name,
                           role_name=display_role_name, # Pass formatted role name
                           title="Confirm Your Identity - Nexus")

@app.route("/handle-confirmation", methods=["POST"])
def handle_confirmation():
    """Processes the user's confirmation choice."""
    # Retrieve data from session
    code_id = session.get('pre_reg_code_id')
    full_name = session.get('pre_reg_full_name')
    role_id = session.get('pre_reg_role_id')
    code_value = session.get('pre_reg_code_value')

    # Check if essential session data is present
    if current_user.is_authenticated:
         flash("You are already logged in.", "info")
         return redirect(url_for("role_redirect"))

    if not code_id or not full_name or not role_id or not code_value:
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        return redirect(url_for('pre_register'))

    # Re-validate the code against the database just in case it was used between pages
    secret_code = db.session.get(SecretCode, code_id)
    if not secret_code or secret_code.is_used or secret_code.code != code_value:
         flash("Pre-registration data mismatch or code used. Please start over.", "danger")
         # Clear session data if code is invalid or used
         session.pop('pre_reg_code_id', None)
         session.pop('pre_reg_full_name', None)
         session.pop('pre_reg_role_id', None)
         session.pop('pre_reg_code_value', None)
         return redirect(url_for('pre_register'))


    # Process the confirmation response from the form
    if request.form.get('confirmation') == 'yes':
        # User confirmed identity, proceed to complete registration
        # Session data is kept and will be validated again in complete_registration
        app.logger.info(f"Identity confirmed for code ID {code_id}. Redirecting to complete registration.")
        return redirect(url_for('complete_registration'))
    else:
        # User declined or submitted form incorrectly
        flash("Identity confirmation declined. Please start over or contact school administration.", "info")
        # Clear session data as registration flow is abandoned
        session.pop('pre_reg_code_id', None)
        session.pop('pre_reg_full_name', None)
        session.pop('pre_reg_role_id', None)
        session.pop('pre_reg_code_value', None)
        app.logger.warning(f"Identity confirmation declined for code ID {code_id}.")
        return redirect(url_for('home')) # Redirect back to the home page

@app.route("/complete-registration", methods=["GET", "POST"])
def complete_registration():
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    code_id = session.get('pre_reg_code_id')
    pre_reg_full_name = session.get('pre_reg_full_name')
    pre_reg_role_id = session.get('pre_reg_role_id')
    pre_reg_code_value = session.get('pre_reg_code_value')

    if not all([code_id, pre_reg_full_name, pre_reg_role_id, pre_reg_code_value]):
        flash("Pre-registration session expired or invalid. Please start over.", "danger")
        return redirect(url_for('pre_register'))

    secret_code = db.session.get(SecretCode, code_id)
    if not secret_code or secret_code.is_used or \
       secret_code.full_name != pre_reg_full_name or \
       secret_code.role_id != pre_reg_role_id or \
       secret_code.code != pre_reg_code_value:
        flash("Pre-registration data mismatch or code used. Please start over.", "danger")
        session.pop('pre_reg_code_id', None)
        # ... clear other session keys ...
        return redirect(url_for('pre_register'))

    form = CompleteRegistrationForm() # Your CompleteRegistrationForm

    if request.method == 'GET':
        form.full_name.data = pre_reg_full_name # Pre-fill full name

    if form.validate_on_submit():
        try:
            user_full_name = form.full_name.data.strip()
            name_parts = user_full_name.split(' ', 1)
            first_name = name_parts[0]
            last_name = name_parts[1] if len(name_parts) > 1 else None

            user = User(
                username=form.username.data.strip(),
                email=form.email.data.strip() if form.email.data else None,
                full_name=user_full_name,
                first_name=first_name,
                last_name=last_name,
                role_id=pre_reg_role_id,
                is_active=True,
                force_password_change=False, # Password set now
                created_at=datetime.now(timezone.utc),
                age=form.age.data, # From form
                sex=form.sex.data if form.sex.data else None, # From form
                # Assuming profile_photo_url is a StringField in the form for Phase A
                profile_photo_url=form.profile_photo_url.data.strip() if form.profile_photo_url.data else None
            )
            user.set_password(form.password.data)
            secret_code.is_used = True

            db.session.add(user)
            db.session.add(secret_code) # Mark code as used
            db.session.commit()

            session.pop('pre_reg_code_id', None)
            session.pop('pre_reg_full_name', None)
            session.pop('pre_reg_role_id', None)
            session.pop('pre_reg_code_value', None)

            flash("Registration complete! Please log in with your new username and password.", "success")
            app.logger.info(f"New user '{user.username}' (ID: {user.id}) registered successfully using secret code ID {secret_code.id}.")
            return redirect(url_for('login'))

        except IntegrityError: # Usually duplicate username/email
            db.session.rollback()
            app.logger.warning(f"Complete registration failed for code ID {code_id} due to IntegrityError.")
            # Form validators for username/email should catch this first and add errors to form fields.
            # If an error still occurs here, it's a fallback.
            flash('Registration failed: Username or email is already in use. Please check the form.', 'danger')
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error during complete registration for code ID {code_id}: {e}", exc_info=True)
            flash("An unexpected error occurred during registration. Please try again.", "danger")
            
    # For GET or if form validation fails on POST
    return render_template('auth/complete_registration.html',
                           form=form,
                           pre_reg_full_name=pre_reg_full_name, # For template greeting
                           title="Complete Your Registration - Nexus")

@app.route("/role-redirect")
@login_required
def role_redirect():
    """Redirects authenticated users to their specific role dashboard, prioritizing TC dashboard for TC students."""
    # Define mapping of role names (lowercase) to dashboard endpoint names
    ROLE_DASHBOARD_ENDPOINTS = {
        'student': 'student_dashboard',
        'teacher': 'teacher_dashboard',
        'system_admin': 'system_admin_dashboard',
        'hr_ceo': 'hr_ceo_dashboard',
        'school_executive': 'school_exec_dashboard',
        'government': 'government_dashboard',
        'librarian': 'librarian_dashboard',
        'talent_club': 'talent_club_dashboard',  # Keep this for the 'talent_club' *role* (e.g. coordinators)
        'parent': 'parent_dashboard',
        # Add other roles and their dashboard endpoints here
    }

    # Get the current user's role name safely
    user_role_name = current_user.role.name.lower() if current_user.role else None

    # --- NEW: Prioritize Talent Club Member Dashboard ---
    if user_role_name == 'student' and current_user.is_tc_member:
        app.logger.info(f"User {current_user.username} (Role: student, TC Member: True) redirecting to TC Member Dashboard.")
        # Ensure user is added to TC Community group if not already (add_to_tc_community_group from app.py Part 3/Phase J)
        if not is_tc_community_member(current_user):  # is_tc_community_member helper
            add_to_tc_community_group(current_user)

        return redirect(url_for("talent_club_dashboard_member_view"))  # <<< UPDATE THIS ENDPOINT NAME

    # --- Existing logic for other roles ---
    elif user_role_name == 'talent_club':  # This is for the "Talent Club Coordinator" role
        # This might be the TC Leader if they have this specific role, or a different coordinator.
        # If the system-wide TC Leader (is_tc_leader=True) should have a unique dashboard,
        # that's a separate consideration or they use one of the admin dashboards.
        # For now, assume 'talent_club' role uses talent_club_role_dashboard/dashboard.html
        dashboard_endpoint = ROLE_DASHBOARD_ENDPOINTS.get('talent_club', 'fallback_dashboard') # Corrected: Use the 'talent_club' key
        app.logger.info(f"User {current_user.username} (Role: talent_club) redirecting to {dashboard_endpoint}.")
    else: # Added: Default for roles not explicitly handled above
        dashboard_endpoint = ROLE_DASHBOARD_ENDPOINTS.get(user_role_name, 'fallback_dashboard')

    try:
        # Redirect to the determined dashboard endpoint
        return redirect(url_for(dashboard_endpoint))
    except BuildError:
        # Handle case where the dashboard endpoint doesn't exist (misconfiguration)
        app.logger.error(f"Dashboard endpoint '{dashboard_endpoint}' not found for role '{user_role_name}'. Redirecting to fallback.")
        flash("Configuration error: Your role dashboard is not defined. Contact administration.", "danger")
        return redirect(url_for('fallback_dashboard'))
    except Exception as e:
        app.logger.error(f"Unexpected error during role redirect for user {current_user.id}: {e}", exc_info=True)
        flash("An unexpected error occurred during redirection. Please try logging in again.", "danger")
        # Optionally log out the user on severe error
        # logout_user()
        return redirect(url_for('login'))

@app.route("/login", methods=["GET", "POST"])
def login():
    """Handles user login."""
    # If user is already authenticated, redirect to their dashboard
    if current_user.is_authenticated:
        flash("You are already logged in.", "info")
        return redirect(url_for("role_redirect"))

    form = LoginForm() # Use the LoginForm defined in Part 4

    if form.validate_on_submit():
        # Get username input (keep original case for logging, use lower for lookup)
        username_input = form.username.data.strip()
        username_lower = username_input.lower()

        # Log the login attempt
        app.logger.info(f"Login attempt for username: '{username_input}' from IP: {request.remote_addr}")

        # Find user by lowercase username
        user = db.session.scalar(
            select(User).filter(func.lower(User.username) == username_lower).options(joinedload(User.role)) # Eager load role
        )

        if user:
            # Check if user is active BEFORE checking password
            if not user.is_active:
                 app.logger.warning(f"Login failed for inactive user: '{username_input}' (ID: {user.id}) from IP: {request.remote_addr}")
                 flash('Your account is inactive. Please contact administration.', 'danger')
                 return render_template("auth/login.html", title="Login", form=form)

            # User is active, now check password using the method from User model (Part 2)
            if user.check_password(form.password.data):
                # Password is correct and user is active - Login the user
                login_user(user) # Logs the user in using Flask-Login
                app.logger.info(f"Login successful for user: '{username_input}' (ID: {user.id}, Role: {user.role.name if user.role else 'N/A'}) from IP: {request.remote_addr}")

                # Update last login timestamp (optional, but good practice)
                user.last_login = datetime.now(timezone.utc)
                db.session.commit()

                # Check if user is required to change password (flag on User model from Part 2)
                if user.force_password_change:
                     flash('You must change your password before continuing.', 'warning')
                     # Store the intended 'next' URL so we can redirect there after forced change
                     # Get the 'next' parameter from the URL query string (if any)
                     next_url = request.args.get('next') or url_for('role_redirect') # Default to dashboard
                     session['_forced_change_next'] = next_url # Store the URL in the session
                     app.logger.debug(f"User {user.id} needs forced password change. Storing next URL: {next_url}")
                     # Redirect to the forced password change page
                     return redirect(url_for('change_password_forced'))

                # If no forced change, proceed to intended destination
                # Check for a 'next' parameter in the URL query string (e.g., /login?next=/some-page)
                next_page = request.args.get('next')
                if next_page:
                     try:
                          # Basic security check: ensure the next_page is a local path starting with /
                          # Use werkzeug.urls.url_parse for safer validation
                          target = url_parse(next_page)
                          if not target.scheme and not target.netloc: # Check if it's a relative path
                               app.logger.debug(f"Redirecting to 'next' page: {next_page}")
                               return redirect(next_page)
                          else:
                               # Log suspicious activity if an external URL is attempted
                               app.logger.warning(f"Invalid 'next' URL '{next_page}' provided during login (not a local path). Falling back to role redirect.")
                               # Fall through to default redirect below
                     except Exception as e: # Catch parsing errors etc.
                          app.logger.error(f"Unexpected error parsing 'next' URL '{next_page}': {e}. Falling back.", exc_info=True)

                # Default redirect if no valid 'next' page parameter or no force change required
                app.logger.debug("No valid 'next' page or forced change, redirecting to role dashboard.")
                return redirect(url_for("role_redirect"))

            else:
                # Invalid password
                app.logger.warning(f"Login failed for username: '{username_input}' (Invalid password) from IP: {request.remote_addr}")
                flash('Invalid username or password.', 'danger') # Use a generic message for security
        else:
            # User not found
            app.logger.warning(f"Login failed for username: '{username_input}' (User not found) from IP: {request.remote_addr}")
            flash('Invalid username or password.', 'danger') # Use a generic message for security

    # For GET request or failed POST validation (e.g., empty fields)
    # Render the login template again, which will display any flash messages and form errors.
    return render_template("auth/login.html", title="Login", form=form)


@app.route("/logout")
@login_required # User must be logged in to log out
def logout():
    """Handles user logout securely."""
    try:
        # Get username before logging out for logging purposes
        username = current_user.username if current_user.is_authenticated else "N/A (unauthenticated)"

        # Log the logout attempt
        app.logger.info(f"Logout attempt for user: {username} from IP: {request.remote_addr}")

        # Clear Flask-Login's session
        logout_user()

        # Clear Flask-Session data to remove any lingering information
        session.clear()

        # Create a response object for the redirect
        response = make_response(redirect(url_for("login")))

        # Add security headers to prevent browser caching of potentially sensitive pages
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '-1' # Historical date

        # Log the successful logout event
        app.logger.info(f"Secure logout successful for user: {username} from IP: {request.remote_addr}")

        flash("You have been securely logged out.", "success")
        return response

    except Exception as e:
        # Log any unexpected errors during the logout process
        username = current_user.username if current_user.is_authenticated else "N/A (unauthenticated)"
        app.logger.error(f"Error during logout for user {username}: {str(e)}", exc_info=True)
        flash("An error occurred during logout. Please clear your browser cache.", "danger")
        # Even if an error occurs, attempt to redirect to the login page
        response = make_response(redirect(url_for("login")))
        # Add headers even on error to attempt cache clearing
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '-1'
        return response

@app.route("/change-password", methods=["GET", "POST"])
@login_required
def change_password():
    form = ChangePasswordForm() # Your ChangePasswordForm
    if form.validate_on_submit():
        if not current_user.check_password(form.current_password.data):
            flash("Incorrect current password.", "danger")
        elif current_user.check_password(form.new_password.data):
            flash("New password cannot be the same as your current password.", "danger")
        else:
            try:
                current_user.set_password(form.new_password.data)
                current_user.force_password_change = False # Clear flag if it was set
                db.session.commit()
                flash("Your password has been changed successfully.", "success")
                app.logger.info(f"Password changed successfully for user {current_user.username} (ID: {current_user.id}).")
                return redirect(url_for("settings")) # Redirect to settings page
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error changing password for user {current_user.username}: {e}", exc_info=True)
                flash("An unexpected error occurred. Please try again.", "danger")
    
    return render_template("auth/change_password.html", 
                           form=form, 
                           title="Change Password - Nexus")
@app.route("/change-password-forced", methods=["GET", "POST"])
@login_required
def change_password_forced():
    if not current_user.force_password_change:
        flash("Password change not required at this time.", "info")
        return redirect(url_for("role_redirect"))

    form = ForcedChangePasswordForm() # Your ForcedChangePasswordForm
    if form.validate_on_submit():
        # Optional: Check if new password is same as old one, if User model has password_hash already
        # This is less critical here as the goal is to set *any* new password.
        try:
            current_user.set_password(form.new_password.data)
            current_user.force_password_change = False # CRITICAL: Clear the flag
            db.session.commit()
            flash("Your new password has been set successfully. You can now access the system.", "success")
            app.logger.info(f"Forced password change completed for user {current_user.username}.")
            
            next_page = session.pop('_forced_change_next', None)
            if next_page:
                try:
                    target = url_parse(next_page)
                    if not target.scheme and not target.netloc:
                        return redirect(next_page)
                    else:
                         app.logger.warning(f"Invalid stored 'next' URL '{next_page}' after forced password change. Falling back.")
                except Exception as e:
                    app.logger.error(f"Error parsing 'next' URL '{next_page}': {e}. Falling back.", exc_info=True)
            return redirect(url_for("role_redirect")) # Default redirect
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error during forced password change for user {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
    
    return render_template("auth/change_password_forced.html", 
                           form=form, 
                           title="Set New Password - Nexus")

# --- Fallback Dashboard (Needed for role_redirect) ---
@app.route("/dashboard") # Or your specific fallback URL
@login_required
def fallback_dashboard():
    flash(
        "Your role-specific dashboard may not be fully configured or is currently unavailable. Displaying a generic dashboard.",
        "info",
    )
    return render_template("dashboard_fallback.html", title="Dashboard - Nexus")

# --- PART 5 END ---

# --- PART 6 START: Role Dashboards & Core Navigation ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Message, Notification, BorrowedAsset, Attendance, Mark, TeacherProfile, Asset, AssetCategory, BehaviorRecord, Parent, ParentStudent are defined.
# - Helpers: get_unread_message_count, get_unread_notifications_count, get_user_assets_query are defined and potentially used in context processor.
# - role_required decorator is defined.
# - url_for, request, flash, render_template, redirect, abort, jsonify are available.
# - The context processor injects unread message/notification counts and `current_user`.

# --- Dashboard Routes (Specific Roles) ---

@app.route("/student/dashboard")
@login_required
@role_required("student") # Make sure your role_required decorator is defined and working
def student_dashboard():
    user_id = current_user.id

    # Teachers in the student's grade and section
    teachers = []
    teachers_count = 0
    if current_user.grade and current_user.section:
        # Ensure TeacherProfile and Role models are correctly imported and joined
        teachers = db.session.scalars(
            select(User)
            .join(User.teacher_profiles) # Assuming 'teacher_profiles' is the relationship name on User to TeacherProfile model
            .where(
                TeacherProfile.grade == current_user.grade,
                TeacherProfile.section == current_user.section,
                User.is_active == True,
                User.role.has(Role.name == "teacher") # Ensure it's a teacher
            )
            .distinct() # Avoid duplicates if a teacher has multiple profiles for the same class (unlikely)
            .order_by(User.full_name)
        ).all()
        teachers_count = len(teachers)

    # Borrowed books (not returned)
    borrowed_books = db.session.scalars(
        select(BorrowedAsset) # Make sure BorrowedAsset model is imported
        .where(BorrowedAsset.user_id == user_id, BorrowedAsset.returned == False)
        .options(joinedload(BorrowedAsset.asset).joinedload(Asset.category)) # Eager load asset and its category
        .order_by(BorrowedAsset.due_date.asc())
    ).all()

    # Recent attendance records (last 5)
    recent_attendance = db.session.scalars(
        select(Attendance) # Make sure Attendance model is imported
        .where(Attendance.student_id == user_id)
        .order_by(Attendance.date.desc())
        .limit(5)
    ).all()

    # Marks for all subjects
    marks_records = db.session.scalars(
        select(Mark) # Make sure Mark model is imported
        .where(Mark.student_id == user_id)
        .order_by(Mark.subject)
    ).all()

    # My Tasks (actionable ones for the student)
    actionable_task_statuses = [
        'Open', 'In Progress', 'Completed (Pending Review)',
        'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Review Rejected'
    ]
    # Ensure UserTask and Task models are imported
    my_tasks = db.session.scalars(
        select(UserTask)
        .join(UserTask.task) # Explicit join to Task for ordering or filtering by task attributes
        .where(UserTask.user_id == user_id, UserTask.status.in_(actionable_task_statuses))
        .options(joinedload(UserTask.task).joinedload(Task.created_by)) # Eager load related task and its creator
        .order_by(Task.due_date.asc().nulls_last(), UserTask.assigned_at.asc()) # Order by task's due_date
    ).all()
    
    # Recent activities for student (placeholder for now, could be recent important notifications)
    # Example: Fetch last 5 notifications of specific types relevant to students
    student_activity_types = ['task_assigned', 'task_review_result', 'behavior_recorded', 'general_announcement_student'] # Define relevant types
    recent_activities = db.session.scalars(
        select(Notification)
        .where(Notification.receiver_id == user_id, Notification.notification_type.in_(student_activity_types))
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()
    # Format these activities for the partial if needed
    # The partial expects: activity.icon, activity.text, activity.timestamp, activity.url, activity.badge_color
    # You'll need to map Notification objects to this structure.
    # For simplicity in this step, we'll pass them directly and let the template adapt or be updated.

    return render_template(
        "student/dashboard.html",
        title="Student Dashboard - Nexus",
        teachers=teachers,
        teachers_count=teachers_count,
        borrowed_books=borrowed_books,
        recent_attendance=recent_attendance,
        marks_records=marks_records,
        my_tasks=my_tasks, # This variable is used in the student dashboard template for a stat card
        # recent_activities=student_activities_formatted # If you format them
        recent_activities=recent_activities # Pass raw notifications for now
        # unread_notifications_count and unread_messages_count are from context_processor
    )
    
@app.route("/teacher/student/<int:user_id>/profile") # Example path
@login_required
@role_required("teacher") # Or any role that should see this teacher-centric view
def teacher_student_profile_view(user_id):
    student = db.get_or_404(User, user_id, description="Student not found.")
    if not student.role or student.role.name.lower() != 'student':
        flash("The specified user is not a student.", "warning")
        abort(404) # Or redirect

    # --- Data specific to Teacher's view of this student ---
    # Current teacher's profile (to check if they teach this student)
    # This logic assumes a teacher might have multiple profiles (grade/section/subject combinations)
    teacher_profiles_for_this_student = [
        tp for tp in current_user.teacher_profiles 
        if tp.grade == student.grade and tp.section == student.section
    ]
    # For simplicity, let's assume the first matching profile or any match grants "teaches this student" status
    teacher_teaches_this_student = bool(teacher_profiles_for_this_student)
    # If a specific subject context is needed:
    # teacher_teaches_subject_to_student = any(tp.subject == "SomeSpecificSubject" for tp in teacher_profiles_for_this_student)

    # Get student's marks (all subjects, or filter by subjects teacher teaches)
    student_marks_query = select(Mark).where(Mark.student_id == student.id)
    # Optional: Filter by subjects this teacher teaches, if applicable
    # taught_subjects = {tp.subject for tp in teacher_profiles_for_this_student if tp.subject}
    # if taught_subjects:
    #     student_marks_query = student_marks_query.where(Mark.subject.in_(taught_subjects))
    student_marks = db.session.scalars(student_marks_query.order_by(Mark.subject)).all()

    # Get student's recent attendance (e.g., last 10 records)
    student_attendance = db.session.scalars(
        select(Attendance).where(Attendance.student_id == student.id).order_by(Attendance.date.desc()).limit(10)
    ).all()

    # Get student's recent behavior records (e.g., last 5)
    student_behavior_records = db.session.scalars(
        select(BehaviorRecord)
        .where(BehaviorRecord.student_id == student.id)
        .options(joinedload(BehaviorRecord.recorded_by)) # Eager load who recorded it
        .order_by(BehaviorRecord.date.desc())
        .limit(5)
    ).all()
    
    # Get the current teacher's profile if needed by template (e.g. to check section)
    # This is slightly different from teacher_profiles_for_this_student
    # current_teacher_primary_profile = current_user.teacher_profiles.first() # Or some other logic
    # Using a simplified version for the template logic
    teacher_profile_context = current_user.teacher_profiles.filter_by(grade=student.grade, section=student.section).first()


    return render_template("teacher/student_profile_view.html",
                           student=student,
                           student_marks=student_marks,
                           student_attendance=student_attendance,
                           student_behavior_records=student_behavior_records,
                           teacher_profile=teacher_profile_context, # Pass current teacher's relevant profile
                           # permissions=get_request_permissions(current_user) # If quick links use it
                           title=f"Profile: {student.full_name or student.username} - Nexus")    
    
@app.route("/teacher/dashboard")
@login_required
@role_required("teacher")
def teacher_dashboard():
    # teacher_profile is used to find students in their class.
    # Assuming a teacher is primarily associated with one main class for dashboard stats.
    # If a teacher can have multiple (grade, section, subject) assignments,
    # this logic might need to pick the "primary" one or aggregate data.
    teacher_profile = db.session.scalar(
        select(TeacherProfile).where(
            TeacherProfile.user_id == current_user.id
            # Add conditions if teachers can have multiple profiles, e.g., filter by a 'is_primary' flag
        ).order_by(TeacherProfile.id.desc()).limit(1) # Get the latest or primary profile
    )

    students_count = 0
    if teacher_profile and teacher_profile.grade and teacher_profile.section:
        students_count = (
            db.session.scalar(
                select(func.count(User.id))
                .join(User.role) # Assuming User.role relationship
                .where(
                    Role.name == "student",
                    User.grade == teacher_profile.grade,
                    User.section == teacher_profile.section,
                    User.is_active == True,
                )
            ) or 0
        )
    
    lab_name = current_user.lab.name if current_user.lab else "Not Assigned"

    # My Tasks (actionable ones for the teacher)
    actionable_task_statuses = [
        'Open', 'In Progress', 'Completed (Pending Review)',
        'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Review Rejected'
    ]
    my_tasks = db.session.scalars(
        select(UserTask)
        .join(UserTask.task)
        .where(UserTask.user_id == current_user.id, UserTask.status.in_(actionable_task_statuses))
        .options(joinedload(UserTask.task).joinedload(Task.created_by))
        .order_by(Task.due_date.asc().nulls_last(), UserTask.assigned_at.asc())
    ).all()

    # Recent activities for teacher (e.g., new submissions for review, system announcements)
    teacher_activity_types = ['task_status_update_for_creator', 'request_submitted_to_handler', 'general_announcement_teacher']
    recent_activities = db.session.scalars(
        select(Notification)
        .where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(teacher_activity_types))
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()
    # You might need a new notification_type like 'task_status_update_for_creator'
    # and ensure notify_user_task_status_update uses it.

    return render_template(
        "teacher/dashboard.html",
        title="Teacher Dashboard - Nexus",
        teacher_profile=teacher_profile, # Pass the single profile object
        students_count=students_count,
        lab_name=lab_name,
        my_tasks=my_tasks,
        recent_activities=recent_activities
        # permissions (for quick links) and unread counts are from context_processor
    )
    
    
@app.route("/librarian/dashboard")
@login_required
@role_required("librarian")
def librarian_dashboard():
    """Librarian specific dashboard."""
    user_id = current_user.id

    # Recent notifications are in context processor

    # Fetch book category ID safely (assuming 'Books' is the standard category name)
    book_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
    book_category_id = book_category.id if book_category else None

    total_books = 0
    available_books = 0
    checked_out_books = 0

    if book_category_id:
        # Total count of assets in the 'Books' category
        total_books = (
            db.session.scalar(
                select(func.sum(Asset.quantity)).where( # Sum quantity for total stock
                    Asset.category_id == book_category_id,
                    Asset.status.in_(['Available', 'CheckedOut', 'Under Maintenance']) # Consider relevant statuses for total stock
                )
            )
            or 0
        )
        # Count of *items* currently marked as Available (quantity > 0)
        available_books = (
            db.session.scalar(
                select(func.sum(Asset.quantity)).where(
                    Asset.category_id == book_category_id,
                    Asset.status == "Available",
                    Asset.quantity > 0
                )
            )
            or 0
        )
        # Count *individual checkouts* that are not yet returned
        checked_out_books = (
            db.session.scalar(
                select(func.count(BookCheckout.id))
                .join(Asset) # Join to filter by category
                .where(
                    Asset.category_id == book_category_id,
                    BookCheckout.returned == False,
                )
            )
            or 0
        )

    # Reports related to library assets (e.g., status 'Needs Repair', 'Broken' for book category)
    library_category_ids = []
    if book_category: library_category_ids.append(book_category.id)
    library_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="Library Equipment"))
    if library_equipment_category: library_category_ids.append(library_equipment_category.id)

    open_library_reports = 0
    if library_category_ids:
         open_library_reports = db.session.scalar(
             select(func.count(AssetReport.id))
             .join(Asset)
             .where(
                 Asset.category_id.in_(library_category_ids),
                 AssetReport.status.in_(['Pending', 'In Progress']) # Open reports
             )
         ) or 0


    return render_template(
        "librarian/dashboard.html",
        title="Librarian Dashboard",
        total_books=total_books,
        available_books=available_books,
        checked_out_books=checked_out_books,
        open_library_reports=open_library_reports, # Pass count of reports related to library
        # recent_notifications and unread_notifications_count are in context
    )
@app.route("/hr_ceo/dashboard")
@login_required
@role_required("hr_ceo") # Assuming "hr_ceo" is the role name
def hr_ceo_dashboard():
    student_count = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_active == True)) or 0
    teacher_count = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == "teacher", User.is_active == True)) or 0
    student_leader_count = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_leader == True, User.is_active == True)) or 0
    
    pending_assets = db.session.scalar(select(func.count(Asset.id)).where(Asset.status == "Pending Review")) or 0
    reports_open = db.session.scalar(select(func.count(AssetReport.id)).where(AssetReport.status.in_(['Pending', 'In Progress']))) or 0

    my_assigned_tasks_count = db.session.scalar(
        select(func.count(Task.id))
        .where(Task.created_by_id == current_user.id)
        # Optionally filter by tasks that are not yet fully completed by all assignees
    ) or 0
    
    requests_inbox_count = db.session.scalar(
        select(func.count(Request.id))
        .where(
            Request.current_handler_id == current_user.id,
            Request.tier == 1, # HR/CEO is Tier 1
            Request.status.in_(['Pending', 'Approved', 'On Progress']) # Actionable requests
        )
    ) or 0
    
    # Recent admin activities (placeholder - e.g., recent important system notifications or audit logs)
    admin_activity_types = ['new_user_registered', 'system_error_report', 'asset_approved', 'request_tier1_escalated']
    recent_activities = db.session.scalars(
        select(Notification) # Or from a dedicated AuditLog model if you have one
        .where(Notification.receiver_id == current_user.id, Notification.notification_type.in_(admin_activity_types))
        .options(joinedload(Notification.sender))
        .order_by(Notification.timestamp.desc())
        .limit(5)
    ).all()

    return render_template(
        "hr_ceo/dashboard.html",
        title="HR & Academics Dashboard - Nexus",
        student_count=student_count,
        teacher_count=teacher_count,
        student_leader_count=student_leader_count,
        pending_assets=pending_assets,
        reports_open=reports_open,
        my_assigned_tasks_count=my_assigned_tasks_count,
        requests_inbox_count=requests_inbox_count,
        recent_activities=recent_activities
    )

@app.route("/school_exec/dashboard")
@login_required
@role_required("school_executive")
def school_exec_dashboard():
    """School Executive specific dashboard."""
    # Unread counts in context processor

    # Relevant stats for School Executive overview
    student_count = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    teacher_count = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )
    total_users = db.session.scalar(select(func.count(User.id)).where(User.is_active == True)) or 0 # Active users total

    total_assets = db.session.scalar(select(func.count(Asset.id))) or 0
    open_reports = db.session.scalar(select(func.count(AssetReport.id)).where(AssetReport.status.in_(['Pending', 'In Progress']))) or 0

    return render_template(
        "school_exec/dashboard.html",
        title="School Executive Dashboard",
        # recent_notifications, unread_notifications_count are in context
        student_count=student_count,
        teacher_count=teacher_count,
        total_users=total_users,
        total_assets=total_assets,
        open_reports=open_reports,
    )


@app.route("/government/dashboard")
@login_required
@role_required("government")
def government_dashboard():
    """Government oversight specific dashboard."""
    # Stats for government view - high level numbers
    total_students = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "student", User.is_active == True)
        )
        or 0
    )
    total_teachers = (
        db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == "teacher", User.is_active == True)
        )
        or 0
    )
    # Could add average scores, attendance rates across the whole school if data is structured for it.
    # Placeholder for total number of assets managed by the school
    total_assets_count = db.session.scalar(select(func.count(Asset.id))) or 0


    return render_template(
        "government/dashboard.html",
        title="Government Oversight Dashboard",
        total_students=total_students,
        total_teachers=total_teachers,
        total_assets_count=total_assets_count, # Example stat
    )


@app.route("/talent_club/dashboard")
@login_required
@role_required("talent_club")
def talent_club_dashboard():
    """Talent Club specific dashboard."""
    # Unread counts in context processor

    # Count active users with the 'talent_club' role
    member_count = db.session.scalar(
        select(func.count(User.id))
        .join(Role)
        .where(Role.name == "talent_club", User.is_active == True)
    ) or 0

    # Assets specifically designated for the Talent Club (assuming a category 'Talent Club Gear')
    talent_club_category = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
    talent_club_assets = []
    if talent_club_category:
        talent_club_assets = db.session.scalars(
            select(Asset)
            .where(Asset.category == talent_club_category, Asset.status.in_(['Available', 'Under Maintenance', 'Needs Repair'])) # Show relevant statuses
            .order_by(Asset.name)
        ).all()

    return render_template(
        "talent_club/dashboard.html",
        title="Talent Club Dashboard",
        member_count=member_count,
        talent_club_assets=talent_club_assets, # Pass assets
        # recent_notifications, unread_notifications_count are in context
    )
@app.route("/parent/dashboard")
@login_required
@role_required("parent")
def parent_dashboard():
    children_list = []
    recent_behavior_records_for_children = []

    # Assuming ParentStudent links Parent to student User, and User has parent_associations
    if current_user.parent_profile and current_user.parent_profile.student_associations:
        # Get verified children
        verified_associations = [
            assoc for assoc in current_user.parent_profile.student_associations 
            if assoc.verification_status == 'verified' and assoc.student # Ensure student exists
        ]
        children_list = [assoc.student for assoc in verified_associations]
        
        if children_list:
            child_ids = [child.id for child in children_list]
            recent_behavior_records_for_children = db.session.scalars(
                select(BehaviorRecord)
                .where(BehaviorRecord.student_id.in_(child_ids))
                .options(joinedload(BehaviorRecord.student)) # Eager load student for display in record
                .order_by(BehaviorRecord.date.desc())
                .limit(5) # Limit for dashboard snippet
            ).all()

    return render_template(
        "parent/dashboard.html",
        title="Parent Dashboard - Nexus",
        children=children_list,
        recent_behavior_records=recent_behavior_records_for_children
    )
@app.route("/library")
@login_required
# Student can see their borrowed books. Librarian view redirects to list_checkouts.
@role_required("student", "librarian") 
def view_library():
    if current_user.role.name.lower() == "student":
        # Ensure BorrowedAsset and its relationships (asset, asset.category) are loaded
        checkouts = db.session.scalars(
            select(BorrowedAsset) # Using BorrowedAsset, as per student dashboard and models
            .where(
                BorrowedAsset.user_id == current_user.id,
                BorrowedAsset.returned == False
            )
            .options(joinedload(BorrowedAsset.asset).joinedload(Asset.category))
            .order_by(BorrowedAsset.due_date.asc())
        ).all()
        # The template "student/library_view.html" needs to be created if not already.
        # For now, let's assume it's similar to a simplified list_checkouts or uses _book_checkout_item.
        # If "student/library_view.html" does not exist, you might need to create it or reuse parts of list_checkouts.
        # For simplicity, let's assume it expects 'checkouts' and can iterate them.
        # If student/library_view.html was intended to list BookCheckout model items,
        # then query BookCheckout instead of BorrowedAsset.
        # Given the backend definition used BorrowedAsset for student dashboard, let's stick to it.
        # If the student dashboard used BookCheckout then query BookCheckout here.
        # *** Assuming `student/library_view.html` will use `_book_checkout_item.html` for consistency. ***
        # This means we should pass BookCheckout objects, not BorrowedAsset.
        
        book_checkouts = db.session.scalars(
            select(BookCheckout) # QUERYING BookCheckout FOR CONSISTENCY WITH _book_checkout_item.html
            .where(
                BookCheckout.user_id == current_user.id,
                BookCheckout.returned == False
            )
            .options(joinedload(BookCheckout.asset).joinedload(Asset.category), joinedload(BookCheckout.user)) # User is already current_user but good for partial
            .order_by(BookCheckout.due_date.asc())
        ).all()

        return render_template("student/library_view.html", 
                               checkouts=book_checkouts, # Pass BookCheckout objects
                               title="My Borrowed Books - Nexus")

    elif current_user.role.name.lower() == "librarian":
        return redirect(url_for('list_checkouts'))
    
    abort(403) # Should not be reached


# --- PART 6 END ---

# --- PART 7 START: Teacher/Librarian Specific Features ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Attendance, StaffAttendance, Mark, TeacherProfile, Asset, Lab, BehaviorRecord, AssetCategory, BookCheckout, BorrowedAsset are defined.
# - Forms: BehaviorRecordForm, AttendanceForm, AssignLeaderForm, BookCheckoutForm are defined.
# - Helpers: update_ranks_for_subject (defined before enter_marks), can_view_behavior_records, notify_student_and_parents, get_user_assets_query are defined.
# - role_required decorator is defined.
# - url_for, request, flash, render_template, redirect, abort, jsonify are available.

# --- Teacher Specific Routes (Marks, Attendance, Lab) ---

# Helper function to update ranks for a subject (Needed by enter_marks)
def update_ranks_for_subject(subject_name):
    """Calculates and updates ranks for all students for a given subject based on average marks."""
    # Ensure app context for DB operations if this function is called outside a request context
    # If only called within request handlers (like enter_marks POST), app_context is implicit.
    # Adding it defensively if there's a CLI command or background task that uses this.
    with app.app_context():
        try:
            # Select relevant marks, calculate rank using a window function
            ranked_marks_stmt = (
                select(
                    Mark.id,
                    over(func.rank(), order_by=Mark.average.desc()).label("new_rank")
                )
                .where(Mark.subject == subject_name, Mark.average.isnot(None))
                .subquery() # Use subquery to get ranks
            )

            # Update the Mark table using the ranks from the subquery
            stmt = (
                db.update(Mark)
                .where(Mark.id == ranked_marks_stmt.c.id) # Join condition to subquery
                .values(rank=ranked_marks_stmt.c.new_rank)
            )
            result = db.session.execute(stmt)

            # Update students who have no average (set rank to None)
            stmt_clear_rank = (
                 db.update(Mark)
                 .where(Mark.subject == subject_name, Mark.average.is_(None))
                 .values(rank=None)
            )
            db.session.execute(stmt_clear_rank)

            # Commit the rank updates
            db.session.commit()

            app.logger.info(
                f"Ranks updated for subject '{subject_name}'. {result.rowcount} students ranked."
            )
        except Exception as e:
            # Rollback only the rank updates if an error occurs here
            db.session.rollback()
            app.logger.error(f"Error updating ranks for subject '{subject_name}': {e}", exc_info=True)
            # Optionally re-raise or flash a message


@app.route("/teacher/marks", methods=["GET", "POST"])
@login_required
@role_required("teacher")
def enter_marks():
    """Allows teachers to enter and update marks for their students and subject."""
    # Assuming a teacher is primarily associated with one profile/class/subject for marks entry
    teacher_profile = current_user.teacher_profiles.filter(
        TeacherProfile.subject.isnot(None),
        TeacherProfile.grade.isnot(None),
        TeacherProfile.section.isnot(None)
    ).first()

    if (
        not teacher_profile
        or not teacher_profile.grade
        or not teacher_profile.section
        or not teacher_profile.subject
    ):
        flash(
            "Your teacher profile is incomplete (grade, section, or subject missing). Please contact an administrator.",
            "warning",
        )
        return redirect(url_for("teacher_dashboard"))

    # Get active students in this teacher's assigned grade and section
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.grade == teacher_profile.grade,
            User.section == teacher_profile.section,
            User.is_active == True,
        )
        .order_by(User.full_name)
    ).all()

    # The subject for marks entry is determined by the teacher's profile
    subject_taught = teacher_profile.subject

    # Pre-fetch existing marks for these students and this subject to display
    existing_marks_map = {}
    if students:
        student_ids = [s.id for s in students]
        if student_ids: # Prevent empty IN clause in query
             existing_marks_records = db.session.scalars(
                 select(Mark).where(
                     Mark.student_id.in_(student_ids), Mark.subject == subject_taught
                 )
             ).all()
             # Map records by student_id for easy lookup in template
             for mark_record in existing_marks_records:
                 existing_marks_map[mark_record.student_id] = mark_record

    # No WTForms form instance is strictly needed for validation here as data is read directly from request.form
    # However, you *could* define a FormField with fields for s1, s2, etc., and use a FieldList.
    # For consistency with the provided POST handling pattern, we read request.form directly.

    if request.method == "POST":
        marks_to_process = []
        validation_errors = {} # Dictionary to store validation errors per student

        # Process submitted data directly from request.form
        for student in students:
            student_id = student.id
            # Get scores as strings, strip whitespace
            s1_str = request.form.get(f"semester_1_{student_id}", "").strip()
            s2_str = request.form.get(f"semester_2_{student_id}", "").strip()

            s1 = None
            s2 = None
            current_student_errors = [] # List for errors specific to this student

            # Attempt to convert to float, handle empty strings and invalid formats
            try:
                if s1_str:
                    s1 = float(s1_str)
                    if not (0 <= s1 <= 100):
                        current_student_errors.append("Semester 1 score must be between 0 and 100.")
                        s1 = None # Treat as invalid if out of range
            except ValueError:
                if s1_str: # Only add error if input wasn't empty
                    current_student_errors.append("Invalid format for Semester 1 score.")

            try:
                if s2_str:
                    s2 = float(s2_str)
                    if not (0 <= s2 <= 100):
                        current_student_errors.append("Semester 2 score must be between 0 and 100.")
                        s2 = None # Treat as invalid if out of range
            except ValueError:
                if s2_str: # Only add error if input wasn't empty
                    current_student_errors.append("Invalid format for Semester 2 score.")

            # Store parsed data (even if None) and any errors for this student
            marks_to_process.append({"student_id": student_id, "s1": s1, "s2": s2})
            if current_student_errors:
                 validation_errors[student_id] = current_student_errors


        if validation_errors:
             # If there are any validation errors for any student, flash them and re-render
             for student_id, errors in validation_errors.items():
                 # Find the student object again to display name
                 student = next((s for s in students if s.id == student_id), None)
                 student_name = student.full_name or student.username if student else f"Student ID {student_id}"
                 for err in errors:
                      flash(f"Error for {student_name}: {err}", "danger")

             # Re-render the page. Submitted data will be available in request.form for the template.
             return render_template(
                 "teacher/marks.html",
                 students=students,
                 subject_taught=subject_taught,
                 existing_marks_map=existing_marks_map, # Pass existing for comparison on re-render
                 validation_errors=validation_errors, # Pass errors to template for field highlighting
                 title=f"Enter Marks for {subject_taught}",
             )

        # If no validation errors, proceed to save to database
        try:
            for mark_data in marks_to_process:
                student_id = mark_data["student_id"]
                s1 = mark_data["s1"]
                s2 = mark_data["s2"]

                # Calculate total and average only if BOTH scores are numeric (not None)
                total = None
                average = None
                if s1 is not None and s2 is not None:
                    total = s1 + s2
                    average = total / 2.0
                # If only one score is provided, leave total/avg as None

                # Find or create attendance record for this student and date
                # Use db.session.scalar and filter_by for unique lookup (student+subject)
                record = db.session.scalar(
                    select(Mark).filter_by(student_id=student_id, subject=subject_taught)
                )

                if record:  # Update existing record
                    # Only update if the input field was not empty.
                    # This allows teacher to submit only S1 or only S2 at different times.
                    if request.form.get(f"semester_1_{student_id}", "").strip():
                         record.semester_1 = s1
                    if request.form.get(f"semester_2_{student_id}", "").strip():
                         record.semester_2 = s2

                    # Recalculate total and average based on current (potentially updated) S1 and S2
                    if record.semester_1 is not None and record.semester_2 is not None:
                        record.total = record.semester_1 + record.semester_2
                        record.average = record.total / 2.0
                    else:
                        record.total = None
                        record.average = None


                else:  # Create new record
                    # Only create if at least one score was successfully parsed and provided
                    if request.form.get(f"semester_1_{student_id}", "").strip() or request.form.get(f"semester_2_{student_id}", "").strip():
                         # Calculate initial total and average if both are present on creation
                         initial_total = s1 + s2 if s1 is not None and s2 is not None else None
                         initial_average = initial_total / 2.0 if initial_total is not None else None

                         record = Mark(
                             student_id=student_id,
                             subject=subject_taught,
                             semester_1=s1,
                             semester_2=s2,
                             total=initial_total,
                             average=initial_average,
                         )
                         db.session.add(record)

                # Ranks are updated separately after the commit

            db.session.commit()

            # Update ranks for this subject AFTER all marks for it are committed
            update_ranks_for_subject(subject_taught) # This function handles its own commit/rollback

            flash(f"Marks for {subject_taught} entered successfully!", "success")
            app.logger.info(
                f"Marks for {subject_taught} updated by {current_user.username} for Grade {teacher_profile.grade}, Section {teacher_profile.section}"
            )
            # Redirect to refresh the page and show updated data/ranks
            return redirect(url_for("enter_marks"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(
                f"Error saving marks for {subject_taught} by {current_user.username}: {e}", exc_info=True
            )
            flash(
                "An unexpected error occurred while saving marks. Please try again.", "danger"
            )
            # Re-render form with submitted data (available in request.form) and error message
            # Need to re-fetch existing marks map for template rendering
            existing_marks_records_after_error = db.session.scalars(
                 select(Mark).where(
                     Mark.student_id.in_(student_ids), Mark.subject == subject_taught
                 )
             ).all()
            existing_marks_map_after_error = {mark_record.student_id: mark_record for mark_record in existing_marks_records_after_error}

            return render_template(
                 "teacher/marks.html",
                 students=students,
                 subject_taught=subject_taught,
                 existing_marks_map=existing_marks_map_after_error, # Pass re-fetched map
                 validation_errors={}, # No input validation errors here, only DB error
                 title=f"Enter Marks for {subject_taught}",
             )


    # For GET request, render the template
    # existing_marks_map is used to pre-fill the form elements in the template
    return render_template(
        "teacher/marks.html",
        students=students,
        subject_taught=subject_taught,
        existing_marks_map=existing_marks_map, # Pass map for pre-filling
        validation_errors={}, # No errors on GET
        title=f"Enter Marks for {subject_taught}",
    )


@app.route("/teacher/attendance", methods=["GET", "POST"])
@login_required
@role_required("teacher")
def mark_attendance():
    """Allows teachers to mark student attendance for their class."""
    # Assuming a teacher is primarily associated with one profile/class for attendance
    teacher_profile = current_user.teacher_profiles.filter(
        TeacherProfile.grade.isnot(None),
        TeacherProfile.section.isnot(None)
    ).first() # Get the first profile if multiple

    if not teacher_profile or not teacher_profile.grade or not teacher_profile.section:
        flash(
            "Your teacher profile is incomplete (grade or section missing). Please contact an administrator.",
            "warning",
        )
        return redirect(url_for("teacher_dashboard"))

    # Get active students in this teacher's assigned grade and section
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.grade == teacher_profile.grade,
            User.section == teacher_profile.section,
            User.is_active == True,
        )
        .order_by(User.full_name)
    ).all()

    # Handle invalid grade/section if no students are found for some reason
    if not students:
         flash(f"No active students found for Grade {teacher_profile.grade}, Section {teacher_profile.section}.", "warning")
         return redirect(url_for('teacher_dashboard')) # Redirect teacher back


    # Determine the date for attendance. Use request.args.get('date') for GET requests/redirects
    attendance_date_str = request.args.get(
        "date", datetime.now(timezone.utc).strftime("%Y-%m-%d")
    )
    try:
        # Validate the date string from args
        attendance_date_obj = datetime.strptime(attendance_date_str, "%Y-%m-%d").date()
        # Prevent viewing future dates
        if attendance_date_obj > datetime.now(timezone.utc).date():
            flash("Cannot view attendance for future dates.", "warning")
            attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
            attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string

    except ValueError:
        flash(
            "Invalid date format provided in URL. Using today's date.", # Clarify it's from URL
            "warning",
        )
        attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
        attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string

    # Pre-fetch existing attendance records for the determined date and students
    # Use the correct Attendance model (student attendance)
    existing_records = db.session.scalars(
        select(Attendance).where(
            Attendance.student_id.in_([s.id for s in students]), # Filter by student IDs
            Attendance.date == attendance_date_obj # Filter by date
        )
    ).all()

    # Map existing records by student_id for easy lookup in template
    existing_attendance_map = {record.student_id: record for record in existing_records}

    # Instantiate the form. Pass the students list to the form's __init__
    # This is primarily for the template to correctly generate the FieldList structure,
    # as data processing happens via request.form directly.
    form = AttendanceForm(students=students) # Pass students list

    if request.method == "POST":
        # Re-validate the date from the POST form data (hidden field or similar)
        form_date_str = request.form.get("date")
        try:
            date_for_marking = datetime.strptime(form_date_str, "%Y-%m-%d").date()
            if date_for_marking > datetime.now(timezone.utc).date():
                flash("Cannot mark attendance for future dates.", "danger")
                # Redirect back with the invalid date string, preserving it in the URL
                return redirect(url_for("mark_attendance", date=form_date_str))
        except (ValueError, TypeError): # TypeError if form_date_str is None
            flash("Invalid date format submitted. Please use YYYY-MM-DD.", "danger")
            # Redirect back, defaulting date to today's format
            return redirect(url_for("mark_attendance")) # Defaults to today's date


        try:
            # Process form data directly from request.form
            # Loop through students to find their status and notes in the POST data
            valid_statuses = ["Present", "Absent", "Late", "Excused"]
            students_processed = 0

            for student in students:
                student_id = student.id
                # Status field names are e.g., status_123, notes_123 (matching template)
                status = request.form.get(f"status_{student_id}")
                notes = request.form.get(f"notes_{student_id}", "").strip()

                # Basic validation: ensure status is one of the valid options
                if status not in valid_statuses:
                     # This indicates unexpected input, likely manipulation
                     app.logger.warning(f"Invalid status '{status}' submitted for student {student_id} by teacher {current_user.username}.")
                     flash(f"Invalid attendance status submitted for {student.full_name or student.username}. Please re-select.", "danger")
                     # Rollback any changes made in this batch and redirect
                     db.session.rollback()
                     return redirect(url_for("mark_attendance", date=form_date_str)) # Redirect back to the form with errors

                # Enforce notes max length
                if len(notes) > 255:
                    app.logger.warning(f"Notes too long for student {student_id} by teacher {current_user.username}.")
                    flash(f"Notes for {student.full_name or student.username} are too long (max 255 characters).", "danger")
                    db.session.rollback() # Rollback
                    return redirect(url_for("mark_attendance", date=form_date_str))


                # Find or create attendance record for this student and date
                # Use db.session.scalar and filter_by for this unique constraint lookup (_student_date_uc)
                record = db.session.scalar(
                    select(Attendance).filter_by(student_id=student_id, date=date_for_marking)
                )

                if record: # Update existing record
                    record.status = status
                    record.notes = notes
                else: # Create new record
                    new_attendance_record = Attendance(
                        student_id=student_id,
                        date=date_for_marking,
                        status=status,
                        notes=notes,
                    )
                    db.session.add(new_attendance_record)

                students_processed += 1

            db.session.commit() # Commit all changes in one transaction

            flash(
                f"Attendance for {date_for_marking.strftime('%Y-%m-%d')} marked successfully for {students_processed} student(s)!",
                "success",
            )
            app.logger.info(
                f"Attendance for {date_for_marking} (Grade {teacher_profile.grade}-{teacher_profile.section}) updated by teacher {current_user.username}. {students_processed} records processed."
            )
            # Redirect back to the same date's attendance page
            return redirect(
                url_for(
                    "mark_attendance",
                    date=date_for_marking.strftime("%Y-%m-%d"),
                )
            )

        except IntegrityError:
            db.session.rollback()
            # This error should ideally be prevented by the find-or-create logic,
            # but it's a fallback.
            app.logger.error(f"Attendance IntegrityError for {date_for_marking}, Grade {teacher_profile.grade}, Section {teacher_profile.section} by {current_user.username}: potentially duplicate entry attempt.", exc_info=True)
            flash(
                "Error saving attendance: A record for one or more students might already exist for this date. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            # Need to re-fetch existing marks map for template rendering on error re-render
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_(student_ids), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "teacher/attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )


        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error saving attendance for {date_for_marking}, Grade {teacher_profile.grade}, Section {teacher_profile.section} by {current_user.username}: {e}", exc_info=True)
            flash(
                "An unexpected error occurred while saving attendance. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_(student_ids), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "teacher/attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )


    # For GET request or failed POST validation/error, render the template
    # existing_attendance_map is used to pre-fill the form elements in the template
    # Pass the form instance to ensure the FieldList structure is available to the template
    return render_template(
        "teacher/attendance.html",
        form=form,
        students=students,
        attendance_date_str=attendance_date_str, # Pass the date string for the input field value
        existing_attendance_map=existing_attendance_map, # Pass map for pre-filling
        title="Mark Attendance",
    )

@app.route("/teacher/lab_equipment")
@login_required
@role_required("teacher")
def teacher_lab_equipment():
    """Displays equipment assigned to the teacher's lab."""
    # Check if teacher is assigned to a lab via lab_id (column added in Part 2)
    if not current_user.lab_id:
        flash("You are not currently assigned to a lab.", "info")
        return redirect(url_for("teacher_dashboard"))

    # Fetch equipment belonging to the teacher's lab (Asset model filtering by lab_id)
    lab_equipment = db.session.scalars(
        select(Asset).where(Asset.lab_id == current_user.lab_id).order_by(Asset.name)
    ).all()

    # Fetch the Lab object to get the name easily
    lab = db.session.get(Lab, current_user.lab_id)
    lab_name = lab.name if lab else "Unknown Lab"

    app.logger.info(
        f"Teacher {current_user.username} (ID: {current_user.id}) accessed equipment for lab {lab_name} (ID: {current_user.lab_id}). Found {len(lab_equipment)} assets."
    )

    return render_template(
        "teacher/lab_equipment.html",
        lab_equipment=lab_equipment,
        lab_name=lab_name,
        title=f"Equipment in {lab_name}",
    )


# --- Librarian Specific Routes ---

@app.route("/librarian/attendance")
@login_required
@role_required("librarian")
def librarian_attendance():
    """Librarian view of student attendance and related stats per class."""
    # Get all distinct grade-section pairs for student attendance tracking
    # Filter for active students who have a grade and section
    stmt = (
        select(User.grade, User.section)
        .join(Role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade.isnot(None),
            User.section.isnot(None)
        )
        .distinct() # Get unique pairs
        .order_by(User.grade, User.section) # Order for display
    )

    grade_section_pairs = db.session.execute(stmt).all()
    today = datetime.now(timezone.utc).date()

    # Calculate attendance statistics for today for each class
    attendance_stats = {}
    # Fetch role and category IDs once for efficiency in the loop
    student_role_id = db.session.scalar(select(Role.id).where(Role.name == "student"))
    book_category_id = db.session.scalar(select(AssetCategory.id).filter_by(name="Books"))

    for grade, section in grade_section_pairs:
        # Total active students in this specific grade-section
        total_students = db.session.scalar(
            select(func.count(User.id)).where(
                User.grade == grade,
                User.section == section,
                User.is_active == True,
                User.role_id == student_role_id # Filter by role ID
            )
        ) or 0 # Default to 0 if count is None

        # Present students for today in this grade-section (using the Attendance model)
        present_students_count = db.session.scalar(
            select(func.count(Attendance.id)).join(User).where( # Join User to filter by grade/section
                Attendance.date == today,
                Attendance.status == "Present", # Use status for student attendance
                User.grade == grade,
                User.section == section,
                User.is_active == True, # Ensure the student is active
            )
        ) or 0

        # Overdue book checkouts count for students in this grade-section
        overdue_books = 0
        if book_category_id: # Only check if book category exists
             overdue_books = db.session.scalar(
                 select(func.count(BookCheckout.id)) # Count checkouts
                 .join(User) # Join to filter by student's grade/section
                 .join(Asset) # Join to filter by asset category
                 .where(
                     BookCheckout.returned == False, # Not returned
                     BookCheckout.due_date < today, # Due date is in the past
                     User.grade == grade,
                     User.section == section,
                     User.is_active == True, # Ensure the student is active
                     Asset.category_id == book_category_id # Filter by book category
                 )
             ) or 0

        # Store stats using a composite key like "grade_section"
        attendance_stats[f"{grade}_{section}"] = {
            "total": total_students,
            "present": present_students_count,
            "absent": total_students - present_students_count, # Simple absent count
            "overdue_books": overdue_books,
            "percentage_present": (present_students_count / total_students * 100) if total_students else 0 # Percentage calc
        }

    # Pass sorted pairs and stats to the template
    # The template can iterate through grade_section_pairs and use the corresponding stats
    return render_template(
        "librarian/attendance_dashboard.html",
        grade_section_pairs=grade_section_pairs, # List of tuples (grade, section)
        attendance_stats=attendance_stats, # Dict keyed by "grade_section" string
        today=today,
        title="Student Attendance Overview",
    )


@app.route("/librarian/attendance/take/<string:grade>/<string:section>", methods=["GET", "POST"]) # Explicitly string type
@login_required
@role_required("librarian")
def take_attendance(grade, section):
    """Allows librarians to mark student attendance for a specific class."""
    # Get active students in this specific grade-section
    student_role = db.session.scalar(select(Role).where(Role.name == "student"))
    # Ensure student role exists and fetch students
    if not student_role:
         flash("Student role not found. Cannot take attendance.", "danger")
         return redirect(url_for('librarian_attendance')) # Redirect back to attendance dashboard

    students = db.session.scalars(
        select(User).where(
            User.grade == grade,
            User.section == section,
            User.is_active == True, # Only active students
            User.role == student_role # Filter by role object or role_id
        ).order_by(User.full_name) # Order students alphabetically
    ).all()

    # Handle invalid grade/section if no active students are found
    if not students:
         flash(f"No active students found for Grade {grade}, Section {section}.", "warning")
         return redirect(url_for('librarian_attendance')) # Redirect back


    # Determine the date for attendance marking
    # Use request.args.get('date') for GET requests/redirects from URL query
    attendance_date_str = request.args.get(
        "date", datetime.now(timezone.utc).strftime("%Y-%m-%d")
    )
    try:
        # Validate the date string from args
        attendance_date_obj = datetime.strptime(attendance_date_str, "%Y-%m-%d").date()
        # Prevent marking/viewing future dates
        if attendance_date_obj > datetime.now(timezone.utc).date():
            flash("Cannot mark attendance for future dates.", "warning")
            attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
            attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string

    except ValueError:
        flash(
            "Invalid date format provided in URL. Using today's date.",
            "warning",
        )
        attendance_date_obj = datetime.now(timezone.utc).date() # Reset to today
        attendance_date_str = attendance_date_obj.strftime("%Y-%m-%d") # Update string


    # Pre-fetch existing attendance records for the determined date and students
    existing_records = db.session.scalars(
        select(Attendance).where(
            Attendance.student_id.in_([s.id for s in students]), # Filter by student IDs
            Attendance.date == attendance_date_obj # Filter by date
        )
    ).all()

    # Map existing records by student_id for easy lookup in template
    existing_attendance_map = {record.student_id: record for record in existing_records}

    # Instantiate the form. Pass the students list to the form's __init__
    # This is needed for the template to correctly generate the FieldList structure,
    # even though data processing happens via request.form directly.
    form = AttendanceForm(students=students)

    if request.method == "POST":
        # Re-validate the date from the POST form data (e.g., a hidden input field)
        form_date_str = request.form.get("date")
        try:
            date_for_marking = datetime.strptime(form_date_str, "%Y-%m-%d").date()
            # Prevent marking future dates from POST data as well
            if date_for_marking > datetime.now(timezone.utc).date():
                flash("Cannot mark attendance for future dates.", "danger")
                # Redirect back with the invalid date string, preserving it
                return redirect(url_for("take_attendance", grade=grade, section=section, date=form_date_str))
        except (ValueError, TypeError):
            flash("Invalid date format submitted. Please use YYYY-MM-DD.", "danger")
            # Redirect back, defaulting date to today
            return redirect(url_for("take_attendance", grade=grade, section=section))


        try:
            # Process form data directly from request.form
            valid_statuses = ["Present", "Absent", "Late", "Excused"]
            students_processed = 0

            for student in students:
                student_id = student.id
                # Status field names are e.g., status_123, notes_123 (matching template)
                status = request.form.get(f"status_{student_id}")
                notes = request.form.get(f"notes_{student_id}", "").strip()

                # Basic validation: ensure status is one of the valid options
                if status not in valid_statuses:
                     app.logger.warning(f"Invalid status '{status}' submitted for student {student_id} by librarian {current_user.username}.")
                     flash(f"Invalid attendance status submitted for {student.full_name or student.username}. Please re-select.", "danger")
                     db.session.rollback() # Rollback any changes made in this batch
                     # Redirect back, preserving the date and class context
                     return redirect(url_for("take_attendance", grade=grade, section=section, date=form_date_str))


                # Enforce notes max length
                if len(notes) > 255:
                    app.logger.warning(f"Notes too long for student {student_id} by librarian {current_user.username}.")
                    flash(f"Notes for {student.full_name or student.username} are too long (max 255 characters).", "danger")
                    db.session.rollback() # Rollback
                    return redirect(url_for("take_attendance", grade=grade, section=section, date=form_date_str))

                # Find or create attendance record for this student and date
                # Use db.session.scalar and filter_by for this unique constraint lookup (_student_date_uc)
                record = db.session.scalar(
                    select(Attendance).filter_by(student_id=student_id, date=date_for_marking)
                )

                if record: # Update existing record
                    record.status = status
                    record.notes = notes
                else: # Create new record
                    new_attendance_record = Attendance(
                        student_id=student_id,
                        date=date_for_marking,
                        status=status,
                        notes=notes,
                    )
                    db.session.add(new_attendance_record)

                students_processed += 1


            db.session.commit() # Commit all changes in one transaction

            flash(
                f"Attendance for {date_for_marking.strftime('%Y-%m-%d')} marked successfully for {students_processed} student(s)!",
                "success",
            )
            app.logger.info(
                f"Attendance for {date_for_marking} (Grade {grade}-{section}) updated by librarian {current_user.username}. {students_processed} records processed."
            )
            # Redirect back to the same date's attendance page for the same class
            return redirect(
                url_for(
                    "take_attendance",
                    grade=grade,
                    section=section,
                    date=date_for_marking.strftime("%Y-%m-%d"),
                )
            )

        except IntegrityError:
            db.session.rollback()
            # This error should ideally be prevented by the find-or-create logic, but it's a fallback.
            app.logger.error(f"Attendance IntegrityError for {date_for_marking}, Grade {grade}, Section {section} by {current_user.username}: potentially duplicate entry attempt.", exc_info=True)
            flash(
                "Error saving attendance: A record for one or more students might already exist for this date. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            # Need to re-fetch existing records map on error re-render
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_([s.id for s in students]), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "librarian/take_attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error saving attendance for {date_for_marking}, Grade {grade}, Section {section} by {current_user.username}: {e}", exc_info=True)
            flash(
                "An unexpected error occurred while saving attendance. Please try again.",
                "danger",
            )
            # Re-render form with submitted data (available in request.form) and error message
            existing_records_after_error = db.session.scalars(
                 select(Attendance).where(
                     Attendance.student_id.in_([s.id for s in students]), Attendance.date == date_for_marking
                 )
             ).all()
            existing_attendance_map_after_error = {record.student_id: record for record in existing_records_after_error}

            return render_template(
                 "librarian/take_attendance.html",
                 form=form, # Pass the form instance (empty of data but keeps structure)
                 students=students, # Pass students list
                 attendance_date_str=date_for_marking.strftime("%Y-%m-%d"), # Pass the date string
                 existing_attendance_map=existing_attendance_map_after_error, # Pass map for pre-filling
                 title="Mark Attendance",
             )


    # For GET request or failed POST validation/error, render the template
    # existing_attendance_map is used to pre-fill the form elements in the template
    # Pass the form instance to ensure the FieldList structure is available to the template
    return render_template(
        "librarian/take_attendance.html",
        form=form,
        students=students,
        grade=grade, # Pass grade for template
        section=section, # Pass section for template
        attendance_date_str=attendance_date_str, # Pass the date string for the input field value
        existing_attendance_map=existing_attendance_map, # Pass map for pre-filling
        title=f"Mark Attendance - Grade {grade}, Section {section}",
    )

@app.route("/librarian/student/<int:user_id>")
@login_required
@role_required("librarian")
def librarian_student_profile(user_id):
    student = db.get_or_404(User, user_id, description="Student user not found.")
    if not student.role or student.role.name.lower() != 'student':
        flash("The specified user is not a student.", "warning")
        abort(404) # Or redirect

    # Current Book Checkouts for this student (using BookCheckout, not BorrowedAsset for consistency with form)
    current_checkouts = db.session.scalars(
        select(BookCheckout) # Use BookCheckout
        .where(
            BookCheckout.user_id == student.id,
            BookCheckout.returned == False
        )
        .options(joinedload(BookCheckout.asset).joinedload(Asset.category)) # Load asset info
        .order_by(BookCheckout.due_date.asc())
    ).all()
    
    # Other data the template might show (already fetched in your Part 7 for this route)
    # For simplicity, let's assume the template focuses on checkouts.
    # recent_attendance = db.session.scalars(...).all()
    # recent_behavior_records = db.session.scalars(...).all()
    # recent_marks = db.session.scalars(...).all()


    return render_template(
        "librarian/student_profile.html",
        student=student,
        current_checkouts=current_checkouts, # Pass current checkouts
        # Pass other data if your template uses it:
        # recent_attendance=recent_attendance,
        # recent_behavior_records=recent_behavior_records,
        # recent_marks=recent_marks,
        title=f"Student Library Profile: {student.full_name or student.username} - Nexus"
    )

# Missing endpoint for returning a book from this profile view (can implement similar to /books/return)
# @app.route("/librarian/student/<int:user_id>/return_book/<int:checkout_id>", methods=["POST"])
# @login_required
# @role_required("librarian")
# def librarian_return_book_from_profile(user_id, checkout_id):
#      # Logic to find and mark the BorrowedAsset record as returned
#      # Update asset quantity
#      # Commit changes
#      # Redirect back to librarian_student_profile(user_id)
#      pass


# --- PART 7 END ---

# --- PART 8 START: HR/CEO & System Admin Management Features ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, TeacherProfile, Asset, AssetReport, AssetCategory, Lab, BehaviorRecord, Mark are defined.
# - Forms: AddAssetForm, ReportAssetForm, EditAssetForm, ResolveReportForm, AddCategoryForm, EditCategoryForm, BehaviorRecordForm, AssignLeaderForm are defined.
# - Helpers: get_user_assets_query, notify_hr_ceo_new_asset, notify_hr_ceo_new_report, notify_reporter_report_update, can_view_behavior_records, notify_student_and_parents, save_profile_photo, update_ranks_for_subject (used in teacher routes but defined earlier).
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, joinedload, etc.), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, os, uuid, secure_filename) are available.


# --- HR/CEO Student Database Routes ---
@app.route("/database/students")
@login_required
@role_required("hr_ceo", "system_admin", "teacher") # Allow teachers to see the index
def student_database_index():
    # Valid grades to display blocks for (can be made dynamic or configurable)
    # VALID_GRADES_FOR_DB_VIEW = ["9", "10", "11", "12"] # Or fetch distinct grades from User table

    # Fetch distinct, active grade/section pairs where students exist
    active_student_blocks_query = (
        select(User.grade, User.section)
        .join(User.role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade.isnot(None), User.grade != '', # Ensure grade has a value
            User.section.isnot(None), User.section != '' # Ensure section has a value
            # User.grade.in_(VALID_GRADES_FOR_DB_VIEW) # Optional: Filter by predefined valid grades
        )
        .distinct()
        .order_by(User.grade.asc(), User.section.asc()) # Order for display
    )
    grade_section_pairs = db.session.execute(active_student_blocks_query).all() # List of (grade, section) tuples

    grouped_blocks = defaultdict(list) # To group sections under each grade
    if grade_section_pairs:
        for grade_val, section_val in grade_section_pairs:
            # For each block, find subjects taught by active teachers in that specific grade/section
            subjects_taught_in_block_query = (
                select(TeacherProfile.subject)
                .join(TeacherProfile.user_obj) # Assuming relationship name from User to TeacherProfile on TeacherProfile model is 'user_obj' or similar. Adjust if different. Or join via User.id == TeacherProfile.user_id
                .join(User.role)
                .where(
                    Role.name == "teacher",
                    User.is_active == True,
                    TeacherProfile.grade == grade_val,
                    TeacherProfile.section == section_val,
                    TeacherProfile.subject.isnot(None), TeacherProfile.subject != ''
                )
                .distinct()
                .order_by(TeacherProfile.subject.asc())
            )
            subjects = db.session.scalars(subjects_taught_in_block_query).all()
            
            grouped_blocks[grade_val].append({
                "section": section_val,
                "subjects": subjects if subjects else [] # Ensure it's a list
            })

    # Sort by grade keys (though defaultdict might preserve insertion order for modern Python)
    # Then sort sections within each grade (already done by the initial query order)
    ordered_grouped_blocks = {grade: sorted(sections, key=lambda s: s['section']) for grade, sections in sorted(grouped_blocks.items())}


    return render_template(
        "Database/students/index.html", # Correct template path
        ordered_grouped_blocks=ordered_grouped_blocks,
        # valid_grades=VALID_GRADES_FOR_DB_VIEW, # If you pass this to template for other UI
        title="Student Database Index - Nexus"
    )
    
@app.route("/database/students/<string:grade>/<string:section>") # Ensure grade/section are strings
@login_required
@role_required("hr_ceo", "system_admin", "teacher")
def student_database_block(grade, section):
    # Permission check for teachers: Can only view their assigned grade/section block(s)
    if current_user.role.name.lower() == 'teacher':
        # Check if any of the teacher's profiles match this grade and section
        can_view_block = db.session.scalar(
            select(TeacherProfile).where(
                TeacherProfile.user_id == current_user.id,
                TeacherProfile.grade == grade,
                TeacherProfile.section == section
            ).exists()
        )
        if not can_view_block:
            flash("You do not have permission to view this student block.", "danger")
            return redirect(url_for('student_database_index')) # Or teacher_dashboard

    # Fetch active students in the specified grade and section
    students_in_block_query = (
        select(User)
        .join(User.role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade == grade,
            User.section == section
        )
        .options(joinedload(User.role)) # Eager load role for student info
        .order_by(User.full_name.asc())
    )
    students = db.session.scalars(students_in_block_query).all()

    if not students:
        flash(f"No active students found for Grade {grade}, Section {section}. This block might be empty or incorrectly specified.", "info")
        # Still render the page to show the message, or redirect
        # return redirect(url_for('student_database_index')) 

    return render_template(
        "Database/students/student_block.html", # Correct template path
        students=students,
        grade=grade,
        section=section,
        title=f"Students: Grade {grade} - Section {section} - Nexus"
    )

@app.route("/database/export_block/<string:grade>/<string:section>")
@login_required
@role_required("hr_ceo", "system_admin")
def export_block(grade, section):
    students = db.session.scalars(
        select(User)
        .join(Role)
        .where(
            Role.name == "student",
            User.is_active == True,
            User.grade == grade,
            User.section == section
        )
        .order_by(User.username)
    ).all()

    if not students:
        flash(f"No students to export for Grade {grade}, Section {section}.", "warning")
        return redirect(request.referrer or url_for("student_database_block", grade=grade, section=section))

    output = io.StringIO()
    writer = csv.writer(output)

    # CSV Header (Matches User model attributes and template output)
    writer.writerow([
        "ID", "USERNAME", "FULL_NAME", "FIRST_NAME", "LAST_NAME", "EMAIL", "GRADE", "SECTION",
        "DATE_OF_BIRTH", "GENDER", "PHONE", "ADDRESS", "IS_ACTIVE", "CREATED_AT", "LAST_LOGIN",
        "IS_LEADER", "IS_TC_MEMBER" # Added these relevant flags
    ])

    for student in students:
        writer.writerow([
            student.id,
            student.username or "",
            student.full_name or "",
            student.first_name or "",
            student.last_name or "",
            student.email or "",
            student.grade or "",
            student.section or "",
            student.date_of_birth.strftime('%Y-%m-%d') if student.date_of_birth else "",
            student.gender or "", # This was student.gender in your User model from app.py
            student.phone or "",
            student.address or "",
            "True" if student.is_active else "False",
            student.created_at.strftime('%Y-%m-%d %H:%M:%S') if student.created_at else "",
            student.last_login.strftime('%Y-%m-%d %H:%M:%S') if student.last_login else "",
            "True" if student.is_leader else "False",
            "True" if student.is_tc_member else "False"
        ])

    csv_data = output.getvalue()
    response = make_response(csv_data)
    export_filename = f"students_{grade}_{section}_export_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.csv"
    response.headers["Content-Disposition"] = f"attachment; filename={export_filename}"
    response.headers["Content-Type"] = "text/csv"

    app.logger.info(f"User {current_user.username} exported student data for Grade {grade}, Section {section}.")
    return response
# --- Behavior Record Management (HR/CEO, System Admin, School Executive) ---
# manage_student_behavior and view_student_behavior routes are defined in Part 6/7

# In Part 7, replace the entire `view_student_behavior_records` route and its subsequent behavior record routes with the following:

# --- Student Behavior Records (Universal View, Refined Recording/Editing/Deletion) ---

@app.route("/student/<int:user_id>/behavior_records")
@login_required
# No role_required here; the internal can_view_behavior_records helper
# will handle granular access based on the 'all can view' rule.
def view_student_behavior_records(user_id):
    """
    Allows authorized users to view a student's behavior records.
    Permissions handled by the `can_view_behavior_records` helper.
    """
    student = db.session.get(User, user_id)
    if not student or not student.is_active or (student.role and student.role.name.lower() != 'student'):
        abort(404, description="Student not found or is inactive.")

    # Check permission using the helper function (all authenticated users can view)
    if not can_view_behavior_records(current_user, student):
        flash("You do not have permission to view these behavior records.", "danger")
        app.logger.warning(f"Unauthorized view of behavior records for student {user_id} by user {current_user.id}.")
        return redirect(url_for('role_redirect'))

    # Fetch behavior records for the student, newest first
    records = db.session.scalars(
        select(BehaviorRecord)
        .where(BehaviorRecord.student_id == user_id)
        .options(joinedload(BehaviorRecord.recorded_by)) # Eager load who recorded it
        .order_by(BehaviorRecord.date.desc(), BehaviorRecord.id.desc())
    ).all()

    # Determine if the current user can add a record for this student
    can_add_record = current_user.is_authenticated and \
                     current_user.role and \
                     current_user.role.name.lower() in [
                         "teacher", "librarian", "talent_club", "hr_ceo",
                         "system_admin", "school_executive", "government", "parent"
                     ]

    # These flags will be used in the template to conditionally show/hide buttons for each record
    # based on the fine-grained permissions.
    # Note: `can_edit_any_record` and `can_delete_any_record` are global role permissions for the current user.
    # `can_edit_this_record` and `can_delete_this_record` will be per-record in the template.
    can_edit_any_record = current_user.role and current_user.role.name.lower() in ['hr_ceo', 'system_admin', 'school_executive']
    can_delete_any_record = current_user.role and current_user.role.name.lower() in ['hr_ceo', 'system_admin', 'school_executive']

    return render_template(
        "behavior/view_student_records.html",
        student=student,
        records=records,
        can_add_record=can_add_record,
        can_edit_any_record=can_edit_any_record,   # For UI logic for top-level roles
        can_delete_any_record=can_delete_any_record, # For UI logic for top-level roles
        title=f"{student.full_name}'s Behavior Records"
    )

@app.route("/student/<int:student_id>/behavior_records/add", methods=["GET", "POST"])
@login_required
# Ensure all roles that can record behavior are listed. Parent was added.
@role_required(
    "teacher", "librarian", "talent_club", "hr_ceo",
    "system_admin", "school_executive", "government", "parent" 
)
def add_behavior_record(student_id):
    student = db.get_or_404(User, student_id, description="Student not found.")
    if not student.role or student.role.name.lower() != 'student':
        flash("Cannot add behavior record: Target user is not a student.", "warning")
        return redirect(request.referrer or url_for('student_database_index')) # Or appropriate redirect

    form = BehaviorRecordForm() # Your BehaviorRecordForm

    if form.validate_on_submit():
        try:
            new_record = BehaviorRecord(
                student_id=student.id,
                recorded_by_id=current_user.id, # The logged-in user is the recorder
                date=datetime.now(timezone.utc), # Or allow form to set date if needed
                behavior_type=form.behavior_type.data,
                description=form.description.data.strip(),
                severity=form.severity.data,
                resolution=form.resolution.data.strip() if form.resolution.data else None,
                is_resolved=form.is_resolved.data,
            )
            db.session.add(new_record)
            db.session.commit()

            # notify_student_and_parents helper (from app.py Part 3) should be called
            notify_student_and_parents(student, new_record)

            flash(f"Behavior record for {student.full_name or student.username} added successfully.", "success")
            app.logger.info(f"User {current_user.username} added behavior record ID {new_record.id} for student {student.id}.")
            return redirect(url_for("view_student_behavior_records", user_id=student.id))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error adding behavior record for student {student.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while adding the record. Please try again.", "danger")
            
    return render_template(
        "behavior/add_edit_record.html", # Your template for adding/editing
        form=form,
        student=student,
        is_edit=False, # Flag for template to know it's "Add" mode
        title=f"Add Behavior Record for {student.full_name or student.username} - Nexus"
    )

@app.route("/behavior_records/edit/<int:record_id>", methods=["GET", "POST"])
@login_required
# Roles that can potentially edit (permission check inside)
@role_required(
    "teacher", "librarian", "talent_club", "hr_ceo",
    "system_admin", "school_executive", "government", "parent"
)
def edit_behavior_record(record_id):
    record = db.get_or_404(BehaviorRecord, record_id, description="Behavior record not found.")
    student = record.student # Get student for context and redirection

    # --- Permission Check ---
    admin_editor_roles = ['hr_ceo', 'system_admin', 'school_executive'] # Roles that can edit ANY record
    is_global_admin_editor = current_user.role and current_user.role.name.lower() in admin_editor_roles
    is_original_recorder = (record.recorded_by_id == current_user.id)

    if not (is_global_admin_editor or is_original_recorder):
        flash("You do not have permission to edit this behavior record.", "danger")
        app.logger.warning(f"Unauthorized edit attempt on behavior record {record_id} by user {current_user.username}.")
        return redirect(url_for("view_student_behavior_records", user_id=student.id))

    form = BehaviorRecordForm(obj=record) # Populate form with existing data

    if form.validate_on_submit():
        try:
            record.behavior_type = form.behavior_type.data
            record.description = form.description.data.strip()
            record.severity = form.severity.data
            record.resolution = form.resolution.data.strip() if form.resolution.data else None
            record.is_resolved = form.is_resolved.data
            # record.date could be made editable too if needed, or keep original record date
            # record.updated_at = datetime.now(timezone.utc) # If you track updates

            db.session.commit()
            flash(f"Behavior record ID {record.id} updated successfully.", "success")
            app.logger.info(f"User {current_user.username} edited behavior record ID {record.id} for student {student.id}.")
            return redirect(url_for("view_student_behavior_records", user_id=student.id))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing behavior record ID {record.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
            
    return render_template(
        "behavior/add_edit_record.html",
        form=form,
        student=student,
        record=record, # Pass record for context if template needs its ID etc.
        is_edit=True,  # Flag for template
        title=f"Edit Behavior Record for {student.full_name or student.username} - Nexus"
    )

@app.route("/behavior_records/delete/<int:record_id>", methods=["POST"]) # Should strictly be POST
@login_required
@role_required(
    "teacher", "librarian", "talent_club", "hr_ceo",
    "system_admin", "school_executive", "government", "parent"
)
def delete_behavior_record(record_id):
    record = db.get_or_404(BehaviorRecord, record_id, description="Behavior record not found.")
    student_id_for_redirect = record.student_id # Store before potential deletion

    # --- Permission Check ---
    admin_deleter_roles = ['hr_ceo', 'system_admin', 'school_executive']
    is_global_admin_deleter = current_user.role and current_user.role.name.lower() in admin_deleter_roles
    is_original_recorder = (record.recorded_by_id == current_user.id)

    if not (is_global_admin_deleter or is_original_recorder):
        flash("You do not have permission to delete this behavior record.", "danger")
        app.logger.warning(f"Unauthorized delete attempt on behavior record {record_id} by user {current_user.username}.")
        return redirect(url_for("view_student_behavior_records", user_id=student_id_for_redirect))

    try:
        db.session.delete(record)
        db.session.commit()
        flash(f"Behavior record ID {record_id} deleted successfully.", "success")
        app.logger.info(f"User {current_user.username} deleted behavior record ID {record_id} for student {student_id_for_redirect}.")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting behavior record ID {record_id} by {current_user.username}: {e}", exc_info=True)
        flash("An error occurred while deleting the record. Please try again.", "danger")
        
    return redirect(url_for("view_student_behavior_records", user_id=student_id_for_redirect))

# In PART 8 START: HR/CEO & System Admin Management Features

# Add a new asset
# Locate this existing route in PART 8
@app.route("/assets/add", methods=["GET", "POST"])
@login_required
# The role_required decorator handles the base roles.
# Specific leader checks are done inside the route.
@role_required("hr_ceo", "system_admin", "teacher", "librarian", "student", "talent_club")
def add_asset():
    form = AddAssetForm() # Your AddAssetForm definition
    current_user_role_name = current_user.role.name.lower()

    # --- Permission check for student/talent_club roles needing leader status ---
    if current_user_role_name == "student" and not current_user.is_leader:
        flash("Only student leaders can add assets.", "danger")
        abort(403)
    if current_user_role_name == "talent_club" and not current_user.is_tc_leader: # Assuming system-wide TC Leader
        flash("Only Talent Club leaders can add assets.", "danger")
        abort(403)

    if form.validate_on_submit():
        final_category_id = None
        final_lab_id = None
        location_desc_to_save = form.location_description.data.strip() if form.location_description.data else None

        try:
            # --- Role-based Auto-Assignment Logic ---
            # (This logic was detailed in your original app.py Part 8. Ensure it's correctly adapted here)
            if current_user_role_name == "student" and current_user.is_leader:
                if not current_user.grade or not current_user.section:
                    flash("Your student profile (grade/section) is incomplete. Cannot determine classroom for asset.", "danger")
                    return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus")
                
                classroom_name = f"Grade {current_user.grade} Section {current_user.section} Classroom"
                classroom_lab = db.session.scalar(select(Lab).filter_by(name=classroom_name))
                if not classroom_lab: # Create if not exists
                    classroom_lab = Lab(name=classroom_name)
                    db.session.add(classroom_lab)
                    db.session.flush() # Get ID
                final_lab_id = classroom_lab.id
                
                classroom_category = db.session.scalar(select(AssetCategory).filter_by(name="Classroom Assets"))
                if not classroom_category: # Create if not exists
                    classroom_category = AssetCategory(name="Classroom Assets", description="Assets primarily used in classrooms.")
                    db.session.add(classroom_category)
                    db.session.flush() # Get ID
                final_category_id = classroom_category.id
                location_desc_to_save = classroom_name # Override user input for student leader

            elif current_user_role_name == "teacher":
                final_lab_id = current_user.lab_id # Teacher's assigned lab by default
                if form.suggested_lab_id.data and form.suggested_lab_id.data != 0:
                    final_lab_id = form.suggested_lab_id.data
                
                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                else: # Default for teachers if not specified
                    lab_eq_cat = db.session.scalar(select(AssetCategory).filter_by(name="Lab Equipment"))
                    if lab_eq_cat: final_category_id = lab_eq_cat.id
                    else: # Fallback or error
                        flash("Default 'Lab Equipment' category not found. Please select a category or contact admin.", "warning")
                        # return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus") # Optionally halt

            elif current_user_role_name == "librarian":
                library_lab = db.session.scalar(select(Lab).filter_by(name="Main Library"))
                if not library_lab: # Create if not exists
                    library_lab = Lab(name="Main Library")
                    db.session.add(library_lab); db.session.flush()
                final_lab_id = library_lab.id
                location_desc_to_save = "Main Library"

                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                else: # Default for librarians
                    books_cat = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
                    if books_cat: final_category_id = books_cat.id
                    else: flash("Default 'Books' category not found.", "warning")

            elif current_user_role_name == "talent_club" and current_user.is_tc_leader:
                tc_hq_lab = db.session.scalar(select(Lab).filter_by(name="Talent Club HQ"))
                if not tc_hq_lab: # Create if not exists
                    tc_hq_lab = Lab(name="Talent Club HQ"); db.session.add(tc_hq_lab); db.session.flush()
                final_lab_id = tc_hq_lab.id
                location_desc_to_save = "Talent Club HQ"

                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                else: # Default for TC Leaders
                    tc_gear_cat = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
                    if tc_gear_cat: final_category_id = tc_gear_cat.id
                    else: flash("Default 'Talent Club Gear' category not found.", "warning")
            
            elif current_user_role_name in ["hr_ceo", "system_admin"]:
                # HR/Admin use the form's direct suggestion if provided, otherwise it can be None
                if form.suggested_category_id.data and form.suggested_category_id.data != 0:
                    final_category_id = form.suggested_category_id.data
                if form.suggested_lab_id.data and form.suggested_lab_id.data != 0:
                    final_lab_id = form.suggested_lab_id.data
            else: # Should not happen due to @role_required and leader checks
                flash("Unauthorized asset addition attempt.", "danger")
                abort(403)

            # --- Create Asset ---
            new_asset = Asset(
                name=form.name.data.strip(),
                description=form.description.data.strip() if form.description.data else None,
                quantity=form.quantity.data,
                purchase_cost=form.purchase_cost.data if form.purchase_cost.data is not None else None,
                condition=form.condition.data,
                is_consumable=form.is_consumable.data,
                expiry_date=form.expiry_date.data if form.is_consumable.data and form.expiry_date.data else None,
                last_maintenance_date=form.last_maintenance_date.data,
                added_by_user_id=current_user.id,
                category_id=final_category_id, # Can be None if not determined/selected
                lab_id=final_lab_id,           # Can be None
                location_description=location_desc_to_save,
                status="Pending Review" # All new assets start as pending
            )
            db.session.add(new_asset)
            db.session.commit()

            notify_hr_ceo_new_asset(new_asset) # Ensure this helper is correctly implemented

            flash(f"Asset '{new_asset.name}' added successfully and is now pending review.", "success")
            app.logger.info(f"User {current_user.username} added asset '{new_asset.name}' (ID: {new_asset.id}).")
            return redirect(url_for("my_assets"))

        except IntegrityError as e: # E.g. if asset name had a unique constraint
            db.session.rollback()
            app.logger.error(f"IntegrityError adding asset by {current_user.username}: {e}", exc_info=True)
            flash("Error: An asset with similar identifying information might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error adding asset by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while adding the asset. Please try again.", "danger")

    return render_template("assets/add_asset.html", form=form, title="Add New Asset - Nexus")
# Add this new route in PART 8, near other asset management routes
@app.route("/assets/<int:asset_id>/delete", methods=["POST"])
@login_required
# Only HR/CEO, System Admin, and relevant leaders can delete assets
@role_required("hr_ceo", "system_admin", "student", "talent_club")
def delete_asset(asset_id):
    """Deletes an asset from the system."""
    asset = db.get_or_404(Asset, asset_id)

    current_user_role_name = current_user.role.name.lower()

    # --- Fine-grained permission check for deletion ---
    # HR/CEO and System Admin can delete any asset.
    is_global_admin = current_user_role_name in ["hr_ceo", "system_admin"]

    # Student leaders can only delete assets they added AND are in their designated classroom lab/category
    is_student_leader_authorized = (
        current_user_role_name == "student" and
        current_user.is_leader and
        asset.added_by_user_id == current_user.id and # Must be the one who added it
        asset.lab and current_user.grade and current_user.section and # Check if they have a lab and grade/section
        asset.lab.name == f"Grade {current_user.grade} Section {current_user.section} Classroom" # Must be in their classroom lab
    )

    # Talent Club leaders can only delete assets they added AND are in the Talent Club HQ lab/category
    is_tc_leader_authorized = (
        current_user_role_name == "talent_club" and
        current_user.is_tc_leader and
        asset.added_by_user_id == current_user.id and # Must be the one who added it
        asset.lab and asset.lab.name == "Talent Club HQ" # Must be in the Talent Club HQ lab
    )

    # Teachers and Librarians are NOT granted deletion permission here.
    # This aligns with the "only leaders can add/delete" for student/TC,
    # while teachers/librarians can add but not delete (HR/CEO handles deletion for them).

    if not (is_global_admin or is_student_leader_authorized or is_tc_leader_authorized):
        flash("You do not have permission to delete this asset.", "danger")
        app.logger.warning(
            f"Unauthorized delete attempt: User {current_user.username} (ID: {current_user.id}, Role: {current_user_role_name}, Leader: {current_user.is_leader}, TC Leader: {current_user.is_tc_leader}) "
            f"tried to delete asset ID {asset.id} (Added by: {asset.added_by_user_id}, Lab: {asset.lab.name if asset.lab else 'N/A'})."
        )
        abort(403)

    try:
        db.session.delete(asset)
        db.session.commit()
        flash(f"Asset '{asset.name}' deleted successfully.", "success")
        app.logger.info(f"User {current_user.username} (ID: {current_user.id}) deleted asset '{asset.name}' (ID: {asset.id}).")
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting asset ID {asset.id} by {current_user.username} (ID: {current_user.id}): {e}", exc_info=True)
        flash("An error occurred while deleting the asset. Please try again.", "danger")

    # Redirect to appropriate asset list
    return redirect(url_for("my_assets")) # Or list_all_assets

# Add this new route, potentially in PART 8 or a new "Asset Views" section
@app.route("/assets/all")
@login_required # All authenticated users can view this
def list_all_assets():
    """Displays a list of all assets visible to the current user, with basic filtering."""
    # Query for all active assets
    # We can add filters based on query parameters (e.g., category, status, lab)
    # For universal view, let's include assets that are "available", "pending review", "under maintenance"
    # but exclude "retired", "lost". HR/CEO can see all.

    # Fetch basic filter parameters from the request query string
    category_filter = request.args.get('category', 'all').strip()
    status_filter = request.args.get('status', 'available_active').strip() # New status filter options
    lab_filter = request.args.get('lab', 'all').strip()
    search_query = request.args.get('search', '').strip()
    page = request.args.get('page', 1, type=int)
    per_page = 20 # Number of assets per page

    assets_query = select(Asset).options(
        joinedload(Asset.category), # Eager load category
        joinedload(Asset.lab),     # Eager load lab
        joinedload(Asset.added_by_user) # Eager load who added it
    )

    # Apply role-based visibility to the query (HR/CEO sees everything)
    if current_user.role.name.lower() not in ['hr_ceo', 'system_admin']:
        # Non-HR/CEO/System Admin users might only see 'Available', 'Under Maintenance', 'Needs Repair' etc.
        # but not 'Pending Review' (unless they added it) or 'Retired', 'Lost' unless they have specific permission.
        # For simplicity, let's define what IS generally visible.
        assets_query = assets_query.where(
            Asset.status.in_(['Available', 'Under Maintenance', 'Needs Repair', 'CheckedOut'])
            # Optionally: only show assets they have a direct connection to, e.g. for student leaders, only assets in their classroom
            # For this route, the requirement is "every one can view".
            # The `my_assets` route (if you implement it specifically for different roles) would be for personalized views.
        )
    else: # HR/CEO, System Admin
        # They see all assets, including 'Pending Review', 'Retired', 'Lost'
        pass


    # Apply Category Filter
    if category_filter != 'all':
        category_obj = db.session.scalar(select(AssetCategory).filter_by(name=category_filter))
        if category_obj:
            assets_query = assets_query.where(Asset.category_id == category_obj.id)
        else:
            flash(f"Invalid category filter: {category_filter}", "warning")
            category_filter = 'all' # Reset to all


    # Apply Status Filter
    if status_filter == 'available_active':
        # Assets that are available for use or actively in use/maintenance
        assets_query = assets_query.where(
            Asset.status.in_(['Available', 'CheckedOut', 'Under Maintenance', 'Needs Repair'])
        )
    elif status_filter == 'pending_review':
        assets_query = assets_query.where(Asset.status == 'Pending Review')
    elif status_filter == 'retired_lost':
        assets_query = assets_query.where(Asset.status.in_(['Retired', 'Lost']))
    # 'all' status filter is covered by the base query (or hr_ceo/system_admin above)

    # Apply Lab Filter
    if lab_filter != 'all':
        lab_obj = db.session.scalar(select(Lab).filter_by(name=lab_filter))
        if lab_obj:
            assets_query = assets_query.where(Asset.lab_id == lab_obj.id)
        else:
            flash(f"Invalid lab filter: {lab_filter}", "warning")
            lab_filter = 'all' # Reset to all

    # Apply Search Query
    if search_query:
        assets_query = assets_query.where(
            or_(
                Asset.name.ilike(f'%{search_query}%'),
                Asset.description.ilike(f'%{search_query}%'),
                Asset.location_description.ilike(f'%{search_query}%')
            )
        )

    # Order assets for display
    assets_query = assets_query.order_by(Asset.name.asc())

    # Paginate the results
    paginated_assets = db.paginate(assets_query, page=page, per_page=per_page, error_out=False)

    # Get all categories and labs for filter dropdowns
    all_categories = db.session.scalars(select(AssetCategory).order_by(AssetCategory.name)).all()
    all_labs = db.session.scalars(select(Lab).order_by(Lab.name)).all()


    return render_template("assets/all_assets.html",
                           paginated_assets=paginated_assets,
                           all_categories=all_categories,
                           all_labs=all_labs,
                           category_filter=category_filter,
                           status_filter=status_filter,
                           lab_filter=lab_filter,
                           search_query=search_query,
                           title="All School Assets")

# Example my_assets (if you have one, modify it like this)
@app.route("/my_assets")
@login_required
def my_assets():
    """Displays assets added by the current user."""
    user_added_assets = db.session.scalars(
        select(Asset)
        .where(Asset.added_by_user_id == current_user.id)
        .order_by(Asset.name.asc())
    ).all()
    # You might also want to show books checked out, etc., here depending on role.
    return render_template("assets/my_assets.html", assets=user_added_assets, title="My Added Assets")

# Route for reporting an issue for a specific asset (clicking  next to a listed asset)
@app.route("/asset/<int:asset_id>/report", methods=["GET", "POST"])
@login_required
# Roles who can report on a specific asset (assuming they can view it)
@role_required("hr_ceo", "system_admin", "teacher", "librarian", "talent_club", "student")
def report_asset_specific(asset_id):
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")
    form = ReportAssetForm() # Your ReportAssetForm definition

    if form.validate_on_submit():
        try:
            new_report = AssetReport(
                asset_id=asset.id, # Link to the specific asset
                reported_by_id=current_user.id,
                damage_description=form.damage_description.data.strip(),
                date_of_damage=form.date_of_damage.data, # WTForms converts to date object or None
                quantity_damaged=form.quantity_damaged.data,
                status="Pending", # New reports default to Pending
                report_date=datetime.now(timezone.utc)
            )
            db.session.add(new_report)
            db.session.commit() # Commit to get report ID for notification

            notify_hr_ceo_new_report(new_report) # Ensure this helper is correctly implemented

            flash(f"Issue reported successfully for asset '{asset.name}'. An administrator will review it.", "success")
            app.logger.info(f"User {current_user.username} reported issue for asset ID {asset.id} (Report ID: {new_report.id}).")
            
            # Redirect back to where they came from, or a sensible default
            # If they came from all_assets or my_assets, request.referrer would be good.
            # If direct link, maybe redirect to asset detail or user's dashboard.
            return redirect(request.referrer or url_for('list_all_assets'))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error submitting specific asset report for asset ID {asset.id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while submitting the report. Please try again.", "danger")
            # Re-render the form with errors, form data is preserved by WTForms
            
    # For GET request or if form validation failed on POST
    return render_template("assets/report_asset_specific.html", 
                           form=form, 
                           asset=asset, 
                           title=f"Report Issue for: {asset.name} - Nexus")
# Route for a general asset report (clicking  next to 'Add Assets')
# This route handles reports that are not initially linked to a specific asset ID.
@app.route("/report/general", methods=["GET", "POST"])
@login_required
# Roles who can submit a general report
@role_required("hr_ceo", "system_admin", "teacher", "librarian", "talent_club", "student")
def report_asset_general():
    form = ReportAssetForm() # Your ReportAssetForm definition

    if form.validate_on_submit():
        try:
            # Get the user-provided asset description if they filled it in the template
            user_provided_asset_name_desc = request.form.get('asset_name_description', '').strip()
            
            full_damage_description = form.damage_description.data.strip()
            if user_provided_asset_name_desc:
                # Prepend it to the main damage description for context
                full_damage_description = f"Reported Item (User Described): {user_provided_asset_name_desc}\n\nIssue Details:\n{full_damage_description}"

            new_report = AssetReport(
                asset_id=None, # General report, not linked to a specific asset initially
                reported_by_id=current_user.id,
                damage_description=full_damage_description, # Save combined description
                date_of_damage=form.date_of_damage.data,
                quantity_damaged=form.quantity_damaged.data,
                status="Pending",
                report_date=datetime.now(timezone.utc)
            )
            db.session.add(new_report)
            db.session.commit()

            notify_hr_ceo_new_report(new_report) # Ensure this helper is correctly implemented

            flash("General issue report submitted successfully. An administrator will review it.", "success")
            app.logger.info(f"User {current_user.username} submitted a general asset report (Report ID: {new_report.id}).")
            
            # Redirect to a relevant page, e.g., user's dashboard or a "my reports" page if it exists
            return redirect(url_for(f"{current_user.role.name.lower()}_dashboard"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error submitting general asset report by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while submitting the general report. Please try again.", "danger")
            # Re-render form with errors

    # For GET request or if form validation failed on POST
    return render_template("assets/report_asset_general.html", 
                           form=form, 
                           title="Report General Asset Issue - Nexus")

# --- HR/CEO Specific Asset Management Routes ---

# List assets pending review (for HR/CEO & System Admin)
@app.route("/hr_ceo/assets/pending")
@login_required
@role_required("hr_ceo", "system_admin")
def list_pending_assets():
    pending_assets = db.session.scalars(
        select(Asset)
        .options(
            joinedload(Asset.added_by_user).joinedload(User.role), # Load user and their role
            joinedload(Asset.category), 
            joinedload(Asset.lab)
        )
        .where(Asset.status == "Pending Review")
        .order_by(Asset.created_at.asc()) # Show oldest pending first
    ).all()

    return render_template("hr_ceo/pending_assets.html",
                           pending_assets=pending_assets,
                           title="Assets Pending Review - Nexus")
# Edit/Review a specific asset (for HR/CEO & System Admin)
@app.route("/assets/<int:asset_id>/edit", methods=["GET", "POST"]) # Ensure path is correct
@login_required
@role_required("hr_ceo", "system_admin") # Only these roles can edit full asset details
def edit_asset(asset_id):
    asset = db.get_or_404(Asset, asset_id, description="Asset not found.")
    # EditAssetForm is defined in your app.py or forms.py
    form = EditAssetForm(obj=asset) # Pre-populate form with existing asset data on GET

    if form.validate_on_submit():
        try:
            old_status = asset.status # Store old status for notification logic

            # Update asset fields from form data
            asset.name = form.name.data.strip()
            asset.description = form.description.data.strip() if form.description.data else None
            asset.quantity = form.quantity.data
            asset.purchase_cost = form.purchase_cost.data if form.purchase_cost.data is not None else None
            
            # Ensure category_id is handled correctly (it's required in the form)
            if form.category_id.data and form.category_id.data != 0: # Assuming 0 might be a "no selection" placeholder if form allows
                asset.category_id = form.category_id.data
            else: # This case should ideally be caught by form.category_id.validators=[DataRequired()]
                flash("Asset category is required.", "danger")
                return render_template("assets/edit_asset.html", form=form, asset=asset, title=f"Edit Asset: {asset.name} - Nexus")

            asset.status = form.status.data
            asset.condition = form.condition.data
            asset.is_consumable = form.is_consumable.data
            
            if asset.is_consumable and form.expiry_date.data:
                asset.expiry_date = form.expiry_date.data
            elif not asset.is_consumable:
                asset.expiry_date = None # Clear expiry if not consumable

            asset.last_maintenance_date = form.last_maintenance_date.data
            
            asset.lab_id = form.lab_id.data if form.lab_id.data and form.lab_id.data != 0 else None
            asset.location_description = form.location_description.data.strip() if form.location_description.data else None
            
            # Asset.updated_at should be handled by onupdate in the model if defined,
            # otherwise, set it manually:
            # asset.last_updated_at = datetime.now(timezone.utc)


            db.session.commit()

            # Notification logic: Notify original adder if status changed from "Pending Review"
            if old_status == "Pending Review" and asset.status != "Pending Review" and asset.added_by_user:
                if asset.added_by_user.is_active:
                    try:
                        message_content = f"Your submitted asset '{asset.name}' (ID: {asset.id}) has been reviewed. New status: '{asset.status}'."
                        # Link to a viewable page for the user, not necessarily the edit page
                        link_url = url_for('my_assets', _external=True) # Or a specific asset view if available for them
                        
                        # Ensure is_notification_allowed is checked
                        if is_notification_allowed(current_user, asset.added_by_user):
                            notification = Notification(
                                sender_id=current_user.id,
                                receiver_id=asset.added_by_user_id,
                                content=message_content,
                                link_url=link_url,
                                timestamp=datetime.now(timezone.utc),
                                notification_type='asset_status_change' # Add a specific type
                            )
                            db.session.add(notification)
                            db.session.commit() # Commit notification separately
                            app.logger.info(f"Notified user {asset.added_by_user_id} about asset {asset.id} status change to '{asset.status}'.")
                    except Exception as notify_e:
                        db.session.rollback() # Rollback only notification part
                        app.logger.error(f"Error sending asset status change notification to {asset.added_by_user_id}: {notify_e}", exc_info=True)
            
            flash(f"Asset '{asset.name}' updated successfully. Status is now '{asset.status}'.", "success")
            app.logger.info(f"User {current_user.username} edited asset ID {asset.id}.")

            if asset.status == "Pending Review":
                return redirect(url_for("list_pending_assets"))
            else:
                return redirect(url_for("list_all_assets")) # Or back to where they came from

        except IntegrityError:
            db.session.rollback()
            flash("Error: Could not update asset. A similar asset might already exist or there was a data conflict.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing asset ID {asset.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the asset. Please try again.", "danger")

    return render_template("assets/edit_asset.html", 
                           form=form, 
                           asset=asset, 
                           title=f"Edit Asset: {asset.name} - Nexus")

# List all asset reports (for HR/CEO & System Admin)
@app.route("/hr_ceo/reports")
@login_required
@role_required("hr_ceo", "system_admin")
def list_asset_reports():
    # Add pagination and filtering later if needed
    reports_query = (
        select(AssetReport)
        .options(
            joinedload(AssetReport.asset).joinedload(Asset.category), # Load asset and its category
            joinedload(AssetReport.reporter).joinedload(User.role),   # Load reporter and their role
            joinedload(AssetReport.resolver).joinedload(User.role)    # Load resolver and their role
        )
        .order_by(
            # Custom order for status: Pending, In Progress, then others, then Resolved/Rejected
            case(
                (AssetReport.status == 'Pending', 1),
                (AssetReport.status == 'In Progress', 2),
                (AssetReport.status == 'Resolved', 4),
                (AssetReport.status == 'Rejected', 5),
                else_=3
            ).asc(),
            AssetReport.report_date.desc()
        )
    )
    reports = db.session.scalars(reports_query).all()

    return render_template("hr_ceo/list_reports.html",
                           reports=reports,
                           title="All Asset Reports - Nexus")
@app.route("/hr_ceo/report/<int:report_id>/resolve", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def resolve_asset_report(report_id):
    report = db.get_or_404(AssetReport, report_id, description="Asset report not found.")
    # Ensure related asset, reporter, resolver are loaded for display in template if needed
    # The query in list_asset_reports already does this, but direct access might not.
    # For simplicity, assume they are accessible via report.asset, report.reporter etc.
    # Or load them explicitly:
    # report = db.session.query(AssetReport).options(joinedload...)...get()

    form = ResolveReportForm(obj=report) # Pre-populate with existing data

    # Logic for potentially linking a general report to an asset (if form.link_to_asset_id exists)
    # This was commented out in the template; if implementing, handle it here.
    # if not report.asset_id and hasattr(form, 'link_to_asset_id'):
    #     # Populate choices for form.link_to_asset_id
    #     form.link_to_asset_id.choices = [(0, '--- Select Asset to Link (Optional) ---')] + \
    #                                     [(a.id, f"{a.name} (ID: {a.id})") for a in db.session.scalars(select(Asset).order_by(Asset.name)).all()]


    if form.validate_on_submit():
        try:
            old_status = report.status

            report.status = form.status.data
            report.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None

            # Handle asset linking for general reports if implemented
            # if not report.asset_id and hasattr(form, 'link_to_asset_id') and form.link_to_asset_id.data and form.link_to_asset_id.data != 0:
            #    report.asset_id = form.link_to_asset_id.data

            if report.status in ["Resolved", "Rejected"] and old_status not in ["Resolved", "Rejected"]:
                report.resolved_by_id = current_user.id
                report.resolved_date = datetime.now(timezone.utc)
            elif report.status not in ["Resolved", "Rejected"] and old_status in ["Resolved", "Rejected"]:
                report.resolved_by_id = None
                report.resolved_date = None
            
            # Update related asset's status/condition if report is "Resolved"
            if report.asset and report.status == "Resolved" and old_status != "Resolved":
                asset_to_update = report.asset
                if asset_to_update.status in ["Needs Repair", "Under Maintenance", "Lost"]: # Or other problematic statuses
                    asset_to_update.status = "Available"
                    # Optionally, update condition if relevant
                    if asset_to_update.condition in ["Poor", "Needs Repair", "Broken"]:
                        asset_to_update.condition = "Good" # Or "Fair"
                app.logger.info(f"Asset ID {asset_to_update.id} status/condition updated due to resolved report {report.id}.")

            db.session.commit()

            notify_reporter_report_update(report) # Ensure this helper is correctly implemented

            flash(f"Report ID {report.id} status updated to '{report.status}'.", "success")
            app.logger.info(f"User {current_user.username} updated report ID {report.id} to status '{report.status}'.")
            return redirect(url_for("list_asset_reports"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error resolving report ID {report.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the report. Please try again.", "danger")

    # For GET, pass the report (and its asset) and form to the template
    return render_template("hr_ceo/resolve_report.html", 
                           form=form, 
                           report=report, 
                           asset=report.asset, # Pass asset explicitly if needed by template beyond report.asset
                           title=f"Resolve Report ID: {report.id} - Nexus")
# Route for HR/CEO to manage asset categories (list, add form)
@app.route("/hr_ceo/asset_categories")
@login_required
@role_required("hr_ceo", "system_admin")
def manage_asset_categories():
    # Fetch all asset categories, ordered by name
    # Eager load assets count if your model has a direct count or efficient way
    # For simplicity, template uses category.assets.count() which might do N+1 if not careful.
    # Consider adding a count property or subquery if performance becomes an issue for many categories.
    categories = db.session.scalars(
        select(AssetCategory).order_by(AssetCategory.name.asc())
        # .options(selectinload(AssetCategory.assets)) # If you want to iterate assets in template for count, but .count() is usually better
    ).all()
    
    add_form = AddCategoryForm() # Your AddCategoryForm definition

    return render_template("hr_ceo/manage_categories.html",
                           categories=categories,
                           add_form=add_form, # Pass the form for adding new categories
                           title="Manage Asset Categories - Nexus")
# Add new category (POST only)
@app.route("/hr_ceo/asset_categories/add", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def add_asset_category():
    # This route now primarily handles the POST from the manage_asset_categories page's form
    add_form = AddCategoryForm() # Instantiate the form to validate against
    
    if add_form.validate_on_submit():
        try:
            new_category_name = add_form.name.data.strip()
            # Check for existing category with the same name (case-insensitive)
            existing_category = db.session.scalar(
                select(AssetCategory).filter(func.lower(AssetCategory.name) == func.lower(new_category_name))
            )
            if existing_category:
                flash(f"Asset category '{new_category_name}' already exists.", "danger")
            else:
                new_category = AssetCategory(
                    name=new_category_name,
                    description=add_form.description.data.strip() if add_form.description.data else None
                )
                db.session.add(new_category)
                db.session.commit()
                flash(f"Asset category '{new_category.name}' added successfully.", "success")
                app.logger.info(f"User {current_user.username} added asset category '{new_category.name}'.")
        except IntegrityError: # Should be caught by the name check above, but as a fallback
            db.session.rollback()
            flash("Asset category with this name already exists or another database error occurred.", "danger")
            app.logger.warning(f"IntegrityError while adding asset category: {add_form.name.data} by {current_user.username}.")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error adding asset category by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while adding the category. Please try again.", "danger")
    else:
        # If form validation fails (e.g., name is empty)
        for field, errors in add_form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(add_form, field).label.text}: {error}", "danger")
                
    return redirect(url_for("manage_asset_categories")) # Always redirect back
# Edit category (GET and POST)
@app.route("/hr_ceo/asset_category/<int:category_id>/edit", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def edit_asset_category(category_id):
    category = db.get_or_404(AssetCategory, category_id, description="Asset category not found.")
    # EditCategoryForm is defined in your app.py or forms.py
    form = EditCategoryForm(obj=category) # Pre-populate with existing data on GET

    if form.validate_on_submit():
        try:
            new_name = form.name.data.strip()
            # Check if new name conflicts with another existing category (case-insensitive)
            existing_category_with_new_name = db.session.scalar(
                select(AssetCategory).filter(
                    AssetCategory.id != category.id, # Exclude the current category being edited
                    func.lower(AssetCategory.name) == func.lower(new_name)
                )
            )
            if existing_category_with_new_name:
                flash(f"Another asset category named '{new_name}' already exists.", "danger")
            else:
                category.name = new_name
                category.description = form.description.data.strip() if form.description.data else None
                # category.updated_at = datetime.now(timezone.utc) # If you have an updated_at field
                db.session.commit()
                flash(f"Asset category '{category.name}' updated successfully.", "success")
                app.logger.info(f"User {current_user.username} edited asset category ID {category.id} to '{category.name}'.")
                return redirect(url_for("manage_asset_categories"))
        except IntegrityError: # Fallback, should be caught by name check
            db.session.rollback()
            flash(f"Update failed. A category named '{form.name.data.strip()}' might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing asset category ID {category_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while updating the category. Please try again.", "danger")
            
    # For GET request or if form validation failed on POST
    return render_template("hr_ceo/edit_category.html", 
                           form=form, 
                           category=category, 
                           title=f"Edit Category: {category.name} - Nexus")
# Delete category (POST only, with safety checks)
@app.route("/hr_ceo/asset_category/<int:category_id>/delete", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def delete_asset_category(category_id):
    category = db.get_or_404(AssetCategory, category_id, description="Asset category not found.")

    # Check dependencies: assets and channels
    # Assuming 'assets' and 'channels' are the correct relationship names on AssetCategory model
    asset_count = category.assets.count() if hasattr(category, 'assets') else \
                  db.session.scalar(select(func.count(Asset.id)).where(Asset.category_id == category.id)) or 0
    
    # The original SocialCategory model (and its relationship to Channel) was used for channels
    # If AssetCategory is also used by Channel (which it was in some of your model snippets), check that too.
    # Based on frontend, AssetCategory does not link to Channel, but SocialCategory does.
    # Let's assume AssetCategory ONLY links to Asset for this check.
    # If Channel can also link to AssetCategory, this check needs to be updated:
    # channel_count = category.channels.count() if hasattr(category, 'channels') else \
    #                 db.session.scalar(select(func.count(Channel.id)).where(Channel.category_id == category.id)) or 0
    # For now, assuming channels use SocialCategory, not AssetCategory.

    if asset_count > 0:
        flash(f"Cannot delete category '{category.name}' because {asset_count} asset(s) are still assigned to it. Please reassign them first.", "danger")
        app.logger.warning(f"Attempted to delete asset category ID {category_id} ('{category.name}') with {asset_count} linked assets.")
    # elif channel_count > 0: # If channels could use AssetCategory
    #     flash(f"Cannot delete category '{category.name}' because {channel_count} social channel(s) are still using it.", "danger")
    else:
        try:
            db.session.delete(category)
            db.session.commit()
            flash(f"Asset category '{category.name}' deleted successfully.", "success")
            app.logger.info(f"User {current_user.username} deleted asset category ID {category.id} ('{category.name}').")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error deleting asset category ID {category_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while deleting the category. Please try again.", "danger")

    return redirect(url_for("manage_asset_categories"))


# --- HR Student Leader Management ---
@app.route("/hr_ceo/manage_student_leaders", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin") # Allow System Admin
def manage_student_leaders():
    """Displays student leaders and allows assigning students to leaders or toggling leader status."""

    # This part handles the POST request for assigning students to a leader.
    # We instantiate the form here for both GET/POST, ensuring it's available for re-rendering on POST failure.
    # The current_leaders argument will be populated for the GET request logic later.
    form = AssignLeaderForm()

    if form.validate_on_submit(): # If the 'Assign Students' form was submitted and valid
        selected_leader_id = form.leader.data
        selected_leader = db.session.get(User, selected_leader_id)

        # Basic validation for the selected leader from the dropdown
        if (
            not selected_leader
            or not selected_leader.is_leader # Must be marked as a leader to be assigned followers
            or selected_leader.role.name.lower() != "student"
            or not selected_leader.is_active
        ):
            flash(
                "Invalid leader selected for assignment. Please select an active student leader.",
                "danger",
            )
        # Ensure the selected leader has a grade and section, which is crucial for section leadership
        elif not selected_leader.grade or not selected_leader.section:
             flash(f"The selected leader ({selected_leader.full_name or selected_leader.username}) does not have a grade or section assigned and cannot be used to lead a section.", "danger")
        else:
            # Get the list of student IDs from the checkboxes submitted in the template
            # Assumes checkbox names are "students_to_assign" and values are student.id
            selected_student_ids_str = request.form.getlist("students_to_assign")
            selected_student_ids = [int(sid) for sid in selected_student_ids_str if sid.isdigit()]

            if not selected_student_ids:
                flash("No students selected to assign to the leader.", "warning")
            else:
                assigned_count = 0
                skipped_count = 0
                try:
                    # Fetch the students who were selected to be assigned, ensuring they are active students
                    students_to_update_stmt = (
                        select(User)
                        .join(Role)
                        .where(
                            User.id.in_(selected_student_ids),
                            Role.name == "student",
                            User.is_active == True
                        )
                    )
                    students_to_update = db.session.scalars(students_to_update_stmt).all()

                    for student in students_to_update:
                        # Crucial check: Only assign students if they are in the *same* grade and section as the leader
                        if (student.id != selected_leader.id and # Cannot assign the leader to follow themselves
                            student.grade == selected_leader.grade and
                            student.section == selected_leader.section):
                            student.leader_id = selected_leader.id # Update the student's leader_id
                            assigned_count += 1
                        else:
                            skipped_count += 1
                            if student.id == selected_leader.id:
                                flash(f"Skipped {student.full_name or student.username}: Cannot assign a leader to follow themselves.", "warning")
                            elif student.grade != selected_leader.grade or student.section != selected_leader.section:
                                flash(f"Skipped {student.full_name or student.username}: Student is in a different grade/section ({student.grade}-{student.section}) than the selected leader ({selected_leader.grade}-{selected_leader.section}).", "warning")


                    if assigned_count > 0:
                        db.session.commit() # Commit the updates
                        flash(
                            f"{assigned_count} student(s) successfully assigned to leader {selected_leader.full_name or selected_leader.username}.",
                            "success",
                        )
                        app.logger.info(
                            f"{assigned_count} students assigned to leader {selected_leader.username} by {current_user.username}"
                        )
                    if skipped_count > 0:
                        # Only show this general message if specific ones were shown above
                        flash(
                            f"{skipped_count} student(s) were skipped (check messages above for reasons).",
                            "info",
                        )

                    # Redirect back to the manage leaders page to see updated assignments
                    return redirect(url_for("manage_student_leaders"))
                except Exception as e:
                    db.session.rollback() # Rollback if any database operation failed
                    app.logger.error(
                        f"Error assigning students to leader {selected_leader.username}: {e}", exc_info=True
                    )
                    flash("An unexpected error occurred while assigning students. Please try again.", "danger")

    # --- Handle GET request or failed POST (if POST failed, form will retain data) ---
    # Fetch all active students with their grade/section, ordered for display
    # Eager load their leader if available (the User object pointed to by leader_id)
    all_students_stmt = (
        select(User)
        .join(Role)
        .where(Role.name == "student", User.is_active == True)
        .options(joinedload(User.leader)) # Eager load the leader object for each student
        .order_by(User.grade, User.section, User.full_name) # Sort for logical grouping
    )
    all_students = db.session.scalars(all_students_stmt).all()

    # Students currently marked as leaders (is_leader=True) and have grade/section defined
    current_leaders = [s for s in all_students if s.is_leader and s.grade and s.section]

    # Re-instantiate form here to ensure choices are fresh for GET request, or on POST re-render.
    # This must be done *after* `current_leaders` is determined.
    form = AssignLeaderForm(current_leaders=current_leaders) # Populate dropdown for leader assignment

    # Group students by grade and section for easier display in the template
    # `defaultdict` is perfect for this, default value is a dictionary with three lists/slots
    students_by_grade_section = defaultdict(lambda: {'leader': None, 'unassigned_students': [], 'followers': []})

    for s in all_students:
        # Create a tuple key for grade and section, handling cases where they might be None
        key = (s.grade or "N/A_Grade", s.section or "N/A_Section")

        if s.is_leader:
            # This student is a designated leader for their section
            students_by_grade_section[key]['leader'] = s
            # A leader's own leader_id should logically be None. If not, it's a data anomaly.
            if s.leader_id is not None:
                app.logger.warning(f"Leader {s.username} (G:{s.grade}, S:{s.section}) has a non-None leader_id ({s.leader_id}). This should be cleared for data consistency, but the system continues.")
        else:
            # This student is not a leader themselves
            # Check if their `leader_id` points to the designated leader for their section
            current_section_leader = students_by_grade_section[key]['leader'] # Already populated if leader was processed

            if current_section_leader and s.leader_id == current_section_leader.id:
                # Student is correctly assigned to the leader of their section
                students_by_grade_section[key]['followers'].append(s)
            else:
                # Student is not a leader, and is either unassigned or assigned to an incorrect/non-existent leader
                students_by_grade_section[key]['unassigned_students'].append(s)

    # Sort the top-level keys (grade-section tuples)
    sorted_grade_section_keys = sorted(students_by_grade_section.keys())
    
    # Create a new ordered dictionary to store the sorted data, with inner lists also sorted
    sorted_students_by_grade_section = {}
    for key in sorted_grade_section_keys:
        block_data = students_by_grade_section[key]
        # Sort unassigned students alphabetically by full name
        block_data['unassigned_students'] = sorted(block_data['unassigned_students'], key=lambda stu: stu.full_name or stu.username)
        # Sort followers alphabetically by full name
        block_data['followers'] = sorted(block_data['followers'], key=lambda stu: stu.full_name or stu.username)
        sorted_students_by_grade_section[key] = block_data


    return render_template(
        "hr_ceo/student_leaders.html",
        form=form, # Pass the AssignLeader form (used for the leader dropdown and its POST validation)
        students_by_grade_section=sorted_students_by_grade_section, # Grouped students for display and checkboxes
        current_leaders=current_leaders, # Still useful for a quick list of leaders (e.g., in a sidebar)
        title="Manage Student Leaders & Assignments",
    )

# Route to toggle the is_leader status of a single student (POST only)
@app.route("/hr_ceo/toggle_leader_status/<int:student_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin") # Allow System Admin
def toggle_student_leader_status(student_id):
    """Toggles the 'is_leader' status for a specific student, enforcing one leader per grade-section."""
    student = db.session.get(User, student_id)

    # Validate that the user exists, is a student, and is active
    if not student or student.role.name.lower() != "student" or not student.is_active:
        flash("User not found, is not a student, or is inactive.", "danger")
        return redirect(request.referrer or url_for("manage_student_leaders"))

    # Ensure the student has a grade and section assigned
    if not student.grade or not student.section:
        flash(f"Student {student.full_name or student.username} must have a grade and section assigned before being promoted/demoted as a section leader.", "danger")
        return redirect(request.referrer or url_for("manage_student_leaders"))

    try:
        action_message = ""
        if student.is_leader:
            # --- Demoting a leader ---
            student.is_leader = False
            # Also, unset the `leader_id` for any students who were following this demoted leader
            # This ensures orphaned leader_ids are cleared.
            db.session.query(User).filter(User.leader_id == student.id).update({User.leader_id: None}, synchronize_session=False)

            action_message = f"{student.full_name or student.username} is no longer the leader for Grade {student.grade}, Section {student.section}."
            app.logger.info(
                f"HR/CEO {current_user.username} (ID: {current_user.id}) demoted student {student.username} (ID: {student.id}) from leader status for G:{student.grade} S:{student.section}."
            )
        else:
            # --- Promoting a leader ---
            # Check if there's already a leader for this student's grade and section
            existing_leader = db.session.scalar(
                select(User)
                .where(
                    User.grade == student.grade,
                    User.section == student.section,
                    User.is_leader == True, # Look for an existing leader flag
                    User.id != student.id, # Exclude the current student in case of self-promotion scenario
                    User.is_active == True # Only active leaders
                )
                .join(Role).filter(Role.name == 'student') # Ensure it's a student leader
            )

            if existing_leader:
                flash(f"A leader ({existing_leader.full_name or existing_leader.username}) already exists for Grade {student.grade}, Section {student.section}. Please demote them first.", "danger")
                return redirect(request.referrer or url_for("manage_student_leaders"))

            # No existing leader found for this section, proceed with promotion
            student.is_leader = True
            student.leader_id = None # A leader does not follow anyone

            action_message = f"{student.full_name or student.username} is now the leader for Grade {student.grade}, Section {student.section}."
            app.logger.info(
                f"HR/CEO {current_user.username} (ID: {current_user.id}) promoted student {student.username} (ID: {student.id}) to leader status for G:{student.grade} S:{student.section}."
            )

            # Assign this new leader to ALL other active students in the same grade and section
            # Exclude the new leader themselves.
            db.session.query(User).filter(
                User.grade == student.grade,
                User.section == student.section,
                User.id != student.id, # Exclude the new leader
                User.is_active == True,
                User.role_id == student.role_id # Ensure they are students
            ).update({User.leader_id: student.id}, synchronize_session=False)

        db.session.commit() # Commit the change to the student's is_leader status and potentially followers' leader_id
        flash(action_message, "success")

    except Exception as e:
        db.session.rollback() # Rollback on error
        app.logger.error(
            f"Error toggling leader status for student {student_id} ({student.username}) by {current_user.username}: {e}", exc_info=True
        )
        flash(
            "An error occurred while updating leader status. Please try again.",
            "danger",
        )

    # Redirect back to the manage leaders page
    return redirect(request.referrer or url_for("manage_student_leaders"))
# --- PART 8 END: HR/CEO & System Admin Management Features ---

# --- PART 9 START: Book Checkout & Management ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Asset, AssetCategory, BookCheckout, BorrowedAsset are defined.
# - Forms: BookCheckoutForm is defined.
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, joinedload, etc.), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify, paginate), and other Python imports (datetime, timezone, date) are available.
@app.route("/books/checkout", methods=["GET", "POST"])
@login_required
@role_required("librarian", "student") # Students can initiate for themselves, Librarians for others
def checkout_book():
# Add this at the beginnincheckout_book route for GET requests
  if request.method == 'GET' and is_librarian:
    user_id_to_prefill = request.args.get('user_id_prefill', type=int)
    if user_id_to_prefill and hasattr(form, 'user_id'):
        # Check if this user_id is a valid choice in the form
        if any(user_id_to_prefill == choice[0] for choice in form.user_id.choices):
            form.user_id.data = user_id_to_prefill  
    form = BookCheckoutForm() # Your BookCheckoutForm definition
    # The form's __init__ method populates asset_id (available books)
    # and user_id (for librarians to select a user).

    is_librarian = current_user.role.name.lower() == "librarian"

    if form.validate_on_submit():
        asset_id_to_checkout = form.asset_id.data
        due_date_from_form = form.due_date.data
        user_to_checkout_for_id = current_user.id # Default for students

        if is_librarian:
            if form.user_id.data and form.user_id.data != 0: # 0 might be the "--- Select User ---" value
                user_to_checkout_for_id = form.user_id.data
            else:
                flash("Librarians must select a user to checkout the book for.", "danger")
                # Re-render form, choices will be repopulated by form.__init__
                return render_template("books/checkout_book.html", 
                                       form=form, 
                                       is_librarian=is_librarian, 
                                       title="Checkout Book - Nexus")
        
        asset = db.session.get(Asset, asset_id_to_checkout)
        user_for_checkout = db.session.get(User, user_to_checkout_for_id)

        if not asset or not user_for_checkout or not user_for_checkout.is_active:
            flash("Invalid book or user selected, or user is inactive.", "danger")
        elif asset.quantity < 1:
            flash(f"Book '{asset.name}' is currently out of stock.", "danger")
        elif asset.status != "Available": # Double check status
            flash(f"Book '{asset.name}' is not currently available for checkout (Status: {asset.status}).", "warning")
        else:
            # Optional: Check if user already has this book checked out and not returned
            existing_checkout = db.session.scalar(
                select(BookCheckout).where(
                    BookCheckout.user_id == user_for_checkout.id,
                    BookCheckout.asset_id == asset.id,
                    BookCheckout.returned == False
                )
            )
            if existing_checkout:
                flash(f"{user_for_checkout.full_name or user_for_checkout.username} already has '{asset.name}' checked out.", "warning")
            else:
                try:
                    new_checkout = BookCheckout(
                        user_id=user_for_checkout.id,
                        asset_id=asset.id,
                        checkout_date=datetime.now(timezone.utc).date(),
                        due_date=due_date_from_form,
                        returned=False
                    )
                    asset.quantity -= 1
                    if asset.quantity == 0 and asset.status == "Available": # Only change if it was available
                        asset.status = "CheckedOut" # Or some other status indicating no stock
                    
                    db.session.add(new_checkout)
                    # asset is already in session, changes will be committed
                    db.session.commit()

                    flash(f"Book '{asset.name}' checked out successfully to {user_for_checkout.full_name or user_for_checkout.username}. Due: {due_date_from_form.strftime('%Y-%m-%d')}.", "success")
                    app.logger.info(f"Book ID {asset.id} checked out to user ID {user_for_checkout.id} by {current_user.username}. Due: {due_date_from_form}.")
                    
                    if is_librarian:
                        return redirect(url_for("list_checkouts"))
                    else: # Student
                        return redirect(url_for("view_library")) # Student's view of their borrowed books

                except Exception as e:
                    db.session.rollback()
                    app.logger.error(f"Error during book checkout (Asset: {asset_id_to_checkout}, User: {user_to_checkout_for_id}): {e}", exc_info=True)
                    flash("An unexpected error occurred during checkout. Please try again.", "danger")

    # For GET request or if form validation failed on POST
    # The form's __init__ will repopulate choices.
    return render_template("books/checkout_book.html", 
                           form=form, 
                           is_librarian=is_librarian, 
                           title="Checkout Book/Asset - Nexus")
@app.route("/books/return/<int:checkout_id>", methods=["POST"])
@login_required
@role_required("librarian") # Only librarians can mark books as returned via this direct route
def return_book(checkout_id):
    checkout_record = db.get_or_404(BookCheckout, checkout_id, description="Checkout record not found.")

    if checkout_record.returned:
        flash(f"Book '{checkout_record.asset.name if checkout_record.asset else 'Unknown Book'}' was already marked as returned on {checkout_record.return_date.strftime('%Y-%m-%d') if checkout_record.return_date else 'N/A'}.", "info")
    else:
        try:
            checkout_record.returned = True
            checkout_record.return_date = datetime.now(timezone.utc).date()

            asset = checkout_record.asset
            if asset: # Ensure asset exists
                asset.quantity += 1
                # If asset was 'CheckedOut' (meaning it was likely out of stock due to this checkout)
                # and now has quantity, set it back to 'Available'.
                # Don't change if it was 'Under Maintenance', 'Lost', etc.
                if asset.status == "CheckedOut" and asset.quantity > 0:
                    asset.status = "Available"
                elif asset.status is None and asset.quantity > 0: # If status was never set
                     asset.status = "Available"

            db.session.commit()
            flash(f"Book '{asset.name if asset else 'Unknown Book'}' marked as returned successfully.", "success")
            app.logger.info(f"Book checkout ID {checkout_id} (Asset: {asset.id if asset else 'N/A'}) marked returned by {current_user.username}.")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error returning book for checkout ID {checkout_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while marking the book as returned. Please try again.", "danger")

    # Redirect back to where the librarian was, or a default list
    return redirect(request.referrer or url_for("list_checkouts"))
@app.route("/books/checkouts")
@login_required
@role_required("librarian")
def list_checkouts():
    page = request.args.get("page", 1, type=int)
    per_page = 15 
    status_filter = request.args.get("status", "active", type=str).lower()
    search_query = request.args.get("search", "", type=str).strip()
    today_date = datetime.now(timezone.utc).date()

    query = select(BookCheckout).options(
        joinedload(BookCheckout.asset).joinedload(Asset.category), # Load asset and its category
        joinedload(BookCheckout.user).joinedload(User.role)       # Load user and their role
    )

    if status_filter == 'active':
        query = query.where(BookCheckout.returned == False)
        query = query.order_by(BookCheckout.due_date.asc()) # Overdue first
    elif status_filter == 'overdue':
        query = query.where(BookCheckout.returned == False, BookCheckout.due_date < today_date)
        query = query.order_by(BookCheckout.due_date.asc())
    elif status_filter == 'returned':
        query = query.where(BookCheckout.returned == True)
        query = query.order_by(BookCheckout.return_date.desc()) # Newest returns first
    else: # 'all'
        query = query.order_by(BookCheckout.returned.asc(), BookCheckout.checkout_date.desc()) # Active first, then newest checkouts

    if search_query:
        search_term = f"%{search_query}%"
        # Ensure you join User and Asset if they are not default joined by the relationships
        # The options(joinedload(...)) above should make them available for filtering.
        query = query.join(BookCheckout.user).join(BookCheckout.asset).where(
            or_(
                User.full_name.ilike(search_term),
                User.username.ilike(search_term),
                Asset.name.ilike(search_term)
            )
        )
    
    # Important: Re-apply order_by if search joins changed the primary table in query construction
    # For simplicity, the initial order_by might still work, but complex joins can affect it.
    # If ordering is lost after search, re-apply a default order or the status-specific order.

    checkouts_paginated = db.paginate(query, page=page, per_page=per_page, error_out=False)

    return render_template(
        "librarian/list_checkouts.html",
        checkouts_paginated=checkouts_paginated,
        status_filter=status_filter,
        search_query=search_query,
        title="Manage Book Checkouts - Nexus"
    )

# --- PART 9 END: Book Checkout & Management ---

# --- PART 10 START: Chat and Contacts ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Message are defined.
# - Helpers: is_chat_allowed (defined in Part 3), get_allowed_roles (defined in Part 3), get_unread_message_count (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: CHAT_PERMISSIONS, VALID_ROLES dictionaries (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_), Flask imports (abort, flash, redirect, url_for, request, render_template, jsonify).
# - Other Python imports (datetime, timezone).

# get_chat_messages helper is defined here, as it's specific to chat routes

# --- (Place with other API/AJAX routes, or in a new section for Chat API) ---

@app.route("/chat/api/messages/<int:other_user_id>/new")
@login_required
def ajax_get_new_chat_messages(other_user_id):
    if other_user_id == current_user.id:
        return jsonify({"messages": [], "latest_timestamp": int(datetime.now(timezone.utc).timestamp() * 1000)}), 200

    since_ms_str = request.args.get("since")
    if not since_ms_str:
        return jsonify({"error": "Missing 'since' timestamp."}), 400
        
    try:
        since_ms = int(since_ms_str)
        # Add a small buffer (e.g., 1 second) to avoid re-fetching the exact last message due to millisecond precision
        since_time = datetime.fromtimestamp((since_ms / 1000.0) + 0.001, tz=timezone.utc) 
    except (ValueError, TypeError):
        app.logger.warning(f"AJAX Chat: Invalid 'since' timestamp '{since_ms_str}' for user {current_user.username} polling {other_user_id}.")
        return jsonify({"error": "Invalid timestamp format."}), 400

    # Fetch new messages FROM other_user_id TO current_user_id
    # AND messages FROM current_user_id TO other_user_id (if sent from another client/tab)
    new_messages_query = (
        select(Message)
        .where(
            Message.timestamp > since_time, # Key condition
            or_(
                (Message.sender_id == current_user.id) & (Message.receiver_id == other_user_id),
                (Message.sender_id == other_user_id) & (Message.receiver_id == current_user.id)
            )
        )
        .options(joinedload(Message.sender).joinedload(User.role)) # Eager load sender for client-side rendering
        .order_by(Message.timestamp.asc()) # Send in chronological order
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data = []
    latest_ts_in_batch = since_ms

    # Mark newly fetched messages FROM other_user_id as read
    unread_ids_to_mark_on_poll = []

    for msg in new_messages_list:
        messages_data.append({
            "id": msg.id,
            "sender_id": msg.sender_id,
            "sender": { # Essential for JS to render the message correctly
                "full_name": msg.sender.full_name if msg.sender else "Unknown",
                "username": msg.sender.username if msg.sender else "unknown",
                "profile_photo_url": msg.sender.profile_photo_url if msg.sender else None
            },
            "receiver_id": msg.receiver_id,
            "content": msg.content,
            "timestamp": msg.timestamp.isoformat() + "Z", # ISO format for JS
            "is_read": msg.is_read # Reflect current read status
        })
        
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms
        
        # If message is from the other user and current user is receiver, mark it read
        if msg.sender_id == other_user_id and msg.receiver_id == current_user.id and not msg.is_read:
            unread_ids_to_mark_on_poll.append(msg.id)

    if unread_ids_to_mark_on_poll:
        try:
            db.session.query(Message).filter(
                Message.id.in_(unread_ids_to_mark_on_poll)
            ).update({Message.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(f"AJAX Chat: Marked {len(unread_ids_to_mark_on_poll)} polled messages as read for user {current_user.username} from {other_user_id}.")
            # Update is_read status in the data being sent to client
            for msg_data in messages_data:
                if msg_data["id"] in unread_ids_to_mark_on_poll:
                    msg_data["is_read"] = True
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"AJAX Chat: Error marking polled messages read for user {current_user.id} from {other_user_id}: {e}", exc_info=True)

    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0)
    
    return jsonify({
        "messages": messages_data,
        "latest_timestamp": final_latest_timestamp # Crucial for client's next poll 'since'
    }), 200

def get_chat_messages(user1_id, user2_id, limit=50):
    """Fetches chat messages between two users, ordered by timestamp."""
    # Ensure app context for DB access if called outside a request context
    with app.app_context():
        # Use `or_` to filter messages where either user is the sender or receiver
        # and the other user is the corresponding receiver or sender.
        return db.session.scalars(
            select(Message)
            .where(
                ((Message.sender_id == user1_id) & (Message.receiver_id == user2_id))
                | ((Message.sender_id == user2_id) & (Message.receiver_id == user1_id))
            )
            .order_by(Message.timestamp.asc())  # Show oldest first for chat flow
            .limit(
                limit
            )  # Limit messages to prevent overload, implement pagination later if needed
        ).all()

# is_chat_allowed helper (defined in Part 3) is used below
@app.route("/chat/user/<int:target_user_id>", methods=["GET", "POST"])
@login_required
def universal_chat(target_user_id):
    if target_user_id == current_user.id:
        flash("You cannot chat with yourself.", "warning")
        return redirect(url_for("contacts_list"))

    target_user = db.session.get(User, target_user_id)
    if not target_user or not target_user.is_active or not target_user.role:
        abort(404, description="The user you are trying to chat with does not exist, is inactive, or has no role.")

    # Permission check using is_chat_allowed helper (from app.py Part 3/Phase J)
    if not is_chat_allowed(current_user, target_user):
        flash(f"You do not have permission to chat with {target_user.full_name or target_user.username}.", "danger")
        return redirect(url_for("contacts_list"))

    if request.method == "POST": # This will now be primarily for AJAX message sending
        # Expecting JSON data from chat.js
        if not request.is_json:
            return jsonify({"success": False, "error": "Invalid request format. JSON expected."}), 400
        
        data = request.get_json()
        content = data.get("message", "").strip()

        if not content:
            return jsonify({"success": False, "error": "Cannot send an empty message."}), 400
        if len(content) > 2000:
            return jsonify({"success": False, "error": "Message is too long (max 2000 characters)."}), 400

        try:
            msg = Message(
                sender_id=current_user.id,
                receiver_id=target_user.id,
                sender_role=current_user.role.name,
                receiver_role=target_user.role.name,
                content=content,
                timestamp=datetime.now(timezone.utc),
                is_read=False 
            )
            db.session.add(msg)
            db.session.commit() # Commit to get msg.id and accurate timestamp

            app.logger.info(f"AJAX: Message ID {msg.id} sent from {current_user.username} to {target_user.username}.")
            
            # Prepare message data to send back (for client-side rendering)
            # Ensure sender details are included for the _chat_message_item.html partial if rendered client-side
            message_data_for_client = {
                "id": msg.id,
                "sender_id": msg.sender_id,
                "sender": { # Frontend JS will use this to construct the sender display
                    "full_name": current_user.full_name,
                    "username": current_user.username,
                    "profile_photo_url": current_user.profile_photo_url
                },
                "receiver_id": msg.receiver_id, # Though not directly used by item, good to have
                "content": msg.content,
                "timestamp": msg.timestamp.isoformat() + "Z", # ISO format for JS Date parsing
                "is_read": msg.is_read # Will be false
            }
            
            # Optional: If you want to render the HTML snippet on the server for AJAX response
            # rendered_message_html = render_template(
            #     "partials/_chat_message_item.html",
            #     message=msg, # Pass the Message object itself
            #     current_user_id=current_user.id
            # )

            return jsonify({
                "success": True, 
                "message": "Message sent!", 
                "message_data": message_data_for_client
                # "message_html": rendered_message_html # If sending HTML
            }), 201 # 201 Created
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"AJAX: Error sending message from {current_user.id} to {target_user.id}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Server error sending message."}), 500

    # --- GET Request Logic ---
    # Fetch initial messages (e.g., last 50, newest at the bottom due to template's column-reverse)
    # The template expects messages sorted oldest first if it prepends them,
    # or newest first if it appends them at the top of a reversed container.
    # The current chat.js appends to top of a column-reverse div, so messages should be oldest first.
    initial_messages_query = (
        db.select(Message)
        .where(
            or_(
                (Message.sender_id == current_user.id) & (Message.receiver_id == target_user.id),
                (Message.sender_id == target_user.id) & (Message.receiver_id == current_user.id)
            )
        )
        .options(joinedload(Message.sender).joinedload(User.role)) # Eager load sender and their role
        .order_by(Message.timestamp.asc()) # Oldest first for appending to a reversed container
        .limit(50) # Load initial batch
    )
    messages = db.session.scalars(initial_messages_query).all()

    # Mark messages received FROM target_user in THIS batch as read
    unread_ids_in_batch_to_mark = [
        m.id for m in messages if m.sender_id == target_user.id and not m.is_read
    ]
    if unread_ids_in_batch_to_mark:
        try:
            db.session.query(Message).filter(
                Message.id.in_(unread_ids_in_batch_to_mark)
            ).update({Message.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(f"Marked {len(unread_ids_in_batch_to_mark)} messages as read from user {target_user.username} upon opening chat with {current_user.username}.")
            # Update objects in 'messages' list to reflect read status for immediate display
            for m in messages:
                if m.id in unread_ids_in_batch_to_mark:
                    m.is_read = True # This won't persist if not committed, but good for template
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error marking messages read in chat between {current_user.id} and {target_user.id}: {e}", exc_info=True)

    return render_template(
        "chat/universal_chat.html",
        target_user=target_user,
        messages=messages, # Pass initial messages
        title=f"Chat with {target_user.full_name or target_user.username} - Nexus"
    )
@app.route("/contacts")
@login_required
def contacts_list():
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for('role_redirect'))

    # Uses get_allowed_chat_roles (which calls get_allowed_roles_helper)
    # This helper is defined in your app.py (Phase J or original Part 3/4).
    allowed_chat_send_to_roles = get_allowed_chat_roles('send_to', current_user)

    contacts_query = (
        select(User)
        .join(User.role) # Assuming User.role relationship
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name.in_(allowed_chat_send_to_roles) # Roles current user can INITIATE chat WITH
        )
        .options(joinedload(User.role)) # Eager load role for display
        .order_by(User.full_name.asc()) # Order alphabetically
    )
    contacts = db.session.scalars(contacts_query).all()

    # Optional: Get unread message counts for each contact from current_user
    contact_unread_counts = {}
    if contacts:
        for contact in contacts:
            # Count unread messages FROM this contact TO current_user
            count = db.session.scalar(
                select(func.count(Message.id))
                .where(
                    Message.sender_id == contact.id,
                    Message.receiver_id == current_user.id,
                    Message.is_read == False
                )
            )
            if count and count > 0:
                contact_unread_counts[contact.id] = count
                
    # all_roles for filter UI, VALID_ROLES from app.config or global
    all_roles_for_filter = current_app.config.get('VALID_ROLES', [])


    return render_template(
        "chat/contacts_list.html",
        contacts=contacts,
        contact_unread_counts=contact_unread_counts, # Pass the unread counts
        all_roles=all_roles_for_filter,
        title="My Chat Contacts - Nexus",
        selected_role_filter='all' # For filter UI state if implemented
    )
@app.route("/contacts_by_role/<string:display_role_filter>")
@login_required
def contacts_by_role_filter(display_role_filter):
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for('role_redirect'))

    allowed_chat_send_to_roles = get_allowed_chat_roles('send_to', current_user)
    display_role_filter_lower = display_role_filter.lower()
    valid_role_names_lower = [r[0].lower() for r in current_app.config.get('VALID_ROLES', [])]

    if display_role_filter_lower != 'all' and display_role_filter_lower not in valid_role_names_lower:
        flash(f"Invalid role filter: {display_role_filter}", "warning")
        return redirect(url_for('contacts_list'))

    contacts_query = (
        select(User)
        .join(User.role)
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name.in_(allowed_chat_send_to_roles)
        )
    )

    if display_role_filter_lower != 'all':
        if display_role_filter_lower in allowed_chat_send_to_roles:
            contacts_query = contacts_query.where(func.lower(Role.name) == display_role_filter_lower)
        else: # User requested a role they aren't allowed to chat with based on their 'send_to'
            flash(f"You do not have permission to initiate chats with users in the '{display_role_filter}' role.", "warning")
            contacts = [] # Override query to return empty
            # To prevent further processing if contacts is empty:
            contact_unread_counts = {}
            all_roles_for_filter = current_app.config.get('VALID_ROLES', [])
            return render_template(
                "chat/contacts_list.html",
                contacts=contacts,
                contact_unread_counts=contact_unread_counts,
                all_roles=all_roles_for_filter,
                title=f"{display_role_filter.replace('_', ' ').title()} Contacts - Nexus",
                selected_role_filter=display_role_filter
            )
    
    contacts = db.session.scalars(contacts_query.order_by(User.full_name.asc())).all()
    
    contact_unread_counts = {}
    if contacts:
        for contact in contacts:
            count = db.session.scalar(
                select(func.count(Message.id))
                .where(Message.sender_id == contact.id, Message.receiver_id == current_user.id, Message.is_read == False)
            )
            if count and count > 0: contact_unread_counts[contact.id] = count
            
    all_roles_for_filter = current_app.config.get('VALID_ROLES', [])

    return render_template(
        "chat/contacts_list.html",
        contacts=contacts,
        contact_unread_counts=contact_unread_counts,
        all_roles=all_roles_for_filter,
        title=f"{display_role_filter.replace('_', ' ').title()} Contacts - Nexus",
        selected_role_filter=display_role_filter
    )
# --- PART 10 END: Chat and Contacts ---    
# --- PART 11 START: Notifications ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Notification are defined.
# - Forms: NotificationForm is defined (in Part 4).
# - Helpers: get_unread_notifications_count (defined in Part 3), get_allowed_roles (defined in Part 3), can_send (defined in Part 3), can_receive (defined in Part 3).
# - Decorators: login_required is defined.
# - Configuration: NOTIFICATION_PERMISSIONS dictionary (defined in Part 3).
# - SQLAlchemy imports (select, func, joinedload, or_, literal, case), Flask imports (abort, flash, redirect, url_for, request, render_template, make_response, jsonify), and other Python imports (datetime, timezone, uuid, secure_filename, os).

@app.route("/notifications")
@login_required
def view_notifications():
    # Fetch notifications, unread first, then newest
    notifications_query = (
        select(Notification)
        .where(Notification.receiver_id == current_user.id)
        .options(joinedload(Notification.sender)) # Eager load sender for display
        .order_by(Notification.is_read.asc(), Notification.timestamp.desc())
    )
    notifications = db.session.scalars(notifications_query).all()

    # Mark these specific fetched notifications as read if they are unread
    unread_ids_to_mark = [n.id for n in notifications if not n.is_read]
    if unread_ids_to_mark:
        try:
            db.session.query(Notification).filter(
                Notification.id.in_(unread_ids_to_mark),
                Notification.receiver_id == current_user.id # Safety check
            ).update({Notification.is_read: True}, synchronize_session=False)
            db.session.commit()
            app.logger.info(f"Marked {len(unread_ids_to_mark)} notifications as read for user {current_user.username} upon viewing /notifications page.")
            # Update the is_read status on the objects we are about to pass to the template
            for n in notifications:
                if n.id in unread_ids_to_mark:
                    n.is_read = True
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error marking notifications as read for user {current_user.id} on /notifications view: {e}", exc_info=True)
            flash("Could not update notification read status.", "warning")
            
    return render_template("notifications/view.html", 
                           notifications=notifications, 
                           title="My Notifications - Nexus")

@app.route("/notifications/contacts_for_sending")
@login_required
def notification_contacts_for_sending():
    if not current_user.role:
        flash("Your user role is not properly configured. Cannot determine contacts.", "danger")
        return redirect(url_for('role_redirect'))

    # Uses get_allowed_notification_roles (which calls get_allowed_roles_helper)
    # This helper should be defined as per your original app.py Part 3/4 or my Phase J adjustments.
    allowed_receiver_role_names = get_allowed_notification_roles('send_to', current_user)

    contacts_query = (
        select(User)
        .join(User.role) # Assuming User.role relationship
        .where(
            User.id != current_user.id,
            User.is_active == True,
            Role.name.in_(allowed_receiver_role_names)
        )
        .options(joinedload(User.role)) # Eager load role for display
        .order_by(Role.name.asc(), User.full_name.asc())
    )
    contacts = db.session.scalars(contacts_query).all()
    
    # all_roles is used by the template for potential filtering UI, ensure it's available
    # VALID_ROLES should be defined globally or in app.config as per app.py Part 4 or my Phase J
    all_roles_for_filter = current_app.config.get('VALID_ROLES', [])


    return render_template(
        "notifications/contacts_for_sending.html",
        contacts=contacts,
        all_roles=all_roles_for_filter, # Pass for potential filter UI
        title="Send Notification - Select Recipient - Nexus",
        selected_role_filter='all' # For filter UI state if implemented
    )
# Optional route to filter notification contacts by role - similar to chat contacts
# @app.route("/notifications/contacts_for_sending/by_role/<string:display_role_filter>")
# @login_required
# def notification_contacts_for_sending_by_role_filter(display_role_filter):
#      # Logic similar to contacts_by_role_filter, but using notification permissions
#      pass
@app.route("/notifications/send_to/<int:receiver_id>", methods=["GET", "POST"])
@login_required
def send_notification_to_user(receiver_id):
    receiver = db.get_or_404(User, receiver_id, description="Recipient not found.")
    if not receiver.is_active or not receiver.role:
        flash("Cannot send notification: Recipient is inactive or has no role.", "warning")
        return redirect(url_for("notification_contacts_for_sending"))

    # Permission check using is_notification_allowed helper from app.py Part 3/Phase J
    if not is_notification_allowed(current_user, receiver):
        flash(f"You do not have permission to send notifications to {receiver.full_name or receiver.username}.", "danger")
        return redirect(url_for("notification_contacts_for_sending"))

    form = NotificationForm() # Your NotificationForm definition

    if form.validate_on_submit():
        try:
            notification = Notification(
                sender_id=current_user.id,
                receiver_id=receiver.id,
                content=form.content.data.strip(),
                # link_url = form.link_url.data.strip() if hasattr(form, 'link_url') and form.link_url.data else None, # If form has link_url
                timestamp=datetime.now(timezone.utc),
                is_read=False,
                notification_type='manual_general' # A type for manually sent notifications
            )
            db.session.add(notification)
            db.session.commit()
            flash(f"Notification sent successfully to {receiver.full_name or receiver.username}!", "success")
            app.logger.info(f"Notification ID {notification.id} sent from {current_user.username} to {receiver.username}.")
            return redirect(url_for("view_notifications"))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error sending notification from {current_user.username} to {receiver.username}: {e}", exc_info=True)
            flash("Failed to send notification due to a server error. Please try again.", "danger")
            # Re-render form with errors

    return render_template(
        "notifications/send_form.html",
        form=form,
        receiver=receiver,
        title=f"Send Notification to {receiver.full_name or receiver.username} - Nexus"
    )

# Add AJAX endpoints for managing notification status (Mark as read, Check for new)

# --- (Place with other API/AJAX routes, or in a new section for Notification API) ---

@app.route("/notifications/mark-all-read", methods=["POST"])
@login_required
def ajax_mark_all_notifications_read():
    try:
        updated_count_result = db.session.execute(
            db.update(Notification).where(
                Notification.receiver_id == current_user.id,
                Notification.is_read == False
            ).values(is_read=True)
        )
        db.session.commit()
        updated_count = updated_count_result.rowcount

        app.logger.info(f"AJAX: Marked {updated_count} notifications as read for user {current_user.username}.")
        return jsonify({
            "success": True,
            "message": f"{updated_count} notification(s) marked as read.",
            "updated_count": updated_count # JS can use this to update UI if needed
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"AJAX: Error marking all notifications read for user {current_user.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error marking notifications."}), 500

@app.route("/notifications/mark-read/<int:notification_id>", methods=["POST"])
@login_required
def ajax_mark_notification_read(notification_id):
    try:
        notification = db.session.get(Notification, notification_id)
        if not notification:
            return jsonify({"success": False, "error": "Notification not found."}), 404
        if notification.receiver_id != current_user.id:
            return jsonify({"success": False, "error": "Unauthorized."}), 403

        if not notification.is_read:
            notification.is_read = True
            db.session.commit()
            app.logger.info(f"AJAX: Marked notification {notification_id} as read for user {current_user.username}.")
        
        # Get current total unread count to send back
        current_total_unread = get_unread_notifications_count(current_user.id)

        return jsonify({
            "success": True, 
            "message": "Notification marked as read.", 
            "notification_id": notification_id,
            "total_unread_count": current_total_unread
            }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"AJAX: Error marking notification {notification_id} read for user {current_user.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/notifications/check-new")
@login_required
def ajax_check_new_notifications():
    since_ms_str = request.args.get("since")
    if not since_ms_str:
        # If no 'since', return current total unread and current server time, no new messages
        current_total_unread = get_unread_notifications_count(current_user.id)
        return jsonify({
            "newNotificationsHTML": [], # HTML snippets for new notifications
            "new_notification_data": [], # Raw data for new notifications
            "count": 0,
            "latestTimestamp": int(datetime.now(timezone.utc).timestamp() * 1000),
            "totalUnreadCount": current_total_unread
        }), 200
        
    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp(since_ms / 1000.0, tz=timezone.utc)
    except (ValueError, TypeError):
        app.logger.warning(f"AJAX: Invalid 'since' timestamp '{since_ms_str}' for user {current_user.username}.")
        return jsonify({"success": False, "error": "Invalid timestamp format."}), 400

    new_notifications_query = (
        select(Notification)
        .where(
            Notification.receiver_id == current_user.id,
            Notification.timestamp > since_time
        )
        .options(joinedload(Notification.sender)) # Eager load sender for template
        .order_by(Notification.timestamp.desc()) # Newest first
    )
    new_notifications_list = db.session.scalars(new_notifications_query).all()

    rendered_html_snippets = []
    new_notification_data_list = [] # For potential non-HTML updates

    latest_ts_in_batch = since_ms # Start with the 'since' timestamp

    for n in new_notifications_list:
        # Render each new notification item using the partial
        # Ensure `humanize_time_diff` is available to templates
        html_snippet = render_template("partials/_notification_item.html", notification=n)
        rendered_html_snippets.append(html_snippet)
        
        # Also prepare raw data if JS needs it for more complex updates
        new_notification_data_list.append({
            "id": n.id,
            "content": n.content,
            "link_url": n.link_url,
            "timestamp_iso": n.timestamp.isoformat(),
            "sender_name": n.sender.full_name or n.sender.username if n.sender else "System",
            "is_read": n.is_read, # Should be false for new ones
            "notification_type": n.notification_type
        })
        
        # Update latest timestamp from this batch
        notification_ts_ms = int(n.timestamp.timestamp() * 1000)
        if notification_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = notification_ts_ms
            
    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_notifications_list else 0)
    
    # Get current total unread count to send back for accurate badge update
    current_total_unread = get_unread_notifications_count(current_user.id)

    return jsonify({
        "newNotificationsHTML": rendered_html_snippets, # Pass rendered HTML
        "new_notification_data": new_notification_data_list, # Pass raw data
        "count": len(new_notifications_list),
        "latestTimestamp": final_latest_timestamp, # Crucial for next poll
        "totalUnreadCount": current_total_unread # For accurate badge update
    }), 200

@app.route("/notifications/mark-all-read", methods=["POST"])
@login_required # User must be logged in
def mark_all_notifications_read():
    """Mark all unread notifications as read for the current user (AJAX endpoint)."""
    try:
        # Use a bulk update for efficiency to mark all unread notifications for the current user as read
        updated_count = db.session.query(Notification).filter(
            Notification.receiver_id == current_user.id, # Only affect current user's notifications
            Notification.is_read == False # Only update those that are currently unread
        ).update(
            {Notification.is_read: True}, # Set is_read to True
            synchronize_session=False # Required for bulk updates outside standard ORM session sync
        )
        db.session.commit() # Commit the bulk update

        app.logger.info(f"Marked {updated_count} notifications as read for user {current_user.username} (ID: {current_user.id}) via mark-all-read endpoint.")

        # Return a JSON response indicating success and the number of notifications updated
        return jsonify({
            "success": True,
            "message": f"Marked {updated_count} notifications as read",
            "updated_count": updated_count
        }), 200 # 200 OK success status code

    except Exception as e:
        db.session.rollback() # Rollback the transaction on error
        app.logger.error(f"Error marking all notifications as read for user {current_user.id}: {e}", exc_info=True)
        # Return a JSON response indicating failure
        return jsonify({
            "success": False,
            "error": "Failed to mark notifications as read due to a server error."
        }), 500 # 500 Internal Server Error status code


@app.route("/notifications/mark-read/<int:notification_id>", methods=["POST"])
@login_required # User must be logged in
def mark_notification_read(notification_id):
    """Mark a specific notification as read (AJAX endpoint)."""
    try:
        # Fetch the specific notification by ID
        notification = db.session.get(Notification, notification_id)

        # Check if notification exists and belongs to the current user
        if not notification:
            app.logger.warning(f"Mark read attempt failed for non-existent notification ID {notification_id} by user {current_user.id}.")
            return jsonify({
                "success": False,
                "error": "Notification not found"
            }), 404 # 404 Not Found

        # Security check: Ensure the notification belongs to the currently logged-in user
        if notification.receiver_id != current_user.id:
            app.logger.warning(f"Unauthorized mark read attempt: User {current_user.id} tried to mark notification {notification_id} belonging to user {notification.receiver_id}.")
            return jsonify({
                "success": False,
                "error": "Unauthorized access to notification"
            }), 403 # 403 Forbidden

        # Only update the notification if it's currently unread
        if not notification.is_read:
            notification.is_read = True # Mark as read
            db.session.commit() # Commit the change
            app.logger.info(f"Marked notification {notification_id} as read for user {current_user.username} (ID: {current_user.id}).")
            # Return success JSON response
            return jsonify({
                "success": True,
                "message": "Notification marked as read",
                "notification_id": notification_id
            }), 200 # 200 OK
        else:
             # Notification was already read, return success but indicate no change was needed
             app.logger.debug(f"Notification {notification_id} was already read for user {current_user.id}.")
             return jsonify({
                "success": True,
                "message": "Notification was already read",
                "notification_id": notification_id
            }), 200


    except Exception as e:
        db.session.rollback() # Rollback on error
        app.logger.error(f"Error marking notification {notification_id} as read for user {current_user.id}: {e}", exc_info=True)
        # Return JSON response indicating failure
        return jsonify({
            "success": False,
            "error": "Failed to mark notification as read due to a server error."
        }), 500 # 500 Internal Server Error


@app.route("/notifications/check-new")
@login_required # User must be logged in to check for new notifications
def check_new_notifications():
    """
    Checks for new notifications received by the current user since a given timestamp (AJAX endpoint for polling).
    Expected query parameter: `since` (timestamp in milliseconds since epoch).
    """
    try:
        # Get the 'since' timestamp from query arguments
        since_ms = request.args.get("since", type=int)

        # Validate the input timestamp
        if since_ms is None or since_ms < 0:
             app.logger.warning(f"Invalid or missing 'since' timestamp ({since_ms}) from user {current_user.id}. Returning empty new notifications.")
             # Return current time and an empty list
             return jsonify({
                "newNotifications": [],
                "count": 0,
                "latestTimestamp": int(datetime.now(timezone.utc).timestamp() * 1000)
            }), 200 # 200 OK

        # Convert milliseconds timestamp to datetime object (UTC)
        # Handle potential errors during conversion (e.g., excessively large timestamp)
        try:
            since_time = datetime.fromtimestamp(since_ms / 1000.0, tz=timezone.utc)
        except (ValueError, OverflowError):
             app.logger.warning(f"Invalid 'since' timestamp value {since_ms} from user {current_user.id}. Conversion error. Returning empty new notifications.")
             # Return current time and an empty list
             return jsonify({
                "newNotifications": [],
                "count": 0,
                "latestTimestamp": int(datetime.now(timezone.utc).timestamp() * 1000)
            }), 200


        # Query for new notifications received by the current user since the provided timestamp
        # Order by timestamp descending (newest first)
        new_notifications = db.session.scalars(Notification.query.filter(
            Notification.receiver_id == current_user.id, # For the current user
            Notification.timestamp > since_time # Notifications created AFTER the 'since' timestamp
        ).order_by(Notification.timestamp.desc())).all()


        # Prepare HTML snippets for the new notifications for display on the client side
        html_snippets = []
        for n in new_notifications:
             try:
                 # Render a small HTML snippet for each new notification using a partial template
                 # Assume a template file like `partials/notification_item.html` exists for rendering a single notification
                 html_snippets.append(render_template("partials/notification_item.html", notification=n))
             except Exception as render_e:
                 app.logger.error(f"Error rendering notification item {n.id} for user {current_user.id}: {render_e}", exc_info=True)
                 # Optionally include a placeholder error message in the snippet list

        # Get the current server timestamp (in milliseconds) to send back to the client
        # The client will use this for the 'since' parameter in the next polling request.
        current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)


        # Return a JSON response containing the new notifications' HTML, count, and the latest server timestamp
        return jsonify({
            "newNotifications": html_snippets, # List of rendered HTML strings
            "count": len(new_notifications), # Number of new notifications fetched
            "latestTimestamp": current_server_timestamp_ms # Server timestamp for next poll
        }), 200 # 200 OK success status code

    except Exception as e:
        # Log any unexpected errors during the check
        app.logger.error(f"Error checking new notifications for user {current_user.id}: {e}", exc_info=True)
        # Return a JSON response indicating failure
        return jsonify({
            "success": False,
            "error": "Failed to fetch new notifications due to a server error."
        }), 500 # 500 Internal Server Error status code

# Notification settings route - needs implementation based on user model fields (e.g., email_notifications, push_notifications)
# This route is likely part of the universal settings page (Part 13) or a dedicated notifications settings page.
@app.route("/notifications/settings", methods=["GET", "POST"])
@login_required # User must be logged in to change settings
def notification_settings():
    """Allows the current user to manage their notification preferences."""
    # This route is typically accessed as a GET to display the current settings
    # and a POST to save updated settings.

    # This requires notification preference columns on the User model (added in Part 2's User model update).
    # Example: email_notifications, push_notifications, notification_sound, etc.

    # A dedicated form for notification settings (`NotificationSettingsForm`) could be defined in Part 4,
    # or these settings could be integrated into the `UniversalSettingsForm` (Part 13).
    # If using a dedicated form:
    # form = NotificationSettingsForm(obj=current_user) # Populate form fields from current_user object

    if request.method == "POST":
        # Handle saving the notification settings from the submitted data.
        # The data might come from a standard form POST or an AJAX JSON request.

        # --- Option 1: Handle data directly from request.form (if using a standard form) ---
        # Assuming form fields like 'email_notifications', 'push_notifications' exist in request.form
        # try:
        #     # Update user attributes based on form data (checkboxes submit 'on' or are missing)
        #     current_user.email_notifications = 'email_notifications' in request.form
        #     current_user.push_notifications = 'push_notifications' in request.form # If column exists
        #     current_user.notification_sound = 'notification_sound' in request.form # If column exists
        #     # Add updates for other notification settings...

        #     db.session.commit() # Save changes
        #     flash("Notification settings saved successfully!", "success")
        #     app.logger.info(f"Notification settings updated for user {current_user.id} via POST.")
        #     # Redirect back to the settings page (GET method)
        #     return redirect(url_for('notification_settings'))

        # except Exception as e:
        #     db.session.rollback()
        #     app.logger.error(f"Error updating notification settings for user {current_user.id} via POST: {e}", exc_info=True)
        #     flash("Failed to save notification settings due to a server error.", "danger")
        #     # Re-render the page with error message - might need to fetch current settings again if not using a form object
        #     # If using a form: return render_template("notifications/settings.html", form=form, title="Notification Settings")
        #     # If not using a form: render the page directly and flash message is shown
        #     return render_template("notifications/settings.html", title="Notification Settings")


        # --- Option 2: Handle data from JSON request (if using AJAX save) ---
        if request.is_json:
            try:
                data = request.get_json() # Get JSON data from the request body

                # Update user attributes based on JSON data keys
                # Accessing data using .get() with a default handles missing keys gracefully
                # Assuming keys like 'email_notifications', 'push_notifications', 'notification_sound' etc.
                # Values expected: boolean (True/False)
                if 'email_notifications' in data: # Check if the key exists in the JSON
                    current_user.email_notifications = bool(data['email_notifications']) # Ensure boolean type
                # Add updates for other notification settings if they exist on the User model:
                # if 'push_notifications' in data:
                #      current_user.push_notifications = bool(data['push_notifications'])
                # if 'notification_sound' in data:
                #      current_user.notification_sound = bool(data['notification_sound'])
                # ... etc. for other notification settings columns ...


                db.session.commit() # Save changes to the database

                app.logger.info(f"Notification settings updated for user {current_user.id} via AJAX.")
                # Return a JSON response indicating success
                return jsonify({"success": True, "message": "Notification settings saved."}), 200 # 200 OK

            except Exception as e:
                db.session.rollback() # Rollback on error
                app.logger.error(f"Error updating notification settings for user {current_user.id} via AJAX: {e}", exc_info=True)
                # Return a JSON response indicating failure
                return jsonify({"success": False, "message": "Failed to save notification settings."}), 500 # 500 Internal Server Error

        else: # Handle cases where POST is not JSON (and not a standard form, if Option 1 is commented out)
            flash("Invalid request format for saving notification settings.", "danger")
            # Redirect back or re-render the page
            return redirect(url_for('notification_settings')) # Redirect back on error


    # --- Handle GET request (displaying the notification settings page) ---
    # Render the settings page template.
    # If using a dedicated form, pass it: return render_template("notifications/settings.html", form=form, title="Notification Settings")
    # If reading settings directly from the current_user object in the template:
    return render_template("notifications/settings.html", title="Notification Settings")


# --- PART 11 END: Notifications ---

# --- Group Routes ---
@app.route("/social/groups")
@login_required
def social_group_list():
    # Fetch groups current user is a member of (any role)
    # This query joins SocialGroup through SocialGroupMember
    my_groups_query = (
        select(SocialGroup)
        .join(SocialGroupMember)
        .where(
            SocialGroupMember.user_id == current_user.id,
            SocialGroup.is_active == True # Only active groups
        )
        .options(
            joinedload(SocialGroup.owner), # Eager load owner for display
            joinedload(SocialGroup.members) # To get member count easily in template
        )
        .order_by(SocialGroup.name.asc())
    )
    my_groups = db.session.scalars(my_groups_query).all()
    
    return render_template("social/groups/list.html",
                           my_groups=my_groups,
                           title="My Social Groups - Nexus")
# Route to discover groups (optional - similar to channels, but groups are often private)
# This would typically list public groups or groups where membership is open/requestable.
# @app.route("/social/groups/discovery")
# @login_required
# def social_group_discovery():
#      # Query for public groups or groups user can join
#      pass
@app.route("/social/groups/<int:group_id>") # Add methods=['GET'] if it only handles GET for now (POST is separate)
@login_required
def view_social_group(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    if not group.is_active:
        flash(f"Group '{group.name}' is currently not active.", "warning")
        return redirect(url_for('social_group_list'))

    user_group_role = current_user.get_group_role(group) # Helper from User model
    if not user_group_role: # Not a member
        # For groups, usually only members can view. Adjust if public groups are a feature.
        flash(f"You must be a member of '{group.name}' to view its content.", "warning")
        return redirect(url_for('social_group_list')) # Or a group discovery page
        
    # Fetch initial messages (e.g., paginated)
    # Assuming column-reverse, so fetch oldest first if prepending via JS later, or newest if initial load shows latest
    messages_query = (
        select(GroupMessage)
        .where(GroupMessage.group_id == group.id)
        .options(
            joinedload(GroupMessage.author).joinedload(User.role), 
            joinedload(GroupMessage.file)
        )
        .order_by(GroupMessage.timestamp.asc()) # Oldest first for typical chat display append
        .limit(50) # Initial batch
    )
    messages = db.session.scalars(messages_query).all()
    
    # Form for creating new messages in this group
    post_form = PostContentForm() # Your PostContentForm for message input

    return render_template("social/groups/view_group.html",
                           group=group,
                           messages=messages,
                           # pagination=pagination, # If messages are paginated
                           post_form=post_form,
                           user_group_role=user_group_role, # e.g., 'owner', 'admin', 'member'
                           title=f"{group.name} - Group Chat - Nexus")
# Route to redirect for viewing a specific message (e.g., from a notification link)
@app.route("/social/messages/<int:message_id>/view")
@login_required
def view_social_group_message_redirect(message_id):
    """Redirects to the group page containing a specific message."""
    message = db.get_or_404(GroupMessage, message_id)

    # Before redirecting, check if the user has permission to view the group where this message is located
    if not current_user.is_group_member(message.group): # Uses User model helper
         flash("You do not have permission to view this message.", "danger")
         return redirect(url_for("social_group_list")) # Redirect to group list or similar safe page

    # Redirect to the group page. Use an anchor if the frontend chat UI supports it.
    # The anchor helps the page scroll to the specific message if the template is set up for it.
    return redirect(url_for("view_social_group", group_id=message.group_id, _anchor=f"message-{message.id}"))
    
@app.route("/social/groups/<int:group_id>/create_message", methods=["POST"])
@login_required
def create_group_message(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    if not group.is_active:
        return jsonify({"success": False, "error": "This group is not active."}), 403

    user_group_role = current_user.get_group_role(group)
    if not user_group_role: # Must be a member to post
        return jsonify({"success": False, "error": "You must be a member to send messages in this group."}), 403

    # Assume PostContentForm for validation consistency
    form = PostContentForm(request.form) 
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Message content or a file must be provided."}), 400
    if form.content.data and not form.content.validate(form):
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage) # Reusing helper
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed."}), 400
        except Exception as e:
            app.logger.error(f"Error processing file for group message by {current_user.username}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Error processing file."}), 500
            
    try:
        new_message = GroupMessage( # Ensure GroupMessage model is imported
            group_id=group.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_message)
        db.session.commit()

        app.logger.info(f"User {current_user.username} sent message ID {new_message.id} in group {group.id}.")

        # Prepare message data for client-side rendering using _chat_message_item.html
        # The _chat_message_item.html expects a 'message' object with 'sender', 'content', 'timestamp'
        message_data_for_client = {
            "id": new_message.id,
            "sender_id": new_message.author_id, # Correct field
            "sender": {
                "full_name": current_user.full_name,
                "username": current_user.username,
                "profile_photo_url": current_user.profile_photo_url
            },
            "content": new_message.content,
            "timestamp": new_message.timestamp.isoformat() + "Z",
            # Include file info if any, for the _chat_message_item to render (if it handles files)
            "file": {
                "id": uploaded_file_obj.id,
                "original_filename": uploaded_file_obj.original_filename,
                "mimetype": uploaded_file_obj.mimetype,
                "size": uploaded_file_obj.size,
                "download_url": url_for('download_social_file', file_id=uploaded_file_obj.id) # Assuming this route exists
            } if uploaded_file_obj else None
        }
        # OR render HTML on server
        # message_for_render = db.session.query(GroupMessage).options(...).get(new_message.id)
        # post_html = render_template("partials/_chat_message_item.html", message=message_for_render, current_user_id=current_user.id)


        return jsonify({
            "success": True, 
            "message": "Message sent!",
            # "post_html": post_html, # If rendering HTML snippet on server
            "post_data": message_data_for_client # If rendering on client
        }), 201

    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath: # Cleanup
            try: os.remove(os.path.join(current_app.static_folder, uploaded_file_obj.filepath))
            except: pass
        app.logger.error(f"Error creating group message in group {group.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error sending message."}), 500

# --- Channel and Group Creation/Management Routes ---
@app.route("/social/api/groups/<int:group_id>/messages/new")
@login_required
def ajax_get_new_group_messages(group_id):
    group = db.get_or_404(SocialGroup, group_id)
    if not current_user.is_group_member(group): # User.is_group_member helper
        return jsonify({"error": "Access denied."}), 403

    since_ms_str = request.args.get("since")
    if not since_ms_str: return jsonify({"error": "Missing 'since' timestamp."}), 400
        
    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp((since_ms / 1000.0) + 0.001, tz=timezone.utc)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid timestamp format."}), 400

    new_messages_query = (
        select(GroupMessage)
        .where(
            GroupMessage.group_id == group_id,
            GroupMessage.timestamp > since_time
        )
        .options(joinedload(GroupMessage.author).joinedload(User.role), joinedload(GroupMessage.file))
        .order_by(GroupMessage.timestamp.asc())
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data_for_client = []
    latest_ts_in_batch = since_ms
    for msg in new_messages_list:
        # Prepare data similarly to create_group_message response
        messages_data_for_client.append({
            "id": msg.id,
            "sender_id": msg.author_id,
            "sender": {
                "full_name": msg.author.full_name if msg.author else "Unknown",
                "username": msg.author.username if msg.author else "unknown",
                "profile_photo_url": msg.author.profile_photo_url if msg.author else None
            },
            "content": msg.content,
            "timestamp": msg.timestamp.isoformat() + "Z",
            "file": {
                "id": msg.file.id,
                "original_filename": msg.file.original_filename,
                "mimetype": msg.file.mimetype,
                "size": msg.file.size,
                "download_url": url_for('download_social_file', file_id=msg.file.id)
            } if msg.file else None
        })
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch:
            latest_ts_in_batch = msg_ts_ms
            
    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0)

    return jsonify({
        "messages": messages_data_for_client, # Send structured data
        "latest_timestamp": final_latest_timestamp
    }), 200
# Note: create_social_channel and create_social_group routes were already generated in Part 8 accidentally.
# I will regenerate them here for completeness of Part 12, assuming they were not included in previous parts.
# If they WERE included in Part 8, you should remove the duplicates.

# Helper function to save profile photos (separate from general file uploads)
# Assuming this helper was intended for Part 12 and is defined here.
# --- (Place with other helper functions, ensure secure_filename, os, uuid are imported) ---
# from werkzeug.utils import secure_filename
# import os
# import uuid
# from flask import current_app, flash # Ensure current_app and flash are available

# Define UPLOAD_PHOTO_FOLDER at the top level of your app.py, after app initialization
# if not already defined in a more central config place.
# UPLOAD_PHOTO_FOLDER = os.path.join(app.root_path, 'static', 'uploads', 'profile_photos')
# app.config['UPLOAD_PHOTO_FOLDER'] = UPLOAD_PHOTO_FOLDER 
# It's better if app.config['UPLOAD_PHOTO_FOLDER'] is set during app configuration.

def save_profile_photo(file_storage):
    """Saves an uploaded profile photo securely and returns its relative path for DB storage."""
    if not file_storage or not file_storage.filename:
        # This case should ideally be caught by FileField validators if field is required
        return None

    # Ensure the target upload folder exists
    # It's better to ensure this once at app startup or use app.config
    upload_folder = current_app.config.get('UPLOAD_PHOTO_FOLDER', os.path.join(current_app.root_path, 'static', 'uploads', 'profile_photos'))
    os.makedirs(upload_folder, exist_ok=True)

    # Allowed extensions for photos
    ALLOWED_PHOTO_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file_storage.filename)
    
    file_ext = filename.rsplit('.', 1)[1].lower() if '.' in filename else ''
    if file_ext not in ALLOWED_PHOTO_EXTENSIONS:
        flash(f"Invalid file type for profile photo: '{file_ext}'. Allowed: {', '.join(ALLOWED_PHOTO_EXTENSIONS)}.", "danger")
        app.logger.warning(f"Profile photo upload rejected for user {current_user.id if current_user.is_authenticated else 'Unknown'}: Invalid extension '{file_ext}'.")
        return None # Indicate failure

    # Check file size (example: 2MB limit)
    # FilePond might handle this client-side, but server-side check is crucial.
    MAX_PHOTO_SIZE = current_app.config.get('MAX_PROFILE_PHOTO_SIZE_MB', 2) * 1024 * 1024 # e.g., 2MB
    file_storage.seek(0, os.SEEK_END)
    file_length = file_storage.tell()
    file_storage.seek(0) # Reset cursor
    if file_length > MAX_PHOTO_SIZE:
        flash(f"Profile photo exceeds maximum size of {MAX_PHOTO_SIZE / (1024*1024):.0f}MB.", "danger")
        app.logger.warning(f"Profile photo upload rejected for user {current_user.id if current_user.is_authenticated else 'Unknown'}: File too large ({file_length} bytes).")
        return None # Indicate failure

    # Generate a unique filename using UUID to prevent collisions and obscure original name
    unique_filename = str(uuid.uuid4()) + '.' + file_ext
    save_path_full = os.path.join(upload_folder, unique_filename)

    try:
        file_storage.save(save_path_full)
        app.logger.info(f"Profile photo '{unique_filename}' saved to '{save_path_full}' for user {current_user.id if current_user.is_authenticated else 'Unknown'}.")
        # Return the path relative to the 'static' folder for use in url_for()
        # e.g., uploads/profile_photos/unique_filename.jpg
        # This assumes your UPLOAD_PHOTO_FOLDER is under 'static'.
        # Adjust if your static file serving or UPLOAD_PHOTO_FOLDER structure is different.
        # The path stored in User.profile_photo_url should be relative from 'static'.
        # Example: if app.root_path is /srv/app, and upload_folder is /srv/app/static/uploads/profile_photos
        # then relative_path should be uploads/profile_photos/unique_filename.jpg
        
        # Construct the relative path from the 'static' folder correctly
        static_folder_path = os.path.join(current_app.root_path, 'static')
        relative_path = os.path.relpath(save_path_full, static_folder_path)
        # On Windows, relpath might use backslashes; convert to forward slashes for URLs
        return relative_path.replace(os.sep, '/')

    except Exception as e:
        app.logger.error(f"Error saving profile photo '{unique_filename}': {e}", exc_info=True)
        flash("An error occurred while saving the profile photo. Please try again.", "danger")
        # Optionally, attempt to clean up if file was partially saved
        if os.path.exists(save_path_full):
            try:
                os.remove(save_path_full)
            except Exception as cleanup_e:
                app.logger.error(f"Failed to cleanup partially saved photo {save_path_full}: {cleanup_e}")
        return None # Indicate failure

# START MODIFICATION (create_social_channel route)
@app.route("/social/create_channel", methods=["GET", "POST"])
@login_required
# Define who can create channels (e.g., teachers, hr_ceo, system_admin)
@role_required("hr_ceo", "system_admin", "teacher") 
def create_social_channel():
    form = CreateChannelForm() # CreateChannelForm from app.py Part 4
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        profile_photo_relative_path = None
        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                # save_profile_photo helper should be suitable for channel photos too,
                # or create a save_channel_photo variant if paths/sizes differ.
                profile_photo_relative_path = save_profile_photo(form.profile_photo.data)
                if not profile_photo_relative_path:
                    # Error flashed by helper
                    return render_template("social/channels/create_channel.html", form=form, title="Create New Channel - Nexus")
            except Exception as e:
                app.logger.error(f"Error saving channel profile photo for user {current_user.id}: {e}", exc_info=True)
                flash("An unexpected error occurred while uploading the profile photo.", "danger")
                return render_template("social/channels/create_channel.html", form=form, title="Create New Channel - Nexus")
        
        try:
            # Check for existing channel name (case-insensitive)
            existing_channel = db.session.scalar(
                select(Channel).filter(func.lower(Channel.name) == func.lower(form.name.data.strip()))
            )
            if existing_channel:
                form.name.errors.append("A channel with this name already exists.")
                # Cleanup uploaded photo if name conflict
                if profile_photo_relative_path:
                    try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                    except: pass
                return render_template("social/channels/create_channel.html", form=form, title="Create New Channel - Nexus")

            new_channel = Channel(
                name=form.name.data.strip(),
                bio=form.bio.data.strip() if form.bio.data else None,
                profile_photo_url=profile_photo_relative_path,
                owner_id=current_user.id,
                social_category_id=form.social_category_id.data,
                type=form.channel_type.data, # 'public' or 'private'
                allow_comments=form.allow_comments.data,
                allow_reactions=form.allow_reactions.data,
                created_at=datetime.now(timezone.utc),
                is_active=True # New channels are active
            )
            db.session.add(new_channel)
            db.session.commit() # Commit to get new_channel.id

            # Automatically subscribe the owner
            owner_subscription = ChannelSubscriber(
                channel_id=new_channel.id,
                user_id=current_user.id,
                role='owner', # Owner role in the channel
                subscribed_at=datetime.now(timezone.utc)
            )
            db.session.add(owner_subscription)
            db.session.commit()

            flash(f"Channel '{new_channel.name}' created successfully!", "success")
            app.logger.info(f"User {current_user.username} created channel '{new_channel.name}' (ID: {new_channel.id}).")
            return redirect(url_for("view_social_channel", channel_id=new_channel.id))

        except IntegrityError: # Should be caught by name check, but as fallback
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup photo if DB error
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            flash("A channel with this name already exists or another database error occurred.", "danger")
        except Exception as e:
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup photo
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            app.logger.error(f"Error creating channel by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
            
    return render_template("social/channels/create_channel.html", 
                           form=form, 
                           title="Create New Channel - Nexus")

@app.route("/social/channels/<int:channel_id>/posts") # GET request
@login_required
def get_channel_posts_paginated(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    # Permission check (same as view_social_channel)
    user_channel_role = current_user.get_channel_role(channel)
    if channel.type == 'private' and not user_channel_role:
        return jsonify({"success": False, "error": "Access denied to private channel."}), 403

    page = request.args.get('page', 1, type=int)
    per_page_posts = 10 # Should match the initial load in view_social_channel

    posts_query = (
        select(ChannelPost)
        .where(ChannelPost.channel_id == channel.id)
        .options(
            joinedload(ChannelPost.author).joinedload(User.role), 
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments).joinedload(ChannelComment.author),
            joinedload(ChannelPost.reactions)
        )
        .order_by(ChannelPost.timestamp.desc())
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts_on_page = pagination.items

    posts_html = ""
    if posts_on_page:
        # Create a temporary list of rendered post items
        rendered_posts_list = []
        for post_item in posts_on_page:
            rendered_posts_list.append(
                render_template("partials/_social_post_item.html", 
                                post=post_item, 
                                current_user=current_user)
            )
        posts_html = "".join(rendered_posts_list) # Join all rendered HTML strings

    return jsonify({
        "success": True,
        "posts_html": posts_html, # The rendered HTML for the posts
        "has_next_page": pagination.has_next,
        "next_page_num": pagination.next_num if pagination.has_next else None,
        "current_page": pagination.page
    })

@app.route("/social/channels/<int:channel_id>/subscribe", methods=["POST"])
@login_required
def ajax_subscribe_channel(channel_id): # Renamed to indicate AJAX
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    if current_user.is_channel_member(channel):
        return jsonify({"success": False, "error": "You are already a member/subscriber."}), 400

    if channel.type != 'public': # For now, only direct subscribe to public
        return jsonify({"success": False, "error": "This is a private channel. Subscription by invite/approval only."}), 403
        
    try:
        new_subscriber = ChannelSubscriber(
            channel_id=channel.id,
            user_id=current_user.id,
            role='subscriber',
            subscribed_at=datetime.now(timezone.utc)
        )
        db.session.add(new_subscriber)
        db.session.commit()
        
        new_subscriber_count = channel.subscribers.count() # Recalculate count
        app.logger.info(f"User {current_user.username} AJAX subscribed to channel {channel.id}.")
        return jsonify({
            "success": True, 
            "message": f"Successfully subscribed to '{channel.name}'.",
            "new_subscriber_count": new_subscriber_count
        }), 200
    except IntegrityError: # Should be caught by first check, but safety
        db.session.rollback()
        return jsonify({"success": False, "error": "Already subscribed (Integrity)."}), 400
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error AJAX subscribing user {current_user.id} to channel {channel.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error during subscription."}), 500

@app.route("/social/channels/<int:channel_id>/unsubscribe", methods=["POST"])
@login_required
def ajax_unsubscribe_channel(channel_id): # Renamed for AJAX
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    subscriber_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(channel_id=channel.id, user_id=current_user.id)
    )

    if not subscriber_entry:
        return jsonify({"success": False, "error": "You are not subscribed to this channel."}), 400

    if subscriber_entry.role == 'owner':
        owner_count = db.session.scalar(
            select(func.count(ChannelSubscriber.user_id))
            .where(ChannelSubscriber.channel_id == channel.id, ChannelSubscriber.role == 'owner')
        ) or 0
        if owner_count <= 1:
            return jsonify({"success": False, "error": "You are the only owner. Transfer ownership before leaving."}), 403
            
    try:
        db.session.delete(subscriber_entry)
        db.session.commit()
        new_subscriber_count = channel.subscribers.count()
        app.logger.info(f"User {current_user.username} AJAX unsubscribed from channel {channel.id}.")
        return jsonify({
            "success": True, 
            "message": f"Successfully unsubscribed from '{channel.name}'.",
            "new_subscriber_count": new_subscriber_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error AJAX unsubscribing user {current_user.id} from channel {channel.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error during unsubscription."}), 500

@app.route("/social/channels/posts/<int:post_id>/react", methods=["POST"])
@login_required
def react_channel_post(post_id):
    post = db.get_or_404(ChannelPost, post_id, description="Post not found.")
    channel = post.channel

    if not channel.is_active or (not channel.allow_reactions and not current_user.get_channel_role(channel) in ['owner','admin']):
        return jsonify({"success": False, "error": "Reactions are disabled for this post or channel."}), 403

    if not current_user.is_channel_member(channel):
        return jsonify({"success": False, "error": "You must be a channel subscriber to react."}), 403

    data = request.get_json()
    emoji = data.get("emoji", "").strip()

    if not emoji: # Basic validation, can be more specific
        return jsonify({"success": False, "error": "Emoji is required."}), 400
    
    # For simplicity, allowing only a few known emojis. Expand as needed.
    ALLOWED_REACTION_EMOJIS = ["", "", "", "", "", ""]
    if emoji not in ALLOWED_REACTION_EMOJIS:
        return jsonify({"success": False, "error": "Invalid reaction emoji."}), 400

    try:
        existing_reaction = db.session.scalar(
            select(ChannelReaction).where(
                ChannelReaction.post_id == post.id,
                ChannelReaction.user_id == current_user.id,
                ChannelReaction.emoji == emoji # Check if user already reacted with this specific emoji
            )
        )

        user_reacted_with_this_emoji = False
        if existing_reaction:
            db.session.delete(existing_reaction)
            action_message = "Reaction removed."
            user_reacted_with_this_emoji = False
        else:
            # Optional: If user has another reaction, remove it before adding new one (single reaction per user per post)
            # current_user_any_reaction = db.session.scalar(
            #     select(ChannelReaction).where(ChannelReaction.post_id == post.id, ChannelReaction.user_id == current_user.id)
            # )
            # if current_user_any_reaction:
            #     db.session.delete(current_user_any_reaction)
            
            new_reaction = ChannelReaction(
                post_id=post.id,
                user_id=current_user.id,
                emoji=emoji,
                created_at=datetime.now(timezone.utc)
            )
            db.session.add(new_reaction)
            action_message = "Reaction added."
            user_reacted_with_this_emoji = True
        
        db.session.commit()

        # Get updated count for this specific emoji
        new_count_for_emoji = db.session.scalar(
            select(func.count(ChannelReaction.id)).where(
                ChannelReaction.post_id == post.id,
                ChannelReaction.emoji == emoji
            )
        ) or 0
        
        app.logger.info(f"User {current_user.username} {action_message.lower()} emoji '{emoji}' on channel post {post.id}.")
        return jsonify({
            "success": True, 
            "message": action_message,
            "emoji": emoji, # Send back the emoji for UI update
            "new_count": new_count_for_emoji,
            "user_reacted": user_reacted_with_this_emoji # True if added, False if removed
        }), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error reacting to channel post {post.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error processing reaction."}), 500
                           
@app.route("/social/channels/posts/<int:post_id>/comment", methods=["POST"])
@login_required
def add_channel_post_comment(post_id):
    post = db.get_or_404(ChannelPost, post_id, description="Post not found.")
    channel = post.channel # Get the channel from the post

    if not channel.is_active or (not channel.allow_comments and not current_user.get_channel_role(channel) in ['owner','admin']):
        return jsonify({"success": False, "error": "Comments are disabled for this post or channel."}), 403

    # Permission to comment (basic: any subscriber if channel allows comments)
    if not current_user.is_channel_member(channel): # Assumes User.is_channel_member helper
        return jsonify({"success": False, "error": "You must be a channel subscriber to comment."}), 403

    data = request.get_json()
    content = data.get("content", "").strip()

    if not content:
        return jsonify({"success": False, "error": "Comment content cannot be empty."}), 400
    if len(content) > 500: # Max comment length
        return jsonify({"success": False, "error": "Comment is too long (max 500 characters)."}), 400

    try:
        new_comment = ChannelComment(
            post_id=post.id,
            author_id=current_user.id,
            content=content,
            timestamp=datetime.now(timezone.utc)
        )
        db.session.add(new_comment)
        db.session.commit()
        app.logger.info(f"User {current_user.username} added comment ID {new_comment.id} to channel post {post.id}.")

        # Eager load author for rendering the partial
        comment_for_render = db.session.query(ChannelComment).options(
            joinedload(ChannelComment.author).joinedload(User.role)
        ).get(new_comment.id)

        comment_html = render_template("partials/_social_comment_item.html", 
                                       comment=comment_for_render, 
                                       current_user=current_user,
                                       post=post) # Pass post if partial needs it for context

        return jsonify({
            "success": True, 
            "message": "Comment posted!", 
            "comment_html": comment_html
        }), 201
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error adding comment to channel post {post.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error posting comment."}), 500

@app.route("/social/channels/posts/<int:post_id>/comments/<int:comment_id>/delete", methods=["POST"])
@login_required
def delete_channel_post_comment(post_id, comment_id):
    comment = db.get_or_404(ChannelComment, comment_id, description="Comment not found.")
    post = comment.post # Assumes comment.post relationship
    if not post or post.id != post_id:
        return jsonify({"success": False, "error": "Comment does not belong to this post."}), 400
    
    channel = post.channel

    # Permission to delete comment: comment author OR channel owner/admin OR post author
    is_comment_author = (comment.author_id == current_user.id)
    is_post_author = (post.author_id == current_user.id)
    user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner_or_admin = user_channel_role in ['owner', 'admin']

    if not (is_comment_author or is_post_author or is_channel_owner_or_admin):
        return jsonify({"success": False, "error": "You do not have permission to delete this comment."}), 403

    try:
        db.session.delete(comment)
        db.session.commit()
        app.logger.info(f"User {current_user.username} deleted comment ID {comment.id} from channel post {post.id}.")
        return jsonify({"success": True, "message": "Comment deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting comment {comment.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error deleting comment."}), 500

@app.route("/social/channels/<int:channel_id>/create_post", methods=["POST"])
@login_required
def create_channel_post(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    if not channel.is_active:
        return jsonify({"success": False, "error": "This channel is not active."}), 403

    # Permission to post (owner, admin, or if channel allows all subscribers - basic for now)
    user_channel_role = current_user.get_channel_role(channel) # Helper from User model
    is_owner = (channel.owner_id == current_user.id)
    is_admin_in_channel = (user_channel_role == 'admin')
    
    # Basic permission: Owner or Admin of the channel can post.
    # Future: Add channel.allow_all_subscribers_to_post setting check
    can_post = is_owner or is_admin_in_channel 
    if not can_post:
        return jsonify({"success": False, "error": "You do not have permission to post in this channel."}), 403

    # Use PostContentForm for validation (text OR file)
    # The form fields are 'content' and 'attached_file'
    form = PostContentForm(request.form) # Pass request.form for text fields
    # File data is in request.files, not request.form for WTForms FileField
    # Manually assign file data to form field if needed for form validation,
    # or handle file separately after text validation.

    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name) # Get by field name

    # Validate: content OR file is required
    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Post content or a file must be provided."}), 400

    # Validate text content length if present
    if form.content.data and not form.content.validate(form): # Trigger validation for content
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    # Handle file upload if present
    if file_storage and file_storage.filename:
        try:
            # save_uploaded_file should return a File DB object (uncommitted) or None
            uploaded_file_obj = save_uploaded_file(file_storage) # Your helper from app.py Part 3/12
            if not uploaded_file_obj:
                # Error (e.g. file type/size) should be flashed by helper, or return specific error here
                return jsonify({"success": False, "error": "File upload failed. Check file type or size."}), 400
        except Exception as e:
            app.logger.error(f"Error processing uploaded file for channel post by {current_user.username}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Error processing uploaded file."}), 500
            
    try:
        new_post = ChannelPost(
            channel_id=channel.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj: # If file was uploaded, add it to session with post
            db.session.add(uploaded_file_obj) 
            
        db.session.add(new_post)
        db.session.commit() # Commits post and file object if new

        app.logger.info(f"User {current_user.username} created post ID {new_post.id} in channel {channel.id}.")

        # Eagerly load necessary relationships for rendering the partial
        # This ensures that when render_template is called, all data is available
        post_for_render = db.session.query(ChannelPost).options(
            joinedload(ChannelPost.author).joinedload(User.role),
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments), # For count
            joinedload(ChannelPost.reactions) # For count
        ).get(new_post.id)


        # Render the HTML for the new post item
        post_html = render_template("partials/_social_post_item.html", 
                                    post=post_for_render, 
                                    current_user=current_user) # Pass current_user if partial needs it

        return jsonify({
            "success": True, 
            "message": "Post created successfully!",
            "post_html": post_html,
            # Optionally send structured post_data if client-side rendering is preferred sometimes
            # "post_data": { ... serialized post data ... }
        }), 201 # 201 Created

    except Exception as e:
        db.session.rollback()
        # If a file was uploaded but DB commit failed, it's good practice to delete the orphaned file
        if uploaded_file_obj and uploaded_file_obj.filepath:
            try:
                full_file_path = os.path.join(current_app.static_folder, uploaded_file_obj.filepath)
                if os.path.exists(full_file_path):
                    os.remove(full_file_path)
                    app.logger.info(f"Cleaned up orphaned file: {uploaded_file_obj.filepath}")
            except Exception as cleanup_e:
                app.logger.error(f"Error cleaning up orphaned file {uploaded_file_obj.filepath}: {cleanup_e}")
        
        app.logger.error(f"Error creating channel post in channel {channel.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error creating post."}), 500

@app.route("/social/channels/<int:channel_id>") # Add methods=['GET'] if it only handles GET for now
@login_required
def view_social_channel(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    if not channel.is_active:
        flash(f"Channel '{channel.name}' is currently not active.", "warning")
        return redirect(url_for('social_channel_list'))

    # Permission to view: Public channels are viewable by all logged-in users.
    # Private channels require membership (or ownership/admin).
    user_channel_role = current_user.get_channel_role(channel) # Helper from User model
    is_owner = (channel.owner_id == current_user.id)
    is_admin = (user_channel_role == 'admin')
    is_subscribed_member = (user_channel_role is not None) # Any role means they are a subscriber

    if channel.type == 'private' and not is_subscribed_member:
        flash(f"'{channel.name}' is a private channel. You must be a subscriber to view its content.", "warning")
        return redirect(url_for('social_channel_discover'))
        
    # Fetch initial posts (e.g., paginated)
    page = request.args.get('page', 1, type=int)
    per_page_posts = 10 # Number of posts per page load
    
    posts_query = (
        select(ChannelPost)
        .where(ChannelPost.channel_id == channel.id)
        .options(
            joinedload(ChannelPost.author).joinedload(User.role), 
            joinedload(ChannelPost.file),
            joinedload(ChannelPost.comments).joinedload(ChannelComment.author), # Load comments and their authors
            joinedload(ChannelPost.reactions) # Load reactions
        )
        .order_by(ChannelPost.timestamp.desc()) # Newest posts first
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts = pagination.items
    
    # Form for creating new posts in this channel
    post_form = PostContentForm() # Your PostContentForm for creating posts

    # Determine if current user can post (owner, admin, or if channel settings allow subscribers - future enhancement)
    can_post_in_channel = is_owner or is_admin # Basic permission for now
    # More advanced: if channel.allow_all_subscribers_to_post and is_subscribed_member: can_post_in_channel = True

    return render_template("social/channels/view_channel.html",
                           channel=channel,
                           posts=posts,
                           pagination=pagination, # Pass pagination object for "Load More"
                           post_form=post_form,
                           is_owner=is_owner,
                           is_admin=is_admin,
                           is_subscribed=is_subscribed_member,
                           can_post_in_channel=can_post_in_channel,
                           title=f"{channel.name} - Channel - Nexus")

@app.route("/social/channels")
@login_required
def social_channel_list():
    # Fetch channels current user owns
    my_owned_channels_query = (
        select(Channel)
        .where(Channel.owner_id == current_user.id, Channel.is_active == True)
        .options(joinedload(Channel.social_category), joinedload(Channel.owner)) # Eager load for card
        .order_by(Channel.name.asc())
    )
    my_owned_channels = db.session.scalars(my_owned_channels_query).all()

    # Fetch channels current user is subscribed to (but does not own)
    my_subscribed_channels_query = (
        select(ChannelSubscriber)
        .join(Channel) # Join to Channel table
        .where(
            ChannelSubscriber.user_id == current_user.id,
            Channel.owner_id != current_user.id, # Exclude owned channels from this list
            Channel.is_active == True
        )
        .options(joinedload(ChannelSubscriber.channel).joinedload(Channel.social_category),
                 joinedload(ChannelSubscriber.channel).joinedload(Channel.owner)) # Eager load for card
        .order_by(Channel.name.asc())
    )
    my_subscribed_channels = db.session.scalars(my_subscribed_channels_query).all()
    
    return render_template("social/channels/list.html",
                           my_owned_channels=my_owned_channels,
                           my_subscribed_channels=my_subscribed_channels,
                           title="My Channels - Nexus")

# END MODIFICATION (create_social_channel route)
@app.route("/social/create_group", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin", "teacher") # Define who can create groups
def create_social_group():
    form = CreateGroupForm() # Your CreateGroupForm from app.py Part 4

    if form.validate_on_submit():
        profile_photo_relative_path = None
        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                profile_photo_relative_path = save_profile_photo(form.profile_photo.data) # Reusing helper
                if not profile_photo_relative_path:
                    return render_template("social/groups/create_group.html", form=form, title="Create New Group - Nexus")
            except Exception as e:
                app.logger.error(f"Error saving group profile photo for group by user {current_user.id}: {e}", exc_info=True)
                flash("An unexpected error occurred while uploading the profile photo.", "danger")
                return render_template("social/groups/create_group.html", form=form, title="Create New Group - Nexus")

        try:
            # Check for existing group name (case-insensitive)
            existing_group = db.session.scalar(
                select(SocialGroup).filter(func.lower(SocialGroup.name) == func.lower(form.name.data.strip()))
            )
            if existing_group:
                form.name.errors.append("A group with this name already exists.")
                if profile_photo_relative_path: # Cleanup
                    try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                    except: pass
                return render_template("social/groups/create_group.html", form=form, title="Create New Group - Nexus")

            new_group = SocialGroup(
                name=form.name.data.strip(),
                description=form.bio.data.strip() if form.bio.data else None, # Form uses 'bio'
                profile_photo_url=profile_photo_relative_path,
                owner_id=current_user.id,
                is_active=True
                # Group type (public/private) if added to model and form
            )
            db.session.add(new_group)
            db.session.commit() # Commit to get new_group.id

            # Automatically make the owner a member
            owner_membership = SocialGroupMember(
                group_id=new_group.id,
                user_id=current_user.id,
                role='owner',
                joined_at=datetime.now(timezone.utc)
            )
            db.session.add(owner_membership)
            db.session.commit()

            flash(f"Group '{new_group.name}' created successfully!", "success")
            app.logger.info(f"User {current_user.username} created group '{new_group.name}' (ID: {new_group.id}).")
            return redirect(url_for("view_social_group", group_id=new_group.id))

        except IntegrityError: # Fallback
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            flash("A group with this name already exists or another database error occurred.", "danger")
        except Exception as e:
            db.session.rollback()
            if profile_photo_relative_path: # Cleanup
                 try: os.remove(os.path.join(current_app.static_folder, profile_photo_relative_path))
                 except: pass
            app.logger.error(f"Error creating group by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")
            
    return render_template("social/groups/create_group.html", 
                           form=form, 
                           title="Create New Social Group - Nexus")
# START MODIFICATION (edit_social_channel route)
@app.route("/social/channels/<int:channel_id>/edit", methods=["GET", "POST"])
@login_required
def edit_social_channel(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")
    
    # Authorization: Owner, channel admin, or system-level admin (hr_ceo, system_admin)
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (channel.owner_id == current_user.id or user_channel_role == 'admin' or is_global_admin):
        flash("You do not have permission to edit this channel.", "danger")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    form = EditChannelForm(obj=channel) # Pre-populate with channel data on GET
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        old_profile_photo_relative_path = channel.profile_photo_url
        new_profile_photo_relative_path = None

        if form.profile_photo.data and form.profile_photo.data.filename: # Check if new photo uploaded
            try:
                saved_relative_path = save_profile_photo(form.profile_photo.data)
                if saved_relative_path:
                    new_profile_photo_relative_path = saved_relative_path
                else: # Error flashed by save_profile_photo
                    return render_template("social/channels/edit_channel.html", form=form, channel=channel, title=f"Edit Channel: {channel.name} - Nexus")
            except Exception as e:
                app.logger.error(f"Error processing channel photo upload for channel {channel_id}: {e}", exc_info=True)
                flash("An error occurred with the photo upload.", "danger")
                return render_template("social/channels/edit_channel.html", form=form, channel=channel, title=f"Edit Channel: {channel.name} - Nexus")

        try:
            # Check for name conflict if name changed
            new_name = form.name.data.strip()
            if new_name.lower() != channel.name.lower():
                existing_channel_with_new_name = db.session.scalar(
                    select(Channel).filter(
                        Channel.id != channel.id,
                        func.lower(Channel.name) == func.lower(new_name)
                    )
                )
                if existing_channel_with_new_name:
                    form.name.errors.append("Another channel with this name already exists.")
                    # Cleanup newly uploaded photo if name conflict
                    if new_profile_photo_relative_path and old_profile_photo_relative_path != new_profile_photo_relative_path:
                        try: os.remove(os.path.join(current_app.static_folder, new_profile_photo_relative_path))
                        except: pass
                    return render_template("social/channels/edit_channel.html", form=form, channel=channel, title=f"Edit Channel: {channel.name} - Nexus")
            
            channel.name = new_name
            channel.bio = form.bio.data.strip() if form.bio.data else None
            channel.social_category_id = form.social_category_id.data
            channel.allow_comments = form.allow_comments.data
            channel.allow_reactions = form.allow_reactions.data
            # channel.type is not typically editable after creation, but if it is:
            # channel.type = form.channel_type.data # Assuming channel_type is on EditChannelForm

            if new_profile_photo_relative_path:
                channel.profile_photo_url = new_profile_photo_relative_path
            
            # channel.updated_at = datetime.now(timezone.utc) # If you have an updated_at field

            db.session.commit()

            # Delete old photo if new one was successfully saved and different
            if new_profile_photo_relative_path and old_profile_photo_relative_path and \
               old_profile_photo_relative_path != new_profile_photo_relative_path and \
               not old_profile_photo_relative_path.startswith('img/placeholders/'):
                old_photo_full_path = os.path.join(current_app.static_folder, old_profile_photo_relative_path)
                if os.path.exists(old_photo_full_path):
                    try:
                        os.remove(old_photo_full_path)
                        app.logger.info(f"Deleted old channel photo: {old_profile_photo_relative_path} for channel {channel.id}")
                    except Exception as e:
                        app.logger.error(f"Error deleting old channel photo {old_profile_photo_relative_path}: {e}")

            flash(f"Channel '{channel.name}' updated successfully!", "success")
            app.logger.info(f"User {current_user.username} edited channel ID {channel.id}.")
            return redirect(url_for("view_social_channel", channel_id=channel.id))

        except IntegrityError: # Fallback if name check fails due to race condition
            db.session.rollback()
            flash("Update failed. A channel with the new name might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing channel {channel.id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the channel.", "danger")

    return render_template("social/channels/edit_channel.html", 
                           form=form, 
                           channel=channel, 
                           title=f"Edit Channel: {channel.name} - Nexus")
@app.route("/social/groups/<int:group_id>/edit", methods=["GET", "POST"])
@login_required
def edit_social_group(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (group.owner_id == current_user.id or user_group_role == 'admin' or is_global_admin):
        flash("You do not have permission to edit this group.", "danger")
        return redirect(url_for("view_social_group", group_id=group.id))

    form = EditGroupForm(obj=group) # Your EditGroupForm

    if form.validate_on_submit():
        old_profile_photo_relative_path = group.profile_photo_url
        new_profile_photo_relative_path = None

        if form.profile_photo.data and form.profile_photo.data.filename:
            try:
                saved_relative_path = save_profile_photo(form.profile_photo.data)
                if saved_relative_path: new_profile_photo_relative_path = saved_relative_path
                else: return render_template("social/groups/edit_group.html", form=form, group=group, title=f"Edit Group: {group.name} - Nexus")
            except Exception as e:
                app.logger.error(f"Error saving updated group photo for group {group_id}: {e}", exc_info=True)
                flash("Error uploading group photo.", "danger")
                return render_template("social/groups/edit_group.html", form=form, group=group, title=f"Edit Group: {group.name} - Nexus")
        
        try:
            new_name = form.name.data.strip()
            if new_name.lower() != group.name.lower():
                existing_group_with_new_name = db.session.scalar(
                    select(SocialGroup).filter(SocialGroup.id != group.id, func.lower(SocialGroup.name) == func.lower(new_name))
                )
                if existing_group_with_new_name:
                    form.name.errors.append("Another group with this name already exists.")
                    if new_profile_photo_relative_path: # Cleanup
                        try: os.remove(os.path.join(current_app.static_folder, new_profile_photo_relative_path))
                        except: pass
                    return render_template("social/groups/edit_group.html", form=form, group=group, title=f"Edit Group: {group.name} - Nexus")
            
            group.name = new_name
            group.description = form.bio.data.strip() if form.bio.data else None # Form field is 'bio'
            if new_profile_photo_relative_path:
                group.profile_photo_url = new_profile_photo_relative_path
            
            # group.is_active = form.is_active.data # If you add is_active to EditGroupForm
            # group.updated_at = datetime.now(timezone.utc)

            db.session.commit()

            if new_profile_photo_relative_path and old_profile_photo_relative_path and \
               old_profile_photo_relative_path != new_profile_photo_relative_path and \
               not old_profile_photo_relative_path.startswith('img/placeholders/'):
                try: os.remove(os.path.join(current_app.static_folder, old_profile_photo_relative_path))
                except Exception as e: app.logger.error(f"Error deleting old group photo {old_profile_photo_relative_path}: {e}")

            flash(f"Group '{group.name}' updated successfully!", "success")
            return redirect(url_for("view_social_group", group_id=group.id))
        except IntegrityError: # Fallback
            db.session.rollback()
            flash("Update failed. A group with this name might already exist.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing group {group.id}: {e}", exc_info=True)
            flash("An unexpected error occurred.", "danger")
            
    return render_template("social/groups/edit_group.html", 
                           form=form, 
                           group=group, 
                           title=f"Edit Group: {group.name} - Nexus")

@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_user_id>/update_role", methods=["POST"])
@login_required
def ajax_update_channel_subscriber_role(channel_id, subscriber_user_id):
    channel = db.get_or_404(Channel, channel_id)
    subscriber_to_update = db.get_or_404(User, subscriber_user_id, description="Subscriber user not found.")
    
    subscription_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(channel_id=channel.id, user_id=subscriber_user_id)
    )
    if not subscription_entry:
        return jsonify({"success": False, "error": "User is not subscribed to this channel."}), 404

    # Authorization: Current user must be channel owner, or channel admin (and not targeting owner), or global admin
    current_user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner = (channel.owner_id == current_user.id)
    is_current_user_channel_admin = (current_user_channel_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    can_manage = False
    if is_global_admin or is_channel_owner:
        can_manage = True
    elif is_current_user_channel_admin and subscription_entry.role != 'owner': # Admin cannot change owner's role
        can_manage = True
    
    if not can_manage:
        return jsonify({"success": False, "error": "You do not have permission to change this subscriber's role."}), 403

    if subscriber_user_id == current_user.id: # Prevent user from changing their own role via this AJAX
        return jsonify({"success": False, "error": "You cannot change your own role here."}), 403
    if channel.owner_id == subscriber_user_id and not is_channel_owner: # Only owner can change owner role (though usually done via transfer)
         return jsonify({"success": False, "error": "Only the channel owner can modify the owner role."}), 403


    data = request.get_json()
    new_role = data.get('role', '').strip().lower()
    valid_roles = ['admin', 'subscriber'] # Owner role typically set on creation or via "transfer ownership"
    
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role '{new_role}'. Valid roles are 'admin', 'subscriber'."}), 400

    old_role = subscription_entry.role
    if old_role == new_role:
        return jsonify({"success": True, "message": "Role is already set to this value."}), 200

    try:
        subscription_entry.role = new_role
        db.session.commit()
        app.logger.info(f"User {current_user.username} updated role of user {subscriber_user_id} in channel {channel_id} to '{new_role}'.")
        return jsonify({
            "success": True, 
            "message": f"Role for {subscriber_to_update.full_name or subscriber_to_update.username} updated to {new_role.title()}.",
            "user_id": subscriber_user_id,
            "new_role": new_role
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating channel subscriber role for user {subscriber_user_id} in channel {channel_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error updating role.", "previous_role": old_role}), 500


@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_user_id>/remove", methods=["POST"])
@login_required
def ajax_remove_channel_subscriber(channel_id, subscriber_user_id):
    channel = db.get_or_404(Channel, channel_id)
    # subscriber_user_to_remove = db.get_or_404(User, subscriber_user_id) # Not needed if we just delete the entry
    
    subscription_entry = db.session.scalar(
        select(ChannelSubscriber).filter_by(channel_id=channel.id, user_id=subscriber_user_id)
    )
    if not subscription_entry:
        return jsonify({"success": True, "message": "User was not subscribed or already removed."}), 200 # Idempotent

    # Authorization (similar to update_role but with different nuances for removal)
    current_user_channel_role = current_user.get_channel_role(channel)
    is_channel_owner = (channel.owner_id == current_user.id)
    is_current_user_channel_admin = (current_user_channel_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if subscriber_user_id == channel.owner_id: # Cannot remove the owner directly
        return jsonify({"success": False, "error": "Channel owner cannot be removed. Transfer ownership first."}), 403
    if subscriber_user_id == current_user.id: # User should use "Unsubscribe" action, not be removed by self here
        return jsonify({"success": False, "error": "Use the 'Unsubscribe' option to leave the channel."}), 403

    can_remove = False
    if is_global_admin or is_channel_owner:
        can_remove = True
    elif is_current_user_channel_admin and subscription_entry.role == 'subscriber': # Admin can remove subscribers
        can_remove = True
        
    if not can_remove:
        return jsonify({"success": False, "error": "You do not have permission to remove this subscriber."}), 403

    try:
        subscriber_name_for_log = subscription_entry.user.full_name or subscription_entry.user.username
        db.session.delete(subscription_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} removed subscriber {subscriber_user_id} ({subscriber_name_for_log}) from channel {channel.id}.")
        
        # Get updated subscriber count for UI update
        new_subscriber_count = channel.subscribers.count()

        return jsonify({
            "success": True, 
            "message": f"{subscriber_name_for_log} removed from channel.",
            "user_id": subscriber_user_id,
            "new_subscriber_count": new_subscriber_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing subscriber {subscriber_user_id} from channel {channel_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error removing subscriber."}), 500
# Route to view and manage channel subscribers
@app.route("/social/channels/<int:channel_id>/manage_subscribers")
@login_required
def manage_channel_subscribers(channel_id):
    channel = db.get_or_404(Channel, channel_id, description="Channel not found.")

    # Authorization: Owner, channel admin, or system-level admin
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (channel.owner_id == current_user.id or user_channel_role == 'admin' or is_global_admin):
        flash("You do not have permission to manage subscribers for this channel.", "danger")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    subscribers_query = (
        select(ChannelSubscriber)
        .where(ChannelSubscriber.channel_id == channel.id)
        .join(ChannelSubscriber.user) # Explicit join to User for ordering by User.full_name
        .options(
            joinedload(ChannelSubscriber.user).joinedload(User.role) # Load user and their global role
        )
        .order_by(
            case( # Custom order for channel roles
                (ChannelSubscriber.role == 'owner', 1),
                (ChannelSubscriber.role == 'admin', 2),
                (ChannelSubscriber.role == 'subscriber', 3),
                else_=4
            ).asc(),
            User.full_name.asc()
        )
    )
    subscribers = db.session.scalars(subscribers_query).all()
    
    return render_template("social/channels/manage_subscribers.html",
                           channel=channel,
                           subscribers=subscribers,
                           user_channel_role=user_channel_role, # Current user's role in this channel
                           title=f"Manage Subscribers - {channel.name} - Nexus")

# Endpoint to change a subscriber's role (AJAX or POST)
@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_id>/update_role", methods=["POST"])
@login_required
def update_channel_subscriber_role(channel_id, subscriber_id):
    """Updates the role of a channel subscriber (Owner/Admin/SysAdmin/HR only)."""
    channel = db.get_or_404(Channel, channel_id)
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, subscriber_id)) # Get the specific association object

    if not subscriber_entry:
         return jsonify({"success": False, "error": "Subscriber not found in this channel"}), 404

    # Check authorization: User must be owner, admin in the channel, or SysAdmin/HR/CEO
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_channel_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to change subscriber role in channel {channel_id}: User {current_user.id} (Role: {user_channel_role})")
        return jsonify({"success": False, "error": "You do not have permission to change roles"}), 403

    # Get the new role from the request (assuming JSON body with key 'role')
    if not request.is_json:
         return jsonify({"success": False, "error": "Invalid request format"}), 400

    data = request.get_json()
    new_role = data.get('role', '').strip().lower()

    # Validate the requested new role
    valid_roles = ['owner', 'admin', 'subscriber']
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role '{new_role}' provided. Valid roles are: {', '.join(valid_roles)}"}), 400

    # Additional authorization checks:
    # - Owner can set/unset any role (including other admins, but maybe not demote self?)
    # - Admin can set/unset 'subscriber' and 'admin', but NOT 'owner'.
    # - Global admin can do anything (handled by initial is_authorized)

    if not is_global_admin: # Apply specific channel role restrictions
         if user_channel_role != 'owner' and new_role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can assign the 'owner' role"}), 403
         if user_channel_role != 'owner' and subscriber_entry.role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can demote the current owner"}), 403
         if user_channel_role == 'admin' and new_role == 'owner':
              return jsonify({"success": False, "error": "Admins cannot assign the 'owner' role"}), 403
         # Prevent demoting self if you are the *last* owner? Or just prevent demoting self at all?
         # Let's prevent changing your own role here for safety.
         if subscriber_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot change your own role via this endpoint"}), 403 # Needs a separate 'leave channel' / 'transfer ownership' flow

    # Prevent setting the same role again (optional optimization)
    if subscriber_entry.role.lower() == new_role:
         return jsonify({"success": True, "message": f"Role is already '{new_role}'"}), 200


    try:
        # Update the subscriber's role
        subscriber_entry.role = new_role
        db.session.commit()
        app.logger.info(f"Channel {channel_id}: User {current_user.username} (ID: {current_user.id}) changed role of user {subscriber_id} to '{new_role}'.")

        return jsonify({
            "success": True,
            "message": f"Role updated to '{new_role}'",
            "user_id": subscriber_id,
            "new_role": new_role
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating subscriber role in channel {channel_id} for user {subscriber_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to update role"}), 500


# Endpoint to remove a subscriber (AJAX or POST)
@app.route("/social/channels/<int:channel_id>/subscribers/<int:subscriber_id>/remove", methods=["POST"])
@login_required
def remove_channel_subscriber(channel_id, subscriber_id):
    """Removes a subscriber from a channel (Owner/Admin/SysAdmin/HR only)."""
    channel = db.get_or_404(Channel, channel_id)
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, subscriber_id)) # Get the specific association object

    if not subscriber_entry:
         return jsonify({"success": True, "message": "User is not a subscriber (already removed?)"}), 200 # Already gone

    # Check authorization: User must be owner, admin in the channel, or SysAdmin/HR/CEO
    user_channel_role = current_user.get_channel_role(channel)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_channel_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to remove subscriber {subscriber_id} from channel {channel_id}: User {current_user.id} (Role: {user_channel_role})")
        return jsonify({"success": False, "error": "You do not have permission to remove subscribers"}), 403

    # Additional authorization checks:
    # - Owner can remove anyone except perhaps themselves (needs separate leave flow)
    # - Admin can remove 'subscriber' role, but NOT 'admin' or 'owner' roles.
    # - Global admin can remove anyone.

    if not is_global_admin:
         if subscriber_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot remove yourself via this endpoint (use leave channel)"}), 403 # Needs separate leave flow
         if user_channel_role == 'admin' and subscriber_entry.role in ['owner', 'admin']:
              return jsonify({"success": False, "error": "Admins cannot remove other admins or owners"}), 403

    # Prevent removing the last owner? This requires more complex logic.
    # For V1, allow removing owner, but the channel might become unmanageable without a new owner.
    # A better flow would be 'transfer ownership' before the owner leaves/is removed.


    try:
        db.session.delete(subscriber_entry) # Delete the association object
        db.session.commit()
        app.logger.info(f"Channel {channel_id}: User {current_user.username} (ID: {current_user.id}) removed user {subscriber_id} (was role: {subscriber_entry.role}).")

        return jsonify({
            "success": True,
            "message": "User removed from channel",
            "user_id": subscriber_id
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing subscriber {subscriber_id} from channel {channel_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to remove user from channel"}), 500


# Endpoint for a user to subscribe to a channel (if public or open)
# This would require a mechanism for public channels or join requests for private ones.
# For V1, let's assume only public channels are joinable via this route, or only owners can add members.
# If membership is invite-only or public-joinable, this route needs to check that.
@app.route("/social/channels/<int:channel_id>/subscribe", methods=["POST"])
@login_required
def subscribe_channel(channel_id):
    """Allows a user to subscribe to a channel (if public or allowed)."""
    channel = db.get_or_404(Channel, channel_id)

    # Check if user is already a member/subscriber
    if current_user.is_channel_member(channel):
        flash("You are already a member of this channel.", "info")
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    # Check if channel is public or requires an invite/request
    # For V1, let's assume only public channels are open for self-subscription via this route.
    # Private channels require an owner/admin to add the member (handled in manage_subscribers or separate invite flow).
    if channel.type != 'public':
         flash("This is a private channel. You cannot subscribe directly.", "warning")
         # Redirect to discovery or back to channel view
         return redirect(url_for("social_channel_discovery")) # Or view_social_channel


    try:
        # Create a new subscriber entry with default 'subscriber' role
        new_subscriber = ChannelSubscriber(
            channel_id=channel.id,
            user_id=current_user.id,
            role='subscriber', # Default role for self-subscription
            subscribed_at=datetime.now(timezone.utc)
        )
        db.session.add(new_subscriber)
        db.session.commit()

        flash(f"Successfully subscribed to channel '{channel.name}'.", "success")
        app.logger.info(f"User {current_user.username} subscribed to channel {channel.id}.")
        # Redirect to the channel view page
        return redirect(url_for("view_social_channel", channel_id=channel.id))

    except IntegrityError:
         db.session.rollback()
         # Should be caught by the initial check, but good safety net
         flash("You are already a member of this channel.", "info")
         return redirect(url_for("view_social_channel", channel_id=channel.id))
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error subscribing user {current_user.id} to channel {channel.id}: {e}", exc_info=True)
        flash("An error occurred while subscribing to the channel. Please try again.", "danger")
        return redirect(url_for("social_channel_discovery"))


# Endpoint for a user to unsubscribe from a channel (if not the last owner)
@app.route("/social/channels/<int:channel_id>/unsubscribe", methods=["POST"])
@login_required
def unsubscribe_channel(channel_id):
    """Allows a user to unsubscribe from a channel."""
    channel = db.get_or_404(Channel, channel_id)

    # Fetch the subscriber entry for the current user in this channel
    subscriber_entry = db.session.get(ChannelSubscriber, (channel_id, current_user.id))

    if not subscriber_entry:
        flash("You are not a member of this channel.", "warning")
        return redirect(url_for("social_channel_discovery")) # Redirect to discovery

    # Prevent the *last* owner from unsubscribing (unless ownership is transferred)
    if subscriber_entry.role == 'owner':
         # Check if this is the only owner left
         owner_count = db.session.scalar(
             select(func.count(ChannelSubscriber.user_id))
             .where(
                 ChannelSubscriber.channel_id == channel.id,
                 ChannelSubscriber.role == 'owner'
             )
         ) or 0 # Use scalar and default 0

         if owner_count <= 1: # If this user is the only owner or one of the last owners
              flash("You are the only owner of this channel. Transfer ownership before leaving.", "danger")
              # Redirect back to channel management page (or view page)
              return redirect(url_for("view_social_channel", channel_id=channel.id)) # Or manage_channel_subscribers


    try:
        db.session.delete(subscriber_entry) # Delete the association object
        db.session.commit()

        flash(f"Successfully unsubscribed from channel '{channel.name}'.", "success")
        app.logger.info(f"User {current_user.username} unsubscribed from channel {channel.id}.")
        # Redirect to channel discovery or user's dashboard
        return redirect(url_for("social_channel_discovery"))

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error unsubscribing user {current_user.id} from channel {channel.id}: {e}", exc_info=True)
        flash("An error occurred while unsubscribing from the channel. Please try again.", "danger")
        # Redirect back to the channel view page on error
        return redirect(url_for("view_social_channel", channel_id=channel.id))

@app.route("/social/channels/discover")
@login_required
def social_channel_discover():
    page = request.args.get('page', 1, type=int)
    per_page = 12 # Number of channels per page for card view
    search_query = request.args.get('search_query', '', type=str).strip()
    category_id_filter = request.args.get('category_id', '', type=str) # String from form, convert to int if not empty

    query = (
        select(Channel)
        .where(Channel.type == 'public', Channel.is_active == True) # Only public and active
        .options(joinedload(Channel.social_category), joinedload(Channel.owner), joinedload(Channel.subscribers)) # Eager load for card
    )

    if search_query:
        search_term = f"%{search_query}%"
        query = query.where(or_(Channel.name.ilike(search_term), Channel.bio.ilike(search_term)))

    selected_category_id_int = None
    if category_id_filter and category_id_filter.isdigit():
        selected_category_id_int = int(category_id_filter)
        query = query.where(Channel.social_category_id == selected_category_id_int)

    query = query.order_by(Channel.name.asc())
    pagination = db.paginate(query, page=page, per_page=per_page, error_out=False)
    discoverable_channels = pagination.items
    
    all_social_categories = db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all()

    # Determine subscription status for displayed channels
    channel_statuses = {}
    if discoverable_channels:
        channel_ids = [c.id for c in discoverable_channels]
        # Fetch subscriptions for the current user for these specific channels
        subscriptions = db.session.scalars(
            select(ChannelSubscriber)
            .where(ChannelSubscriber.user_id == current_user.id, ChannelSubscriber.channel_id.in_(channel_ids))
        ).all()
        subscribed_channel_ids = {s.channel_id for s in subscriptions}
        
        for ch in discoverable_channels:
            channel_statuses[ch.id] = {
                'is_subscribed': ch.id in subscribed_channel_ids,
                'is_owner': ch.owner_id == current_user.id
            }

    return render_template("social/channels/discover.html",
                           discoverable_channels=discoverable_channels,
                           all_social_categories=all_social_categories,
                           pagination=pagination,
                           search_query=search_query,
                           selected_category_id=selected_category_id_int, # Pass as int
                           channel_statuses=channel_statuses,
                           title="Discover Channels - Nexus")
                           
# Route to view and manage group members (Owner/Admin)
@app.route("/social/groups/<int:group_id>/manage_members")
@login_required
def manage_group_members(group_id):
    group = db.get_or_404(SocialGroup, group_id, description="Group not found.")
    
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
    if not (group.owner_id == current_user.id or user_group_role == 'admin' or is_global_admin):
        flash("You do not have permission to manage members for this group.", "danger")
        return redirect(url_for("view_social_group", group_id=group.id))

    members_query = (
        select(SocialGroupMember)
        .where(SocialGroupMember.group_id == group.id)
        .join(SocialGroupMember.user)
        .options(joinedload(SocialGroupMember.user).joinedload(User.role))
        .order_by(
            case(
                (SocialGroupMember.role == 'owner', 1),
                (SocialGroupMember.role == 'admin', 2),
                (SocialGroupMember.role == 'member', 3),
                else_=4
            ).asc(),
            User.full_name.asc()
        )
    )
    members = db.session.scalars(members_query).all()
    
    return render_template("social/groups/manage_members.html",
                           group=group,
                           members=members,
                           user_group_role=user_group_role, # Current user's role in this group
                           title=f"Manage Members - {group.name} - Nexus")

@app.route("/social/groups/<int:group_id>/members/<int:member_user_id>/update_role", methods=["POST"])
@login_required
def ajax_update_group_member_role(group_id, member_user_id):
    group = db.get_or_404(SocialGroup, group_id)
    member_to_update = db.get_or_404(User, member_user_id, description="Member user not found.")
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=member_user_id)
    )
    if not membership_entry:
        return jsonify({"success": False, "error": "User is not a member of this group."}), 404

    # Authorization (similar to channel role update)
    current_user_group_role = current_user.get_group_role(group)
    is_group_owner = (group.owner_id == current_user.id)
    is_current_user_group_admin = (current_user_group_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    can_manage = False
    if is_global_admin or is_group_owner:
        can_manage = True
    elif is_current_user_group_admin and membership_entry.role != 'owner':
        can_manage = True
    
    if not can_manage:
        return jsonify({"success": False, "error": "Permission denied to change role."}), 403
    if member_user_id == current_user.id:
        return jsonify({"success": False, "error": "Cannot change your own role."}), 403
    if group.owner_id == member_user_id and not is_group_owner :
         return jsonify({"success": False, "error": "Only group owner can modify owner role."}), 403


    data = request.get_json()
    new_role = data.get('role', '').strip().lower()
    valid_roles = ['admin', 'member'] # Owner usually by transfer
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role. Valid: {', '.join(valid_roles)}."}), 400
    
    old_role = membership_entry.role
    if old_role == new_role:
        return jsonify({"success": True, "message": "Role is already set."}), 200

    try:
        membership_entry.role = new_role
        db.session.commit()
        app.logger.info(f"User {current_user.username} updated role of user {member_user_id} in group {group_id} to '{new_role}'.")
        return jsonify({
            "success": True, 
            "message": f"Role for {member_to_update.full_name or member_to_update.username} updated to {new_role.title()}.",
            "user_id": member_user_id, "new_role": new_role
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating group member role for {member_user_id} in group {group_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error.", "previous_role": old_role}), 500

@app.route("/social/groups/<int:group_id>/members/<int:member_user_id>/remove", methods=["POST"])
@login_required
def ajax_remove_group_member(group_id, member_user_id):
    group = db.get_or_404(SocialGroup, group_id)
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=member_user_id)
    )
    if not membership_entry:
        return jsonify({"success": True, "message": "User not a member or already removed."}), 200

    # Authorization (similar to channel member removal)
    current_user_group_role = current_user.get_group_role(group)
    is_group_owner = (group.owner_id == current_user.id)
    is_current_user_group_admin = (current_user_group_role == 'admin')
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if member_user_id == group.owner_id:
        return jsonify({"success": False, "error": "Group owner cannot be removed. Transfer ownership first."}), 403
    if member_user_id == current_user.id:
        return jsonify({"success": False, "error": "Use 'Leave Group' option."}), 403

    can_remove = False
    if is_global_admin or is_group_owner:
        can_remove = True
    elif is_current_user_group_admin and membership_entry.role == 'member':
        can_remove = True
        
    if not can_remove:
        return jsonify({"success": False, "error": "Permission denied to remove member."}), 403

    try:
        member_name_for_log = membership_entry.user.full_name or membership_entry.user.username
        db.session.delete(membership_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} removed member {member_user_id} ({member_name_for_log}) from group {group.id}.")
        new_member_count = group.members.count()
        return jsonify({
            "success": True, "message": f"{member_name_for_log} removed from group.",
            "user_id": member_user_id, "new_member_count": new_member_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing member {member_user_id} from group {group_id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/social/groups/<int:group_id>/leave", methods=["POST"])
@login_required
def ajax_leave_social_group(group_id): # Renamed for AJAX
    group = db.get_or_404(SocialGroup, group_id)
    membership_entry = db.session.scalar(
        select(SocialGroupMember).filter_by(group_id=group.id, user_id=current_user.id)
    )
    if not membership_entry:
        return jsonify({"success": False, "error": "You are not a member of this group."}), 400

    if membership_entry.role == 'owner':
        owner_count = db.session.scalar(
            select(func.count(SocialGroupMember.user_id)).where(SocialGroupMember.group_id == group.id, SocialGroupMember.role == 'owner')
        ) or 0
        if owner_count <= 1:
            return jsonify({"success": False, "error": "You are the only owner. Transfer ownership before leaving."}), 403
            
    try:
        db.session.delete(membership_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.username} left group {group.id}.")
        return jsonify({
            "success": True, 
            "message": f"Successfully left group '{group.name}'.",
            "redirect_url": url_for('social_group_list') # Client-side can use this
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} leaving group {group.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error leaving group."}), 500


@app.route("/social/groups/<int:group_id>/members/<int:member_id>/update_role", methods=["POST"])
@login_required
def update_group_member_role(group_id, member_id):
    """Updates the role of a group member (Owner/Admin/SysAdmin/HR only)."""
    group = db.get_or_404(SocialGroup, group_id)
    member_entry = db.session.get(SocialGroupMember, (group_id, member_id)) # Get the specific association object

    if not member_entry:
         return jsonify({"success": False, "error": "Member not found in this group"}), 404

    # Check authorization: User must be owner, admin in the group, or SysAdmin/HR/CEO
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_group_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to change member role in group {group_id}: User {current_user.id} (Role: {user_group_role})")
        return jsonify({"success": False, "error": "You do not have permission to change roles"}), 403

    # Get the new role from the request (assuming JSON body with key 'role')
    if not request.is_json:
         return jsonify({"success": False, "error": "Invalid request format"}), 400

    data = request.get_json()
    new_role = data.get('role', '').strip().lower()

    # Validate the requested new role
    valid_roles = ['owner', 'admin', 'member']
    if new_role not in valid_roles:
        return jsonify({"success": False, "error": f"Invalid role '{new_role}' provided. Valid roles are: {', '.join(valid_roles)}"}), 400

    # Additional authorization checks:
    # - Owner can set/unset any role
    # - Admin can set/unset 'member' and 'admin', but NOT 'owner'.
    # - Global admin can do anything.

    if not is_global_admin: # Apply specific group role restrictions
         if user_group_role != 'owner' and new_role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can assign the 'owner' role"}), 403
         if user_group_role != 'owner' and member_entry.role == 'owner':
             return jsonify({"success": False, "error": "Only the owner can demote the current owner"}), 403
         if user_group_role == 'admin' and new_role == 'owner':
              return jsonify({"success": False, "error": "Admins cannot assign the 'owner' role"}), 403
         # Prevent changing your own role via this endpoint.
         if member_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot change your own role via this endpoint"}), 403 # Needs a separate 'leave group' / 'transfer ownership' flow


    # Prevent setting the same role again (optional optimization)
    if member_entry.role.lower() == new_role:
         return jsonify({"success": True, "message": f"Role is already '{new_role}'"}), 200


    try:
        # Update the member's role
        member_entry.role = new_role
        db.session.commit()
        app.logger.info(f"Group {group_id}: User {current_user.username} (ID: {current_user.id}) changed role of user {member_id} to '{new_role}'.")

        return jsonify({
            "success": True,
            "message": f"Role updated to '{new_role}'",
            "user_id": member_id,
            "new_role": new_role
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating member role in group {group_id} for user {member_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to update role"}), 500


# Endpoint to remove a member (AJAX or POST)
@app.route("/social/groups/<int:group_id>/members/<int:member_id>/remove", methods=["POST"])
@login_required
def remove_group_member(group_id, member_id):
    """Removes a member from a group (Owner/Admin/SysAdmin/HR only)."""
    group = db.get_or_404(SocialGroup, group_id)
    member_entry = db.session.get(SocialGroupMember, (group_id, member_id)) # Get the specific association object

    if not member_entry:
         return jsonify({"success": True, "message": "User is not a member (already removed?)"}), 200 # Already gone

    # Check authorization: User must be owner, admin in the group, or SysAdmin/HR/CEO
    user_group_role = current_user.get_group_role(group)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    is_authorized = (user_group_role in ['owner', 'admin']) or is_global_admin

    if not is_authorized:
        app.logger.warning(f"Unauthorized attempt to remove member {member_id} from group {group_id}: User {current_user.id} (Role: {user_group_role})")
        return jsonify({"success": False, "error": "You do not have permission to remove members"}), 403

    # Additional authorization checks:
    # - Owner can remove anyone except perhaps themselves (needs separate leave flow)
    # - Admin can remove 'member' role, but NOT 'admin' or 'owner' roles.
    # - Global admin can remove anyone.

    if not is_global_admin:
         if member_entry.user_id == current_user.id:
              return jsonify({"success": False, "error": "You cannot remove yourself via this endpoint (use leave group)"}), 403 # Needs separate leave flow
         if user_group_role == 'admin' and member_entry.role in ['owner', 'admin']:
              return jsonify({"success": False, "error": "Admins cannot remove other admins or owners"}), 403

    # Prevent removing the last owner? This requires more complex logic.
    # For V1, allow removing owner, but the group might become unmanageable without a new owner.
    # A better flow would be 'transfer ownership' before the owner leaves/is removed.


    try:
        db.session.delete(member_entry) # Delete the association object
        db.session.commit()
        app.logger.info(f"Group {group_id}: User {current_user.username} (ID: {current_user.id}) removed user {member_id} (was role: {member_entry.role}).")

        return jsonify({
            "success": True,
            "message": "User removed from group",
            "user_id": member_id
        }), 200 # 200 OK

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error removing member {member_id} from group {group_id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to remove user from group"}), 500

# Endpoint for a user to join a group (if joinable - requires group settings)
# Groups are typically private and invite-only. This route is a placeholder for join requests
# or direct joining if a group is marked as 'open' or 'public' (feature not in current model).
# For V1, groups are likely managed by owner/admin adding members.
# @app.route("/social/groups/<int:group_id>/join", methods=["POST"])
# @login_required
# def join_social_group(group_id):
#     """Allows a user to join a group (if public or allowed)."""
#      # Logic depends on group join settings (public, request, invite-only)
#      pass # Placeholder

# Endpoint for a user to leave a group (if not the last owner)
@app.route("/social/groups/<int:group_id>/leave", methods=["POST"])
@login_required
def leave_social_group(group_id):
    """Allows a user to leave a group."""
    group = db.get_or_404(SocialGroup, group_id)

    # Fetch the member entry for the current user in this group
    member_entry = db.session.get(SocialGroupMember, (group_id, current_user.id))

    if not member_entry:
        flash("You are not a member of this group.", "warning")
        return redirect(url_for("social_group_list")) # Redirect to group list

    # Prevent the *last* owner from leaving (unless ownership is transferred)
    if member_entry.role == 'owner':
         # Check if this is the only owner left
         owner_count = db.session.scalar(
             select(func.count(SocialGroupMember.user_id))
             .where(
                 SocialGroupMember.group_id == group.id,
                 SocialGroupMember.role == 'owner'
             )
         ) or 0

         if owner_count <= 1: # If this user is the only owner or one of the last owners
              flash("You are the only owner of this group. Transfer ownership before leaving.", "danger")
              # Redirect back to group management page (or view page)
              return redirect(url_for("view_social_group", group_id=group.id)) # Or manage_group_members


    try:
        db.session.delete(member_entry) # Delete the association object
        db.session.commit()

        flash(f"Successfully left group '{group.name}'.", "success")
        app.logger.info(f"User {current_user.username} left group {group.id}.")
        # Redirect to group list
        return redirect(url_for("social_group_list"))

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error leaving group {group.id} by {current_user.id}: {e}", exc_info=True)
        flash("An error occurred while leaving the group. Please try again.", "danger")
        # Redirect back to the group view page on error
        return redirect(url_for("view_social_group", group_id=group.id))


# --- PART 12 END: Social Media Features ---

# --- PART 13 START: Settings ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User are defined with settings columns (e.g., age, sex, profile_photo_url, etc.).
# - Forms: UniversalSettingsForm is defined.
# - Decorators: login_required, role_required are defined.
# - Helpers: save_profile_photo (defined in Part 12) is used for profile photo uploads.
# - SQLAlchemy imports (select, func), Flask imports (abort, flash, redirect, url_for, request, render_template, jsonify), and other Python imports (datetime, timezone, os).

# Universal Settings Page
@app.route("/settings", methods=["GET", "POST"])
@login_required
def settings():
    # UniversalSettingsForm should be defined in your app.py or imported.
    # It should include fields like: full_name, username, email, age, sex,
    # and critically for this step: profile_photo (as FileField)
    # The 'profile_photo_url' field in the form (StringField) from previous phases can be removed
    # if direct file upload is now the primary method via 'profile_photo' FileField.
    
    # Ensure UniversalSettingsForm in your app.py has:
    # profile_photo = FileField("Update Profile Photo", 
    # validators=[Optional(), FileAllowed(['jpg', 'png', 'jpeg', 'gif', 'webp'], 'Images only!')])

    form = UniversalSettingsForm(
        obj=current_user,  # Pre-populate with current user's data
        original_username=current_user.username, # For unique username validation
        original_email=current_user.email      # For unique email validation
    )
    
    # Manually set the display-only TC member status for the form, if the field exists
    if hasattr(form, 'is_tc_member_display'):
        form.is_tc_member_display.data = current_user.is_tc_member

    if form.validate_on_submit():
        old_profile_photo_relative_path = current_user.profile_photo_url
        new_profile_photo_relative_path = None

        # --- Handle Profile Photo Upload ---
        # Check if the 'profile_photo' FileField in the form has data
        if form.profile_photo.data and form.profile_photo.data.filename:
            file_storage = form.profile_photo.data # This is a FileStorage object
            try:
                # Call your save_profile_photo helper
                saved_relative_path = save_profile_photo(file_storage)
                if saved_relative_path:
                    new_profile_photo_relative_path = saved_relative_path
                    app.logger.info(f"New profile photo uploaded for user {current_user.username}: {new_profile_photo_relative_path}")
                else:
                    # save_profile_photo should flash its own error, but we can add a general one
                    # If photo save failed, we might not want to proceed with other updates,
                    # or save other updates but not the photo. For now, we'll proceed with other updates.
                    flash("Profile photo update failed, but other settings might be saved.", "warning")
            except Exception as e:
                app.logger.error(f"Critical error processing profile photo for user {current_user.id}: {e}", exc_info=True)
                flash("A critical error occurred with the photo upload. Other settings were not saved.", "danger")
                return render_template("settings.html", form=form, title="My Settings - Nexus")


        # --- Update User Object ---
        try:
            current_user.full_name = form.full_name.data.strip()
            # Update first_name and last_name based on full_name
            name_parts = current_user.full_name.split(' ', 1)
            current_user.first_name = name_parts[0]
            current_user.last_name = name_parts[1] if len(name_parts) > 1 else None

            # Username and Email uniqueness is handled by form validators
            current_user.username = form.username.data.strip()
            current_user.email = form.email.data.strip() if form.email.data else None
            
            current_user.age = form.age.data
            current_user.sex = form.sex.data if form.sex.data else None # Handle empty select

            if new_profile_photo_relative_path:
                current_user.profile_photo_url = new_profile_photo_relative_path
            # If no new photo was uploaded, current_user.profile_photo_url remains unchanged.

            # Example for other settings if they were on UniversalSettingsForm:
            # if hasattr(form, 'theme') and hasattr(current_user, 'theme'):
            #     current_user.theme = form.theme.data
            # if hasattr(form, 'email_notifications') and hasattr(current_user, 'email_notifications'):
            #     current_user.email_notifications = form.email_notifications.data

            db.session.commit()

            # If a new photo was successfully saved and DB committed, delete the old one (if different)
            if new_profile_photo_relative_path and old_profile_photo_relative_path and \
               old_profile_photo_relative_path != new_profile_photo_relative_path and \
               not old_profile_photo_relative_path.startswith('img/placeholders/'): # Don't delete default placeholders
                
                old_photo_full_path = os.path.join(current_app.static_folder, old_profile_photo_relative_path)
                if os.path.exists(old_photo_full_path):
                    try:
                        os.remove(old_photo_full_path)
                        app.logger.info(f"Deleted old profile photo: {old_profile_photo_relative_path} for user {current_user.username}")
                    except Exception as e:
                        app.logger.error(f"Error deleting old profile photo {old_profile_photo_relative_path}: {e}")
            
            flash("Your settings have been updated successfully!", "success")
            app.logger.info(f"User {current_user.username} (ID: {current_user.id}) updated their settings.")
            return redirect(url_for("settings")) # Redirect to refresh the page with new data

        except IntegrityError: # Should be caught by form validators ideally
            db.session.rollback()
            app.logger.warning(f"Settings update for user {current_user.username} failed: IntegrityError (username/email).")
            # Form validators (validate_username, validate_email in UniversalSettingsForm) should add errors to form.
            # If they are not present on the form, add a generic flash message.
            if not form.username.errors and not form.email.errors:
                 flash("Update failed. The username or email may already be in use.", "danger")
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error updating settings for user {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while saving your settings. Please try again.", "danger")

    # For GET request or if form validation failed on POST
    # The form object (with data and errors) is passed to the template.
    return render_template("settings.html", form=form, title="My Settings - Nexus")

# --- PART 13 END: Settings ---

# --- PART Y START: Task System Features ---

@app.route("/tasks/create", methods=["GET", "POST"])
@login_required
def create_task():
    """Allows authorized users to create a new task."""
    # Check if current user's role is in the list of roles allowed to create tasks
    if current_user.role.name.lower() not in TASK_CREATOR_ROLES:
        flash("You do not have permission to create tasks.", "danger")
        app.logger.warning(f"Unauthorized task creation attempt by user {current_user.username} (Role: {current_user.role.name}).")
        abort(403)

    form = CreateTaskForm()

    # Populate dynamic choices for group assignments on GET (and potentially re-render on POST fail)
    if request.method == 'GET':
        # Get assignable roles for dropdown/checkboxes
        assignable_roles_list = get_assignable_roles() # List of role names
        form.group_roles_choices = [(r, r.replace('_', ' ').title()) for r in assignable_roles_list] # Store as attribute for template

        # Get assignable grade-section pairs for dropdown/checkboxes
        assignable_grade_sections_list = get_assignable_grade_sections() # List of (grade, section) tuples
        form.group_grade_sections_choices = [(f"{g}-{s}", f"Grade {g}, Section {s}") for g, s in assignable_grade_sections_list] # Store as attribute for template


    if form.validate_on_submit():
        # --- Custom Validation for Assignment Target ---
        assignment_type = form.assignment_type.data
        individual_user_ids = []
        selected_roles = []
        selected_grade_sections = []
        errors_found = False # Flag to track assignment target validation errors

        if assignment_type == 'individual':
            # Validate individual user IDs from the hidden field
            user_ids_str = form.individual_user_ids.data
            if not user_ids_str:
                flash("Please select at least one user for individual assignment.", "danger")
                errors_found = True
            else:
                try:
                    individual_user_ids = [int(uid) for uid in user_ids_str.split(',') if uid.isdigit()]
                    if not individual_user_ids:
                         flash("Invalid user selection for individual assignment.", "danger")
                         errors_found = True
                    else:
                         # Optional: Validate if the selected users are actually 'assignable' roles
                         # This check prevents assigning tasks to System Admins if get_assignable_users filters them.
                         assignable_users_list = get_assignable_users()
                         assignable_user_ids = {u.id for u in assignable_users_list}
                         invalid_selected_ids = [uid for uid in individual_user_ids if uid not in assignable_user_ids]
                         if invalid_selected_ids:
                             flash(f"Cannot assign tasks to the following user IDs: {', '.join(map(str, invalid_selected_ids))}.", "danger")
                             errors_found = True
                             # Filter out invalid users so we only attempt to assign to valid ones
                             individual_user_ids = [uid for uid in individual_user_ids if uid not in invalid_selected_ids]


                except ValueError:
                    flash("Invalid format for selected user IDs.", "danger")
                    errors_found = True

        elif assignment_type == 'group':
            # Get selected roles and grade/sections from request.form
            # Assuming checkboxes/multiselects in the template named 'group_roles' and 'group_grade_sections'
            selected_roles = request.form.getlist('group_roles')
            selected_grade_sections = request.form.getlist('group_grade_sections')

            if not selected_roles and not selected_grade_sections:
                flash("Please select at least one role or grade/section for group assignment.", "danger")
                errors_found = True
            else:
                # Validate selected roles against assignable roles
                assignable_roles_list = get_assignable_roles()
                invalid_roles = [r for r in selected_roles if r not in assignable_roles_list]
                if invalid_roles:
                    flash(f"Invalid role(s) selected for group assignment: {', '.join(invalid_roles)}.", "danger")
                    errors_found = True
                    # Filter out invalid roles
                    selected_roles = [r for r in selected_roles if r in assignable_roles_list]

                # Validate selected grade-sections against assignable grade-sections
                assignable_grade_sections_list = get_assignable_grade_sections() # Returns tuples (grade, section)
                assignable_grade_sections_str = {f"{g}-{s}" for g, s in assignable_grade_sections_list} # Convert to strings for comparison
                invalid_grade_sections = [gs for gs in selected_grade_sections if gs not in assignable_grade_sections_str]
                if invalid_grade_sections:
                    flash(f"Invalid grade/section(s) selected for group assignment: {', '.join(invalid_grade_sections)}.", "danger")
                    errors_found = True
                    # Filter out invalid grade-sections
                    selected_grade_sections = [gs for gs in selected_grade_sections if gs not in invalid_grade_sections]


        # If there were validation errors, re-render the form
        if errors_found:
             # Need to re-populate dynamic choices and pass the form back
             assignable_roles_list = get_assignable_roles()
             form.group_roles_choices = [(r, r.replace('_', ' ').title()) for r in assignable_roles_list]
             assignable_grade_sections_list = get_assignable_grade_sections()
             form.group_grade_sections_choices = [(f"{g}-{s}", f"Grade {g}, Section {s}") for g, s in assignable_grade_sections_list]

             return render_template("tasks/create.html", form=form, title="Create New Task")


        # --- Process Task Creation and Assignment ---
        try:
            new_task = Task(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                due_date=form.due_date.data,
                urgency=form.urgency.data,
                created_by=current_user,
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            # No commit yet, need to create UserTask entries as well

            assigned_count_total = 0

            if assignment_type == 'individual' and individual_user_ids:
                assigned_count_total += assign_task_to_users(new_task, individual_user_ids, current_user, assignment_type='individual') # Helper commits

            elif assignment_type == 'group' and (selected_roles or selected_grade_sections):
                 # Create UserTask for each selected role
                 for role_name in selected_roles:
                      assigned_count_total += assign_task_to_role(new_task, role_name, current_user) # Helper commits

                 # Create UserTask for each selected grade/section
                 for grade_section_str in selected_grade_sections:
                      try:
                           grade, section = grade_section_str.split('-', 1) # Split "9-A" into "9", "A"
                           assigned_count_total += assign_task_to_grade_section(new_task, grade, section, current_user) # Helper commits
                      except ValueError:
                           app.logger.error(f"Invalid grade-section string format during task assignment: {grade_section_str}")
                           flash(f"Skipped assignment for invalid grade/section: {grade_section_str}.", "warning")
                           # continue loop

            if assigned_count_total > 0:
                # The assignment helpers commit implicitly after creating UserTask entries
                # We need to ensure the new_task is added and committed *before* or *with* the UserTasks.
                # Let's wrap this in a single session for better transaction control.
                db.session.add(new_task) # Add the task first
                # assign_task_to_users/role/grade_section should ideally take the session and flush, but commit at the end.
                # Refactored helpers above to commit internally for simplicity, but this might be less ideal.
                # Let's assume the helpers manage their commits. If not, need to adjust.

                flash(f"Task '{new_task.title}' created and assigned to {assigned_count_total} user(s) successfully!", "success")
                app.logger.info(f"Task ID {new_task.id} created and assigned to {assigned_count_total} users by {current_user.username}.")
                return redirect(url_for("my_assigned_tasks"))

            else:
                 # If no users were found for the selected assignment targets
                 flash("No users were found for the selected assignment criteria. Task not created.", "warning")
                 app.logger.warning(f"Task creation cancelled by {current_user.username}: No users found for assignment type '{assignment_type}'.")
                 # Re-render the form with the input data retained
                 assignable_roles_list = get_assignable_roles()
                 form.group_roles_choices = [(r, r.replace('_', ' ').title()) for r in assignable_roles_list]
                 assignable_grade_sections_list = get_assignable_grade_sections()
                 form.group_grade_sections_choices = [(f"{g}-{s}", f"Grade {g}, Section {s}") for g, s in assignable_grade_sections_list]
                 return render_template("tasks/create.html", form=form, title="Create New Task")


        except Exception as e:
            db.session.rollback() # Ensure rollback on unexpected errors
            app.logger.error(f"Error creating/assigning task by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while creating the task. Please try again.", "danger")
            # Re-render form with submitted data and error
            assignable_roles_list = get_assignable_roles()
            form.group_roles_choices = [(r, r.replace('_', ' ').title()) for r in assignable_roles_list]
            assignable_grade_sections_list = get_assignable_grade_sections()
            form.group_grade_sections_choices = [(f"{g}-{s}", f"Grade {g}, Section {s}") for g, s in assignable_grade_sections_list]
            return render_template("tasks/create.html", form=form, title="Create New Task")


    # For GET request or validation failure on POST
    # Ensure dynamic choices are populated for rendering
    if request.method == 'GET' or not form.is_submitted(): # Ensure choices are populated if it's a fresh GET or re-render without submit
         assignable_roles_list = get_assignable_roles()
         form.group_roles_choices = [(r, r.replace('_', ' ').title()) for r in assignable_roles_list]

         assignable_grade_sections_list = get_assignable_grade_sections()
         form.group_grade_sections_choices = [(f"{g}-{s}", f"Grade {g}, Section {s}") for g, s in assignable_grade_sections_list]


    return render_template("tasks/create.html", form=form, title="Create New Task")


@app.route("/tasks/api/users/search") # AJAX Endpoint for User Search Picker
@login_required # User must be logged in
def api_search_users():
    """Provides a list of assignable users based on a search query (for JS picker)."""
    search_query = request.args.get('q', '').strip()
    if not search_query or len(search_query) < 2: # Require minimum 2 characters
        return jsonify([]) # Return empty list if query too short

    try:
        # Get users who are eligible to be assigned tasks (reuse helper logic)
        # The helper already excludes System Admins by default
        assignable_users_query = select(User).where(User.is_active == True) # Start with active users
        # Exclude Task Creator roles from being assigned? Or just System Admin?
        # Let's exclude System Admins based on the helper
        system_admin_role = db.session.scalar(select(Role).filter_by(name='system_admin'))
        if system_admin_role:
             assignable_users_query = assignable_users_query.where(User.role != system_admin_role)

        # Filter by search query (case-insensitive on username or full_name)
        assignable_users_query = assignable_users_query.where(
            or_(
                User.username.ilike(f'%{search_query}%'),
                User.full_name.ilike(f'%{search_query}%')
            )
        )

        # Order results and limit
        results = db.session.scalars(assignable_users_query.order_by(User.full_name).limit(20)).all() # Limit results

        # Format results for JSON response
        formatted_results = [{
            'id': user.id,
            'text': f"{user.full_name} ({user.username})", # Format for display in picker
            'role': user.role.name if user.role else 'N/A'
        } for user in results]

        return jsonify(formatted_results)

    except Exception as e:
        app.logger.error(f"Error searching users for task assignment picker by user {current_user.id}: {e}", exc_info=True)
        return jsonify({"error": "Failed to search users"}), 500


@app.route("/tasks/my_tasks")
@login_required
def my_tasks():
    """Lists tasks assigned to the current user."""
    # Fetch UserTask entries assigned *to* the current user
    my_tasks_list = db.session.scalars(
        select(UserTask)
        .where(UserTask.user_id == current_user.id)
        # Eager load the Task and the creator of the Task
        .options(joinedload(UserTask.task).joinedload(Task.created_by))
        # Order by status (Open first), then urgency (High first), then assigned_at (oldest first)
        .order_by(
            # Custom order for statuses: Open, In Progress, Delayed, Rejected, Completed, Accepted, Review Rejected
             case(
                {
                    'Open': 1,
                    'In Progress': 2,
                    'Delayed (Pending Review)': 3,
                    'Rejected (Pending Review)': 4,
                    'Completed (Pending Review)': 5,
                    'Review Rejected': 6, # Tasks rejected by reviewer need action again
                    'Accepted': 7 # Final state
                },
                value=UserTask.status # Order by this mapping
            ),
            UserTask.task.urgency.desc(), # Order by task urgency descending within status
            UserTask.assigned_at.asc() # Order by assignment date ascending
        )
    ).all()

    # Filter tasks that are still 'Open', 'In Progress', 'Delayed', 'Rejected', 'Review Rejected' for the "My Tasks" list
    # 'Completed (Pending Review)' should also be listed under My Tasks until reviewed.
    # 'Accepted' tasks are considered done for the user and might be filtered out of the primary "My Tasks" view.
    # 'Review Rejected' tasks are effectively sent back, so they should remain in the "My Tasks" view.

    # Let's show statuses requiring action: 'Open', 'In Progress', 'Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)', 'Review Rejected'
    actionable_statuses = [
        'Open',
        'In Progress',
        'Completed (Pending Review)',
        'Delayed (Pending Review)',
        'Rejected (Pending Review)',
        'Review Rejected'
    ]
    my_actionable_tasks = [ut for ut in my_tasks_list if ut.status in actionable_statuses]
    # You might want a separate list for 'Accepted' tasks or view them via history.

    return render_template(
        "tasks/my_tasks.html",
        my_tasks=my_actionable_tasks,
        title="My Tasks"
    )

@app.route("/tasks/user_task/<int:user_task_id>/view") # View detail of a specific UserTask instance
@login_required
def view_user_task(user_task_id):
    """Displays details of a specific task assignment for the assigned user."""
    user_task = db.get_or_404(UserTask, user_task_id)

    # Check if the user task is assigned to the current user OR if the current user is the task creator or an admin
    is_assigned_user = (user_task.user_id == current_user.id)
    is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False # Ensure task exists
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if not is_assigned_user and not is_task_creator and not is_global_admin:
         flash("You do not have permission to view this task assignment.", "danger")
         app.logger.warning(f"Unauthorized view of UserTask {user_task_id} by user {current_user.id}. Assigned: {user_task.user_id}, Creator: {user_task.task.created_by_id if user_task.task else 'N/A'}.")
         abort(403) # Forbidden

    # Fetch history for this specific UserTask instance
    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc()) # Oldest first
    ).all()

    # Determine if the assigned user can update status
    can_update_status = is_assigned_user and user_task.status in ['Open', 'In Progress', 'Review Rejected', 'Delayed (Pending Review)', 'Rejected (Pending Review)'] # Can update if not in a final state or awaiting creator review

    # Determine if the creator can review this status
    can_review_status = is_task_creator and user_task.status in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)'] # Can review if status is pending review

    # Instantiate forms if needed (will be rendered conditionally in template)
    update_form = UpdateUserTaskStatusForm() if can_update_status else None
    review_form = ReviewUserTaskForm() if can_review_status else None

    # If it's a GET request and user can update, pre-populate update form with current notes if any
    if request.method == 'GET' and can_update_status and user_task.completion_notes:
         update_form.completion_notes.data = user_task.completion_notes

    # If it's a GET request and creator can review, pre-populate review form with current reviewer_notes if any
    if request.method == 'GET' and can_review_status and user_task.reviewer_notes:
         review_form.reviewer_notes.data = user_task.reviewer_notes


    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=user_task.task, # Pass the related task object
        history_records=history_records,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=update_form, # Pass the form instance if available
        review_form=review_form, # Pass the form instance if available
        title=f"Task: {user_task.task.title}"
    )


@app.route("/tasks/user_task/<int:user_task_id>/update_status", methods=["POST"])
@login_required
def update_user_task_status(user_task_id):
    """Handles status updates submitted by the assigned user."""
    user_task = db.get_or_404(UserTask, user_task_id)

    # Check authorization: Must be the assigned user
    if user_task.user_id != current_user.id:
        flash("You do not have permission to update this task.", "danger")
        app.logger.warning(f"Unauthorized status update attempt for UserTask {user_task_id} by user {current_user.id}. Assigned: {user_task.user_id}.")
        abort(403)

    # Check if status can be updated (not in a final state like 'Accepted' or 'Review Rejected' or already pending review)
    # Allowing updates if 'Open', 'In Progress', or 'Review Rejected' (sent back)
    if user_task.status not in ['Open', 'In Progress', 'Review Rejected']:
        flash(f"Cannot update status from '{user_task.status}'.", "warning")
        return redirect(url_for('view_user_task', user_task_id=user_task.id))


    form = UpdateUserTaskStatusForm()

    if form.validate_on_submit():
        old_status = user_task.status
        new_status = form.status.data # Get the new status from the form
        completion_notes = form.completion_notes.data.strip() if form.completion_notes.data else None

        # Additional check: Ensure the submitted status is valid for this endpoint flow
        valid_update_statuses = ['In Progress', 'Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']
        if new_status not in valid_update_statuses:
             flash("Invalid status update submitted.", "danger")
             app.logger.warning(f"User {current_user.id} submitted invalid status '{new_status}' for UserTask {user_task_id}.")
             return redirect(url_for('view_user_task', user_task_id=user_task.id)) # Redirect back


        try:
            user_task.status = new_status
            user_task.completion_notes = completion_notes
            user_task.last_status_update_at = datetime.now(timezone.utc)
            user_task.reviewed_by_id = None # Clear previous reviewer/notes on new user update
            user_task.reviewer_notes = None

            # Log history
            log_user_task_history(user_task, current_user, old_status, new_status, 'Status Update', completion_notes)

            db.session.commit() # Commit update and history

            # Notify the task creator about the status update
            notify_user_task_status_update(user_task)

            flash("Task status updated successfully!", "success")
            app.logger.info(f"UserTask {user_task_id} status updated to '{new_status}' by user {current_user.id}.")
            return redirect(url_for('view_user_task', user_task_id=user_task.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error updating status for UserTask {user_task_id} by user {current_user.id}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating task status. Please try again.", "danger")
            # Re-render or redirect back
            return redirect(url_for('view_user_task', user_task_id=user_task.id))


    # If form validation fails (e.g., notes missing for Delayed/Rejected)
    flash("Failed to update status. Please check notes.", "warning")
    # Re-render the view page, passing the form with errors. Need to fetch data again.
    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc())
    ).all()
    can_update_status = user_task.status not in ['Accepted', 'Review Rejected'] # Re-evaluate permission
    can_review_status = user_task.status in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']

    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=user_task.task,
        history_records=history_records,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=form, # Pass the form with errors
        review_form=ReviewUserTaskForm() if can_review_status else None, # Pass new review form if applicable
        title=f"Task: {user_task.task.title}"
    )


@app.route("/tasks/user_task/<int:user_task_id>/review", methods=["POST"])
@login_required
def review_user_task(user_task_id):
    """Handles review of a user's task status update by the task creator."""
    user_task = db.get_or_404(UserTask, user_task_id)

    # Check authorization: Must be the task creator or a global admin
    is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if not is_task_creator and not is_global_admin:
         flash("You do not have permission to review this task.", "danger")
         app.logger.warning(f"Unauthorized review attempt for UserTask {user_task_id} by user {current_user.id}. Creator: {user_task.task.created_by_id if user_task.task else 'N/A'}.")
         abort(403)

    # Check if status is pending review
    if user_task.status not in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']:
        flash(f"This task status ('{user_task.status}') is not pending review.", "warning")
        return redirect(url_for('view_user_task', user_task_id=user_task.id))


    form = ReviewUserTaskForm()

    if form.validate_on_submit():
        old_status = user_task.status
        review_outcome = form.review_outcome.data # 'Accepted' or 'Review Rejected'
        reviewer_notes = form.reviewer_notes.data.strip() if form.reviewer_notes.data else None

        # Additional check for outcome validity
        valid_outcomes = ['Accepted', 'Review Rejected']
        if review_outcome not in valid_outcomes:
             flash("Invalid review outcome submitted.", "danger")
             app.logger.warning(f"User {current_user.id} submitted invalid review outcome '{review_outcome}' for UserTask {user_task_id}.")
             return redirect(url_for('view_user_task', user_task_id=user_task.id)) # Redirect back


        try:
            user_task.reviewer_notes = reviewer_notes
            user_task.reviewed_by = current_user
            user_task.reviewed_at = datetime.now(timezone.utc)

            action = '' # To be logged in history
            if review_outcome == 'Accepted':
                user_task.status = 'Accepted'
                action = 'Review Accepted'
                flash("Task status update accepted.", "success")
            elif review_outcome == 'Review Rejected':
                user_task.status = 'Open' # Reset status for the assigned user to try again
                action = 'Review Rejected'
                flash("Task status update rejected. Status reset to 'Open'.", "warning")

            # Log history
            log_user_task_history(user_task, current_user, old_status, user_task.status, action, reviewer_notes)

            db.session.commit() # Commit update and history

            # Notify the assigned user about the review result
            notify_user_task_review_result(user_task)

            app.logger.info(f"UserTask {user_task_id} review outcome '{review_outcome}' by creator/reviewer {current_user.id}. New status: '{user_task.status}'.")
            # Redirect back to the creator's view of the overall task
            return redirect(url_for('view_assigned_task_detail', task_id=user_task.task_id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error reviewing UserTask {user_task_id} by {current_user.id}: {e}", exc_info=True)
            flash("An unexpected error occurred while processing the review. Please try again.", "danger")
            # Re-render or redirect back
            return redirect(url_for('view_user_task', user_task_id=user_task.id))


    # If form validation fails (e.g., notes missing for Review Rejected)
    flash("Failed to submit review. Please check notes.", "warning")
    # Re-render the view page, passing the form with errors. Need to fetch data again.
    history_records = db.session.scalars(
        select(TaskHistory)
        .where(TaskHistory.user_task_id == user_task.id)
        .options(joinedload(TaskHistory.changed_by))
        .order_by(TaskHistory.timestamp.asc())
    ).all()
    can_update_status = user_task.status not in ['Accepted', 'Review Rejected']
    can_review_status = user_task.status in ['Completed (Pending Review)', 'Delayed (Pending Review)', 'Rejected (Pending Review)']

    return render_template(
        "tasks/user_task_detail.html",
        user_task=user_task,
        task=user_task.task,
        history_records=history_records,
        can_update_status=can_update_status,
        can_review_status=can_review_status,
        update_form=UpdateUserTaskStatusForm() if can_update_status else None,
        review_form=form, # Pass the review form with errors
        title=f"Task: {user_task.task.title}"
    )


@app.route("/tasks/my_assigned_tasks")
@login_required
def my_assigned_tasks():
    """Lists tasks created by the current user for their review/management."""
    # Check if current user's role is in the list of roles allowed to create tasks
    if current_user.role.name.lower() not in TASK_CREATOR_ROLES:
        flash("You do not have permission to view tasks you assigned.", "danger")
        app.logger.warning(f"Unauthorized view of assigned tasks list by user {current_user.username} (Role: {current_user.role.name}).")
        abort(403)

    # Fetch tasks created by the current user
    my_created_tasks = db.session.scalars(
        select(Task)
        .where(Task.created_by_id == current_user.id)
        .order_by(Task.created_at.desc()) # Newest first
    ).all()

    # For each task, get counts of UserTask assignments by status
    task_status_counts = {}
    for task in my_created_tasks:
         status_counts = db.session.execute(
             select(UserTask.status, func.count(UserTask.id))
             .where(UserTask.task_id == task.id)
             .group_by(UserTask.status)
         ).all()
         task_status_counts[task.id] = dict(status_counts) # Store as a dictionary per task

    return render_template(
        "tasks/my_assigned_tasks.html",
        my_created_tasks=my_created_tasks,
        task_status_counts=task_status_counts, # Pass the counts
        title="Tasks I Assigned"
    )


@app.route("/tasks/my_assigned_tasks/<int:task_id>")
@login_required
def view_assigned_task_detail(task_id):
    """Displays details and all user assignments for a task created by the current user."""
    task = db.get_or_404(Task, task_id)

    # Check authorization: Must be the task creator or a global admin
    is_task_creator = (task.created_by_id == current_user.id)
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']

    if not is_task_creator and not is_global_admin:
         flash("You do not have permission to view details for this task.", "danger")
         app.logger.warning(f"Unauthorized view of assigned task detail {task_id} by user {current_user.id}. Creator: {task.created_by_id}.")
         abort(403)

    # Fetch all UserTask assignments for this task
    user_assignments = db.session.scalars(
        select(UserTask)
        .where(UserTask.task_id == task.id)
        # Eager load the assigned user and their role
        .options(joinedload(UserTask.user).joinedload(User.role))
        # Order assignments by status (pending review first), then assigned user name
        .order_by(
            case(
                {
                    'Completed (Pending Review)': 1,
                    'Delayed (Pending Review)': 2,
                    'Rejected (Pending Review)': 3
                },
                value=UserTask.status,
                else_=4 # All other statuses after pending review
            ),
            User.full_name.asc()
        )
    ).all()

    # Determine counts of assignments by status for a summary
    status_counts = defaultdict(int)
    for assignment in user_assignments:
        status_counts[assignment.status] += 1


    return render_template(
        "tasks/my_assigned_tasks_detail.html",
        task=task,
        user_assignments=user_assignments,
        status_counts=dict(status_counts), # Convert back to dict for template
        title=f"Assigned Task: {task.title}"
    )

# @app.route("/tasks/all") # Optional Admin View (Placeholder)
# @login_required
# @role_required("system_admin", "hr_ceo")
# def list_all_tasks_admin():
#     """Admin view to list all tasks in the system."""
#     # Implement query for all Task objects, possibly with pagination and filtering
#     all_tasks = db.session.scalars(
#          select(Task)
#          .options(joinedload(Task.created_by))
#          .order_by(Task.created_at.desc())
#     ).all()
#     # Render template...
#     pass

# @app.route("/tasks/user_task/<int:user_task_id>/history") # Optional history detail
# @login_required
# def view_user_task_history(user_task_id):
#     """Displays the history of a specific user's task assignment."""
#     user_task = db.get_or_404(UserTask, user_task_id)
#     # Check permissions (assigned user, creator, or admin)
#     is_assigned_user = (user_task.user_id == current_user.id)
#     is_task_creator = (user_task.task.created_by_id == current_user.id) if user_task.task else False
#     is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo']
#
#     if not is_assigned_user and not is_task_creator and not is_global_admin:
#          flash("You do not have permission to view this task assignment history.", "danger")
#          abort(403)
#
#     history_records = db.session.scalars(
#         select(TaskHistory)
#         .where(TaskHistory.user_task_id == user_task.id)
#         .options(joinedload(TaskHistory.changed_by))
#         .order_by(TaskHistory.timestamp.asc())
#     ).all()
#
#     # Render template...
#     pass

# --- PART Y END: Task System Features ---

# --- PART 14 START: Analytics (Placeholder/Basic) ---

# --- (Place with other Analytics or API routes) ---

@app.route("/analytics/attendance")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive") # Roles that can access this data
def analytics_attendance_data():
    try:
        today = datetime.now(timezone.utc).date()
        
        # Counts of attendance statuses for today
        # Ensure Attendance model and func are imported
        attendance_summary_raw = db.session.execute(
            select(Attendance.status, func.count(Attendance.id).label("count"))
            .where(Attendance.date == today)
            .group_by(Attendance.status)
        ).all() # List of Row objects [(status, count), ...]
        
        summary_dict = {row.status: row.count for row in attendance_summary_raw}

        # Calculate 'Absent (No Entry)' if needed, based on total eligible students
        total_eligible_students = db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == 'student', User.is_active == True)
        ) or 0
        
        students_with_entry_today = sum(summary_dict.values())
        absent_no_entry_count = total_eligible_students - students_with_entry_today
        
        # Prepare labels and data for Chart.js
        labels = []
        data_values = []
        
        # Order for consistency, e.g., Present, Late, Excused, Absent (from DB), Absent (No Entry)
        status_order = ['Present', 'Late', 'Excused', 'Absent']
        for status_key in status_order:
            if status_key in summary_dict:
                labels.append(status_key)
                data_values.append(summary_dict[status_key])
        
        if absent_no_entry_count > 0:
            labels.append('Absent (No Entry)')
            data_values.append(absent_no_entry_count)
        
        # If no data at all, provide empty arrays but success
        if not labels and not data_values and total_eligible_students == 0:
             labels = ["No Student Data"]
             data_values = [0]
        elif not labels and not data_values and total_eligible_students > 0 : # No attendance marked today
            labels = ["Attendance Not Marked"]
            data_values = [total_eligible_students]


        return jsonify({
            "success": True, # Indicate successful data fetch
            "labels": labels,
            "data": data_values,
            "chart_type": "doughnut", # Suggest chart type
            "title": f"Attendance Summary for {today.strftime('%Y-%m-%d')}",
            "total_eligible_students": total_eligible_students # Extra context for frontend
        }), 200

    except Exception as e:
        app.logger.error(f"Error fetching attendance analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve attendance analytics data."}), 500

@app.route("/analytics/enrollment_trends")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_enrollment_trends():
    # Placeholder: This would typically involve querying student enrollment data over time periods (e.g., per year/semester)
    # Example: Counts of new student registrations per month for the last year.
    # For now, returning static placeholder data.
    try:
        # Replace with actual query logic
        labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"] # Example labels (months)
        data_values = [20, 25, 22, 30, 28, 35] # Example data (new enrollments)
        
        if not data_values: # No data found
            labels = ["No Enrollment Trend Data"]
            data_values = [0]


        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values,
            "chart_type": "line",
            "title": "Recent Enrollment Trends"
        }), 200
    except Exception as e:
        app.logger.error(f"Error fetching enrollment trend analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve enrollment trend data."}), 500

@app.route("/analytics/graduation_rates")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_graduation_rates():
    # Placeholder: This would involve querying student status (e.g., 'graduated') over time or by cohort.
    # For now, returning static placeholder data.
    try:
        # Replace with actual query logic
        labels = ["Cohort 2020", "Cohort 2021", "Cohort 2022", "Cohort 2023"] # Example labels
        data_values = [85, 88, 90, 92] # Example data (graduation percentage)

        if not data_values:
            labels = ["No Graduation Rate Data"]
            data_values = [0]


        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values, # Percentages
            "chart_type": "bar",
            "title": "Graduation Rates by Cohort (%)"
        }), 200
    except Exception as e:
        app.logger.error(f"Error fetching graduation rate analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve graduation rate data."}), 500

@app.route("/analytics/demographics")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_demographics_data():
    try:
        # Gender distribution for active students
        # Ensure User, Role, func are imported
        demographics_raw = db.session.execute(
            select(User.gender, func.count(User.id).label("count"))
            .join(User.role) # Assuming User.role relationship
            .where(User.is_active == True, Role.name == 'student') # Focus on active students
            .group_by(User.gender)
            .order_by(User.gender.asc()) # For consistent order
        ).all() # List of Row objects [(gender, count), ...]

        summary_dict = {}
        for row in demographics_raw:
            gender_key = row.gender if row.gender and row.gender.strip() != '' else 'Not Specified'
            summary_dict[gender_key] = summary_dict.get(gender_key, 0) + row.count
            
        # Ensure all expected categories are present for consistent chart display
        # This list can be expanded or made configurable
        expected_genders = ['Male', 'Female', 'Other', 'Prefer Not to Say', 'Not Specified']
        labels = []
        data_values = []
        for gender_cat in expected_genders:
            count = summary_dict.get(gender_cat, 0)
            if count > 0 or gender_cat in summary_dict : # Only add if data exists or it's a defined category
                labels.append(gender_cat)
                data_values.append(count)
        
        if not labels : # No demographic data found
            labels = ["No Demographic Data"]
            data_values = [0]


        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values,
            "chart_type": "pie", # Suggest chart type
            "title": "Student Gender Demographics (Active)"
        }), 200

    except Exception as e:
        app.logger.error(f"Error fetching demographics analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve demographics analytics data."}), 500

@app.route("/analytics/performance")
@login_required
@role_required("hr_ceo", "system_admin", "school_executive")
def analytics_performance_data():
    try:
        # Average of student averages per subject
        # Ensure Mark model and func are imported
        performance_summary_raw = db.session.execute(
            select(Mark.subject, func.avg(Mark.average).label("average_score"))
            .where(Mark.average.isnot(None)) # Only consider students with a calculated average
            .group_by(Mark.subject)
            .order_by(Mark.subject.asc())
        ).all() # List of Row objects [(subject, average_score), ...]

        labels = [row.subject for row in performance_summary_raw]
        data_values = [round(row.average_score, 2) if row.average_score is not None else 0 for row in performance_summary_raw]

        if not labels: # No performance data found
            labels = ["No Performance Data"]
            data_values = [0]

        return jsonify({
            "success": True,
            "labels": labels,
            "data": data_values,
            "chart_type": "bar", # Suggest chart type
            "title": "Average Performance by Subject"
        }), 200

    except Exception as e:
        app.logger.error(f"Error fetching performance analytics: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to retrieve performance analytics data."}), 500

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, login_manager, current_user are initialized and configured.
# - Models: User, Role, Attendance, Mark, Asset, AssetReport, etc. are defined.
# - Decorators: login_required, role_required are defined.
# - SQLAlchemy imports (select, func, or_), Flask imports (jsonify, request, render_template, make_response), and other Python imports (csv, io, datetime, timezone).

# --- Analytics Routes (Basic Implementations / Placeholders) ---
# These routes are for HR/CEO and System Admin roles to view basic data summaries.
# Full-featured analytics with complex calculations and filtering are beyond the scope of this V1 generation.

@app.route("/analytics/attendance")
@login_required
@role_required("hr_ceo", "system_admin") # Allow System Admin
def attendance_analytics():
    """Provides basic attendance data summary as JSON."""
    # This is a basic placeholder. Real analytics would involve filtering by date range, grade, section, etc.

    try:
        # Get counts of attendance statuses for today
        today = datetime.now(timezone.utc).date()

        attendance_summary = db.session.execute(
            select(Attendance.status, func.count(Attendance.id))
            .where(Attendance.date == today)
            .group_by(Attendance.status)
        ).all()

        # Format the results into a dictionary
        summary_dict = dict(attendance_summary)

        # Include total students count for context
        total_students_today = sum(summary_dict.values()) # Sum of students with *an* entry today

        # You might also want the total number of *eligible* students
        total_eligible_students = db.session.scalar(
            select(func.count(User.id)).join(Role).where(Role.name == 'student', User.is_active == True)
        ) or 0

        # Structure data for a chart/display (example format)
        labels = list(summary_dict.keys()) # Status names
        values = list(summary_dict.values()) # Counts

        # Add 'Absent' if not present in results but eligible students exist
        if 'Absent' not in labels and total_eligible_students > 0:
            # Calculate truly absent students = total eligible - those with entries today
            actual_absent = total_eligible_students - total_students_today
            if actual_absent > 0:
                 labels.append('Absent (No Entry)')
                 values.append(actual_absent)


        return jsonify({
            "labels": labels, # e.g., ['Present', 'Late', 'Absent (No Entry)']
            "data": values,  # e.g., [150, 10, 20]
            "date": today.strftime('%Y-%m-%d'),
            "total_eligible_students": total_eligible_students
        })

    except Exception as e:
        app.logger.error(f"Error fetching attendance analytics data by {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to fetch attendance data"}), 500


@app.route("/analytics/performance")
@login_required
@role_required("hr_ceo", "system_admin")
def performance_analytics():
    """Provides basic performance data summary by subject as JSON."""
    # This is a basic placeholder. Real analytics would involve filtering by grade, section, etc.

    try:
        # Get average marks per subject (using average of 'average' column in Mark model)
        performance_summary = db.session.execute(
            select(Mark.subject, func.avg(Mark.average))
            .where(Mark.average.isnot(None)) # Only include marks where average is calculated
            .group_by(Mark.subject)
            .order_by(Mark.subject)
        ).all()

        # Format the results
        summary_dict = dict(performance_summary)

        labels = list(summary_dict.keys()) # Subject names
        values = [round(v, 2) for v in summary_dict.values()] # Average scores, rounded

        return jsonify({
            "labels": labels, # e.g., ['Math', 'Science', 'History']
            "data": values   # e.g., [75.5, 82.1, 68.9]
        })

    except Exception as e:
        app.logger.error(f"Error fetching performance analytics data by {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to fetch performance data"}), 500


@app.route("/analytics/demographics")
@login_required
@role_required("hr_ceo", "system_admin")
def demographics_analytics():
    """Provides basic demographic breakdown (e.g., gender) as JSON."""
    try:
         # Get gender counts for all active users (or perhaps just students?)
         # Let's do all active users for a general demographic overview
         gender_counts = db.session.execute(
             select(User.gender, func.count(User.id))
             .where(User.is_active == True) # Only active users
             .group_by(User.gender)
             .order_by(User.gender) # Order results consistently
         ).all()

         # Format results into a dictionary, handling None/empty gender
         summary_dict = {
             (row[0] if row[0] is not None and row[0] != '' else 'Not Specified'): row[1]
             for row in gender_counts
         }

         # Ensure common gender categories are present even if count is 0
         all_genders = ['Male', 'Female', 'Other', 'Prefer Not to Say', 'Not Specified']
         final_summary = {g: summary_dict.get(g, 0) for g in all_genders}


         labels = list(final_summary.keys())
         values = list(final_summary.values())


         return jsonify({
             "labels": labels, # e.g., ['Female', 'Male', 'Not Specified', 'Other']
             "data": values   # e.g., [120, 130, 15, 5]
         })

    except Exception as e:
        app.logger.error(f"Error fetching demographics data by {current_user.username}: {e}", exc_info=True)
        return jsonify({"error": "Failed to fetch demographics data"}), 500


@app.route("/analytics/performance-comparison")
@login_required
@role_required("hr_ceo", "system_admin")
def performance_comparison():
    """Placeholder for comparing performance metrics (e.g., across grades/sections)."""
    # This route is complex and requires more specific data structure and logic.
    # Returning empty data as a placeholder.

    return jsonify({
        "labels": [],
        "average_scores": [],
        "leader_averages": [], # Example comparison metric
        "error": "Performance comparison analytics not yet implemented."
    })

# Ensure csv and io are imported at the top
# import csv
# import io

@app.route("/analytics/export/<string:export_type>") # Make sure export_type is string
@login_required
@role_required("hr_ceo", "system_admin", "school_executive") # Ensure roles are correct
def export_analytics_data(export_type):
    valid_export_types = ["attendance_summary", "performance_averages", "demographics", 
                          "enrollment_trends", "graduation_rates"] # Add new conceptual types

    if export_type not in valid_export_types:
        flash(f"Invalid export type requested: {export_type}", "danger")
        abort(404)

    output = io.StringIO()
    writer = csv.writer(output)
    filename = f"{export_type}_export_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.csv"
    
    try:
        if export_type == "attendance_summary":
            writer.writerow(["Status", "Count", "Date", "Total Eligible Students"])
            today = datetime.now(timezone.utc).date()
            attendance_summary_raw = db.session.execute(
                select(Attendance.status, func.count(Attendance.id).label("count"))
                .where(Attendance.date == today).group_by(Attendance.status)
            ).all()
            summary_dict = {row.status: row.count for row in attendance_summary_raw}
            total_eligible_students = db.session.scalar(select(func.count(User.id)).join(Role).where(Role.name == 'student', User.is_active == True)) or 0
            students_with_entry_today = sum(summary_dict.values())
            absent_no_entry_count = total_eligible_students - students_with_entry_today

            for status, count in summary_dict.items():
                writer.writerow([status, count, today.strftime('%Y-%m-%d'), total_eligible_students])
            if absent_no_entry_count > 0:
                writer.writerow(['Absent (No Entry)', absent_no_entry_count, today.strftime('%Y-%m-%d'), total_eligible_students])

        elif export_type == "performance_averages":
            writer.writerow(["Subject", "Average Score"])
            performance_summary_raw = db.session.execute(
                select(Mark.subject, func.avg(Mark.average).label("average_score"))
                .where(Mark.average.isnot(None)).group_by(Mark.subject).order_by(Mark.subject.asc())
            ).all()
            for row in performance_summary_raw:
                writer.writerow([row.subject, round(row.average_score, 2) if row.average_score is not None else "N/A"])
        
        elif export_type == "demographics": # Example: Student Demographics by Gender
            writer.writerow(["Gender", "Count"])
            demographics_raw = db.session.execute(
                select(User.gender, func.count(User.id).label("count"))
                .join(Role).where(User.is_active == True, Role.name == 'student')
                .group_by(User.gender).order_by(User.gender.asc())
            ).all()
            summary_dict = {}
            for row in demographics_raw:
                gender_key = row.gender if row.gender and row.gender.strip() != '' else 'Not Specified'
                summary_dict[gender_key] = summary_dict.get(gender_key, 0) + row.count
            for gender, count in summary_dict.items():
                 writer.writerow([gender, count])

        # Add CSV generation for 'enrollment_trends' and 'graduation_rates' using their placeholder data
        elif export_type == "enrollment_trends":
            writer.writerow(["Month", "New Enrollments"])
            labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"]
            data_values = [20, 25, 22, 30, 28, 35]
            for label, value in zip(labels, data_values):
                writer.writerow([label, value])
                
        elif export_type == "graduation_rates":
            writer.writerow(["Cohort", "Graduation Rate (%)"])
            labels = ["Cohort 2020", "Cohort 2021", "Cohort 2022", "Cohort 2023"]
            data_values = [85, 88, 90, 92]
            for label, value in zip(labels, data_values):
                writer.writerow([label, value])
        else:
            # Should be caught by valid_export_types check
            flash("Unknown data type for export.", "danger")
            return redirect(request.referrer or url_for('hr_ceo_dashboard'))


        csv_data = output.getvalue()
        response = make_response(csv_data)
        response.headers["Content-Disposition"] = f"attachment; filename={filename}"
        response.headers["Content-Type"] = "text/csv"
        app.logger.info(f"User {current_user.username} exported analytics data: {export_type}.")
        return response

    except Exception as e:
        app.logger.error(f"Error generating CSV export for {export_type} by {current_user.username}: {e}", exc_info=True)
        flash(f"An error occurred while generating the {export_type} CSV export. Please try again.", "danger")
        return redirect(request.referrer or url_for('hr_ceo_dashboard')) 
# --- PART X START: Multi-Tiered Request System Features ---

# NOTE: This new part relies on:
# - Models: Request, RequestHistory, User, Role
# - Forms: CreateRequestForm, ReviewRequestForm
# - Helpers: get_request_permissions, log_request_history, notify_request_event, get_users_in_role
# - Auth: login_required, role_required

@app.route("/requests/submit", methods=["GET", "POST"])
@login_required
# Only specific roles can initiate. Student & Talent Club are checked with is_leader/is_tc_leader
@role_required("librarian", "student", "teacher", "talent_club") # These roles are checked in the route logic
def submit_request():
    """Allows authorized users (requester roles) to submit a new request."""
    form = CreateRequestForm()
    permissions = get_request_permissions(current_user)

    # Double check if the current user is authorized to create a request
    # This handles student leaders / talent club leaders by their is_leader / is_tc_leader flags
    if not permissions['can_create_request']:
        flash("You do not have permission to submit new requests.", "danger")
        app.logger.warning(f"Unauthorized request submission attempt by user {current_user.username} (Role: {current_user.role.name}).")
        abort(403) # Forbidden

    if form.validate_on_submit():
        try:
            # Determine the initial handler (HR/CEO)
            hr_ceo_role_name = REQUEST_SYSTEM_PERMISSIONS['tier_handlers'][1]
            hr_ceos = get_users_in_role(hr_ceo_role_name)
            
            if not hr_ceos:
                flash("No HR/CEO users available to handle requests. Please contact administration.", "danger")
                app.logger.error("No active HR/CEO users found when attempting to submit a new request.")
                return render_template("requests/submit.html", form=form, title="Submit New Request")

            # Assign to the first active HR/CEO for simplicity (can implement round-robin later)
            initial_handler = hr_ceos[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id,
                current_handler_id=initial_handler.id,
                status='Pending',
                tier=1, # Always starts at Tier 1
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            db.session.add(new_request)
            db.session.flush() # Flush to get request ID for history and notification

            # Log history: Initial submission
            log_request_history(new_request, current_user, None, 'Pending', 'Submitted', new_request.description)

            db.session.commit() # Commit new request and history

            # Notify the initial handler
            notify_request_event(new_request, 'Submitted', changed_by_user=current_user)

            flash("Your request has been submitted successfully and is awaiting review.", "success")
            app.logger.info(f"Request ID {new_request.id} submitted by {current_user.username} (Role: {current_user.role.name}).")
            return redirect(url_for("my_requests"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error submitting request by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while submitting your request. Please try again.", "danger")

    return render_template("requests/submit.html", form=form, title="Submit New Request")

@app.route("/requests/my_requests")
@login_required
def my_requests():
    """Lists requests submitted by the current user."""
    # Filter requests by requester_id
    requests = db.session.scalars(
        select(Request)
        .where(Request.requester_id == current_user.id)
        .options(joinedload(Request.current_handler), joinedload(Request.requester)) # Eager load handler
        .order_by(Request.last_updated_at.desc()) # Newest updates first
    ).all()

    return render_template("requests/my_requests.html", requests=requests, title="My Submitted Requests")

@app.route("/requests/<int:request_id>/view")
@login_required
def view_request_detail(request_id):
    """Displays detailed information and history for a specific request."""
    request_obj = db.get_or_404(Request, request_id)
    permissions = get_request_permissions(current_user, request_obj)

    # User must be the requester, current handler, a global admin, or last_forwarded_by
    if not permissions['is_requester_of_request'] and \
       not permissions['is_handler_for_request'] and \
       not (current_user.role and current_user.role.name.lower() in ['system_admin', 'hr_ceo', 'school_executive', 'government']) and \
       (request_obj.last_forwarded_by_id != current_user.id): # Allow previous forwarders to view for audit
        flash("You do not have permission to view this request.", "danger")
        app.logger.warning(f"Unauthorized view of request ID {request_id} by user {current_user.username}.")
        abort(403)

    # Fetch request history
    history_records = db.session.scalars(
        select(RequestHistory)
        .where(RequestHistory.request_id == request_id)
        .options(joinedload(RequestHistory.changed_by))
        .order_by(RequestHistory.timestamp.asc()) # Oldest first for chronological display
    ).all()

    return render_template(
        "requests/detail.html",
        request_obj=request_obj,
        history_records=history_records,
        permissions=permissions, # Pass permissions for template logic (e.g., show/hide buttons)
        title=f"Request: {request_obj.title}"
    )

@app.route("/requests/inbox")
@login_required
@role_required("hr_ceo", "school_executive", "government") # Only these roles have an inbox
def requests_inbox():
    """Lists requests currently assigned to the current user for review."""
    # Fetch requests where the current user is the current_handler and status is not final
    inbox_requests = db.session.scalars(
        select(Request)
        .where(
            Request.current_handler_id == current_user.id,
            Request.status.notin_(['Resolved', 'Denied']) # Exclude already final statuses
        )
        .options(joinedload(Request.requester)) # Eager load requester for display
        .order_by(Request.urgency.desc(), Request.created_at.asc()) # High urgency first, then oldest
    ).all()

    return render_template("requests/inbox.html", inbox_requests=inbox_requests, title="Requests Inbox")

@app.route("/requests/<int:request_id>/review", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "school_executive", "government") # Only these roles can review
def review_request(request_id):
    """Allows handlers to review and update the status of a request."""
    request_obj = db.get_or_404(Request, request_id)
    permissions = get_request_permissions(current_user, request_obj)

    # Crucial authorization check: User must be the current handler or a global admin
    is_global_admin = current_user.role and current_user.role.name.lower() in ['system_admin']
    if not permissions['is_handler_for_request'] and not is_global_admin:
        flash("You do not have permission to review this request.", "danger")
        app.logger.warning(f"Unauthorized review attempt of request ID {request_id} by user {current_user.username}.")
        abort(403)

    # If the request is already resolved or denied, it cannot be reviewed further by this handler
    if request_obj.status in ['Resolved', 'Denied']:
        flash(f"This request is already '{request_obj.status}' and cannot be reviewed further.", "info")
        return redirect(url_for("view_request_detail", request_id=request_id))

    # Instantiate form, dynamically populating choices based on current user's role and request's tier
    form = ReviewRequestForm(
        obj=request_obj, # Pre-populate existing notes/reason
        current_user_role_name=current_user.role.name.lower(),
        request_tier=request_obj.tier,
        request_status=request_obj.status
    )

    # Populate 'forward_to_user_id' choices if the current role can forward
    if permissions['can_forward']:
        next_role_name = REQUEST_SYSTEM_PERMISSIONS['forward_paths'].get(current_user.role.name.lower())
        if next_role_name:
            next_tier_users = get_users_in_role(next_role_name)
            form.forward_to_user_id.choices = [(0, '--- Select User to Forward To ---')] + \
                                              [(u.id, f"{u.full_name} ({u.username})") for u in next_tier_users]
        else:
            form.forward_to_user_id.choices = [(0, 'No users in next tier or no forward path')]


    if form.validate_on_submit():
        old_status = request_obj.status
        selected_action = form.status.data # This is the action chosen from the dropdown (e.g., 'Approved', 'Forward')

        try:
            # Handle 'Forward' action
            if selected_action == 'Forward':
                if not permissions['can_forward']:
                    flash("You cannot forward this request.", "danger")
                    app.logger.warning(f"User {current_user.username} attempted to forward request {request_id} without permission.")
                    return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")

                # Update current handler and tier
                request_obj.current_handler_id = form.forward_to_user_id.data
                request_obj.tier += 1
                request_obj.status = 'Pending' # Reset status to Pending for the next handler
                request_obj.last_forwarded_by_id = current_user.id
                request_obj.last_updated_at = datetime.now(timezone.utc)

                # Log history
                log_request_history(request_obj, current_user, old_status, request_obj.status, 'Forwarded', form.resolution_notes.data)

                db.session.commit()

                # Notify the new handler
                new_handler = db.session.get(User, request_obj.current_handler_id)
                notify_request_event(request_obj, 'Forwarded', changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} forwarded successfully to {new_handler.full_name or new_handler.username}.", "success")
                app.logger.info(f"Request ID {request_obj.id} forwarded by {current_user.username} to tier {request_obj.tier}.")
                return redirect(url_for("requests_inbox"))

            # Handle 'Denied' action
            elif selected_action == 'Denied':
                if not form.denial_reason.data: # Should be caught by form validation but double check
                     flash("Denial reason is required if status is 'Denied'.", "danger")
                     return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")

                request_obj.status = 'Denied'
                request_obj.denial_reason = form.denial_reason.data.strip()
                request_obj.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None
                request_obj.current_handler_id = None # No longer assigned to anyone once denied
                request_obj.last_updated_at = datetime.now(timezone.utc)

                # Log history
                log_request_history(request_obj, current_user, old_status, 'Denied', 'Denied', form.denial_reason.data)

                db.session.commit()

                # Notify the requester
                notify_request_event(request_obj, 'Denied', changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} denied.", "info")
                app.logger.info(f"Request ID {request_obj.id} denied by {current_user.username}.")
                return redirect(url_for("requests_inbox"))

            # Handle 'Resolved' action (only for HR/CEO and School Executive)
            elif selected_action == 'Resolved':
                if current_user.role.name.lower() not in REQUEST_SYSTEM_PERMISSIONS['resolver_roles']:
                    flash("You do not have permission to mark this request as 'Resolved'.", "danger")
                    return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")
                
                request_obj.status = 'Resolved'
                request_obj.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None
                request_obj.denial_reason = None # Clear if previously denied
                request_obj.current_handler_id = None # No longer assigned to anyone once resolved
                request_obj.last_updated_at = datetime.now(timezone.utc)

                # Log history
                log_request_history(request_obj, current_user, old_status, 'Resolved', 'Resolved', form.resolution_notes.data)

                db.session.commit()

                # Notify the requester
                notify_request_event(request_obj, 'Resolved', changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} successfully resolved.", "success")
                app.logger.info(f"Request ID {request_obj.id} resolved by {current_user.username}.")
                return redirect(url_for("requests_inbox"))

            # Handle 'Approved' or 'On Progress' actions
            else: # Status is 'Approved' or 'On Progress'
                request_obj.status = selected_action
                request_obj.resolution_notes = form.resolution_notes.data.strip() if form.resolution_notes.data else None
                request_obj.denial_reason = None # Clear if previously denied

                # Log history
                log_request_history(request_obj, current_user, old_status, selected_action, 'Reviewed', form.resolution_notes.data)

                db.session.commit()

                # Notify the requester about status update
                notify_request_event(request_obj, 'Status_Updated', old_status=old_status, changed_by_user=current_user)
                flash(f"Request ID {request_obj.id} status updated to '{selected_action}'.", "success")
                app.logger.info(f"Request ID {request_obj.id} status updated to '{selected_action}' by {current_user.username}.")
                return redirect(url_for("requests_inbox"))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error reviewing request ID {request_id} by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while updating the request. Please try again.", "danger")

    return render_template("requests/review.html", form=form, request_obj=request_obj, permissions=permissions, title=f"Review Request: {request_obj.title}")


# --- Direct Initiation Routes (HR/CEO, School Executive) ---

@app.route("/requests/hr_ceo/new_to_school_exec", methods=["GET", "POST"])
@login_required
@role_required("hr_ceo", "system_admin") # System Admin can also initiate this path
def hr_ceo_initiate_request():
    """Allows HR/CEO to initiate a new request directly to School Executive."""
    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            # Determine the next handler (School Executive)
            school_exec_role_name = REQUEST_SYSTEM_PERMISSIONS['tier_handlers'][2]
            school_execs = get_users_in_role(school_exec_role_name)
            
            if not school_execs:
                flash("No School Executive users available to handle requests. Cannot initiate.", "danger")
                app.logger.error("No active School Executive users found when HR/CEO attempted to initiate a request.")
                return render_template("requests/hr_ceo_initiate.html", form=form, title="New Request to School Executive")

            # Assign to the first active School Executive for simplicity
            initial_handler = school_execs[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id, # HR/CEO is the requester
                current_handler_id=initial_handler.id,
                status='Pending', # Still pending for the next tier
                tier=2, # Starts at Tier 2
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            db.session.add(new_request)
            db.session.flush()

            # Log history: Initial submission by HR/CEO
            log_request_history(new_request, current_user, None, 'Pending', 'Submitted (HR/CEO Direct)', new_request.description)

            db.session.commit()

            # Notify the initial handler (School Executive)
            notify_request_event(new_request, 'Submitted', changed_by_user=current_user)

            flash("Your request has been submitted to School Executive successfully!", "success")
            app.logger.info(f"HR/CEO {current_user.username} initiated request ID {new_request.id} to School Executive.")
            return redirect(url_for("my_requests")) # Or requests_inbox for HR/CEO

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error HR/CEO initiating request to School Executive by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while initiating the request. Please try again.", "danger")

    return render_template("requests/hr_ceo_initiate.html", form=form, title="New Request to School Executive")


@app.route("/requests/school_exec/new_to_government", methods=["GET", "POST"])
@login_required
@role_required("school_executive", "system_admin") # System Admin can also initiate this path
def school_exec_initiate_request():
    """Allows School Executive to initiate a new request directly to Government."""
    form = CreateRequestForm()

    if form.validate_on_submit():
        try:
            # Determine the final handler (Government)
            government_role_name = REQUEST_SYSTEM_PERMISSIONS['tier_handlers'][3]
            government_users = get_users_in_role(government_role_name)
            
            if not government_users:
                flash("No Government users available to handle requests. Cannot initiate.", "danger")
                app.logger.error("No active Government users found when School Executive attempted to initiate a request.")
                return render_template("requests/school_exec_initiate.html", form=form, title="New Request to Government")

            # Assign to the first active Government user for simplicity
            initial_handler = government_users[0]

            new_request = Request(
                title=form.title.data.strip(),
                description=form.description.data.strip(),
                request_type=form.request_type.data,
                urgency=form.urgency.data,
                requester_id=current_user.id, # School Executive is the requester
                current_handler_id=initial_handler.id,
                status='Pending', # Still pending for the final tier
                tier=3, # Starts at Tier 3
                created_at=datetime.now(timezone.utc),
                last_updated_at=datetime.now(timezone.utc)
            )

            db.session.add(new_request)
            db.session.flush()

            # Log history: Initial submission by School Executive
            log_request_history(new_request, current_user, None, 'Pending', 'Submitted (School Exec Direct)', new_request.description)

            db.session.commit()

            # Notify the final handler (Government)
            notify_request_event(new_request, 'Submitted', changed_by_user=current_user)

            flash("Your request has been submitted to Government successfully!", "success")
            app.logger.info(f"School Executive {current_user.username} initiated request ID {new_request.id} to Government.")
            return redirect(url_for("my_requests")) # Or requests_inbox for School Exec

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error School Executive initiating request to Government by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while initiating the request. Please try again.", "danger")

    return render_template("requests/school_exec_initiate.html", form=form, title="New Request to Government")

# --- PART X END: Multi-Tiered Request System Features ---

# --- PART 14 END: Analytics (Placeholder/Basic) ---

# --- PART X START: Talent Club Features ---

# Decorator to require user is a Talent Club member (defined in Phase 3)
# from .helpers import tc_member_required # Ensure this import is correct if moved to helpers file
@app.route("/talent_club/member_dashboard") # Or just /talent_club/dashboard if no coordinator dashboard
@login_required
@tc_member_required # Ensures user is an active TC member
def talent_club_dashboard_member_view(): # Unique function name
    # --- Data for Stat Cards ---
    # My Club Memberships Count (active memberships in active clubs)
    my_club_memberships_count = db.session.scalar(
        select(func.count(TalentClubMembership.talent_club_id))
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True
        )
    ) or 0

    # Clubs I Follow Count (for active clubs, excluding those I'm a member of)
    membered_club_ids = db.session.scalars(
        select(TalentClubMembership.talent_club_id)
        .where(TalentClubMembership.user_id == current_user.id, TalentClubMembership.is_active == True)
    ).all()
    my_followed_clubs_count = db.session.scalar(
        select(func.count(TalentClubFollow.talent_club_id))
        .join(TalentClubFollow.club)
        .where(
            TalentClubFollow.user_id == current_user.id,
            TalentClub.is_active == True,
            TalentClub.id.notin_(membered_club_ids) # Only count follows if not a member
        )
    ) or 0
    
    # My Pending Proposals Count
    my_pending_proposals_count = db.session.scalar(
        select(func.count(TalentClubProposal.id))
        .where(
            TalentClubProposal.creator_id == current_user.id,
            TalentClubProposal.status.in_(['pending_leader_review', 'pending_members_accept'])
        )
    ) or 0

    # TC-specific Notifications Count (placeholder, uses global for now)
    # For a more specific count, filter Notification.notification_type.startswith('tc_')
    # unread_tc_notifications_count = get_unread_notifications_count(current_user.id) # Already in context

    # --- Data for "My Active Clubs (Joined)" List ---
    my_active_club_memberships = db.session.scalars(
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category) 
            # Add other eager loads for club if needed by the partial, e.g., owner for display
        )
        .order_by(TalentClub.name.asc())
        .limit(5) # Show first 5 for dashboard snippet
    ).all()

    # --- Data for "Recent Activity in My Clubs" (Conceptual) ---
    # This would require a more complex query:
    # - Get IDs of clubs user is member of.
    # - Fetch recent TalentClubFeedPost items from those clubs' feeds.
    # - Format them into the 'activity' dictionary structure expected by the partial.
    # For now, passing an empty list.
    recent_my_clubs_activity = [] 
    # Example query idea (very simplified):
    if my_active_club_memberships:
        my_club_ids = [m.talent_club_id for m in my_active_club_memberships]
        recent_posts_in_my_clubs = db.session.scalars(
            select(TalentClubFeedPost)
            .join(TalentClubFeedPost.feed)
            .where(TalentClubFeed.talent_club_id.in_(my_club_ids))
            .order_by(TalentClubFeedPost.timestamp.desc())
            .limit(5)
        ).all()
        for post in recent_posts_in_my_clubs:
            recent_my_clubs_activity.append({
                'icon': 'bi-chat-right-text-fill', 'badge_color': 'primary',
                'text': f"New post in <strong>{post.feed.talent_club.name}</strong>: \"{post.content[:30]}...\"",
                'timestamp': post.timestamp,
                'url': url_for('view_talent_club_feed', club_id=post.feed.talent_club_id, _anchor=f'tc_feed_post-{post.id}')
            })


    # --- Data for "System TC Leader Info" ---
    system_tc_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).limit(1)
    )

    return render_template(
        "talent_club/dashboard.html", # The new TC Member dashboard template
        title="My Talent Club Hub - Nexus TC",
        my_club_memberships_count=my_club_memberships_count,
        my_followed_clubs_count=my_followed_clubs_count,
        my_pending_proposals_count=my_pending_proposals_count,
        my_active_club_memberships=my_active_club_memberships,
        recent_my_clubs_activity=recent_my_clubs_activity,
        system_tc_leader=system_tc_leader
        # unread_notifications_count is from context_processor
    )

@app.route("/join_talent_club", methods=["POST"])
@login_required
@role_required("student") 
def join_talent_club():
    if current_user.is_tc_member:
        flash("You are already a Talent Club member.", "info")
        return redirect(url_for("talent_club_dashboard_member_view")) # Redirect to TC Member Dashboard

    try:
        current_user.is_tc_member = True
        # Ensure the user is added to the TC Community group
        # add_to_tc_community_group helper should be defined (from app.py Part 3 / Phase J)
        # It handles checking if already a member and commits.
        community_add_success = add_to_tc_community_group(current_user) 
        
        db.session.commit() # Commit user.is_tc_member change

        if not community_add_success:
            flash("Welcome to the Talent Club! However, there was an issue adding you to the main community group. Please contact an administrator.", "warning")
        else:
            flash("Welcome to the Talent Club! You've also been added to the TC Community group.", "success")
        
        app.logger.info(f"Student {current_user.username} (ID: {current_user.id}) opted in to Talent Club.")
        return redirect(url_for("talent_club_dashboard_member_view")) # Redirect to TC Member Dashboard

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error student {current_user.id} joining Talent Club: {e}", exc_info=True)
        flash("An error occurred while joining Talent Club. Please try again.", "danger")
        return redirect(url_for("student_dashboard")) # Back to general student dashboard
@app.route("/talent_club/clubs")
@login_required
@tc_member_required # Custom decorator from app.py Part 4 / Phase J
def my_talent_clubs():
    # Clubs user is a MEMBER of (active memberships)
    my_memberships_query = (
        select(TalentClubMembership)
        .join(TalentClubMembership.club) # Join to TalentClub for ordering and eager loading
        .where(
            TalentClubMembership.user_id == current_user.id, 
            TalentClubMembership.is_active == True, # Only active memberships
            TalentClub.is_active == True # Only for active clubs
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_memberships = db.session.scalars(my_memberships_query).all()

    # Clubs user is FOLLOWING (and is not a member of)
    # Get IDs of clubs where user is already a member
    membered_club_ids = [m.talent_club_id for m in my_memberships]

    my_follows_query = (
        select(TalentClubFollow)
        .join(TalentClubFollow.club)
        .where(
            TalentClubFollow.user_id == current_user.id,
            TalentClub.is_active == True, # Only follow active clubs
            TalentClub.id.notin_(membered_club_ids) # Exclude clubs they are already a member of
        )
        .options(
            joinedload(TalentClubFollow.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubFollow.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_follows = db.session.scalars(my_follows_query).all()

    return render_template(
        "talent_club/my_clubs.html",
        my_memberships=my_memberships, # List of TalentClubMembership objects
        my_follows=my_follows,         # List of TalentClubFollow objects
        title="My Clubs & Follows - Nexus TC"
    )
@app.route("/talent_club/discover")
@login_required
@tc_member_required
def talent_club_discover():
    page = request.args.get('page', 1, type=int)
    per_page = 12 # Clubs per page
    search_query = request.args.get('search_query', '', type=str).strip()
    category_id_filter = request.args.get('category_id', '', type=str)

    query = (
        select(TalentClub)
        .where(TalentClub.is_active == True) # Only discover active clubs
        .options(
            joinedload(TalentClub.social_category), 
            joinedload(TalentClub.owner),
            # Eager load counts using subqueries for efficiency if your SQLAlchemy version supports it well,
            # or rely on relationship.count() in template (can be N+1 if not careful).
            # For now, template uses .count() on relationships.
            joinedload(TalentClub.memberships), # To allow .memberships.count()
            joinedload(TalentClub.follows)      # To allow .follows.count()
            )
    )

    if search_query:
        search_term = f"%{search_query}%"
        query = query.where(or_(TalentClub.name.ilike(search_term), TalentClub.description.ilike(search_term)))

    selected_category_id_int = None
    if category_id_filter and category_id_filter.isdigit():
        selected_category_id_int = int(category_id_filter)
        query = query.where(TalentClub.social_category_id == selected_category_id_int)

    query = query.order_by(TalentClub.level.desc(), TalentClub.name.asc()) # Example order
    pagination_obj = db.paginate(query, page=page, per_page=per_page, error_out=False)
    discoverable_clubs = pagination_obj.items
    
    # Get SocialCategory list for the filter dropdown
    all_social_categories_for_filter = get_social_categories() # Helper from app.py Part 4 / Phase J

    # Determine current user's status (member/follower) for each displayed club
    club_statuses = {}
    if discoverable_clubs:
        club_ids = [c.id for c in discoverable_clubs]
        
        memberships = db.session.scalars(
            select(TalentClubMembership.talent_club_id) # Select only the ID
            .where(TalentClubMembership.user_id == current_user.id, 
                   TalentClubMembership.talent_club_id.in_(club_ids),
                   TalentClubMembership.is_active == True)
        ).all()
        member_of_club_ids = set(memberships)

        follows = db.session.scalars(
            select(TalentClubFollow.talent_club_id) # Select only the ID
            .where(TalentClubFollow.user_id == current_user.id, 
                   TalentClubFollow.talent_club_id.in_(club_ids))
        ).all()
        following_club_ids = set(follows)

        for club_item in discoverable_clubs:
            club_statuses[club_item.id] = {
                'is_member': club_item.id in member_of_club_ids,
                'is_following': club_item.id in following_club_ids and club_item.id not in member_of_club_ids
            }
            
    return render_template("talent_club/discover.html",
                           all_clubs=discoverable_clubs, # Renamed for template consistency
                           categories=all_social_categories_for_filter, # For filter dropdown
                           pagination=pagination_obj,
                           search_query=search_query,
                           selected_category_id=selected_category_id_int,
                           club_statuses=club_statuses,
                           title="Discover Talent Clubs - Nexus TC")
@app.route("/talent_club/discover/search") # AJAX Endpoint for real-time search
@login_required
@tc_member_required
def talent_club_search():
    """Handles real-time search for Talent Clubs by name."""
    search_query = request.args.get('q', '').strip()
    if not search_query:
        return jsonify([]) # Return empty list if no query

    # Search for active clubs whose name matches the query (case-insensitive)
    results_query = (
        select(TalentClub)
        .where(
            TalentClub.is_active == True,
            TalentClub.name.ilike(f'%{search_query}%') # Case-insensitive LIKE
        )
        .order_by(TalentClub.name)
        .limit(10) # Limit results for performance
    )
    results = db.session.scalars(results_query).all()

    # Format results for JSON response (list of dictionaries)
    formatted_results = []
    for club in results:
         # Determine if the current user is a member or follower for display in search results
         is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=club, user=current_user, is_active=True).exists())
         is_following = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user).exists())

         formatted_results.append({
             'id': club.id,
             'name': club.name,
             'profile_photo_url': club.profile_photo_url,
             'is_member': is_member,
             'is_following': is_following,
             # Add other relevant info if needed
         })

    # Return JSON response
    return jsonify(formatted_results)

@app.route("/talent_club/<int:club_id>/profile")
@login_required
@tc_member_required # Any TC member can view an active club's profile
def view_talent_club_profile(club_id):
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is no longer active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # is_member and is_following needed for UI buttons on profile
    is_member = db.session.scalar(
        select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True).exists()
    )
    follow_entry = db.session.scalar(
        select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id)
    )
    is_following = (follow_entry is not None) and not is_member # Don't show "following" if already a member

    # For user_status on template (determines follow/join/member button state)
    user_status = 'none'
    if is_member: user_status = 'member'
    elif is_following: user_status = 'following'
    
    receive_notifications_status = follow_entry.receive_notifications if follow_entry else False
    
    # Fetch follower and member counts (these are relationship counts on the model)
    # The template used club.follows.count() and club.memberships.filter_by(is_active=True).count()
    # For follower_count on template:
    # total_engagement = (db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0) + \
    #                    (db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0)
    # Simpler in template if relationships are loaded. The template has:
    # follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
    # Ensure club.memberships and club.follows are queryable collections or efficiently countable.

    # Fetch content snippets for profile page (e.g., last 3-5 posts of each type)
    # This requires club.feed to be loaded.
    recent_posts_snippets = []
    media_snippets = []
    file_snippets = []
    text_snippets = []

    if club.feed: # Ensure club has a feed relationship
        recent_posts_snippets_query = (
            select(TalentClubFeedPost)
            .where(TalentClubFeedPost.feed_id == club.feed.id)
            .options(joinedload(TalentClubFeedPost.file)) # Eager load file for mimetype check
            .order_by(TalentClubFeedPost.timestamp.desc())
            .limit(9) # Fetch a few more to try and get diverse types
        )
        recent_posts_snippets = db.session.scalars(recent_posts_snippets_query).all()

        for p in recent_posts_snippets:
            if p.file and p.file.mimetype and (p.file.mimetype.startswith('image/') or p.file.mimetype.startswith('video/')) and len(media_snippets) < 3:
                media_snippets.append(p)
            elif p.file and len(file_snippets) < 3 : # Not image/video but has a file
                file_snippets.append(p)
            elif p.content and len(text_snippets) < 3:
                text_snippets.append(p)
    
    return render_template(
        "talent_club/club_profile.html",
        club=club, # Pass full club object with loaded owner, social_category, feed
        user_status=user_status,
        receive_notifications_status=receive_notifications_status,
        media_snippets=media_snippets,
        file_snippets=file_snippets,
        text_snippets=text_snippets,
        title=f"Profile: {club.name} - Nexus TC"
    )
    
# Endpoint to fetch full content for the Media, Files, Texts tabs

@app.route("/talent_club/<int:club_id>/follow_club", methods=["POST"]) # Matched action in JS
@login_required
@tc_member_required
def ajax_tc_follow_club(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        return jsonify({"success": False, "error": "Club is inactive."}), 400

    is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True).exists())
    if is_member:
        return jsonify({"success": False, "error": "You are already a member."}), 400
    
    existing_follow = db.session.scalar(select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id))
    if existing_follow:
        return jsonify({"success": False, "error": "Already following."}), 400

    try:
        new_follow = TalentClubFollow(club_id=club.id, user_id=current_user.id, receive_notifications=True)
        db.session.add(new_follow)
        db.session.commit()
        app.logger.info(f"User {current_user.id} followed TC Club {club.id}.")
        # Recalculate total engagement
        member_c = db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0
        follow_c = db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0
        return jsonify({"success": True, "message": f"Now following {club.name}.", "new_total_engagement": member_c + follow_c}), 200
    except Exception as e: # Catch other errors
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} following club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/unfollow_club", methods=["POST"]) # Matched action in JS
@login_required
@tc_member_required
def ajax_tc_unfollow_club(club_id):
    club = db.get_or_404(TalentClub, club_id)
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id))
    if not follow_entry:
        return jsonify({"success": False, "error": "Not following this club."}), 400
    try:
        db.session.delete(follow_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.id} unfollowed TC Club {club.id}.")
        member_c = db.session.scalar(select(func.count(TalentClubMembership.user_id)).where(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True)) or 0
        follow_c = db.session.scalar(select(func.count(TalentClubFollow.user_id)).where(TalentClubFollow.talent_club_id == club.id)) or 0
        return jsonify({"success": True, "message": f"Unfollowed {club.name}.", "new_total_engagement": member_c + follow_c}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} unfollowing club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500


@app.route("/talent_club/<int:club_id>/toggle_notifications", methods=["POST"])
@login_required
@tc_member_required
def ajax_tc_toggle_notifications(club_id):
    club = db.get_or_404(TalentClub, club_id)
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(talent_club_id=club.id, user_id=current_user.id))
    if not follow_entry:
        return jsonify({"success": False, "error": "You must be following this club to change notification settings."}), 400
    try:
        follow_entry.receive_notifications = not follow_entry.receive_notifications
        db.session.commit()
        app.logger.info(f"User {current_user.id} toggled TC notifications for club {club.id} to {follow_entry.receive_notifications}.")
        return jsonify({"success": True, "message": "Notification setting updated.", "new_status": follow_entry.receive_notifications}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} toggling TC notifications for club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500
@app.route("/talent_club/<int:club_id>/content/<string:content_type>")
@login_required
@tc_member_required
def view_talent_club_content(club_id, content_type):
    """Fetches and renders a list of content posts for a specific club by type (for tabs)."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
         return jsonify({"error": "Club is inactive"}), 404 # Or redirect on error handler

    # Validate content_type
    valid_types = ['media', 'files', 'texts', 'all']
    if content_type not in valid_types:
        abort(404, description="Invalid content type.")

    # Build query for posts in the club's feed
    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed == club.feed)
        .options(joinedload(TalentClubFeedPost.author), joinedload(TalentClubFeedPost.file))
        .order_by(TalentClubFeedPost.timestamp.desc())
    )

    # Filter by content type
    if content_type == 'media':
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(
                or_(
                    File.mimetype.like('image/%'),
                    File.mimetype.like('video/%')
                )
            )
        )
    elif content_type == 'files':
        posts_query = posts_query.where(
            TalentClubFeedPost.file.has(
                ~or_( # NOT (image OR video)
                    File.mimetype.like('image/%'),
                    File.mimetype.like('video/%')
                )
            )
        )
    elif content_type == 'texts':
        posts_query = posts_query.where(TalentClubFeedPost.content.isnot(None))

    # Execute the query (consider pagination for large feeds)
    posts = db.session.scalars(posts_query).all()

    # Render a partial template for the list of posts and return HTML
    # Assume a template like `partials/talent_club/content_list.html` exists
    # This partial template needs to handle displaying posts based on their content type.
    return render_template(
        "partials/talent_club/content_list.html",
        posts=posts,
        club=club, # Pass club for context in template (e.g., allow_comments/reactions)
        content_type=content_type # Pass type to assist template rendering
    )


@app.route("/talent_club/<int:club_id>/follow", methods=["POST"])
@login_required
@tc_member_required
def talent_club_follow(club_id):
    """Allows a TC member to follow a specific Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
         return jsonify({"success": False, "error": "Club is inactive"}), 400

    # Check if user is already a member of this club instance
    is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=club, user=current_user, is_active=True).exists())
    if is_member:
        return jsonify({"success": False, "error": "You are already a member of this club"}), 400 # Cannot follow if a member

    # Check if user is already following
    is_following = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user).exists())
    if is_following:
        return jsonify({"success": False, "error": "You are already following this club"}), 400

    try:
        # Create the follow entry
        new_follow = TalentClubFollow(
            club=club,
            user=current_user,
            followed_at=datetime.now(timezone.utc),
            receive_notifications=True # Default to receiving notifications on follow
        )
        db.session.add(new_follow)
        db.session.commit()
        app.logger.info(f"User {current_user.id} started following Talent Club {club.id}.")
        # Return updated follower count (approx) or success message
        follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
        return jsonify({"success": True, "message": f"Following {club.name}", "follower_count": follower_count}), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} following club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to follow club"}), 500

@app.route("/talent_club/<int:club_id>/unfollow", methods=["POST"])
@login_required
@tc_member_required
def talent_club_unfollow(club_id):
    """Allows a TC member to unfollow a specific Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    # Check if user is a member (cannot unfollow if a member, must leave)
    is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=club, user=current_user, is_active=True).exists())
    if is_member:
         return jsonify({"success": False, "error": "You are a member of this club, not just following. Use the 'Leave Club' option instead."}), 400

    # Find the follow entry
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user))
    if not follow_entry:
        return jsonify({"success": False, "error": "You are not following this club"}), 400 # Or already unfollowed

    try:
        db.session.delete(follow_entry)
        db.session.commit()
        app.logger.info(f"User {current_user.id} unfollowed Talent Club {club.id}.")
        # Return updated follower count (approx) or success message
        follower_count = club.follows.count() + club.memberships.filter_by(is_active=True).count()
        return jsonify({"success": True, "message": f"Unfollowed {club.name}", "follower_count": follower_count}), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} unfollowing club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to unfollow club"}), 500

# Endpoint to toggle notifications for a followed club
@app.route("/talent_club/<int:club_id>/toggle_notifications", methods=["POST"])
@login_required
@tc_member_required
def talent_club_toggle_notifications(club_id):
    """Toggles notification preference for a followed Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    # Find the follow entry - must be FOLLOWING, not just a member
    follow_entry = db.session.scalar(select(TalentClubFollow).filter_by(club=club, user=current_user))
    if not follow_entry:
        return jsonify({"success": False, "error": "You must be following this club to change notification settings"}), 400

    try:
        # Toggle the boolean value
        follow_entry.receive_notifications = not follow_entry.receive_notifications
        db.session.commit()
        app.logger.info(f"User {current_user.id} toggled notifications for Talent Club {club.id} to {follow_entry.receive_notifications}.")
        return jsonify({"success": True, "message": "Notification setting updated", "new_status": follow_entry.receive_notifications}), 200

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error user {current_user.id} toggling notifications for club {club.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Failed to update notification setting"}), 500


@app.route("/talent_club/configuration")
@login_required
@tc_member_required
def talent_club_configuration():
    """Displays the Talent Club Configuration menu for TC members."""
    # This route just renders the template with navigation options.
    return render_template("talent_club/configuration.html", title="TC Configuration")

@app.route("/talent_club/configuration/my_club_management")
@login_required
@tc_member_required
def my_talent_club_management():
    # Fetch clubs where the user is 'creator' or 'admin'
    my_manager_memberships_query = (
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
            TalentClubMembership.role.in_(['creator', 'admin'])
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_manager_memberships = db.session.scalars(my_manager_memberships_query).all()

    # Fetch clubs where the user is just a 'member'
    my_member_memberships_query = (
        select(TalentClubMembership)
        .join(TalentClubMembership.club)
        .where(
            TalentClubMembership.user_id == current_user.id,
            TalentClubMembership.is_active == True,
            TalentClub.is_active == True,
            TalentClubMembership.role == 'member'
        )
        .options(
            joinedload(TalentClubMembership.club).joinedload(TalentClub.social_category),
            joinedload(TalentClubMembership.club).joinedload(TalentClub.owner)
        )
        .order_by(TalentClub.name.asc())
    )
    my_member_memberships = db.session.scalars(my_member_memberships_query).all()

    return render_template(
        "talent_club/config_my_clubs.html",
        my_manager_memberships=my_manager_memberships, # List of TalentClubMembership objects
        my_member_memberships=my_member_memberships,   # List of TalentClubMembership objects
        title="My Club Involvement - Nexus TC"
    )
# Route to view/post to a specific club's feed (via linked channel logic)
@app.route("/talent_club/<int:club_id>/feed", methods=["GET"]) # POST handled by a separate AJAX endpoint
@login_required
@tc_member_required 
def view_talent_club_feed(club_id):
    club = db.get_or_404(TalentClub, club_id, description="Talent Club not found.")
    if not club.is_active:
        flash("This Talent Club is not active.", "warning")
        return redirect(url_for("talent_club_discover"))

    # Ensure the club has a feed record created (should happen when club is created)
    if not club.feed:
        # This is an inconsistency; ideally, a feed is created with the club.
        # For robustness, create it if missing, though this indicates a setup issue.
        app.logger.warning(f"Talent Club {club.id} ('{club.name}') was missing a feed record. Creating one now.")
        new_feed = TalentClubFeed(talent_club_id=club.id)
        db.session.add(new_feed)
        db.session.commit()
        club = db.session.get(TalentClub, club_id) # Re-fetch to get the new feed relationship

    # Permission to view feed (any TC member can view an active club's feed)
    # Posting permissions are checked separately.

    # Fetch initial posts (e.g., paginated)
    page = request.args.get('page', 1, type=int)
    per_page_posts = 10 
    
    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role), 
            joinedload(TalentClubFeedPost.file),
            # Eager load comments and their authors for each post
            joinedload(TalentClubFeedPost.comments).joinedload(TalentClubFeedComment.author).joinedload(User.role),
            # Eager load reactions for each post (for counts)
            joinedload(TalentClubFeedPost.reactions) 
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts = pagination.items
    
    post_form = PostContentForm() # For creating new posts in this feed

    # Determine if current user can post in this feed
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
    )
    can_post_in_feed = False
    if user_membership:
        can_post_in_feed = TALENT_CLUB_POSTING_PERMISSIONS.get(user_membership.role.lower(), False)
    
    # Determine if current user is a manager (owner or admin of this club) for edit/delete all posts
    is_club_manager = (club.owner_id == current_user.id) or (user_membership and user_membership.role == 'admin')


    return render_template("talent_club/club_feed.html",
                           club=club,
                           posts=posts,
                           pagination=pagination,
                           post_form=post_form,
                           can_post_in_feed=can_post_in_feed,
                           is_club_manager=is_club_manager, # Pass this for admin actions on posts
                           title=f"{club.name} Feed - Nexus TC")
                          
@app.route("/talent_club/<int:club_id>/feed/posts", methods=["POST"])
@login_required
@tc_member_required
def create_talent_club_feed_post(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active or not club.feed:
        return jsonify({"success": False, "error": "Club or its feed is not active/available."}), 403

    # Check posting permissions
    user_membership = db.session.scalar(
        select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True)
    )
    can_post = False
    if user_membership:
        can_post = TALENT_CLUB_POSTING_PERMISSIONS.get(user_membership.role.lower(), False)
    
    if not can_post:
        return jsonify({"success": False, "error": "You do not have permission to post in this club's feed."}), 403

    form = PostContentForm(request.form) # For text content
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Post content or a file must be provided."}), 400
    if form.content.data and not form.content.validate(form): # Validate text content
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage) # Reusing general helper
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed. Check type/size."}), 400
        except Exception as e:
            app.logger.error(f"Error processing file for TC feed post by {current_user.username}: {e}", exc_info=True)
            return jsonify({"success": False, "error": "Error processing uploaded file."}), 500
            
    try:
        new_post = TalentClubFeedPost( # Use TalentClubFeedPost model
            feed_id=club.feed.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj:
            db.session.add(uploaded_file_obj)
        db.session.add(new_post)
        db.session.commit()

        app.logger.info(f"User {current_user.username} created TC feed post ID {new_post.id} in club {club.id}.")

        post_for_render = db.session.query(TalentClubFeedPost).options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role),
            joinedload(TalentClubFeedPost.file),
            joinedload(TalentClubFeedPost.comments), 
            joinedload(TalentClubFeedPost.reactions)
        ).get(new_post.id)

        post_html = render_template("partials/_tc_feed_post_item.html", 
                                    post=post_for_render, 
                                    current_user=current_user,
                                    club=club) # Pass club to partial for context

        # TODO: Notify club followers/members (see Phase 3 TC Proposal notification logic for example)
        # notify_tc_club_new_post(new_post, club)

        return jsonify({"success": True, "message": "Post created!", "post_html": post_html}), 201
    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath: # Cleanup
            try: os.remove(os.path.join(current_app.static_folder, uploaded_file_obj.filepath))
            except: pass
        app.logger.error(f"Error creating TC feed post in club {club.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error creating post."}), 500

@app.route("/talent_club/feed/posts/<int:post_id>/delete", methods=["POST"])
@login_required
@tc_member_required
def delete_tc_feed_post_ajax(post_id): # Renamed to avoid conflict if a GET view existed
    post = db.get_or_404(TalentClubFeedPost, post_id)
    club = post.feed.talent_club

    # Permissions: Post author, Club owner, Club admin
    is_post_author = (post.author_id == current_user.id)
    user_membership = db.session.scalar(select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True))
    is_club_owner_or_admin = (club.owner_id == current_user.id) or (user_membership and user_membership.role == 'admin')

    if not (is_post_author or is_club_owner_or_admin):
        return jsonify({"success": False, "error": "Permission denied."}), 403
        
    try:
        # If post has an associated file, delete it from filesystem (optional, handle orphans otherwise)
        if post.file:
            file_to_delete = post.file
            full_file_path = os.path.join(current_app.static_folder, file_to_delete.filepath)
            # Delete the File DB record first or after, cascade might handle it.
            # For safety, explicitly delete file record if not cascaded by post deletion.
        
        db.session.delete(post) # This should cascade to comments and reactions if model relationships are set up with cascade='all, delete-orphan'
        if post.file: # Delete File record if post deletion doesn't cascade to it
            db.session.delete(post.file) # This assumes a one-to-one from post to file

        db.session.commit()
        
        # Now delete file from disk
        if post.file and file_to_delete: # Check if file_to_delete was set
             if os.path.exists(full_file_path):
                try:
                    os.remove(full_file_path)
                    app.logger.info(f"Deleted associated file {file_to_delete.filepath} for TC post {post.id}.")
                except Exception as fe:
                    app.logger.error(f"Error deleting file {file_to_delete.filepath} for TC post {post.id}: {fe}")


        app.logger.info(f"User {current_user.username} deleted TC feed post {post.id}.")
        return jsonify({"success": True, "message": "Post deleted successfully."}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting TC feed post {post.id}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/talent_club/feed/posts/<int:post_id>/react", methods=["POST"])
@login_required
@tc_member_required
def react_tc_feed_post(post_id):
    post = db.get_or_404(TalentClubFeedPost, post_id)
    club = post.feed.talent_club

    if not club.is_active or not club.feed.allow_reactions:
        # Club owner/admin might bypass this
        user_membership = db.session.scalar(select(TalentClubMembership).filter_by(talent_club_id=club.id, user_id=current_user.id, is_active=True))
        is_manager = (club.owner_id == current_user.id) or (user_membership and user_membership.role == 'admin')
        if not is_manager:
            return jsonify({"success": False, "error": "Reactions are disabled."}), 403

    data = request.get_json()
    emoji = data.get("emoji", "").strip()
    if not emoji or emoji not in ["", "", "", "", "", ""]: # Allowed emojis
        return jsonify({"success": False, "error": "Invalid emoji."}), 400

    try:
        existing_reaction = db.session.scalar(
            select(TalentClubFeedReaction).where(
                TalentClubFeedReaction.post_id == post.id,
                TalentClubFeedReaction.user_id == current_user.id,
                TalentClubFeedReaction.emoji == emoji
            )
        )
        user_reacted_flag = False
        if existing_reaction:
            db.session.delete(existing_reaction)
            action_message = "Reaction removed."
        else:
            # Optional: If only one reaction type per user is allowed, remove their other reactions first
            # db.session.query(TalentClubFeedReaction).filter_by(post_id=post.id, user_id=current_user.id).delete()
            new_reaction = TalentClubFeedReaction(post_id=post.id, user_id=current_user.id, emoji=emoji)
            db.session.add(new_reaction)
            action_message = "Reaction added."
            user_reacted_flag = True
        db.session.commit()

        new_count = db.session.scalar(
            select(func.count(TalentClubFeedReaction.id)).where(
                TalentClubFeedReaction.post_id == post.id, TalentClubFeedReaction.emoji == emoji)
        ) or 0
        
        app.logger.info(f"User {current_user.username} {action_message} emoji '{emoji}' on TC post {post.id}.")
        return jsonify({
            "success": True, "message": action_message, "emoji": emoji,
            "new_count": new_count, "user_reacted": user_reacted_flag
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error reacting TC post {post.id} by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error."}), 500

@app.route("/talent_club/<int:club_id>/feed/posts") # GET request
@login_required
@tc_member_required # Must be TC member to view feed posts
def get_tc_feed_posts_paginated(club_id):
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active or not club.feed:
        return jsonify({"success": False, "error": "Club or feed not available."}), 404

    page = request.args.get('page', 1, type=int)
    per_page_posts = 10

    posts_query = (
        select(TalentClubFeedPost)
        .where(TalentClubFeedPost.feed_id == club.feed.id)
        .options(
            joinedload(TalentClubFeedPost.author).joinedload(User.role), 
            joinedload(TalentClubFeedPost.file),
            joinedload(TalentClubFeedPost.comments).joinedload(TalentClubFeedComment.author),
            joinedload(TalentClubFeedPost.reactions)
        )
        .order_by(TalentClubFeedPost.timestamp.desc())
    )
    pagination = db.paginate(posts_query, page=page, per_page=per_page_posts, error_out=False)
    posts_on_page = pagination.items

    posts_html = ""
    if posts_on_page:
        rendered_posts_list = [
            render_template("partials/_tc_feed_post_item.html", post=p, current_user=current_user, club=club)
            for p in posts_on_page
        ]
        # Also render the "Load More" button if there's a next page, for JS to replace old one
        if pagination.has_next:
            next_page_trigger_html = f"""
            <div class="text-center my-4" id="loadMoreTcPostsTrigger-{club.id}">
                <button class="btn btn-outline-primary load-more-tc-posts-btn" data-club-id="{club.id}" data-current-page="{pagination.page}">
                    <span class="spinner-border spinner-border-sm d-none me-1" role="status" aria-hidden="true"></span>
                    Load More Posts
                </button>
            </div>
            """
            rendered_posts_list.append(next_page_trigger_html)

        posts_html = "".join(rendered_posts_list)


    return jsonify({
        "success": True,
        "posts_html": posts_html, # Contains posts and potentially the next load_more button
        "has_next_page": pagination.has_next
    })
        
@app.route("/talent_club/configuration/current_leader")
@login_required
@tc_member_required # Only TC members can view this page
def view_current_tc_leader():
    current_system_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).limit(1)
    )
    active_election = get_active_tc_leader_election() # Helper from app.py Part 3 / Phase J

    candidates_for_voting = []
    user_has_voted_in_active_election = None
    can_user_vote = False
    vote_form = None

    if active_election:
        candidates_for_voting = get_tc_leader_candidates() # Helper from app.py Part 3 / Phase J (all active TC members)
        user_has_voted_in_active_election = db.session.scalar(
            select(TalentClubLeaderVote).filter_by(election_id=active_election.id, voter_id=current_user.id).limit(1)
        )
        if not user_has_voted_in_active_election: # Can vote if election is active and they haven't voted
            can_user_vote = True
            # Pass the list of candidates to the form's __init__
            vote_form = TalentClubLeaderVoteForm(candidates=candidates_for_voting)
    
    return render_template(
        "talent_club/config_current_leader.html",
        current_leader=current_system_leader,
        active_election=active_election,
        candidates=candidates_for_voting, # For display or form population
        user_vote=user_has_voted_in_active_election, # The vote object if they voted
        can_vote=can_user_vote,
        vote_form=vote_form, # Pass form if user can vote
        title="TC Leadership & Election - Nexus TC"
    )

@app.route("/talent_club/leader_vote", methods=["POST"])
@login_required
@tc_member_required # Only TC members can vote
def cast_tc_leader_vote():
    """Handles casting a vote in an active TC Leader election."""
    # Ensure user is eligible to vote (is_tc_member) - handled by decorator
    # Ensure an election is active
    active_election = get_active_tc_leader_election()
    if not active_election:
        flash("No active Talent Club Leader election is in progress.", "danger")
        return redirect(url_for("view_current_tc_leader"))

    # Ensure user hasn't already voted
    existing_vote = db.session.scalar(select(TalentClubLeaderVote).filter_by(election=active_election, voter=current_user))
    if existing_vote:
        flash("You have already voted in this election.", "warning")
        return redirect(url_for("view_current_tc_leader"))

    # Get eligible candidates to populate the form and validate submitted candidate
    candidates = get_tc_leader_candidates()
    form = TalentClubLeaderVoteForm(candidates=candidates) # Need to pass candidates to validate submitted candidate_id

    if form.validate_on_submit():
        candidate_id = form.candidate_id.data
        # Verify the selected candidate is actually one of the eligible candidates
        candidate = next((c for c in candidates if c.id == candidate_id), None)

        if not candidate:
             flash("Invalid candidate selected.", "danger")
             # Re-render the voting form page with error
             # Need to pass necessary data to re-render the template correctly
             return render_template("talent_club/config_current_leader.html",
                                    current_leader=None, # Re-fetch if needed, or pass empty
                                    active_election=active_election,
                                    candidates=candidates,
                                    user_vote=None,
                                    can_vote=True,
                                    vote_form=form, # Pass the form with errors
                                    title="Current Talent Club Leader")


        try:
            # Create the vote entry
            new_vote = TalentClubLeaderVote(
                election=active_election,
                voter=current_user,
                candidate=candidate,
                voted_at=datetime.now(timezone.utc)
            )
            db.session.add(new_vote)
            db.session.commit()

            flash("Your vote has been cast successfully!", "success")
            app.logger.info(f"User {current_user.id} voted for user {candidate.id} in election {active_election.id}.")

            # Redirect back to the leader view page
            return redirect(url_for("view_current_tc_leader"))

        except IntegrityError:
             db.session.rollback()
             flash("You have already voted in this election.", "warning") # Safety net for unique constraint
             app.logger.warning(f"IntegrityError casting vote for user {current_user.id} in election {active_election.id}.")
             return redirect(url_for("view_current_tc_leader"))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error user {current_user.id} casting vote in election {active_election.id}: {e}", exc_info=True)
            flash("An error occurred while casting your vote. Please try again.", "danger")
            return redirect(url_for("view_current_tc_leader"))

    # If form validation fails (unlikely with just select field but possible)
    flash("Invalid vote submission.", "danger")
    # Re-render the voting form page with errors
    # Need to pass necessary data to re-render the template correctly
    return render_template("talent_club/config_current_leader.html",
                           current_leader=None,
                           active_election=active_election,
                           candidates=candidates,
                           user_vote=None,
                           can_vote=True,
                           vote_form=form,
                           title="Current Talent Club Leader")

@app.route("/talent_club/configuration/new_club_proposal", methods=["GET", "POST"])
@login_required
@tc_member_required
def create_talent_club_proposal():
    form = CreateTalentClubProposalForm() # Your form definition
    # form.social_category_id.choices are populated in its __init__

    if form.validate_on_submit():
        proposal_file_obj = None # Will hold the File DB object if a file is uploaded
        
        # --- Handle Proposal File Upload ---
        if form.proposal_file.data and form.proposal_file.data.filename:
            try:
                uploaded_file_obj = save_uploaded_file(form.proposal_file.data) # Your general file saver
                if not uploaded_file_obj:
                    # Error should be flashed by save_uploaded_file
                    return render_template("talent_club/config_new_proposal.html", form=form, title="Submit Club Proposal - Nexus TC", all_tc_members=get_tc_leader_candidates())
                proposal_file_obj = uploaded_file_obj # Store the File object
            except Exception as e:
                app.logger.error(f"Error processing proposal file for user {current_user.id}: {e}", exc_info=True)
                flash("An error occurred uploading the proposal document.", "danger")
                return render_template("talent_club/config_new_proposal.html", form=form, title="Submit Club Proposal - Nexus TC", all_tc_members=get_tc_leader_candidates())

        # --- Handle Mentioned Members ---
        mentioned_member_ids_str = request.form.get('mentioned_member_ids_hidden', '') # Get from hidden input
        mentioned_member_ids = [int(uid) for uid in mentioned_member_ids_str.split(',') if uid.isdigit()]
        
        # Fetch actual User objects for validation and ensure they are active TC members, excluding creator
        valid_mentioned_users = []
        if mentioned_member_ids:
            valid_mentioned_users = db.session.scalars(
                select(User).where(
                    User.id.in_(mentioned_member_ids),
                    User.id != current_user.id, # Exclude self
                    User.is_tc_member == True,
                    User.is_active == True
                )
            ).all()

        MIN_MENTIONED_MEMBERS = 5 # Define your minimum
        if len(valid_mentioned_users) < MIN_MENTIONED_MEMBERS:
            flash(f"You must successfully mention at least {MIN_MENTIONED_MEMBERS} other active Talent Club members. You selected {len(valid_mentioned_users)} valid members.", "danger")
            # Cleanup uploaded file if any
            if proposal_file_obj and proposal_file_obj.filepath:
                try: os.remove(os.path.join(current_app.static_folder, proposal_file_obj.filepath))
                except: pass
            return render_template("talent_club/config_new_proposal.html", form=form, title="Submit Club Proposal - Nexus TC", all_tc_members=get_tc_leader_candidates())

        # --- Create Proposal and Mentions ---
        try:
            new_proposal = TalentClubProposal(
                creator_id=current_user.id,
                name=form.name.data.strip(),
                description=form.description.data.strip(),
                social_category_id=form.social_category_id.data,
                proposal_file_id=proposal_file_obj.id if proposal_file_obj else None,
                status='pending_leader_review',
                created_at=datetime.now(timezone.utc)
            )
            if proposal_file_obj: # Add to session if it was created
                db.session.add(proposal_file_obj)

            db.session.add(new_proposal)
            db.session.flush() # To get new_proposal.id for mentions

            mention_entries_for_notification = []
            for user_to_mention in valid_mentioned_users:
                mention = TalentClubMention(
                    proposal_id=new_proposal.id,
                    user_id=user_to_mention.id,
                    status='pending' 
                )
                db.session.add(mention)
                mention_entries_for_notification.append(mention)
            
            db.session.commit()
            app.logger.info(f"User {current_user.username} submitted TC Proposal ID {new_proposal.id} mentioning {len(valid_mentioned_users)} users.")

            # --- Notifications ---
            # 1. To Mentioned Members
            notification_content_mention = f"You've been mentioned in a new Talent Club proposal for '{new_proposal.name}' by {current_user.full_name or current_user.username}. Your response is requested."
            for mention_record in mention_entries_for_notification: # Iterate over the committed mention objects
                link_url_mention = url_for('view_tc_proposal_mention', mention_id=mention_record.id, _external=True)
                # notify_tc_member is your helper from app.py Part 3 / Phase J
                notify_tc_member( 
                    receiver_user=mention_record.user, # The mentioned user object
                    sender_user=current_user,
                    content=notification_content_mention,
                    notification_type='tc_proposal_mention_invite', # New distinct type
                    related_object_id=mention_record.id,
                    link_url=link_url_mention
                )

            # 2. To TC Leader
            tc_leader = db.session.scalar(select(User).where(User.is_tc_leader == True, User.is_active == True))
            if tc_leader:
                notification_content_leader = f"New TC Proposal '{new_proposal.name}' submitted by {current_user.full_name or current_user.username} is awaiting your review."
                link_url_leader = url_for('review_tc_proposal', proposal_id=new_proposal.id, _external=True)
                notify_tc_member(
                    receiver_user=tc_leader,
                    sender_user=current_user,
                    content=notification_content_leader,
                    notification_type='tc_proposal_for_review', # New distinct type
                    related_object_id=new_proposal.id,
                    link_url=link_url_leader
                )
            else:
                app.logger.warning(f"No active TC Leader found to notify about new proposal {new_proposal.id}.")


            flash(f"Your proposal for '{new_proposal.name}' has been submitted and mentioned members notified!", "success")
            return redirect(url_for("my_talent_club_proposals"))

        except IntegrityError: # E.g. proposal name unique constraint
            db.session.rollback()
            if proposal_file_obj and proposal_file_obj.filepath: # Cleanup
                 try: os.remove(os.path.join(current_app.static_folder, proposal_file_obj.filepath))
                 except: pass
            flash("A proposal with this name might already exist, or another database error occurred.", "danger")
        except Exception as e:
            db.session.rollback()
            if proposal_file_obj and proposal_file_obj.filepath: # Cleanup
                 try: os.remove(os.path.join(current_app.static_folder, proposal_file_obj.filepath))
                 except: pass
            app.logger.error(f"Error submitting TC proposal by {current_user.id}: {e}", exc_info=True)
            flash("An unexpected error occurred. Please try again.", "danger")

    # For GET request or if form validation fails
    # all_tc_members for TomSelect user picker if not using AJAX search primarily
    # For AJAX search, the picker itself handles it. If you want initial options:
    all_tc_members_for_picker = db.session.scalars(
        select(User).where(User.is_tc_member == True, User.is_active == True, User.id != current_user.id).order_by(User.full_name)
    ).all()


    return render_template("talent_club/config_new_proposal.html", 
                           form=form, 
                           all_tc_members=all_tc_members_for_picker, # For TomSelect if not purely AJAX
                           title="Propose New Talent Club - Nexus TC")
# Route for displaying mentioned member invite response page
@app.route("/talent_club/invite/<int:mention_id>") # GET request
@login_required
@tc_member_required 
def view_tc_proposal_mention(mention_id):
    mention = db.get_or_404(TalentClubMention, mention_id, description="Proposal mention not found.")

    if mention.user_id != current_user.id:
        flash("This invitation is not for you.", "danger")
        return redirect(url_for("view_notifications")) # Or TC dashboard

    # Eager load related proposal data
    proposal = db.session.scalar(
        select(TalentClubProposal)
        .where(TalentClubProposal.id == mention.proposal_id)
        .options(
            joinedload(TalentClubProposal.creator),
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file)
        )
    )
    if not proposal: # Should not happen if mention exists
        flash("Associated proposal not found.", "danger")
        return redirect(url_for("view_notifications"))

    return render_template("talent_club/invite_response.html",
                           mention=mention,
                           proposal=proposal,
                           title=f"Invitation: Join '{proposal.name}' Proposal - Nexus TC")

# Endpoint to handle accepting/declining a club proposal mention
@app.route("/talent_club/invite/<int:mention_id>/respond/<string:response_action>", methods=["POST"]) # Renamed 'response' to 'response_action'
@login_required
@tc_member_required
def respond_tc_proposal_mention(mention_id, response_action):
    mention = db.get_or_404(TalentClubMention, mention_id, description="Proposal mention not found.")
    proposal = mention.proposal # Assumes relationship is loaded or accessible

    if mention.user_id != current_user.id:
        flash("This is not your invitation to respond to.", "danger")
        abort(403)

    if response_action not in ['accept', 'decline']:
        flash("Invalid response action.", "danger")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))

    if mention.status != 'pending':
        flash(f"You have already responded to this invitation (your response: {mention.status.title()}).", "info")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))
    
    # Crucially, only allow response if the main proposal is still in a state where responses matter
    if proposal.status != 'pending_leader_review':
        flash(f"This proposal (Status: {proposal.status.replace('_',' ').title()}) is no longer awaiting member responses.", "warning")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))

    try:
        if response_action == 'accept':
            mention.status = 'accepted'
        elif response_action == 'decline':
            mention.status = 'rejected'
        mention.responded_at = datetime.now(timezone.utc)
        db.session.commit()
        
        app.logger.info(f"User {current_user.username} {mention.status} mention ID {mention.id} for proposal '{proposal.name}'.")

        # Notify proposal creator
        creator = proposal.creator
        if creator and creator.is_active and creator.id != current_user.id:
            response_text = "accepted" if mention.status == 'accepted' else "declined"
            content = f"{current_user.full_name or current_user.username} has {response_text} your invitation to join the '{proposal.name}' club proposal."
            link = url_for('review_tc_proposal', proposal_id=proposal.id, _external=True) # Link for TC Leader, or a creator view of proposal
            # Link for creator could be my_talent_club_proposals or a detail view of their own proposal
            # For now, TC Leader link is fine, creator can see status on their "My Proposals" page.

            notify_tc_member(
                receiver_user=creator,
                sender_user=current_user,
                content=content,
                notification_type='tc_mention_response_to_creator', # New distinct type
                related_object_id=mention.id, # Could link to the mention or the proposal
                link_url=link # Link to the proposal detail/review page
            )

        flash(f"Thank you! You have {mention.status.title()} the invitation for '{proposal.name}'.", "success" if mention.status == 'accepted' else "info")
        return redirect(url_for("view_notifications")) # Or back to My Proposals

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error responding to TC mention {mention_id} by {current_user.id}: {e}", exc_info=True)
        flash("An error occurred while processing your response. Please try again.", "danger")
        return redirect(url_for('view_tc_proposal_mention', mention_id=mention.id))
# Route for viewing submitted proposals (for the creator)
@app.route("/talent_club/my_proposals")
@login_required
@tc_member_required
def my_talent_club_proposals():
    proposals_query = (
        select(TalentClubProposal)
        .where(TalentClubProposal.creator_id == current_user.id)
        .options(
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file),
            joinedload(TalentClubProposal.reviewed_by) # If displaying reviewer
            # No need to load all mentioned_members here for list view, just count
        )
        .order_by(TalentClubProposal.created_at.desc())
    )
    proposals = db.session.scalars(proposals_query).all()

    accepted_counts = {}
    for p in proposals:
        # Efficiently count accepted mentions for each proposal
        accepted_counts[p.id] = db.session.scalar(
            select(func.count(TalentClubMention.id))
            .where(TalentClubMention.proposal_id == p.id, TalentClubMention.status == 'accepted')
        ) or 0
        
    return render_template("talent_club/my_proposals.html",
                           proposals=proposals,
                           accepted_counts=accepted_counts,
                           title="My Club Proposals - Nexus TC")
                           
@app.route("/talent_club/configuration/community") # This is a navigation link from config menu
@login_required
@tc_member_required # Ensures only TC members can access this path
def talent_club_community_group():
    # get_tc_community_group() helper should be defined (from app.py Part 3 / Phase J)
    # It fetches the single TalentClubCommunity instance.
    community_group = get_tc_community_group() 
    if not community_group:
        flash("The Talent Club Community group has not been configured by an administrator yet.", "danger")
        app.logger.error("TC Community group not found in DB when navigating from config menu.")
        return redirect(url_for("talent_club_configuration"))

    # Ensure current user (who is a TC member due to @tc_member_required) is in the TalentClubCommunityMember table
    # is_tc_community_member() and add_to_tc_community_group() helpers are from app.py Part 3 / Phase J
    if not is_tc_community_member(current_user):
        add_success = add_to_tc_community_group(current_user)
        if not add_success:
            flash("Successfully joined Talent Club, but there was an issue adding you to the TC Community group chat. Please contact an administrator.", "warning")
            # Log is in helper
        else:
            flash("You've been added to the Talent Club Community group chat!", "info")
            
    # All checks passed, redirect to the actual message viewing route
    return redirect(url_for("view_tc_community_messages"))

@app.route("/talent_club/community/messages", methods=["GET"]) # POST handled by separate AJAX endpoint
@login_required
@tc_member_required
def view_tc_community_messages():
    community_group = get_tc_community_group()
    if not community_group:
        flash("Talent Club Community group is not available.", "danger")
        return redirect(url_for("talent_club_dashboard_member_view")) # Redirect to TC member dashboard

    # Double check membership (should be guaranteed by redirect from /talent_club/configuration/community)
    if not is_tc_community_member(current_user):
        flash("You are not a member of the TC Community group.", "danger")
        app.logger.warning(f"User {current_user.id} attempted direct access to TCC messages but not a member.")
        return redirect(url_for("talent_club_dashboard_member_view"))

    # Determine if user can post (not muted system-wide in TC)
    # is_currently_banned_muted helper from app.py Part 3 / Phase J
    active_restriction = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == current_user.id,
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        )
    )
    can_post_in_community = not (active_restriction and active_restriction.type == 'mute')


    # Fetch initial messages for display
    # Template uses column-reverse, so fetch oldest first if JS will prepend, or newest if template handles display order
    messages_query = (
        select(TalentClubCommunityMessage) # Your TalentClubCommunityMessage model
        .where(TalentClubCommunityMessage.community_id == community_group.id)
        .options(
            joinedload(TalentClubCommunityMessage.author).joinedload(User.role), 
            joinedload(TalentClubCommunityMessage.file)
        )
        .order_by(TalentClubCommunityMessage.timestamp.asc()) # Oldest first for chat-like display
        .limit(50) # Initial batch
    )
    messages = db.session.scalars(messages_query).all()
    
    post_form = PostContentForm() # For message input (reusing from social features)

    return render_template("talent_club/community_group.html",
                           community_group=community_group,
                           messages=messages,
                           post_form=post_form,
                           can_post_in_community=can_post_in_community,
                           title=f"{community_group.name} - Nexus TC")
@app.route("/talent_club/leaderboard")
@login_required
@tc_member_required
def talent_club_leaderboard():
    leaderboard_clubs = db.session.scalars(
        select(TalentClub)
        .where(TalentClub.is_active == True)
        .options(joinedload(TalentClub.owner), joinedload(TalentClub.social_category), joinedload(TalentClub.memberships), joinedload(TalentClub.follows)) # Load for counts
        .order_by(TalentClub.level.desc(), TalentClub.warning_count.asc(), TalentClub.name.asc())
    ).all()
    
    return render_template(
        "talent_club/leaderboard.html",
        leaderboard_clubs=leaderboard_clubs,
        title="Talent Club Leaderboard - Nexus TC"
    )

# --- TC Leader Specific Routes (Requires is_tc_leader = TRUE) ---
# We need a custom decorator or check within routes for is_tc_leader

def tc_leader_required(f):
    """Decorator to restrict access to routes to the system-wide Talent Club Leader."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash("Please log in to access this page.", "warning")
            return redirect(url_for("login", next=request.url))

        # Check if the user is the system-wide TC Leader
        if not current_user.is_tc_leader:
            app.logger.warning(
                f"User {current_user.username} (ID: {current_user.id}) "
                f"attempted to access TC Leader restricted route {request.path} but is not the leader."
            )
            flash("You must be the Talent Club Leader to access this page.", "danger")
            # Redirect them back to the main TC dashboard
            return redirect(url_for('talent_club_dashboard'))

        return f(*args, **kwargs)

    return decorated_function

# Route to view pending proposals for the TC Leader
@app.route("/talent_club/leader/proposals")
@login_required
@tc_leader_required # Custom decorator for system-wide TC Leader
def review_tc_proposals():
    pending_proposals_query = (
        select(TalentClubProposal)
        .where(TalentClubProposal.status == 'pending_leader_review')
        .options(
            joinedload(TalentClubProposal.creator),
            joinedload(TalentClubProposal.social_category),
            joinedload(TalentClubProposal.proposal_file) # For viewing document
            # mentioned_members are loaded per proposal below for counts and details
        )
        .order_by(TalentClubProposal.created_at.asc()) # Oldest first
    )
    pending_proposals = db.session.scalars(pending_proposals_query).all()

    proposal_mentions_details = {} # To store list of mention objects per proposal
    accepted_mention_counts = {}   # To store count of accepted mentions per proposal

    for proposal in pending_proposals:
        mentions_for_proposal = db.session.scalars(
            select(TalentClubMention)
            .where(TalentClubMention.proposal_id == proposal.id)
            .options(joinedload(TalentClubMention.user).joinedload(User.role)) # Load user and their role
        ).all()
        proposal_mentions_details[proposal.id] = mentions_for_proposal
        
        accepted_mention_counts[proposal.id] = sum(
            1 for m in mentions_for_proposal if m.status == 'accepted' and m.user_id != proposal.creator_id
        )

    return render_template(
        "talent_club/leader/review_proposals.html",
        pending_proposals=pending_proposals,
        proposal_mentions=proposal_mentions_details, # Pass the actual mention objects
        accepted_counts=accepted_mention_counts,     # Pass the calculated counts
        title="Review Club Proposals - TC Leader Admin - Nexus TC"
    )
@app.route("/talent_club/leader/proposals/<int:proposal_id>/review", methods=["GET", "POST"])
@login_required
@tc_leader_required
def review_tc_proposal(proposal_id):
    proposal = db.get_or_404(TalentClubProposal, proposal_id, description="Proposal not found.")

    if proposal.status != 'pending_leader_review':
        flash(f"This proposal (Status: {proposal.status.replace('_',' ').title()}) is no longer awaiting leader review.", "info")
        return redirect(url_for("review_tc_proposals"))

    mentions = db.session.scalars(
        select(TalentClubMention)
        .where(TalentClubMention.proposal_id == proposal.id)
        .options(joinedload(TalentClubMention.user).joinedload(User.role))
    ).all()
    
    accepted_count = sum(1 for m in mentions if m.status == 'accepted' and m.user_id != proposal.creator_id)
    MIN_REQUIRED_ACCEPTED_FOR_CLUB = 5 # Define your constant
    meets_min_members = accepted_count >= MIN_REQUIRED_ACCEPTED_FOR_CLUB

    if request.method == "POST":
        action = request.form.get('action')
        review_notes = request.form.get('review_notes', '').strip()
        
        if action not in ['accept', 'reject', 'save_notes']:
            flash("Invalid review action specified.", "danger")
            # Re-render with current data
            return render_template(
                "talent_club/leader/review_proposal_detail.html",
                proposal=proposal, mentions=mentions, accepted_count=accepted_count,
                meets_min_members=meets_min_members, title=f"Review: {proposal.name} - Nexus TC")

        try:
            proposal.leader_review_notes = review_notes if review_notes else proposal.leader_review_notes
            proposal.reviewed_by_id = current_user.id
            proposal.reviewed_at = datetime.now(timezone.utc)

            if action == 'accept':
                if not meets_min_members:
                    flash(f"Cannot accept: Proposal needs at least {MIN_REQUIRED_ACCEPTED_FOR_CLUB} accepted mentions (has {accepted_count}).", "danger")
                else:
                    proposal.status = 'accepted'
                    # --- Create TalentClub, Feed, Memberships ---
                    new_club = TalentClub(
                        name=proposal.name,
                        description=proposal.description,
                        # profile_photo_url set later via edit club profile
                        owner_id=proposal.creator_id,
                        social_category_id=proposal.social_category_id,
                        level=1, # Default start level
                        is_active=True,
                        created_at=datetime.now(timezone.utc)
                    )
                    db.session.add(new_club)
                    db.session.flush() # Get new_club.id

                    new_feed = TalentClubFeed(talent_club_id=new_club.id) # Create linked feed
                    db.session.add(new_feed)

                    # Add creator as 'creator' role member
                    creator_membership = TalentClubMembership(club_id=new_club.id, user_id=proposal.creator_id, role='creator')
                    db.session.add(creator_membership)

                    # Add accepted mentioned members as 'member' role
                    for mention in mentions:
                        if mention.status == 'accepted' and mention.user_id != proposal.creator_id:
                            member_membership = TalentClubMembership(club_id=new_club.id, user_id=mention.user_id, role='member')
                            db.session.add(member_membership)
                    
                    db.session.commit() # Commit proposal, new club, feed, memberships
                    app.logger.info(f"TC Proposal {proposal.id} accepted by {current_user.username}. New Club ID: {new_club.id}")
                    flash(f"Proposal '{proposal.name}' accepted and Talent Club created!", "success")

                    # --- Notifications for Acceptance ---
                    # 1. To Creator
                    notify_tc_member(proposal.creator, current_user, f"Your club proposal '{new_club.name}' has been APPROVED and the club is now active!",
                                     'tc_proposal_approved_creator', new_club.id, url_for('view_talent_club_feed', club_id=new_club.id, _external=True))
                    # 2. To Accepted Members
                    for mention in mentions:
                        if mention.status == 'accepted' and mention.user_id != proposal.creator_id:
                             notify_tc_member(mention.user, current_user, f"The proposal for '{new_club.name}' (which you accepted) has been approved! You are now a member.",
                                              'tc_club_membership_granted', new_club.id, url_for('view_talent_club_feed', club_id=new_club.id, _external=True))
                    return redirect(url_for("review_tc_proposals"))

            elif action == 'reject':
                proposal.status = 'rejected'
                db.session.commit()
                app.logger.info(f"TC Proposal {proposal.id} rejected by {current_user.username}.")
                flash(f"Proposal '{proposal.name}' has been rejected.", "info")
                
                # --- Notifications for Rejection ---
                # 1. To Creator
                notes_info = f" Reviewer notes: {proposal.leader_review_notes[:100]}..." if proposal.leader_review_notes else ""
                notify_tc_member(proposal.creator, current_user, f"Your club proposal '{proposal.name}' has been REJECTED.{notes_info}",
                                 'tc_proposal_rejected_creator', proposal.id, url_for('my_talent_club_proposals', _external=True)) # Link to their proposals list
                # 2. To Mentioned Members (who had accepted/pending)
                for mention in mentions:
                     if mention.status in ['accepted', 'pending'] and mention.user_id != proposal.creator_id:
                          notify_tc_member(mention.user, current_user, f"The club proposal '{proposal.name}' (that you were mentioned in) has been rejected by the TC Leader.",
                                           'tc_proposal_rejected_mention', proposal.id, url_for('view_notifications', _external=True)) # Generic link
                return redirect(url_for("review_tc_proposals"))

            elif action == 'save_notes':
                db.session.commit()
                flash("Review notes saved for this proposal.", "success")
                # Stay on the same page to continue review
                return redirect(url_for('review_tc_proposal', proposal_id=proposal.id))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error processing TC proposal {proposal.id} action '{action}' by {current_user.username}: {e}", exc_info=True)
            flash("An unexpected error occurred while processing the proposal.", "danger")

    # For GET request
    return render_template("talent_club/leader/review_proposal_detail.html",
                           proposal=proposal,
                           mentions=mentions,
                           accepted_count=accepted_count,
                           meets_min_members=meets_min_members,
                           title=f"Review Proposal: {proposal.name} - Nexus TC")

@app.route("/talent_club/leader/club/<int:club_id>/set_level", methods=["POST"])
@login_required
@tc_leader_required
def set_talent_club_level_action(club_id): # Renamed to avoid conflict if a GET view existed
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        flash("Cannot change level of an inactive club.", "warning")
        return redirect(url_for("manage_talent_clubs_leader"))

    form = TalentClubLevelForm(request.form) # Bind form to request data for validation

    if form.validate_on_submit(): # WTForms validation
        new_level = form.level.data
        old_level = club.level

        # Optional: Further validation if TALENT_CLUB_LEVELS is a list of allowed values
        # if new_level not in [lvl[1] if isinstance(lvl, tuple) else lvl for lvl in TALENT_CLUB_LEVELS]:
        #     flash("Invalid level selected.", "danger")
        #     return redirect(url_for("manage_talent_clubs_leader"))

        try:
            club.level = new_level
            db.session.commit()
            app.logger.info(f"TC Leader {current_user.username} set level of club {club.id} from {old_level} to {new_level}.")
            flash(f"Level for club '{club.name}' successfully updated to {new_level}.", "success")

            # --- Notification for Level Change ---
            # (Similar notification logic as in your original app.py Part X for set_talent_club_level)
            # Query members and followers who want notifications.
            # Send notification with notify_tc_member(...)
            # Example:
            # users_to_notify = get_club_members_and_followers_for_notification(club) # A helper you'd create
            # for user_to_notify in users_to_notify:
            #    notify_tc_member(user_to_notify, current_user, f"Club '{club.name}' level changed to {new_level}.", 'tc_level_change', club.id, url_for('view_talent_club_profile', club_id=club.id, _external=True))


        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error setting level for club {club.id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while updating the club level.", "danger")
    else:
        # Form validation failed
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(form, field).label.text}: {error}", "danger")
                
    return redirect(url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/club/<int:club_id>/set_level", methods=["POST"])
@login_required
@tc_leader_required
def set_talent_club_level(club_id):
    """Allows the TC Leader to set the level of a Talent Club."""
    club = db.get_or_404(TalentClub, club_id)

    if not club.is_active:
         flash("Cannot change level of an inactive club.", "warning")
         return redirect(request.referrer or url_for("manage_talent_clubs_leader"))

    form = TalentClubLevelForm() # Use the level form

    if form.validate_on_submit():
        new_level = form.level.data

        # Optional validation: Ensure level is within a valid range if you have a max level
        # if new_level not in TALENT_CLUB_LEVELS and isinstance(TALENT_CLUB_LEVELS[0], int): # Check if using integer levels
        #      flash("Invalid level provided.", "danger")
        #      # Need to re-render the management page or handle AJAX error
        #      return redirect(request.referrer or url_for("manage_talent_clubs_leader")) # Redirect for simplicity

        old_level = club.level

        try:
            club.level = new_level
            db.session.commit()

            # --- Notification ---
            # Notify club members and followers (who want notifications) about level change
            members_and_followers = db.session.scalars(
                 select(User)
                 .join(TalentClubMembership, and_(TalentClubMembership.talent_club_id == club.id, TalentClubMembership.is_active == True), isouter=True) # Outer join for members
                 .join(TalentClubFollow, TalentClubFollow.talent_club_id == club.id, isouter=True) # Outer join for follows
                 .where(or_(TalentClubMembership.user_id == User.id, TalentClubFollow.user_id == User.id)) # User is in either membership or follow
                 .distinct() # Ensure distinct users
                 .where(User.is_active == True, User.id != current_user.id) # Only active, not the leader
            ).all()

            if members_and_followers:
                 notification_content = f"Talent Club '{club.name}' level changed from {old_level} to {new_level}."
                 link_url = url_for('view_talent_club_profile', club_id=club.id)

                 notifications_to_add = []
                 for user in members_and_followers:
                      # Only notify followers if their setting is True
                      if user.is_tc_member or (user.tc_follows.filter_by(club=club, receive_notifications=True).first() is not None): # Notify members, or followers with notifications on
                            try:
                                 notify = Notification(
                                     sender_id=current_user.id,
                                     receiver_id=user.id,
                                     content=notification_content,
                                     link_url=link_url,
                                     timestamp=datetime.now(timezone.utc),
                                     is_read=False,
                                     notification_type='tc_level_change', # Specific type
                                     related_object_id=club.id
                                 )
                                 notifications_to_add.append(notify)
                            except Exception as notify_e:
                                 app.logger.error(f"Error creating TC level change notification for user {user.id}: {notify_e}")

                 if notifications_to_add:
                    db.session.add_all(notifications_to_add)
                    db.session.commit()
                    app.logger.info(f"Notified {len(notifications_to_add)} users about level change for club {club.id}.")


            flash(f"Level for club '{club.name}' set to {new_level}.", "success")
            app.logger.info(f"TC Leader {current_user.id} set level of club {club.id} to {new_level}.")

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error TC Leader {current_user.id} setting level for club {club.id}: {e}", exc_info=True)
            flash("An error occurred while setting the club level. Please try again.", "danger")

    else:
         # If form validation failed (e.g., non-integer level)
         flash("Invalid level submitted.", "danger")

    # Redirect back to club management page
    return redirect(request.referrer or url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/club/<int:club_id>/warn", methods=["POST"])
@login_required
@tc_leader_required
def warn_talent_club_action(club_id): # Renamed
    club = db.get_or_404(TalentClub, club_id)
    if not club.is_active:
        flash("Cannot issue a warning to an inactive club.", "warning")
        return redirect(url_for("manage_talent_clubs_leader"))

    form = TalentClubWarningForm(request.form) # Bind to request data

    if form.validate_on_submit():
        try:
            reason = form.reason.data.strip()
            new_warning = TalentClubWarning(
                talent_club_id=club.id,
                issued_by_id=current_user.id,
                reason=reason,
                issued_at=datetime.now(timezone.utc)
            )
            db.session.add(new_warning)
            club.warning_count += 1
            
            club_deactivated_due_to_warnings = False
            if club.level == 1 and club.warning_count >= 3:
                club.is_active = False # Soft delete
                club_deactivated_due_to_warnings = True
                app.logger.warning(f"TC Club {club.id} ('{club.name}') deactivated due to reaching 3 warnings at Level 1.")
            
            db.session.commit()
            
            flash_message = f"Warning issued to club '{club.name}'. Reason: {reason}. Warning count is now {club.warning_count}."
            if club_deactivated_due_to_warnings:
                flash_message += " The club has been deactivated due to exceeding warnings at Level 1."
            flash(flash_message, "success" if not club_deactivated_due_to_warnings else "danger")
            app.logger.info(f"TC Leader {current_user.username} issued warning to club {club.id}. Reason: {reason}. Count: {club.warning_count}.")

            # --- Notifications for Warning & Potential Deactivation ---
            # (Similar to your original app.py Part X for warn_talent_club)
            # Notify club owner, members, followers about the warning.
            # If club deactivated, send a specific "club_destroyed" notification.

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error issuing warning to club {club.id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while issuing the warning.", "danger")
    else:
        for field, errors in form.errors.items():
            for error in errors:
                flash(f"Error in {getattr(form, field).label.text}: {error}", "danger")
                
    return redirect(url_for("manage_talent_clubs_leader"))

@app.route("/talent_club/leader/member_management")
@login_required
@tc_leader_required # Custom decorator for system-wide TC Leader
def manage_tc_members_leader():
    active_tc_members_query = (
        select(User)
        .where(User.is_tc_member == True, User.is_active == True)
        .options(joinedload(User.role), joinedload(User.tc_memberships).joinedload(TalentClubMembership.club)) # Load roles and club memberships
        .order_by(User.full_name.asc())
    )
    tc_members = db.session.scalars(active_tc_members_query).all()

    member_ban_status = {} # To store active TalentClubBan object or None
    if tc_members:
        member_ids = [m.id for m in tc_members]
        active_bans = db.session.scalars(
            select(TalentClubBan)
            .where(
                TalentClubBan.user_id.in_(member_ids),
                or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
            )
        ).all()
        for ban in active_bans:
            member_ban_status[ban.user_id] = ban
            
    return render_template(
        "talent_club/leader/member_management.html",
        tc_members=tc_members,
        member_ban_status=member_ban_status,
        title="Manage TC Members - TC Leader Admin - Nexus TC"
    )
    
@app.route("/talent_club/leader/member/<int:user_id>/ban_mute", methods=["GET", "POST"])
@login_required
@tc_leader_required
def ban_mute_tc_member(user_id):
    user_to_manage = db.get_or_404(User, user_id, description="User not found.")

    if not user_to_manage.is_tc_member: # Can only ban/mute current TC members
        flash(f"{user_to_manage.full_name or user_to_manage.username} is not currently a Talent Club member.", "warning")
        return redirect(url_for("manage_tc_members_leader"))
    if user_to_manage.id == current_user.id:
        flash("You cannot ban or mute yourself.", "danger")
        return redirect(url_for("manage_tc_members_leader"))

    # Fetch current active ban/mute, if any
    active_ban_object = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == user_to_manage.id,
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        ).limit(1)
    )
    
    form = TalentClubBanMuteForm() # Your form definition

    if form.validate_on_submit():
        ban_type_from_form = form.ban_type.data
        reason_from_form = form.reason.data.strip()
        duration_days_from_form = form.duration_days.data # Integer or None

        if ban_type_from_form not in TALENT_CLUB_BAN_TYPES: # TALENT_CLUB_BAN_TYPES from app.py config
            flash("Invalid action type selected.", "danger")
        else:
            try:
                # End any existing active ban/mute for this user before applying a new one
                if active_ban_object:
                    active_ban_object.expires_at = datetime.now(timezone.utc) - timedelta(seconds=1) # Expire immediately
                    db.session.add(active_ban_object) # Add to session for commit
                    app.logger.info(f"Expiring previous ban/mute ID {active_ban_object.id} for user {user_to_manage.id} before applying new one.")

                expires_at_val = None
                if duration_days_from_form is not None and duration_days_from_form > 0:
                    expires_at_val = datetime.now(timezone.utc) + timedelta(days=duration_days_from_form)

                new_ban_entry = TalentClubBan(
                    user_id=user_to_manage.id,
                    issued_by_id=current_user.id,
                    type=ban_type_from_form,
                    reason=reason_from_form,
                    issued_at=datetime.now(timezone.utc),
                    expires_at=expires_at_val
                )
                db.session.add(new_ban_entry)

                # Apply side-effects of 'ban'
                if ban_type_from_form == 'ban':
                    user_to_manage.is_tc_member = False # Revoke TC membership
                    # Remove from TC Community Group
                    community_group = get_tc_community_group()
                    if community_group:
                        community_member_entry = db.session.scalar(select(TalentClubCommunityMember).filter_by(community_id=community_group.id, user_id=user_to_manage.id))
                        if community_member_entry:
                            db.session.delete(community_member_entry)
                    # Deactivate/remove from all specific club memberships
                    db.session.query(TalentClubMembership).filter_by(user_id=user_to_manage.id).update({"is_active": False})
                    # Remove all club follows
                    db.session.query(TalentClubFollow).filter_by(user_id=user_to_manage.id).delete()
                    if user_to_manage.is_tc_leader: # If they were the system leader
                        user_to_manage.is_tc_leader = False
                        app.logger.warning(f"System TC Leader {user_to_manage.username} was banned and demoted.")
                        # TODO: Notify HR/CEO about this auto-demotion
                
                db.session.commit()
                flash(f"{user_to_manage.full_name or user_to_manage.username} has been successfully {ban_type_from_form}ned.", "success")
                app.logger.info(f"TC Leader {current_user.username} {ban_type_from_form}ned user {user_to_manage.id}. Reason: {reason_from_form}.")

                # --- Notification to the affected user ---
                notif_content = f"You have received a Talent Club system {ban_type_from_form}. Reason: {reason_from_form[:100]}..."
                if expires_at_val: notif_content += f" Expires: {expires_at_val.strftime('%Y-%m-%d %H:%M')}."
                if user_to_manage.is_active: # Only notify if user account is active
                    notify_tc_member(user_to_manage, current_user, notif_content, f'tc_system_{ban_type_from_form}', new_ban_entry.id, None)

                return redirect(url_for("manage_tc_members_leader"))
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error applying {ban_type_from_form} to user {user_id} by {current_user.username}: {e}", exc_info=True)
                flash(f"An error occurred. Could not apply {ban_type_from_form}.", "danger")
    
    # For GET request or if form validation failed
    return render_template("talent_club/leader/ban_mute_member.html",
                           user_to_manage=user_to_manage,
                           active_ban=active_ban_object, # Pass current ban object
                           form=form,
                           title=f"Apply Restriction to {user_to_manage.full_name or user_to_manage.username} - Nexus TC")

@app.route("/talent_club/api/community/<int:community_group_id>/messages/new")
@login_required
@tc_member_required
def ajax_get_new_tc_community_messages(community_group_id):
    # Verify community_group_id matches the single global one, or adapt if multiple could exist
    community_group = get_tc_community_group()
    if not community_group or community_group.id != community_group_id:
        return jsonify({"error": "Invalid community group."}), 404
    
    if not is_tc_community_member(current_user): # Should be covered by decorator
        return jsonify({"error": "Not a member."}), 403

    since_ms_str = request.args.get("since")
    if not since_ms_str: return jsonify({"error": "Missing 'since' timestamp."}), 400
        
    try:
        since_ms = int(since_ms_str)
        since_time = datetime.fromtimestamp((since_ms / 1000.0) + 0.001, tz=timezone.utc)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid timestamp format."}), 400

    new_messages_query = (
        select(TalentClubCommunityMessage)
        .where(
            TalentClubCommunityMessage.community_id == community_group.id,
            TalentClubCommunityMessage.timestamp > since_time,
            TalentClubCommunityMessage.author_id != current_user.id # Don't poll own messages back immediately
        )
        .options(joinedload(TalentClubCommunityMessage.author).joinedload(User.role), 
                 joinedload(TalentClubCommunityMessage.file))
        .order_by(TalentClubCommunityMessage.timestamp.asc())
    )
    new_messages_list = db.session.scalars(new_messages_query).all()

    messages_data_for_client = []
    latest_ts_in_batch = since_ms
    for msg in new_messages_list:
        messages_data_for_client.append({
            "id": msg.id, "sender_id": msg.author_id,
            "sender": {
                "full_name": msg.author.full_name if msg.author else "N/A",
                "username": msg.author.username if msg.author else "N/A",
                "profile_photo_url": msg.author.profile_photo_url if msg.author else None
            },
            "content": msg.content, "timestamp": msg.timestamp.isoformat() + "Z",
            "file": { "id": msg.file.id, "original_filename": msg.file.original_filename,
                      "mimetype": msg.file.mimetype, "size": msg.file.size,
                      "download_url": url_for('download_social_file', file_id=msg.file.id)
                    } if msg.file else None
        })
        msg_ts_ms = int(msg.timestamp.timestamp() * 1000)
        if msg_ts_ms > latest_ts_in_batch: latest_ts_in_batch = msg_ts_ms
            
    current_server_timestamp_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
    final_latest_timestamp = max(latest_ts_in_batch, current_server_timestamp_ms if not new_messages_list else 0)

    return jsonify({"messages": messages_data_for_client, "latest_timestamp": final_latest_timestamp}), 200

@app.route("/talent_club/community/create_message", methods=["POST"])
@login_required
@tc_member_required
def create_tc_community_message():
    community_group = get_tc_community_group()
    if not community_group:
        return jsonify({"success": False, "error": "TC Community group not available."}), 404

    if not is_tc_community_member(current_user): # Redundant due to @tc_member_required but good check
        return jsonify({"success": False, "error": "Not a member of TC Community."}), 403

    # Check if muted
    active_restriction = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == current_user.id,
            TalentClubBan.type == 'mute', # Specifically check for mute
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        )
    )
    if active_restriction:
        return jsonify({"success": False, "error": "You are currently muted in the Talent Club."}), 403

    form = PostContentForm(request.form)
    uploaded_file_obj = None
    file_storage = request.files.get(form.attached_file.name)

    if not form.content.data.strip() and not (file_storage and file_storage.filename):
        return jsonify({"success": False, "error": "Message content or a file must be provided."}), 400
    if form.content.data and not form.content.validate(form):
         return jsonify({"success": False, "error": form.content.errors[0] if form.content.errors else "Invalid content."}), 400
    
    if file_storage and file_storage.filename:
        try:
            uploaded_file_obj = save_uploaded_file(file_storage)
            if not uploaded_file_obj:
                return jsonify({"success": False, "error": "File upload failed."}), 400
        except Exception as e:
            return jsonify({"success": False, "error": "Error processing file."}), 500
            
    try:
        new_message = TalentClubCommunityMessage(
            community_id=community_group.id,
            author_id=current_user.id,
            content=form.content.data.strip() if form.content.data else None,
            file_id=uploaded_file_obj.id if uploaded_file_obj else None,
            timestamp=datetime.now(timezone.utc)
        )
        if uploaded_file_obj: db.session.add(uploaded_file_obj)
        db.session.add(new_message)
        db.session.commit()

        app.logger.info(f"User {current_user.username} sent TCC Message ID {new_message.id}.")

        # Prepare data for client-side rendering via _chat_message_item.html
        message_data_for_client = {
            "id": new_message.id,
            "sender_id": new_message.author_id,
            "sender": {
                "full_name": current_user.full_name, "username": current_user.username,
                "profile_photo_url": current_user.profile_photo_url
            },
            "content": new_message.content,
            "timestamp": new_message.timestamp.isoformat() + "Z",
            "file": { # Adapt based on how _chat_message_item handles files or if a different partial is used
                "id": uploaded_file_obj.id, "original_filename": uploaded_file_obj.original_filename,
                "mimetype": uploaded_file_obj.mimetype, "size": uploaded_file_obj.size,
                "download_url": url_for('download_social_file', file_id=uploaded_file_obj.id)
            } if uploaded_file_obj else None
        }
        # Or server-render HTML:
        # msg_for_render = db.session.query(TalentClubCommunityMessage).options(...).get(new_message.id)
        # post_html = render_template("partials/_chat_message_item.html", message=msg_for_render, current_user_id=current_user.id)


        return jsonify({"success": True, "message": "Message sent!", "post_data": message_data_for_client}), 201
    except Exception as e:
        db.session.rollback()
        if uploaded_file_obj and uploaded_file_obj.filepath: # Cleanup
            try: os.remove(os.path.join(current_app.static_folder, uploaded_file_obj.filepath))
            except: pass
        app.logger.error(f"Error creating TCC message by {current_user.username}: {e}", exc_info=True)
        return jsonify({"success": False, "error": "Server error sending message."}), 500
# Route to remove a ban/mute (POST only)

@app.route("/talent_club/leader/member/<int:user_id>/unban_unmute", methods=["POST"])
@login_required
@tc_leader_required
def unban_unmute_tc_member(user_id):
    user_to_manage = db.get_or_404(User, user_id, description="User not found.")
    if user_to_manage.id == current_user.id:
        flash("Invalid action on self.", "danger")
        return redirect(url_for("manage_tc_members_leader"))

    active_ban = db.session.scalar(
        select(TalentClubBan).where(
            TalentClubBan.user_id == user_to_manage.id,
            or_(TalentClubBan.expires_at.is_(None), TalentClubBan.expires_at > datetime.now(timezone.utc))
        ).limit(1)
    )

    if not active_ban:
        flash(f"{user_to_manage.full_name or user_to_manage.username} does not have an active ban or mute.", "info")
        return redirect(url_for("manage_tc_members_leader"))

    try:
        ban_type_lifted = active_ban.type
        active_ban.expires_at = datetime.now(timezone.utc) - timedelta(seconds=1) # Expire it

        # If 'ban' was lifted, re-grant TC membership. This is a policy decision.
        # User might need to re-join clubs manually or be re-added.
        if ban_type_lifted == 'ban':
            user_to_manage.is_tc_member = True 
            # Attempt to add back to TC Community Group
            add_to_tc_community_group(user_to_manage) 
            # Note: Previous club memberships are NOT automatically restored here. User would need to rejoin or be re-added.
        
        db.session.commit()
        flash(f"The {ban_type_lifted} for {user_to_manage.full_name or user_to_manage.username} has been lifted.", "success")
        app.logger.info(f"TC Leader {current_user.username} lifted {ban_type_lifted} for user {user_id} (Ban ID: {active_ban.id}).")

        # --- Notification to the affected user ---
        if user_to_manage.is_active:
            notify_tc_member(user_to_manage, current_user, f"Your Talent Club system {ban_type_lifted} has been lifted.", f'tc_system_un{ban_type_lifted}', active_ban.id, None)
            
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error lifting {ban_type_lifted} for user {user_id} by {current_user.username}: {e}", exc_info=True)
        flash("An error occurred while removing the restriction.", "danger")

    return redirect(url_for("manage_tc_members_leader"))
# --- HR/CEO Specific Routes for TC Leader Management ---
@app.route("/hr_ceo/talent_club_leader_management")
@login_required
@role_required("hr_ceo", "system_admin")
def manage_system_tc_leader():
    current_system_leader = db.session.scalar(
        select(User).where(User.is_tc_leader == True, User.is_active == True).options(joinedload(User.role))
    )
    active_election = get_active_tc_leader_election() # Helper function
    
    total_votes_in_active_election = 0
    candidate_vote_counts_dict = {}
    eligible_candidates_list = get_tc_leader_candidates() # Helper function

    if active_election:
        total_votes_in_active_election = db.session.scalar(
            select(func.count(TalentClubLeaderVote.id)).where(TalentClubLeaderVote.election_id == active_election.id)
        ) or 0
        
        # Get vote counts per candidate for the active election
        vote_counts_raw = db.session.execute(
            select(TalentClubLeaderVote.candidate_id, func.count(TalentClubLeaderVote.id).label("vote_count"))
            .where(TalentClubLeaderVote.election_id == active_election.id)
            .group_by(TalentClubLeaderVote.candidate_id)
            .order_by(desc("vote_count")) # Order by most votes
        ).all() # Returns list of Row objects
        candidate_vote_counts_dict = {row.candidate_id: row.vote_count for row in vote_counts_raw}

    past_elections_query = (
        select(TalentClubLeaderElection)
        .where(TalentClubLeaderElection.status == 'concluded')
        .options(joinedload(TalentClubLeaderElection.elected_leader)) # Load who won
        .order_by(TalentClubLeaderElection.concluded_at.desc())
        .limit(5) # Show recent past elections
    )
    past_elections = db.session.scalars(past_elections_query).all()

    return render_template(
        "hr_ceo/manage_tc_leader.html",
        current_leader=current_system_leader,
        active_election=active_election,
        total_votes_in_active_election=total_votes_in_active_election,
        candidate_vote_counts=candidate_vote_counts_dict, # Pass the dictionary
        eligible_candidates=eligible_candidates_list, # For mapping candidate IDs to names in template
        past_elections=past_elections,
        title="Manage System TC Leader - Nexus TC"
    )

@app.route("/hr_ceo/talent_club_leader/demote/<int:user_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_demote_tc_leader(user_id):
    user_to_demote = db.get_or_404(User, user_id, description="User not found.")

    if not user_to_demote.is_tc_leader:
        flash(f"{user_to_demote.full_name or user_to_demote.username} is not currently the Talent Club Leader.", "warning")
    elif user_to_demote.id == current_user.id and user_to_demote.is_tc_leader: # HR/Admin trying to demote self if they were also leader
        flash("You cannot demote yourself from the TC Leader role via this action. Assign another leader or contact support.", "danger")
    else:
        try:
            user_to_demote.is_tc_leader = False
            db.session.commit()
            flash(f"{user_to_demote.full_name or user_to_demote.username} has been successfully demoted from System Talent Club Leader.", "success")
            app.logger.info(f"User {current_user.username} demoted user {user_id} from system TC Leader.")

            # Notify the demoted user
            if user_to_demote.is_active:
                notify_tc_member( # Your helper function
                    receiver_user=user_to_demote,
                    sender_user=current_user,
                    content=f"You have been demoted from the role of System Talent Club Leader by administration.",
                    notification_type='tc_leader_demoted_by_admin', # New specific type
                    related_object_id=user_to_demote.id, # Link to the user demoted
                    link_url=url_for('view_current_tc_leader', _external=True) # Link to general TC Leader info page
                )
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error demoting TC Leader {user_id} by {current_user.username}: {e}", exc_info=True)
            flash("An error occurred while demoting the leader. Please try again.", "danger")
            
    return redirect(request.referrer or url_for("manage_system_tc_leader"))

@app.route("/hr_ceo/talent_club_leader/initiate_election", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_initiate_tc_leader_election():
    if get_active_tc_leader_election(): # Check if one is already active
        flash("An election for Talent Club Leader is already in progress.", "warning")
        return redirect(url_for("manage_system_tc_leader"))

    if not get_tc_leader_candidates(): # Check if there are any eligible TC members
        flash("Cannot start an election: No eligible Talent Club members found to be candidates/voters.", "danger")
        return redirect(url_for("manage_system_tc_leader"))
        
    try:
        new_election = TalentClubLeaderElection(
            initiated_by_id=current_user.id,
            initiated_at=datetime.now(timezone.utc),
            status='active'
        )
        db.session.add(new_election)
        db.session.commit()
        flash("New Talent Club Leader election initiated successfully! Members can now vote.", "success")
        app.logger.info(f"User {current_user.username} initiated TC Leader Election ID {new_election.id}.")

        # Notify all active TC members (who are the voters/candidates)
        tc_members_to_notify = get_tc_leader_candidates() # Gets all active TC members
        notification_content = "A new election for System Talent Club Leader has started! Cast your vote now."
        link_url_vote = url_for('view_current_tc_leader', _external=True) # Link to voting page

        for member in tc_members_to_notify:
            if member.id != current_user.id: # Don't notify the initiator (HR/Admin)
                notify_tc_member(
                    member, current_user, notification_content,
                    'tc_election_started', new_election.id, link_url_vote
                )
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error initiating TC Leader election by {current_user.username}: {e}", exc_info=True)
        flash("An error occurred while initiating the election.", "danger")
        
    return redirect(url_for("manage_system_tc_leader"))


@app.route("/hr_ceo/talent_club_leader/conclude_election/<int:election_id>", methods=["POST"])
@login_required
@role_required("hr_ceo", "system_admin")
def hr_ceo_conclude_tc_leader_election(election_id):
    """Allows HR/CEO to conclude a Talent Club Leader election and declare a winner."""
    election = db.get_or_404(TalentClubLeaderElection, election_id)

    # Check if the election is active and can be concluded
    if election.status != 'active':
        flash("This election is not currently active.", "warning")
        return redirect(request.referrer or url_for("manage_system_tc_leader"))

    try:
        # Count votes per candidate
        vote_counts_query = db.session.query(
            TalentClubLeaderVote.candidate_id,
            func.count(TalentClubLeaderVote.id)
        ).filter(TalentClubLeaderVote.election_id == election.id).group_by(TalentClubLeaderVote.candidate_id).all()

        vote_counts = dict(vote_counts_query)

        elected_leader = None
        if vote_counts:
            # Find candidate(s) with the maximum votes
            max_votes = max(vote_counts.values())
            winners = [candidate_id for candidate_id, count in vote_counts.items() if count == max_votes]

            if len(winners) == 1:
                # Clear any existing TC Leader
                current_leader = db.session.scalar(select(User).where(User.is_tc_leader == True))
                if current_leader and current_leader.id != winners[0]:
                     current_leader.is_tc_leader = False
                     app.logger.info(f"Existing TC Leader {current_leader.id} demoted due to election conclusion.")

                # Set the winner as the new TC Leader
                winner_user = db.session.get(User, winners[0])
                if winner_user: # Ensure winner user exists and is active
                     if winner_user.is_active:
                          winner_user.is_tc_leader = True
                          elected_leader = winner_user
                          flash(f"Election concluded. {winner_user.full_name or winner_user.username} is the new Talent Club Leader!", "success")
                          app.logger.info(f"User {winner_user.id} elected as new TC Leader (Election {election.id}).")
                     else:
                          flash(f"Election concluded with winner ID {winners[0]}, but user is inactive. No leader assigned.", "warning")
                          app.logger.warning(f"Election {election.id} winner {winners[0]} is inactive. No leader assigned.")
                else:
                     flash(f"Election concluded with winner ID {winners[0]}, but user not found. No leader assigned.", "warning")
                     app.logger.warning(f"Election {election.id} winner {winners[0]} not found. No leader assigned.")


            else:
                # Handle tie (e.g., no leader assigned, manual HR decision needed)
                flash("Election resulted in a tie. No leader assigned via election.", "warning")
                app.logger.info(f"Election {election.id} resulted in a tie among users: {winners}. No leader assigned.")

        else:
            # No votes were cast
            flash("No votes were cast in the election. No leader assigned.", "info")
            app.logger.info(f"Election {election.id} had no votes cast.")

        # Conclude the election status and record winner (if any)
        election.status = 'concluded'
        election.concluded_at = datetime.now(timezone.utc)
        election.elected_leader = elected_leader # Link the winner user

        db.session.commit()

        # --- Notification ---
        # Notify all active TC members about election results
        eligible_candidates = get_tc_leader_candidates() # Get all TC members who *could* have voted
        notification_content = f"Talent Club Leader election concluded. Winner: {elected_leader.full_name or elected_leader.username if elected_leader else 'None'}. Check results."
        link_url = url_for('manage_system_tc_leader') # Link to the management page to see results

        notifications_to_add = []
        for member in eligible_candidates:
             if member.is_active and member.id != current_user.id:
                  try:
                       notify = Notification(
                           sender_id=current_user.id,
                           receiver_id=member.id,
                           content=notification_content,
                           link_url=link_url,
                           timestamp=datetime.now(timezone.utc),
                           is_read=False,
                           notification_type='tc_vote_result', # Specific type
                           related_object_id=election.id
                       )
                       notifications_to_add.append(notify)
                  except Exception as notify_e:
                       app.logger.error(f"Error creating TC vote result notification for user {member.id}: {notify_e}")

        if notifications_to_add:
           db.session.add_all(notifications_to_add)
           db.session.commit() # Commit notifications


    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error HR/CEO {current_user.id} concluding TC Leader election {election_id}: {e}", exc_info=True)
        flash("An error occurred while concluding the election. Please try again.", "danger")

    # Redirect back to management page
    return redirect(request.referrer or url_for("manage_system_tc_leader"))


# --- PART X END: Talent Club Features ---


# --- PART 15 START: CLI Commands, Error Handlers, and Main Execution ---

# NOTE: This part assumes the following exist from previous parts:
# - Flask app, db, Role, AssetCategory, User models are defined.
# - password hashing functions (generate_password_hash) are available.
# - Werkzeug imports (NotFound) are available.
# - Other Python imports (click, sys, os, datetime, timezone).

import click # Import click for CLI commands
import sys # Import sys for exiting

# --- CLI Commands ---
# Use @app.cli.command() to register functions as CLI commands

# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# START MODIFICATION (create_initial CLI Command)
@app.cli.command("create-initial")
def create_initial_roles_and_categories():
    """Creates initial Role, AssetCategory, SocialCategory, and core Lab entries if they don't exist.""" # MODIFIED: Updated docstring
    with app.app_context():
        print("Creating initial roles...")
        initial_roles = ["system_admin", "hr_ceo", "school_executive", "government", "teacher", "librarian", "talent_club", "student", "parent"]
        created_roles = []
        try:
            for role_name in initial_roles:
                role = db.session.scalar(select(Role).filter_by(name=role_name))
                if not role:
                    new_role = Role(name=role_name)
                    db.session.add(new_role)
                    created_roles.append(role_name)
            db.session.commit()
            if created_roles:
                print(f"Created roles: {', '.join(created_roles)}")
            else:
                print("All initial roles already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating roles: {e}", file=sys.stderr)
            sys.exit(1)

        print("\nCreating initial asset categories...")
        # MODIFIED: Removed social media categories from this list
        initial_asset_categories = [
            "General Equipment", "IT Hardware", "Furniture", "Teaching Supplies",
            "Lab Equipment", "Library Equipment", "Books", "Talent Club Gear",
            "Office Supplies", "Sports Equipment", "Student Activities Gear",
            "Classroom Assets"
        ]
        created_asset_categories = []
        try:
            for cat_name in initial_asset_categories:
                category = db.session.scalar(select(AssetCategory).filter_by(name=cat_name))
                if not category:
                    new_category = AssetCategory(name=cat_name)
                    db.session.add(new_category)
                    created_asset_categories.append(cat_name)
            db.session.commit()
            if created_asset_categories:
                print(f"Created asset categories: {', '.join(created_asset_categories)}")
            else:
                print("All initial asset categories already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating asset categories: {e}", file=sys.stderr)
            sys.exit(1)


        # START ADDITION (SocialCategory creation)
        print("\nCreating initial social media categories...")
        initial_social_categories = [
            "Entertainment",
            "Fun",
            "Sport",
            "Education",
            "Technology",
            "Personal",
            "Social",
            "Lifestyle",
            "Innovation",
            "Relationships"
        ]
        created_social_categories = []
        try:
            for social_cat_name in initial_social_categories:
                social_category = db.session.scalar(select(SocialCategory).filter_by(name=social_cat_name))
                if not social_category:
                    new_social_category = SocialCategory(name=social_cat_name)
                    db.session.add(new_social_category)
                    created_social_categories.append(social_cat_name)
            db.session.commit()
            if created_social_categories:
                print(f"Created social categories: {', '.join(created_social_categories)}")
            else:
                print("All initial social categories already exist.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating social categories: {e}", file=sys.stderr)
            sys.exit(1)
        # END ADDITION (SocialCategory creation)


        print("\nCreating core Lab entries...")
        # ... (core Lab entries) ...
# END MODIFICATION (create_initial CLI Command)
        # START ADDITION (Talent Club Community Group creation)
        print(f"\nCreating '{TC_COMMUNITY_GROUP_NAME}' group...")
        try:
            community_group = db.session.scalar(select(TalentClubCommunity).filter_by(name=TC_COMMUNITY_GROUP_NAME))
            if not community_group:
                new_community_group = TalentClubCommunity(name=TC_COMMUNITY_GROUP_NAME, description="Official community group for all Talent Club members.")
                db.session.add(new_community_group)
                db.session.commit()
                print(f"Created '{TC_COMMUNITY_GROUP_NAME}'.")
            else:
                print(f"'{TC_COMMUNITY_GROUP_NAME}' already exists.")

        except Exception as e:
            db.session.rollback()
            print(f"Error creating Talent Club Community group: {e}", file=sys.stderr)
            sys.exit(1)
        # END ADDITION (Talent Club Community Group creation)
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
# In PART 15 START: CLI Commands, Error Handlers, and Main Execution
@app.cli.command("seed-db")
@click.argument("count", default=10)
def seed_db_command(count):
    """Seeds the database with dummy data, including specific lab/category assignments and Talent Club data.""" # Updated docstring
    with app.app_context():
        print(f"Seeding database with {count} dummy users (students, teachers, talent club) and assets...")
        try:
            # Fetch necessary roles
            student_role = db.session.scalar(select(Role).filter_by(name="student"))
            teacher_role = db.session.scalar(select(Role).filter_by(name="teacher"))
            hr_ceo_role = db.session.scalar(select(Role).filter_by(name="hr_ceo"))
            system_admin_role = db.session.scalar(select(Role).filter_by(name="system_admin"))
            talent_club_role = db.session.scalar(select(Role).filter_by(name="talent_club"))
            librarian_role = db.session.scalar(select(Role).filter_by(name="librarian"))

            if not all([student_role, teacher_role, hr_ceo_role, system_admin_role, talent_club_role, librarian_role]):
                print("Error: Required roles not found. Run 'flask create-initial' first.", file=sys.stderr)
                sys.exit(1)

            # Fetch necessary categories
            classroom_category = db.session.scalar(select(AssetCategory).filter_by(name="Classroom Assets"))
            lab_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="Lab Equipment"))
            books_category = db.session.scalar(select(AssetCategory).filter_by(name="Books"))
            tc_gear_category = db.session.scalar(select(AssetCategory).filter_by(name="Talent Club Gear"))
            general_equipment_category = db.session.scalar(select(AssetCategory).filter_by(name="General Equipment"))

            if not all([classroom_category, lab_equipment_category, books_category, tc_gear_category, general_equipment_category]):
                print("Error: Required asset categories not found. Run 'flask create-initial' first.", file=sys.stderr)
                sys.exit(1)

            # Fetch core Labs (or create if missing - create-initial should make these)
            main_library_lab = db.session.scalar(select(Lab).filter_by(name="Main Library"))
            talent_club_hq_lab = db.session.scalar(select(Lab).filter_by(name="Talent Club HQ"))
            # Create a generic Science Lab if it doesn't exist for teachers
            science_lab = db.session.scalar(select(Lab).filter_by(name="Science Lab A"))
            if not science_lab:
                science_lab = Lab(name="Science Lab A")
                db.session.add(science_lab)
                # No flush/commit here, will be committed with users later


            # Create a default admin user if one doesn't exist
            admin_user = db.session.scalar(select(User).filter_by(username="admin"))
            if not admin_user:
                 print("Creating default 'admin' user...")
                 admin_user = User(
                     username="admin",
                     email="admin@school.com",
                     full_name="System Administrator",
                     first_name="System",
                     last_name="Administrator",
                     role=system_admin_role,
                     is_active=True,
                     force_password_change=True,
                     created_at=datetime.now(timezone.utc)
                 )
                 admin_user.set_password("default_admin_password")
                 db.session.add(admin_user)
                 print("Default admin user 'admin' created with password 'default_admin_password'. PLEASE CHANGE THIS IMMEDIATELY after first login using the forced change password page.")


            # Create dummy users (mix of students, teachers, librarians, and talent_club members)
            grades = ["9", "10", "11", "12"]
            sections = ["A", "B", "C"]
            subjects = ["Math", "Science", "History", "English", "Physics", "Chemistry", "Biology"]
            genders = ["Male", "Female"]

            print("\nCreating dummy users and associated assets...")
            for i in range(count):
                role_choice = i % 4 # Now 4 categories: student, teacher, talent_club, librarian
                if role_choice == 0:
                    role = student_role
                elif role_choice == 1:
                    role = teacher_role
                elif role_choice == 2:
                    role = talent_club_role
                else: # role_choice == 3
                    role = librarian_role

                dummy_username = f"{role.name}_{i+1}".lower()
                dummy_email = f"{dummy_username}@example.com"
                dummy_full_name = f"{role.name.capitalize()} User {i+1}"
                dummy_first_name = f"{role.name.capitalize()}"
                dummy_last_name = f"User{i+1}"

                existing_user = db.session.scalar(
                    select(User).filter(
                        (User.username == dummy_username) | (User.email == dummy_email)
                    )
                )
                if existing_user:
                    print(f"Skipping user {dummy_username}: already exists.")
                    continue

                user = User(
                    username=dummy_username,
                    email=dummy_email,
                    full_name=dummy_full_name,
                    first_name=dummy_first_name,
                    last_name=dummy_last_name,
                    role=role,
                    is_active=True,
                    created_at=datetime.now(timezone.utc),
                    age=14 + i if role == student_role else 30 + i,
                    gender=genders[i % len(genders)],
                    phone=f"555-123-{1000 + i}",
                    address=f"Dummy Address {i+1}",
                    force_password_change=False,
                    is_tc_member=False, # Default False, set True below for some students
                    is_tc_leader=False # Default False, set True below for some talent_club role users
                )
                user.set_password("password")

                # --- Role-Specific Attribute Assignment and Asset Creation within the loop ---
                if role == student_role:
                    user.grade = grades[i % len(grades)]
                    user.section = sections[i % len(sections)]
                    # Dynamically create/get classroom lab for students
                    classroom_name = f"Grade {user.grade} Section {user.section} Classroom"
                    classroom_lab = db.session.scalar(select(Lab).filter_by(name=classroom_name))
                    if not classroom_lab:
                        classroom_lab = Lab(name=classroom_name)
                        db.session.add(classroom_lab)
                        db.session.flush() # Flush to get ID for newly created lab
                    # Assign student to their classroom lab (conceptual)
                    user.lab_id = classroom_lab.id

                    # Make some students leaders
                    if i % 3 == 0:
                        user.is_leader = True
                        print(f"  - User {user.username} is a Student Leader.")
                        # Add an asset for this student leader in their classroom
                        classroom_asset = Asset(
                            name=f"Classroom Projector {i}",
                            description="Projector for class use.",
                            quantity=1,
                            condition="Good",
                            added_by_user=user, # Link to the user being created
                            category=classroom_category,
                            lab=classroom_lab,
                            status="Available"
                        )
                        db.session.add(classroom_asset)
                    # Make some students TC members
                    if i % 2 == 0: # Example: Make every other student a TC member
                        user.is_tc_member = True
                        print(f"  - User {user.username} is a Talent Club Member.")
                        # Adding to community group is handled *after* the loop


                elif role == teacher_role:
                    # Assign teachers to a lab (e.g., Science Lab A)
                    # Ensure science_lab exists before assigning its ID
                    if science_lab:
                        user.lab_id = science_lab.id

                    dummy_subject = subjects[i % len(subjects)]
                    dummy_grade = grades[i % len(grades)]
                    dummy_section = sections[i % len(sections)]
                    teacher_profile = TeacherProfile(
                         user=user, # Link to the user being created
                         subject=dummy_subject,
                         grade=dummy_grade,
                         section=dummy_section,
                         salary=50000.0 + i * 1000.0
                    )
                    db.session.add(teacher_profile)

                    # Add an asset for this teacher in their lab
                    if science_lab and lab_equipment_category: # Ensure prerequisites exist
                         lab_asset = Asset(
                             name=f"Microscope {i}",
                             description="For science experiments.",
                             quantity=2,
                             condition="Good",
                             added_by_user=user, # Link to the user being created
                             category=lab_equipment_category,
                             lab=science_lab,
                             status="Available"
                         )
                         db.session.add(lab_asset)


                elif role == talent_club_role:
                    # Ensure Talent Club HQ Lab exists before assigning
                    if talent_club_hq_lab:
                         user.lab_id = talent_club_hq_lab.id

                    if i % 2 == 0:
                        user.is_tc_leader = True
                        print(f"  - User {user.username} is a Talent Club Leader.")
                        # Add an asset for this talent club leader in Talent Club HQ
                        if talent_club_hq_lab and tc_gear_category: # Ensure prerequisites exist
                             tc_asset = Asset(
                                 name=f"Stage Light {i}",
                                 description="Lighting equipment for club performances.",
                                 quantity=1,
                                 condition="Fair",
                                 added_by_user=user, # Link to the user being created
                                 category=tc_gear_category,
                                 lab=talent_club_hq_lab,
                                 status="Available"
                             )
                             db.session.add(tc_asset)


                elif role == librarian_role:
                    # Ensure Main Library Lab exists before assigning
                    if main_library_lab:
                         user.lab_id = main_library_lab.id
                    # Add a book asset for the librarian
                    if main_library_lab and books_category: # Ensure prerequisites exist
                         book_asset = Asset(
                             name=f"Math Textbook Vol {i}",
                             description="Calculus textbook.",
                             quantity=10,
                             condition="New",
                             added_by_user=user, # Link to the user being created
                             category=books_category, # Corrected typo here as well
                             lab=main_library_lab,
                             status="Available"
                         )
                         db.session.add(book_asset)

                # Add the user to the session after all specific attributes/relations are set for their role
                db.session.add(user)

            # --- Code AFTER the main user loop finishes ---

            db.session.commit() # Commit all users and assets created *within* the loop

            # Ensure TC Community group exists (should be done by create-initial, but double-check)
            community_group = get_tc_community_group()
            if not community_group:
                 print(f"Error: '{TC_COMMUNITY_GROUP_NAME}' group not found. Run 'flask create-initial' first.", file=sys.stderr)
                 sys.exit(1)


            # Add all is_tc_member students to the TC Community group
            print("\nAdding TC Members to Community Group...")
            tc_members = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True)).all()
            for member in tc_members:
                 # Use the helper which checks if they are already a member
                 add_to_tc_community_group(member)
                 # The helper commits internally, so no separate commit needed here for this loop

            # Create some dummy Talent Clubs, Feeds, Memberships, and Follows
            print("\nCreating dummy Talent Clubs...")
            tc_categories = db.session.scalars(select(SocialCategory).order_by(SocialCategory.name)).all()
            if not tc_categories:
                 print("Error: No Social Categories found. Cannot create dummy Talent Clubs.", file=sys.stderr)
            else:
                 # Select some TC members to be club owners (ensure they are active and TC members)
                 tc_owners = db.session.scalars(select(User).where(User.is_tc_member == True, User.is_active == True).order_by(User.id).limit(3)).all() # Get 3 owners, consistent order
                 if not tc_owners:
                      print("Warning: No TC members found to be club owners. Skipping dummy club creation.")
                 else:
                      for i, owner in enumerate(tc_owners):
                          club_name = f"{owner.full_name}'s Awesome Club {i+1}"
                          # Check if club name already exists
                          existing_club = db.session.scalar(select(TalentClub).filter_by(name=club_name))
                          if existing_club:
                               print(f"Skipping club '{club_name}': already exists.")
                               continue

                          try:
                              category = tc_categories[i % len(tc_categories)]
                              new_club = TalentClub(
                                   name=club_name,
                                   description=f"A dummy club created by {owner.full_name or owner.username}.",
                                   owner=owner,
                                   social_category=category,
                                   level=(i % 5) + 1, # Levels 1-5
                                   warning_count=i % 3, # Warnings 0-2
                                   is_active=True,
                                   created_at=datetime.now(timezone.utc) - timedelta(days=i*10) # Backdate creation
                              )
                              db.session.add(new_club)
                              db.session.flush() # Flush to get club ID

                              # Create the linked feed
                              club_feed = TalentClubFeed(talent_club=new_club)
                              db.session.add(club_feed)

                              # Add owner as a member ('creator' role)
                              owner_membership = TalentClubMembership(club=new_club, user=owner, role='creator')
                              db.session.add(owner_membership)

                              # Add a few other random TC members as 'member' (ensure they are active TC members)
                              other_members = db.session.scalars(
                                   select(User)
                                   .where(User.is_tc_member == True, User.id != owner.id, User.is_active == True)
                                   .order_by(db.func.random()) # Random members
                                   .limit(5)
                              ).all()
                              for other_member in other_members:
                                   try:
                                        # Check if they are already a member of this specific club instance (unlikely but safe)
                                        is_already_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=new_club, user=other_member).exists())
                                        if not is_already_member:
                                            member_membership = TalentClubMembership(club=new_club, user=other_member, role='member')
                                            db.session.add(member_membership)
                                            # Add some dummy posts to the feed from a few members
                                            if len(new_club.feed.posts.all()) < 5: # Add a few posts per club
                                                 post_content = f"Hello from {other_member.full_name or other_member.username} in {new_club.name}!"
                                                 feed_post = TalentClubFeedPost(feed=club_feed, author=other_member, content=post_content)
                                                 db.session.add(feed_post)
                                   except IntegrityError:
                                        db.session.rollback() # Rollback only this specific membership/post add
                                        print(f"    - User {other_member.username} already member of club {new_club.name} (IntegrityError).", file=sys.stderr)
                                   except Exception as e:
                                        db.session.rollback() # Rollback only this specific membership/post add
                                        print(f"    - Error adding member {other_member.username} or post to club {new_club.name}: {e}", file=sys.stderr)


                              # Add some dummy followers (can be any active user)
                              followers = db.session.scalars(select(User).where(User.is_active == True).order_by(db.func.random()).limit(10)).all() # Any active user can follow
                              for follower in followers:
                                  # Avoid adding user if they are already a member of this specific club instance
                                  is_member = db.session.scalar(select(TalentClubMembership).filter_by(talent_club=new_club, user=follower).exists())
                                  # Avoid adding user if they already follow this specific club instance
                                  is_already_following = db.session.scalar(select(TalentClubFollow).filter_by(club=new_club, user=follower).exists())
                                  if not is_member and not is_already_following:
                                      try:
                                          follow_entry = TalentClubFollow(club=new_club, user=follower)
                                          db.session.add(follow_entry)
                                      except IntegrityError:
                                          db.session.rollback() # Rollback only this specific follow add
                                          print(f"    - User {follower.username} already follows club {new_club.name} (IntegrityError).", file=sys.stderr)
                                      except Exception as e:
                                          db.session.rollback() # Rollback only this specific follow add
                                          print(f"    - Error adding follower {follower.username} to club {new_club.name}: {e}", file=sys.stderr)


                              db.session.commit() # Commit the new club, feed, memberships, posts, and follows
                              print(f"Created club '{new_club.name}' (ID: {new_club.id}) with {new_club.memberships.filter_by(is_active=True).count()} members and {new_club.follows.count()} followers.")


                          except IntegrityError:
                               db.session.rollback()
                               print(f"Skipping club '{club_name}': name already exists.", file=sys.stderr)
                          except Exception as e:
                              db.session.rollback()
                              print(f"Error creating club '{club_name}': {e}", file=sys.stderr)

            # Add a few general assets by admin for testing HR/CEO view (if admin_user was created/exists)
            if admin_user and general_equipment_category: # Ensure prerequisites exist
                 print("\nCreating dummy admin assets...")
                 for i in range(3):
                     admin_asset = Asset(
                         name=f"Admin PC {i + 1}",
                         description="Office computer for staff.",
                         quantity=1,
                         condition="Good",
                         added_by_user=admin_user,
                         category=general_equipment_category,
                         lab=None, # No specific lab initially
                         status="Pending Review"
                     )
                     db.session.add(admin_asset)
                 db.session.commit() # Commit admin assets


            print("\nDatabase seeding process complete.")
            sys.exit(0) # Exit successfully

        except Exception as e:
            db.session.rollback() # Rollback everything in case of a general error
            print(f"General error during seeding: {e}", file=sys.stderr)
            sys.exit(1) # Exit with error code


# --- Error Handlers ---
# Define custom error pages for common HTTP errors

@app.errorhandler(403) # Forbidden
def forbidden_error(error):
    """Render custom 403 Forbidden page."""
    # Log the 403 error, including the user and path
    user_info = f"User {current_user.username} (ID: {current_user.id})" if current_user.is_authenticated else "Unauthenticated user"
    app.logger.warning(f"403 Forbidden: {user_info} attempted access to {request.path} from IP {request.remote_addr}")
    # Render a template specific to 403 errors
    return render_template("errors/403.html", title="Forbidden", error=error), 403

@app.errorhandler(404) # Not Found
def not_found_error(error):
    """Render custom 404 Not Found page."""
    # Log the 404 error, including the requested path and source IP
    app.logger.info(f"404 Not Found: Path {request.path} from IP {request.remote_addr}")
    # Render a template specific to 404 errors
    return render_template("errors/404.html", title="Page Not Found", error=error), 404

@app.errorhandler(500) # Internal Server Error
def internal_error(error):
    """Render custom 500 Internal Server Error page."""
    # Log the 500 error with traceback for debugging
    user_info = f"User {current_user.username} (ID: {current_user.id})" if current_user.is_authenticated else "Unauthenticated user"
    app.logger.error(f"500 Internal Server Error: {user_info} on path {request.path} from IP {request.remote_addr}", exc_info=True) # Log traceback

    # Ensure the database session is properly rolled back in case of an error
    # Flask-SQLAlchemy usually handles this, but explicit rollback in 500 handler is safer.
    db.session.rollback()
    # Render a template specific to 500 errors
    return render_template("errors/500.html", title="Server Error", error=error), 500

# Route to serve static favicon.ico if it exists in the static folder
# Browsers automatically request this, defining a route avoids 404 errors in logs.
@app.route('/favicon.ico')
def favicon():
    try:
        return send_from_directory(os.path.join(app.root_path, 'static'),
                                   'favicon.ico',
                                   mimetype='image/vnd.microsoft.icon')
    except NotFound:
         app.logger.debug("favicon.ico not found in static directory.")
         abort(404)
# --- Main Execution Block ---
# This block runs when the script is executed directly.
# It typically starts the Flask development server or the SocketIO server.

if __name__ == '__main__':
    # If you are using Flask-SocketIO, you should run the app using socketio.run()
    # in the main execution block, not app.run().
    # Ensure host and port are configured as needed.
    print("Starting SocketIO server...")
    socketio.run(app, host='127.0.0.1', port=5000, debug=app.debug)
    # For production, use a production WSGI server like Gunicorn with gevent/eventlet workers for SocketIO.

    # Example production start: gunicorn --worker-class eventlet -w 1 app:app

# --- PART 15 END ----e 

===== static/favicon.ico =====
-e 

===== static/css/style.scss =====
@use "sass:color"; // Import the sass:color module
@use "sass:list";  // Import the sass:list module

// Nexus School Management System - style.scss

// --- SCSS Helper Variables for Color Calculations ---
// These store the literal color values from your theme to be used by sass:color functions

// Light Theme Base Values
$nexus-primary-light-value: #0D47A1;
$nexus-primary-rgb-light-tuple: (13, 71, 161);
$nexus-border-color-light-value: #e0e5ec;
// (Add other base color literal values here if they are directly manipulated by sass:color for light theme)

// Dark Theme Base Values
$nexus-primary-dark-value: #4dabf7;
$nexus-primary-rgb-dark-tuple: (77, 171, 247);
$nexus-border-color-dark-value: #495057;
// (Add other base color literal values here if they are directly manipulated by sass:color for dark theme)
// --- End SCSS Helper Variables ---


// 0. Configuration & Utilities
// ---------------------------------------------------------
// Google Fonts are imported in base.html

// 1. Theme Variables (CSS Custom Properties)
// ---------------------------------------------------------
:root {
    // Core Palette
    --nexus-primary: #{$nexus-primary-light-value};
    --nexus-primary-rgb: #{list.nth($nexus-primary-rgb-light-tuple, 1)}, #{list.nth($nexus-primary-rgb-light-tuple, 2)}, #{list.nth($nexus-primary-rgb-light-tuple, 3)};
    --nexus-secondary: #1976D2;       // Medium Blue
    --nexus-secondary-rgb: 25, 118, 210;
    --nexus-success: #198754;
    --nexus-success-rgb: 25, 135, 84;
    --nexus-info: #00796B;            // Teal
    --nexus-info-rgb: 0, 121, 107;
    --nexus-warning: #ffc107;
    --nexus-warning-rgb: 255, 193, 7;
    --nexus-danger: #dc3545;
    --nexus-danger-rgb: 220, 53, 69;
    --nexus-light: #f8f9fa;
    --nexus-dark: #212529;
    --nexus-body-bg: #f4f7fc;         // Light, slightly bluish-gray
    --nexus-content-bg: #ffffff;
    --nexus-text-primary: #212529;
    --nexus-text-secondary: #5a6268; // Slightly darker for better readability
    --nexus-border-color: #{$nexus-border-color-light-value}; // Softer border
    --nexus-accent: var(--nexus-warning);

    // Derived Colors (Calculated by Sass for Light Theme)
    --nexus-primary-text-hover: #{color.adjust($nexus-primary-light-value, $lightness: -10%)};
    --nexus-primary-bg-darken-7: #{color.adjust($nexus-primary-light-value, $lightness: -7%)};
    --nexus-primary-border-darken-9: #{color.adjust($nexus-primary-light-value, $lightness: -9%)};
    --nexus-border-color-darken-7: #{color.adjust($nexus-border-color-light-value, $lightness: -7%)};

    // For dashboard-stat-card .card-footer:hover background
    // Original light theme: var(--nexus-sidebar-link-hover-bg) is rgba(var(--nexus-primary-rgb), 0.05)
    // darken(rgba(13, 71, 161, 0.05), 3%) -> rgb part gets darker, alpha stays
    --dashboard-stat-card-footer-hover-bg: #{rgba(color.adjust(rgb(list.nth($nexus-primary-rgb-light-tuple,1),list.nth($nexus-primary-rgb-light-tuple,2),list.nth($nexus-primary-rgb-light-tuple,3)), $lightness: -3%), 0.05)};

    // Typography
    --nexus-font-sans-serif: 'Open Sans', sans-serif;
    --nexus-font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --nexus-font-heading: 'Poppins', sans-serif;

    // Sizes & Spacing
    --nexus-border-radius: 0.375rem; // Bootstrap's default
    --nexus-border-radius-lg: 0.5rem;
    --nexus-font-size-base: 1rem;    // 16px
    --nexus-line-height-base: 1.65;  // Increased for readability

    // Sidebar
    --nexus-sidebar-width: 260px;
    --nexus-sidebar-bg: var(--nexus-content-bg);
    --nexus-sidebar-border-color: var(--nexus-border-color);
    --nexus-sidebar-link-color: #343a40;
    --nexus-sidebar-link-hover-bg: rgba(var(--nexus-primary-rgb), 0.05);
    --nexus-sidebar-link-hover-color: var(--nexus-primary);
    --nexus-sidebar-link-active-bg: var(--nexus-primary);
    --nexus-sidebar-link-active-color: #ffffff;
    --nexus-sidebar-icon-color: #6c757d;
    --nexus-sidebar-active-icon-color: #ffffff;
    --nexus-sidebar-heading-color: var(--nexus-text-secondary);

    // Shadows for depth
    --nexus-shadow-sm: 0 .125rem .25rem rgba(0,0,0, .075);
    --nexus-shadow: 0 .5rem 1rem rgba(0,0,0, .15);
    --nexus-shadow-lg: 0 1rem 3rem rgba(0,0,0, .175);

    // Transitions
    --nexus-transition-base: all .2s ease-in-out;
}

// Dark Theme Variables
[data-bs-theme="dark"] {
    --nexus-primary: #{$nexus-primary-dark-value};
    --nexus-primary-rgb: #{list.nth($nexus-primary-rgb-dark-tuple, 1)}, #{list.nth($nexus-primary-rgb-dark-tuple, 2)}, #{list.nth($nexus-primary-rgb-dark-tuple, 3)};
    --nexus-secondary: #74c0fc;
    --nexus-secondary-rgb: 116, 192, 252;
    --nexus-success: #40c057;
    --nexus-info: #3bc9db;
    --nexus-warning: #fcc419;
    --nexus-danger: #fa5252;
    --nexus-light: #343a40;
    --nexus-dark: #e9ecef;
    --nexus-body-bg: #1a1d20; // Darker body
    --nexus-content-bg: #212529; // Standard Bootstrap dark
    --nexus-text-primary: #f1f3f5;
    --nexus-text-secondary: #adb5bd;
    --nexus-border-color: #{$nexus-border-color-dark-value};

    // Derived Colors (Calculated by Sass for Dark Theme)
    --nexus-primary-text-hover: #{color.adjust($nexus-primary-dark-value, $lightness: 10%)}; // Was lighten
    --nexus-primary-bg-darken-7: #{color.adjust($nexus-primary-dark-value, $lightness: -7%)}; // Still darken for button consistency
    --nexus-primary-border-darken-9: #{color.adjust($nexus-primary-dark-value, $lightness: -9%)}; // Still darken
    --nexus-border-color-darken-7: #{color.adjust($nexus-border-color-dark-value, $lightness: -7%)}; // Still darken

    // For dashboard-stat-card .card-footer:hover background
    // Original dark theme: var(--nexus-sidebar-link-hover-bg) is rgba(var(--nexus-primary-rgb), 0.15)
    // darken(rgba(77, 171, 247, 0.15), 3%)
    --dashboard-stat-card-footer-hover-bg: #{rgba(color.adjust(rgb(list.nth($nexus-primary-rgb-dark-tuple,1),list.nth($nexus-primary-rgb-dark-tuple,2),list.nth($nexus-primary-rgb-dark-tuple,3)), $lightness: -3%), 0.15)};

    --nexus-sidebar-bg: var(--nexus-content-bg);
    --nexus-sidebar-border-color: #373b3e;
    --nexus-sidebar-link-color: var(--nexus-text-secondary);
    --nexus-sidebar-link-hover-bg: rgba(var(--nexus-primary-rgb), 0.15);
    --nexus-sidebar-link-hover-color: var(--nexus-primary);
    --nexus-sidebar-link-active-bg: var(--nexus-primary);
    --nexus-sidebar-link-active-color: var(--nexus-dark); // Text on active link
    --nexus-sidebar-icon-color: var(--nexus-text-secondary);
    --nexus-sidebar-active-icon-color: var(--nexus-dark);
    --nexus-sidebar-heading-color: var(--nexus-text-secondary);

    .navbar-brand-img-light { display: none; }
    .navbar-brand-img-dark { display: inline-block !important; }

    .card, .modal-content { // Ensure cards and modals pick up dark theme bg
        background-color: var(--nexus-content-bg);
        border-color: var(--nexus-border-color);
    }
    .table {
        --bs-table-bg: var(--nexus-content-bg);
        --bs-table-border-color: var(--nexus-border-color);
        --bs-table-color: var(--nexus-text-primary);
        --bs-table-striped-bg: rgba(255,255,255,0.03);
        --bs-table-hover-bg: rgba(255,255,255,0.04);
    }
}

[data-bs-theme="light"] {
    .navbar-brand-img-light { display: inline-block !important; }
    .navbar-brand-img-dark { display: none; }
}


// 2. Base Styles & Resets
// ---------------------------------------------------------
.nexus-body {
    font-family: var(--nexus-font-sans-serif);
    color: var(--nexus-text-primary);
    background-color: var(--nexus-body-bg);
    line-height: var(--nexus-line-height-base);
    font-size: var(--nexus-font-size-base);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
    font-family: var(--nexus-font-heading);
    font-weight: 600;
    color: var(--nexus-text-primary);
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    line-height: 1.3;
}
.page-title {
    font-size: 1.875rem; // ~30px
    margin-bottom: 1.75rem;
    font-weight: 500;
    color: var(--nexus-text-primary);
}

a {
    color: var(--nexus-primary);
    text-decoration: none;
    transition: var(--nexus-transition-base);
    &:hover {
        color: var(--nexus-primary-text-hover); // Use derived CSS variable
    }
}

.main-container { padding-top: 0; }

// 3. Layout Components
// ---------------------------------------------------------
.nexus-navbar {
    background-color: var(--nexus-content-bg) !important;
    border-bottom: 1px solid var(--nexus-border-color);
    box-shadow: var(--nexus-shadow-sm);
    .navbar-brand {
        font-family: var(--nexus-font-heading);
        font-weight: 700;
        font-size: 1.5rem;
        color: var(--nexus-text-primary) !important;
    }
    .nav-link {
        color: var(--nexus-text-secondary) !important;
        &:hover, &:focus {
            color: var(--nexus-text-primary) !important;
        }
        &.active {
            color: var(--nexus-primary) !important;
            font-weight: 500;
        }
    }
    .dropdown-menu {
        background-color: var(--nexus-content-bg);
        border-color: var(--nexus-border-color);
        box-shadow: var(--nexus-shadow);
        .dropdown-header {
            color: var(--nexus-text-secondary);
            font-weight: 600;
        }
        .dropdown-item {
            color: var(--nexus-text-primary);
            &:hover, &:focus {
                background-color: rgba(var(--nexus-primary-rgb), 0.1);
                color: var(--nexus-primary);
            }
            &:active {
                 background-color: var(--nexus-primary);
                 color: #fff;
            }
        }
        .dropdown-divider {
            border-top-color: var(--nexus-border-color);
        }
    }
     #themeSwitcher {
        color: var(--nexus-text-secondary);
        border-color: var(--nexus-border-color);
        &:hover {
            background-color: rgba(var(--nexus-primary-rgb), 0.1);
            color: var(--nexus-primary);
            border-color: var(--nexus-primary);
        }
    }
}
[data-bs-theme="dark"] .nexus-navbar {
    background-color: var(--nexus-content-bg) !important;
}


.nexus-sidebar {
    position: fixed; top: 0; bottom: 0; left: 0;
    z-index: 1020;
    padding: 0; padding-top: 56px;
    background-color: var(--nexus-sidebar-bg);
    border-right: 1px solid var(--nexus-sidebar-border-color);
    width: var(--nexus-sidebar-width);
    transition: var(--nexus-transition-base);
    overflow-y: auto;

    .sidebar-sticky { padding-top: 1rem; padding-bottom: 1rem; }
    .nav-link {
        font-weight: 500;
        font-size: 0.95rem;
        color: var(--nexus-sidebar-link-color);
        padding: 0.75rem 1.5rem;
        border-left: 4px solid transparent;
        transition: var(--nexus-transition-base);
        display: flex;
        align-items: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        .bi {
            margin-right: 0.875rem;
            font-size: 1.2rem;
            min-width: 24px;
            color: var(--nexus-sidebar-icon-color);
            transition: var(--nexus-transition-base);
        }

        &:hover {
            background-color: var(--nexus-sidebar-link-hover-bg);
            color: var(--nexus-sidebar-link-hover-color);
            border-left-color: var(--nexus-sidebar-link-hover-color);
            .bi { color: var(--nexus-sidebar-link-hover-color); }
        }
        &.active {
            color: var(--nexus-sidebar-link-active-color);
            background-color: var(--nexus-sidebar-link-active-bg);
            border-left-color: var(--nexus-accent);
            font-weight: 600;
            .bi { color: var(--nexus-sidebar-active-icon-color); }
        }
    }
    .sidebar-heading {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        padding: 1.25rem 1.5rem 0.6rem;
        color: var(--nexus-sidebar-heading-color);
        font-weight: 700;
    }
}

.nexus-main-content, .nexus-main-content-full {
    background-color: var(--nexus-body-bg);
    padding: 1.5rem;
    min-height: calc(100vh - 56px - 56px);
    flex-grow: 1;
    transition: margin-left .3s ease-in-out;
}
@media (min-width: 768px) {
    .nexus-main-content {
        margin-left: var(--nexus-sidebar-width);
    }
}


.footer {
    background-color: var(--nexus-content-bg);
    color: var(--nexus-text-secondary);
    border-top: 1px solid var(--nexus-border-color);
    font-size: 0.875rem;
    padding-top: 1rem;
    padding-bottom: 1rem;
    a {
        color: var(--nexus-primary);
        font-weight: 500;
        &:hover { color: var(--nexus-primary-text-hover); } // Use derived CSS variable
    }
}
[data-bs-theme="dark"] .footer {
    background-color: var(--nexus-content-bg);
    color: var(--nexus-text-secondary);
     a { color: var(--nexus-primary);
        &:hover { color: var(--nexus-primary-text-hover); } // Use derived CSS variable
     }
}


// 4. UI Elements (Enhanced)
// ---------------------------------------------------------
.btn {
    font-weight: 500;
    border-radius: var(--nexus-border-radius);
    padding: 0.6rem 1.2rem;
    transition: var(--nexus-transition-base);
    letter-spacing: 0.025em;
    &:focus {
        box-shadow: 0 0 0 0.2rem rgba(var(--nexus-primary-rgb), 0.35) !important;
    }
}
.btn-lg {
    padding: 0.75rem 1.5rem;
    font-size: 1.1rem;
}
.btn-primary {
    background-color: var(--nexus-primary);
    border-color: var(--nexus-primary);
    color: #fff;
    &:hover, &:focus, &:active {
        color: #fff;
        background-color: var(--nexus-primary-bg-darken-7); // Use derived CSS variable
        border-color: var(--nexus-primary-border-darken-9); // Use derived CSS variable
    }
}
.btn-outline-primary {
    color: var(--nexus-primary);
    border-color: var(--nexus-primary);
    &:hover, &:focus, &:active {
        color: #fff;
        background-color: var(--nexus-primary);
        border-color: var(--nexus-primary);
    }
}
.btn-subtle {
    background-color: var(--nexus-content-bg);
    border: 1px solid var(--nexus-border-color);
    color: var(--nexus-text-secondary);
    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg);
        border-color: var(--nexus-border-color-darken-7); // Use derived CSS variable
        color: var(--nexus-text-primary);
    }
}

.card {
    border: 1px solid var(--nexus-border-color);
    border-radius: var(--nexus-border-radius-lg);
    box-shadow: var(--nexus-shadow-sm);
    margin-bottom: 1.75rem;
    background-color: var(--nexus-content-bg);
    overflow: hidden;
}
.card-header {
    background-color: var(--nexus-content-bg);
    border-bottom: 1px solid var(--nexus-border-color);
    font-family: var(--nexus-font-heading);
    font-weight: 500;
    font-size: 1.1rem;
    color: var(--nexus-text-primary);
    padding: 0.85rem 1.25rem;
    .bi { margin-right: 0.6rem; color: var(--nexus-primary); font-size: 1.2em; }
}
.card-footer {
    background-color: var(--nexus-sidebar-link-hover-bg);
    border-top: 1px solid var(--nexus-border-color);
    padding: 0.75rem 1.25rem;
    a:not(.btn) {
        color: var(--nexus-text-secondary);
        &:hover { color: var(--nexus-primary); }
    }
}

.form-control, .form-select {
    border-radius: var(--nexus-border-radius);
    border-color: var(--nexus-border-color);
    padding: 0.5rem 0.85rem;
    transition: var(--nexus-transition-base);
    background-color: var(--nexus-content-bg);
    color: var(--nexus-text-primary);
    &:focus {
        border-color: var(--nexus-primary);
        box-shadow: 0 0 0 0.2rem rgba(var(--nexus-primary-rgb), 0.25);
        background-color: var(--nexus-content-bg);
    }
    &::placeholder {
        color: var(--nexus-text-secondary);
        opacity: 0.7;
    }
}
.form-label {
    font-weight: 500;
    margin-bottom: 0.35rem;
    font-size: 0.9rem;
    color: var(--nexus-text-secondary);
}
.form-control-lg {
    padding: 0.65rem 1rem;
    font-size: 1.05rem;
}

// Tables
.table {
    border-color: var(--nexus-border-color);
    th {
        font-family: var(--nexus-font-heading);
        font-weight: 500;
        color: var(--nexus-text-primary);
        background-color: var(--nexus-sidebar-link-hover-bg);
        border-bottom-width: 2px;
    }
    td, th {
        vertical-align: middle;
        padding: 0.85rem;
    }
    &.table-hover > tbody > tr:hover > * {
      --bs-table-accent-bg: rgba(var(--nexus-primary-rgb), 0.075);
    }
}

// SweetAlert2 Customizations
.nexus-swal-popup {
    border-radius: var(--nexus-border-radius-lg) !important;
    background-color: var(--nexus-content-bg) !important;
    border: 1px solid var(--nexus-border-color) !important;
    box-shadow: var(--nexus-shadow-lg) !important;
}
.nexus-swal-title {
    font-family: var(--nexus-font-heading) !important;
    color: var(--nexus-text-primary) !important;
    font-weight: 600 !important;
}
.nexus-swal-html-container {
    color: var(--nexus-text-secondary) !important;
    font-family: var(--nexus-font-sans-serif) !important;
}
.nexus-swal-button.btn-primary {
    background-color: var(--nexus-primary) !important;
    border-color: var(--nexus-primary) !important;
    &:hover, &:focus {
        background-color: var(--nexus-primary-bg-darken-7) !important; // Use derived CSS variable
        border-color: var(--nexus-primary-border-darken-9) !important; // Use derived CSS variable
    }
}


// 5. Dashboard Specific Styles
// ---------------------------------------------------------
.dashboard-stat-card {
    transition: var(--nexus-transition-base);
    &:hover {
        transform: translateY(-3px);
        box-shadow: var(--nexus-shadow);
    }
    .stat-icon {}
    .stat-content {
        .card-subtitle {
            font-weight: 600;
            letter-spacing: 0.03em;
        }
        .card-text {
            color: var(--nexus-text-primary);
        }
    }
    .card-footer {
        font-size: 0.85rem;
        transition: var(--nexus-transition-base);
        &:hover {
            background-color: var(--dashboard-stat-card-footer-hover-bg) !important; // Use derived CSS variable
            color: var(--nexus-primary) !important;
        }
    }
}

.dashboard-quick-links {
    .list-group-item {
        background-color: transparent;
        border-color: var(--nexus-border-color);
        color: var(--nexus-text-secondary);
        transition: var(--nexus-transition-base);
        padding: 0.85rem 1.25rem;
        &:hover {
            background-color: rgba(var(--nexus-primary-rgb), 0.05);
            color: var(--nexus-primary);
            border-left: 3px solid var(--nexus-primary);
            padding-left: calc(1.25rem - 3px);
        }
        .bi {
            margin-right: 0.75rem;
            color: var(--nexus-primary);
        }
    }
}

// Chart container placeholder styles
.chart-container {
    position: relative;
    height: 300px;
    width: 100%;
    background-color: var(--nexus-sidebar-link-hover-bg);
    border-radius: var(--nexus-border-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--nexus-text-secondary);
    border: 1px dashed var(--nexus-border-color);
}


// 6. Utility Classes & Helpers
// ---------------------------------------------------------
.cursor-pointer { cursor: pointer; }
.text-small { font-size: 0.875em; }
.font-heading { font-family: var(--nexus-font-heading); }
.font-body { font-family: var(--nexus-font-sans-serif); }
.icon-lg { font-size: 1.5rem; }
.icon-xl { font-size: 2rem; }
.hover-bg-light:hover {
    background-color: var(--nexus-sidebar-link-hover-bg) !important;
}


// Auth form specific styling
.auth-form-container {
    max-width: 480px;
    margin: 3rem auto;
    .card {
        border: none;
        box-shadow: var(--nexus-shadow-lg) !important;
    }
    .card-body { padding: 2rem 2.5rem; }
    .auth-form-logo { max-width: 120px; margin-bottom: 1.5rem; }
}


// Responsive adjustments
@media (max-width: 767.98px) {
    .nexus-sidebar {
        padding-top: 56px;
    }
    .nexus-main-content, .nexus-main-content-full {
        padding: 1rem;
    }
    .page-title {
        font-size: 1.5rem;
    }
    .display-4 { font-size: 2.5rem; }
    .display-6 { font-size: 1.75rem; }
}


// 5. UI Elements (Continued - specific for Assets)
// ---------------------------------------------------------

.asset-card {
    display: flex;
    flex-direction: column;
    transition: var(--nexus-transition-base);
    border-radius: var(--nexus-border-radius-lg);

    &:hover {
        transform: translateY(-4px);
        box-shadow: var(--nexus-shadow);
    }

    .asset-card-img-placeholder {
        height: 150px;
        display: flex;
        align-items: center;
        justify-content: center;
        .bi {
            opacity: 0.6;
        }
    }

    .card-title a {
        color: var(--nexus-text-primary);
        &:hover {
            color: var(--nexus-primary);
        }
    }
     .card-title a.pe-none {
        color: var(--nexus-text-primary) !important;
        cursor: default;
        &:hover {
            text-decoration: none !important;
        }
    }

    .card-body {
        padding: 1rem;
    }

    .fs-08rem {
        font-size: 0.8rem;
    }

    .card-footer {
        padding: 0.75rem 1rem;
        font-size: 0.85rem;
        .asset-actions .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
            line-height: 1;
             .bi {
                vertical-align: middle;
            }
        }
    }
}

// Asset Filter Bar
#assetFilters .form-label {
    font-size: 0.8rem;
    margin-bottom: 0.25rem;
}
#assetFilters .form-select-sm, #assetFilters .form-control-sm {
    font-size: 0.875rem;
}


// 6. Page-Specific Styling (Continued)
// ---------------------------------------------------------
// assets/all_assets.html specific
.page-item.active .page-link {
    background-color: var(--nexus-primary);
    border-color: var(--nexus-primary);
}
.page-link {
    color: var(--nexus-primary);
    &:hover {
        color: var(--nexus-primary-text-hover); // Use derived CSS variable
    }
    &:focus {
        box-shadow: none;
    }
}
[data-bs-theme="dark"] {
    .page-item.active .page-link {
        background-color: var(--nexus-primary);
        border-color: var(--nexus-primary);
    }
    .page-link {
        background-color: var(--nexus-content-bg);
        border-color: var(--nexus-border-color);
        color: var(--nexus-primary);
        &:hover {
            background-color: var(--nexus-sidebar-link-hover-bg);
            color: var(--nexus-primary-text-hover); // Use derived CSS variable
        }
    }
     .page-item.disabled .page-link {
        background-color: var(--nexus-content-bg);
        border-color: var(--nexus-border-color);
        color: var(--nexus-text-secondary);
    }
}


// 5. UI Elements (Continued - specific for Asset Reports)
// ---------------------------------------------------------

.asset-report-item {
    transition: var(--nexus-transition-base);
    border-left-width: 4px;
    border-left-color: var(--nexus-border-color);

    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg);
    }

    &.status-pending { border-left-color: var(--nexus-warning); }
    &.status-in-progress { border-left-color: var(--nexus-info); }
    &.status-resolved { border-left-color: var(--nexus-success); }
    &.status-rejected { border-left-color: var(--nexus-danger); }

    .font-heading {
        font-family: var(--nexus-font-heading);
    }
    .badge {
        font-size: 0.85rem;
    }
}

// 5. UI Elements (Continued - specific for Notifications & Chat)
// ---------------------------------------------------------

.notification-item {
    border-left-width: 4px;
    border-left-color: transparent;
    transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;

    .notification-icon {
        .badge {
            width: 40px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    }

    .notification-title {
        font-weight: 500;
        color: var(--nexus-text-primary);
    }
    .notification-timestamp {
        font-size: 0.8em;
    }
    .notification-text {
        font-size: 0.9em;
        color: var(--nexus-text-secondary);
        line-height: 1.4;
    }

    &.unread-notification, &.list-group-item-primary {
        border-left-color: var(--nexus-primary) !important;
        .notification-title {
            font-weight: 600;
        }
    }

    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg) !important;
    }
}

.notification-list-full {
    .notification-item {
        margin-bottom: 0.5rem;
        border-radius: var(--nexus-border-radius);
        &:last-child {
            margin-bottom: 0;
            border-bottom: 0 !important;
        }
    }
}

.contact-list-item-clickable {
    transition: var(--nexus-transition-base);
    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg);
        .font-heading {
            color: var(--nexus-primary);
        }
        .bi-send-plus-fill, .bi-chat-fill {
            transform: scale(1.1);
            opacity: 1;
        }
    }
     .bi-send-plus-fill, .bi-chat-fill {
        transition: var(--nexus-transition-base);
    }
}

// 5. UI Elements (Continued - specific for Chat)
// ---------------------------------------------------------

.chat-message {
    .message-bubble {
        border-radius: 1.25rem;
        word-wrap: break-word;
        max-width: 100%;
        font-size: 0.95rem;
        line-height: 1.5;

        p:last-child {
            margin-bottom: 0;
        }
    }

    &.sent {
        .message-bubble {
            background-color: var(--nexus-primary);
            color: #fff;
            border-bottom-right-radius: 0.5rem;
        }
    }
    &.received {
        .message-bubble {
            background-color: var(--nexus-content-bg);
            color: var(--nexus-text-primary);
            border: 1px solid var(--nexus-border-color);
            border-bottom-left-radius: 0.5rem;
        }
        [data-bs-theme="dark"] & .message-bubble {
             background-color: var(--nexus-light);
             color: var(--nexus-text-primary);
             border-color: var(--nexus-border-color);
        }
    }
    .message-timestamp {
        font-size: 0.75rem;
        opacity: 0.8;
    }
}

.chat-input-area {
    textarea#chatMessageInput {
        max-height: 120px;
        overflow-y: auto;
    }
    .btn-primary i.bi-send-fill {
        font-size: 1.1rem;
    }
    #typingIndicator {
        font-size: 0.8rem;
        font-style: italic;
        color: var(--nexus-text-secondary);
        min-height: 1.2em;
        transition: opacity 0.3s ease-in-out;
    }
}

.contact-list-item-clickable {
    .contact-name {
        font-weight: 500;
    }
    .contact-role, .contact-last-active, .contact-last-message-snippet {
        font-size: 0.85rem;
    }
    .contact-action-icon {
        transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
    }
}

.sticky-top {
    background-color: var(--nexus-content-bg) !important;
    [data-bs-theme="dark"] & {
        background-color: var(--nexus-content-bg) !important;
    }
}

// 5. UI Elements (Continued - specific for Social Features)
// ---------------------------------------------------------

.social-post-item {
    .card-header {
        background-color: var(--nexus-content-bg) !important;
        border-bottom: 1px solid var(--nexus-border-color) !important;
    }

    .post-content-text {
        font-size: 1rem;
        line-height: 1.6;
        color: var(--nexus-text-primary);
        white-space: pre-wrap;
    }
    .post-attachment {
        img, video {
            border: 1px solid var(--nexus-border-color);
        }
        .d-flex.align-items-center.p-2 {
            border: 1px solid var(--nexus-border-color);
            border-radius: var(--nexus-border-radius);
            background-color: var(--nexus-sidebar-link-hover-bg);
            a {
                font-weight: 500;
            }
        }
    }

    .post-actions {
        .btn.reaction-btn {
            padding: 0.25rem 0.6rem;
            font-size: 0.85rem;
            color: var(--nexus-text-secondary);
            border-color: var(--nexus-border-color);
            &:hover, &.active {
                color: var(--nexus-primary);
                border-color: var(--nexus-primary);
                background-color: rgba(var(--nexus-primary-rgb), 0.1);
            }
            &.active {
                 color: var(--nexus-primary);
                 font-weight: 600;
                 i.bi {
                     color: var(--nexus-primary) !important;
                 }
            }
            i.bi {
                vertical-align: text-bottom;
                margin-right: 0.25rem;
                font-size: 1em;
            }
            .reaction-count {
                font-size: 0.9em;
                margin-left: 0.2rem;
            }
        }
        .comment-toggle-btn {
             color: var(--nexus-text-secondary);
             border-color: var(--nexus-border-color);
             &:hover {
                color: var(--nexus-primary);
                border-color: var(--nexus-primary);
                background-color: rgba(var(--nexus-primary-rgb), 0.1);
             }
        }
    }

    .comments-section {
        background-color: var(--nexus-body-bg);
        padding-top: 0.5rem;
        .comment-form {
            textarea.comment-input {
                font-size: 0.9rem;
                border-top-right-radius: 0;
                border-bottom-right-radius: 0;
            }
            .comment-submit-btn {
                border-top-left-radius: 0;
                border-bottom-left-radius: 0;
            }
        }
    }
}

.social-comment-item {
    .comment-bubble {
        font-size: 0.9rem;
        line-height: 1.45;
    }
    .comment-actions .btn-link {
        color: var(--nexus-text-secondary);
        &:hover { color: var(--nexus-primary); }
    }
    .comment-timestamp {
        font-size: 0.75rem;
    }
     .comment-content-text {
        white-space: pre-wrap;
    }
}

.social-content-form-card {
    .card-body {
        padding: 1rem;
    }
    .post-content-textarea {
        min-height: 80px;
        font-size: 1rem;
        line-height: 1.5;
        resize: vertical;
    }
    .post-attachment-area {
        .form-control-sm {
            font-size: 0.875rem;
        }
    }
    .post-submit-btn {
        font-weight: 500;
    }
}

// 5. UI Elements (Continued - specific for Social Channels)
// ---------------------------------------------------------

.channel-card {
    transition: var(--nexus-transition-base);
    border-radius: var(--nexus-border-radius-lg);

    &:hover {
        transform: translateY(-4px);
        box-shadow: var(--nexus-shadow);
    }
    .channel-card-image-link {
        display: block;
    }
    .channel-card-img-placeholder {
        border-top-left-radius: var(--nexus-border-radius-lg);
        border-top-right-radius: var(--nexus-border-radius-lg);
        .bi {
            opacity: 0.6;
        }
    }
    img.img-fluid {
        border-top-left-radius: var(--nexus-border-radius-lg);
        border-top-right-radius: var(--nexus-border-radius-lg);
    }

    .card-body {
        padding: 1rem 1.25rem;
        .card-title a {
            color: var(--nexus-text-primary);
            &:hover { color: var(--nexus-primary); }
        }
    }

    .card-footer {
        font-size: 0.85rem;
        .channel-action-btn {
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
        }
    }
}

.nav-tabs {
    border-bottom-color: var(--nexus-border-color);
    .nav-link {
        color: var(--nexus-text-secondary);
        font-weight: 500;
        border-bottom-width: 2px;
        padding: 0.75rem 1.25rem;
        &:hover {
            border-color: var(--nexus-sidebar-link-hover-bg) var(--nexus-sidebar-link-hover-bg) var(--nexus-border-color);
            color: var(--nexus-primary);
        }
        &.active {
            color: var(--nexus-primary);
            background-color: var(--nexus-content-bg);
            border-color: var(--nexus-border-color) var(--nexus-border-color) var(--nexus-content-bg);
            font-weight: 600;
        }
    }
}
[data-bs-theme="dark"] .nav-tabs {
     .nav-link {
        color: var(--nexus-text-secondary);
        &:hover {
             border-color: var(--nexus-sidebar-link-hover-bg) var(--nexus-sidebar-link-hover-bg) var(--nexus-border-color);
             color: var(--nexus-primary);
        }
         &.active {
            color: var(--nexus-primary);
            background-color: var(--nexus-content-bg);
            border-color: var(--nexus-border-color) var(--nexus-border-color) var(--nexus-content-bg);
        }
     }
}

// 5. UI Elements (Continued - specific for Social Channels View/Create)
// ---------------------------------------------------------
.channel-header {}
.channel-sidebar {
    .card {}
}
.social-feed-container {}


// 5. UI Elements (Continued - specific for Social Groups)
// ---------------------------------------------------------

.group-card {
    transition: var(--nexus-transition-base);
    border-radius: var(--nexus-border-radius-lg);

    &:hover {
        transform: translateY(-4px);
        box-shadow: var(--nexus-shadow);
    }
    .group-card-img-placeholder {
        border-top-left-radius: var(--nexus-border-radius-lg);
        border-top-right-radius: var(--nexus-border-radius-lg);
        .bi { opacity: 0.6; }
    }
    img.img-fluid {
        border-top-left-radius: var(--nexus-border-radius-lg);
        border-top-right-radius: var(--nexus-border-radius-lg);
    }
    .card-title a {
        color: var(--nexus-text-primary);
        &:hover { color: var(--nexus-primary); }
    }
    .card-footer {
        font-size: 0.85rem;
        .group-action-btn {
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
        }
    }
}

.group-header {}
.group-chat-window {}
.group-chat-input-area {
    .social-content-form-card {
        margin-bottom: 0 !important;
        border: none;
        box-shadow: none;
    }
}

// 5. UI Elements (Continued - specific for Social Management)
// ---------------------------------------------------------
.table {
    .form-select-sm {
        min-width: 120px;
        font-size: 0.85rem;
    }
}

// 5. UI Elements (Continued - FilePond Integration)
// ---------------------------------------------------------
.filepond--root {
    font-family: var(--nexus-font-sans-serif);
    border-radius: var(--nexus-border-radius);
    margin-bottom: 0.5rem;
}
.filepond--panel-root {
    background-color: var(--nexus-sidebar-link-hover-bg);
    border: 1px dashed var(--nexus-border-color);
    [data-bs-theme="dark"] & {
        background-color: var(--nexus-light);
        border: 1px dashed var(--nexus-border-color);
    }
}
.filepond--drop-label {
    color: var(--nexus-text-secondary);
    label {
        font-size: 0.95rem;
    }
}
.filepond--label-action {
    color: var(--nexus-primary);
    font-weight: 500;
    text-decoration-color: var(--nexus-primary);
}
.filepond-errors span {
    font-size: 0.875em;
    color: var(--nexus-danger);
}

// 5. UI Elements (Continued - specific for Talent Club)
// ---------------------------------------------------------
.talent-club-card {
    transition: var(--nexus-transition-base);
    border-radius: var(--nexus-border-radius-lg);
    border-left: 4px solid transparent;

    &.status-active { border-left-color: var(--nexus-success); }
    &.status-pending-review { border-left-color: var(--nexus-warning); }

    &:hover {
        transform: translateY(-5px);
        box-shadow: var(--nexus-shadow);
        border-left-color: var(--nexus-primary);
    }
    .tc-club-card-image-link { display: block; }
    .tc-club-card-img-placeholder {
        border-top-left-radius: calc(var(--nexus-border-radius-lg) - 1px);
        border-top-right-radius: calc(var(--nexus-border-radius-lg) - 1px);
        .bi { opacity: 0.65; }
    }
    img.img-fluid {
        border-top-left-radius: calc(var(--nexus-border-radius-lg) - 1px);
        border-top-right-radius: calc(var(--nexus-border-radius-lg) - 1px);
    }

    .card-title a {
        color: var(--nexus-text-primary);
        font-weight: 600;
        &:hover { color: var(--nexus-primary); }
    }
    .badge {
        font-size: 0.75rem;
        font-weight: 500;
    }

    .card-footer {
        font-size: 0.85rem;
        .tc-action-btn {
            font-size: 0.8rem;
            padding: 0.35rem 0.7rem;
        }
    }
}

// 5. UI Elements (Continued - specific for Talent Club Feeds)
// ---------------------------------------------------------
.tc-feed-post-item {
    .card-header {}
}
.tc-feed-container {}
.tc-feed-post-item .comments-section {}
.tc-comment-form {}

// 5. UI Elements (Continued - specific for Talent Club Proposals)
// ---------------------------------------------------------
.tc-proposal-item {
    transition: var(--nexus-transition-base);
    border-left-width: 4px;
    border-left-color: var(--nexus-border-color);

    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg);
        border-left-color: var(--nexus-primary);
    }
    .font-heading {
        font-family: var(--nexus-font-heading);
    }
    .badge {
        font-size: 0.8rem;
    }
}

.feature-card-hover {
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    &:hover {
        transform: translateY(-5px);
        box-shadow: var(--nexus-shadow);
    }
    .card-body .bi {
        transition: transform 0.3s ease-out;
    }
    &:hover .card-body .bi {
        transform: scale(1.1);
    }
}


// 5. UI Elements (Continued - specific for TC Community Group)
// ---------------------------------------------------------
.tc-community-header {}
.tc-community-chat-window {}
.tc-community-input-area {
    .social-content-form-card {
        margin-bottom: 0 !important;
        border: none;
        box-shadow: none;
    }
}

// 5. UI Elements (Continued - specific for TC Leader Admin Views)
// ---------------------------------------------------------
.tc-proposal-item {
    .btn-sm {
        font-size: 0.75rem;
        padding: 0.2rem 0.4rem;
    }
}

#reviewProposalForm {
    .card-header {}
    dl.row dt {
        font-weight: 500;
        color: var(--nexus-text-secondary);
    }
    dl.row dd {
        margin-bottom: 0.75rem;
    }
    .blockquote {
        font-size: 0.95rem;
        border-left: 3px solid var(--nexus-border-color);
    }
    .list-group-item {
        img { margin-right: 0.75rem; }
    }
    @media (min-width: 992px) {
        .sticky-lg-top {
           top: calc(56px + 1.5rem);
        }
    }
}

// 5. UI Elements (Continued - specific for TC Leader Admin Tables)
// ---------------------------------------------------------
.tc-club-management-table, .tc-member-management-table {
    th, td {
        font-size: 0.9rem;
    }
    .badge {
        font-size: 0.75rem;
        font-weight: 500;
    }
    .btn-sm i.fs-6 {
        vertical-align: -0.1em;
    }
    .form-select-sm {
        min-width: 120px;
        font-size: 0.85rem;
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
    }
}

// 5. UI Elements (Continued - specific for TC Leader/Election Management)
// ---------------------------------------------------------
.list-group-item-light {
    font-size: 0.9rem;
    img {
        border: 1px solid var(--nexus-border-color);
    }
}
#tcLeaderVoteForm {
    .form-select {}
}

// 5. UI Elements (Continued - specific for Task System Views)
// ---------------------------------------------------------
.task-list-item {
    transition: var(--nexus-transition-base);
    border-left-width: 4px;
    border-left-color: var(--nexus-border-color);
    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg);
        border-left-color: var(--nexus-primary);
    }
    .task-title {
        font-weight: 500;
        color: var(--nexus-text-primary);
    }
    .task-description {
        color: var(--nexus-text-secondary);
    }
    .task-due-date, .task-creator {
        font-size: 0.85rem;
    }
    .badge {
        font-size: 0.75rem;
        font-weight: 500;
        padding: 0.3em 0.6em;
    }
}

#userTaskDetailContainer {
    .dl-row dt {
        font-weight: 500;
        color: var(--nexus-text-secondary);
    }
    .dl-row dd {
        margin-bottom: 0.85rem;
    }
    .card-header h5.font-heading {
        font-size: 1.15rem;
    }
}

.task-history-entry {
    font-size: 0.9rem;
    border-bottom: 1px solid var(--nexus-border-color);
    &:last-child {
        border-bottom: none;
    }
    .history-timestamp, .history-actor {
        font-size: 0.8rem;
        opacity: 0.8;
    }
    .history-action {
        .badge {
            font-size: 0.75rem;
            padding: .2em .5em;
            vertical-align: middle;
        }
    }
    .history-notes {
        background-color: var(--nexus-sidebar-link-hover-bg);
        padding: 0.3rem 0.5rem;
        border-radius: var(--nexus-border-radius);
        font-size: 0.85rem;
        color: var(--nexus-text-secondary);
    }
}

// 5. UI Elements (Continued - specific for Task Creator Views)
// ---------------------------------------------------------
.task-creator-view-item {
    .badge {
        font-size: 0.75rem;
        font-weight: 500;
    }
}
.user-task-assignment-item {
    .assignee-name {
        font-weight: 500;
    }
    .assignment-notes {
        font-size: 0.85rem;
        strong { font-weight: 600; }
    }
    .badge.fs-08rem {
        font-size: 0.8rem;
    }
}

// 5. UI Elements (Continued - specific for Request System)
// ---------------------------------------------------------
.request-list-item {
    transition: var(--nexus-transition-base);
    border-left-width: 4px;
    border-left-color: var(--nexus-border-color);
    &:hover {
        background-color: var(--nexus-sidebar-link-hover-bg);
        border-left-color: var(--nexus-primary);
    }
    .request-title {
        font-weight: 500;
        color: var(--nexus-text-primary);
    }
    .request-last-updated, .request-meta, .request-status, .request-description {
        font-size: 0.875rem;
    }
    .request-meta .badge, .request-status .badge {
        font-size: 0.75rem;
        font-weight: 500;
    }
}

.request-detail-view {
    dl.row dt {
        font-weight: 500;
        color: var(--nexus-text-secondary);
    }
    dl.row dd {
        margin-bottom: 0.85rem;
        color: var(--nexus-text-primary);
    }
    .blockquote {
        font-size: 0.95rem;
        border-left: 3px solid var(--nexus-border-color);
    }
}

.request-history-item {
    font-size: 0.9rem;
    border-bottom: 1px solid var(--nexus-border-color);
    &:last-child {
        border-bottom: none;
    }
    .history-timestamp, .history-actor {
        font-size: 0.8rem;
        opacity: 0.8;
    }
    .history-action .badge {
        font-size: 0.75rem;
        padding: .2em .5em;
        vertical-align: middle;
    }
    .history-notes {
        background-color: var(--nexus-sidebar-link-hover-bg);
        padding: 0.5rem 0.75rem;
        border-radius: var(--nexus-border-radius);
        font-size: 0.875rem;
        color: var(--nexus-text-secondary);
        white-space: pre-wrap;
        border-left-width: 3px !important;
    }
}

// 5. UI Elements (Continued)
// ---------------------------------------------------------
.assignment-section-sub {
    border-left: 3px solid var(--nexus-info);
    padding: 1rem;
    margin-bottom: 1rem;
    background-color: rgba(var(--nexus-info-rgb), 0.05);
    border-radius: var(--nexus-border-radius);
}
[data-bs-theme="dark"] .assignment-section-sub {
    background-color: rgba(var(--nexus-info-rgb), 0.1);
    border-left-color: var(--nexus-info);
}

// 5. UI Elements (Continued - specific for Student DB & Behavior)
// ---------------------------------------------------------
.list-group-item-action {
    h5.font-heading {
        color: var(--nexus-primary);
        transition: var(--nexus-transition-base);
    }
    &:hover h5.font-heading {
        color: var(--nexus-primary-text-hover); // Use derived CSS variable
    }
    .bi-chevron-right {
        transition: transform 0.2s ease-in-out;
    }
    &:hover .bi-chevron-right {
        transform: translateX(3px);
    }
}

.student-roster-table {
    th, td {
        font-size: 0.9rem;
    }
    .btn-sm i.fs-6 {
        vertical-align: -0.1em;
    }
    td a {
        font-weight: 500;
    }
    .bi-star-fill, .bi-trophy-fill {
        font-size: 1.1em;
    }
}

// 7. Analytics & Charts section
// ---------------------------------------------------------
.chart-container {
    position: relative;
    min-height: 250px;
    height: 300px;
    width: 100%;
    background-color: var(--nexus-sidebar-link-hover-bg);
    border-radius: var(--nexus-border-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px dashed var(--nexus-border-color);
    padding: 0.5rem;
    canvas {
        max-width: 100%;
        max-height: 100%;
    }
    .content-placeholder {
        border: none;
        background-color: transparent;
        padding: 1rem;
    }
}

[data-bs-theme="dark"] .chart-container {
    background-color: var(--nexus-light);
    border-color: var(--nexus-border-color);
}
-e 

===== static/css/style.css =====
:root {
  --nexus-primary: #0D47A1;
  --nexus-primary-rgb: 13, 71, 161;
  --nexus-secondary: #1976D2;
  --nexus-secondary-rgb: 25, 118, 210;
  --nexus-success: #198754;
  --nexus-success-rgb: 25, 135, 84;
  --nexus-info: #00796B;
  --nexus-info-rgb: 0, 121, 107;
  --nexus-warning: #ffc107;
  --nexus-warning-rgb: 255, 193, 7;
  --nexus-danger: #dc3545;
  --nexus-danger-rgb: 220, 53, 69;
  --nexus-light: #f8f9fa;
  --nexus-dark: #212529;
  --nexus-body-bg: #f4f7fc;
  --nexus-content-bg: #ffffff;
  --nexus-text-primary: #212529;
  --nexus-text-secondary: #5a6268;
  --nexus-border-color: #e0e5ec;
  --nexus-accent: var(--nexus-warning);
  --nexus-primary-text-hover: rgb(9.1896551724, 50.1896551724, 113.8103448276);
  --nexus-primary-bg-darken-7: rgb(10.3327586207, 56.4327586207, 127.9672413793);
  --nexus-primary-border-darken-9: rgb(9.5706896552, 52.2706896552, 118.5293103448);
  --nexus-border-color-darken-7: rgb(201.866, 210.436, 222.434);
  --dashboard-stat-card-footer-hover-bg: rgba(11.8568965517, 64.7568965517, 146.8431034483, 0.05);
  --nexus-font-sans-serif: "Open Sans", sans-serif;
  --nexus-font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --nexus-font-heading: "Poppins", sans-serif;
  --nexus-border-radius: 0.375rem;
  --nexus-border-radius-lg: 0.5rem;
  --nexus-font-size-base: 1rem;
  --nexus-line-height-base: 1.65;
  --nexus-sidebar-width: 260px;
  --nexus-sidebar-bg: var(--nexus-content-bg);
  --nexus-sidebar-border-color: var(--nexus-border-color);
  --nexus-sidebar-link-color: #343a40;
  --nexus-sidebar-link-hover-bg: rgba(var(--nexus-primary-rgb), 0.05);
  --nexus-sidebar-link-hover-color: var(--nexus-primary);
  --nexus-sidebar-link-active-bg: var(--nexus-primary);
  --nexus-sidebar-link-active-color: #ffffff;
  --nexus-sidebar-icon-color: #6c757d;
  --nexus-sidebar-active-icon-color: #ffffff;
  --nexus-sidebar-heading-color: var(--nexus-text-secondary);
  --nexus-shadow-sm: 0 .125rem .25rem rgba(0,0,0, .075);
  --nexus-shadow: 0 .5rem 1rem rgba(0,0,0, .15);
  --nexus-shadow-lg: 0 1rem 3rem rgba(0,0,0, .175);
  --nexus-transition-base: all .2s ease-in-out;
}

[data-bs-theme=dark] {
  --nexus-primary: #4dabf7;
  --nexus-primary-rgb: 77, 171, 247;
  --nexus-secondary: #74c0fc;
  --nexus-secondary-rgb: 116, 192, 252;
  --nexus-success: #40c057;
  --nexus-info: #3bc9db;
  --nexus-warning: #fcc419;
  --nexus-danger: #fa5252;
  --nexus-light: #343a40;
  --nexus-dark: #e9ecef;
  --nexus-body-bg: #1a1d20;
  --nexus-content-bg: #212529;
  --nexus-text-primary: #f1f3f5;
  --nexus-text-secondary: #adb5bd;
  --nexus-border-color: #495057;
  --nexus-primary-text-hover: rgb(125.8064516129, 194.0322580645, 249.1935483871);
  --nexus-primary-bg-darken-7: rgb(42.835483871, 154.8774193548, 245.464516129);
  --nexus-primary-border-darken-9: rgb(33.0741935484, 150.2709677419, 245.0258064516);
  --nexus-border-color-darken-7: rgb(56.711875, 62.15, 67.588125);
  --dashboard-stat-card-footer-hover-bg: rgba(62.3580645161, 164.0903225806, 246.3419354839, 0.15);
  --nexus-sidebar-bg: var(--nexus-content-bg);
  --nexus-sidebar-border-color: #373b3e;
  --nexus-sidebar-link-color: var(--nexus-text-secondary);
  --nexus-sidebar-link-hover-bg: rgba(var(--nexus-primary-rgb), 0.15);
  --nexus-sidebar-link-hover-color: var(--nexus-primary);
  --nexus-sidebar-link-active-bg: var(--nexus-primary);
  --nexus-sidebar-link-active-color: var(--nexus-dark);
  --nexus-sidebar-icon-color: var(--nexus-text-secondary);
  --nexus-sidebar-active-icon-color: var(--nexus-dark);
  --nexus-sidebar-heading-color: var(--nexus-text-secondary);
}
[data-bs-theme=dark] .navbar-brand-img-light {
  display: none;
}
[data-bs-theme=dark] .navbar-brand-img-dark {
  display: inline-block !important;
}
[data-bs-theme=dark] .card, [data-bs-theme=dark] .modal-content {
  background-color: var(--nexus-content-bg);
  border-color: var(--nexus-border-color);
}
[data-bs-theme=dark] .table {
  --bs-table-bg: var(--nexus-content-bg);
  --bs-table-border-color: var(--nexus-border-color);
  --bs-table-color: var(--nexus-text-primary);
  --bs-table-striped-bg: rgba(255,255,255,0.03);
  --bs-table-hover-bg: rgba(255,255,255,0.04);
}

[data-bs-theme=light] .navbar-brand-img-light {
  display: inline-block !important;
}
[data-bs-theme=light] .navbar-brand-img-dark {
  display: none;
}

.nexus-body {
  font-family: var(--nexus-font-sans-serif);
  color: var(--nexus-text-primary);
  background-color: var(--nexus-body-bg);
  line-height: var(--nexus-line-height-base);
  font-size: var(--nexus-font-size-base);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
  font-family: var(--nexus-font-heading);
  font-weight: 600;
  color: var(--nexus-text-primary);
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
  line-height: 1.3;
}

.page-title {
  font-size: 1.875rem;
  margin-bottom: 1.75rem;
  font-weight: 500;
  color: var(--nexus-text-primary);
}

a {
  color: var(--nexus-primary);
  text-decoration: none;
  transition: var(--nexus-transition-base);
}
a:hover {
  color: var(--nexus-primary-text-hover);
}

.main-container {
  padding-top: 0;
}

.nexus-navbar {
  background-color: var(--nexus-content-bg) !important;
  border-bottom: 1px solid var(--nexus-border-color);
  box-shadow: var(--nexus-shadow-sm);
}
.nexus-navbar .navbar-brand {
  font-family: var(--nexus-font-heading);
  font-weight: 700;
  font-size: 1.5rem;
  color: var(--nexus-text-primary) !important;
}
.nexus-navbar .nav-link {
  color: var(--nexus-text-secondary) !important;
}
.nexus-navbar .nav-link:hover, .nexus-navbar .nav-link:focus {
  color: var(--nexus-text-primary) !important;
}
.nexus-navbar .nav-link.active {
  color: var(--nexus-primary) !important;
  font-weight: 500;
}
.nexus-navbar .dropdown-menu {
  background-color: var(--nexus-content-bg);
  border-color: var(--nexus-border-color);
  box-shadow: var(--nexus-shadow);
}
.nexus-navbar .dropdown-menu .dropdown-header {
  color: var(--nexus-text-secondary);
  font-weight: 600;
}
.nexus-navbar .dropdown-menu .dropdown-item {
  color: var(--nexus-text-primary);
}
.nexus-navbar .dropdown-menu .dropdown-item:hover, .nexus-navbar .dropdown-menu .dropdown-item:focus {
  background-color: rgba(var(--nexus-primary-rgb), 0.1);
  color: var(--nexus-primary);
}
.nexus-navbar .dropdown-menu .dropdown-item:active {
  background-color: var(--nexus-primary);
  color: #fff;
}
.nexus-navbar .dropdown-menu .dropdown-divider {
  border-top-color: var(--nexus-border-color);
}
.nexus-navbar #themeSwitcher {
  color: var(--nexus-text-secondary);
  border-color: var(--nexus-border-color);
}
.nexus-navbar #themeSwitcher:hover {
  background-color: rgba(var(--nexus-primary-rgb), 0.1);
  color: var(--nexus-primary);
  border-color: var(--nexus-primary);
}

[data-bs-theme=dark] .nexus-navbar {
  background-color: var(--nexus-content-bg) !important;
}

.nexus-sidebar {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  z-index: 1020;
  padding: 0;
  padding-top: 56px;
  background-color: var(--nexus-sidebar-bg);
  border-right: 1px solid var(--nexus-sidebar-border-color);
  width: var(--nexus-sidebar-width);
  transition: var(--nexus-transition-base);
  overflow-y: auto;
}
.nexus-sidebar .sidebar-sticky {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.nexus-sidebar .nav-link {
  font-weight: 500;
  font-size: 0.95rem;
  color: var(--nexus-sidebar-link-color);
  padding: 0.75rem 1.5rem;
  border-left: 4px solid transparent;
  transition: var(--nexus-transition-base);
  display: flex;
  align-items: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.nexus-sidebar .nav-link .bi {
  margin-right: 0.875rem;
  font-size: 1.2rem;
  min-width: 24px;
  color: var(--nexus-sidebar-icon-color);
  transition: var(--nexus-transition-base);
}
.nexus-sidebar .nav-link:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
  color: var(--nexus-sidebar-link-hover-color);
  border-left-color: var(--nexus-sidebar-link-hover-color);
}
.nexus-sidebar .nav-link:hover .bi {
  color: var(--nexus-sidebar-link-hover-color);
}
.nexus-sidebar .nav-link.active {
  color: var(--nexus-sidebar-link-active-color);
  background-color: var(--nexus-sidebar-link-active-bg);
  border-left-color: var(--nexus-accent);
  font-weight: 600;
}
.nexus-sidebar .nav-link.active .bi {
  color: var(--nexus-sidebar-active-icon-color);
}content://com.android.externalstorage.documents/tree/primary%3ANexusbeta::primary:Nexusbeta/static/css/style.css
.nexus-sidebar .sidebar-heading {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 1.25rem 1.5rem 0.6rem;
  color: var(--nexus-sidebar-heading-color);
  font-weight: 700;
}

.nexus-main-content, .nexus-main-content-full {
  background-color: var(--nexus-body-bg);
  padding: 1.5rem;
  min-height: calc(100vh - 56px - 56px);
  flex-grow: 1;
  transition: margin-left 0.3s ease-in-out;
}

@media (min-width: 768px) {
  .nexus-main-content {
    margin-left: var(--nexus-sidebar-width);
  }
}
.footer {
  background-color: var(--nexus-content-bg);
  color: var(--nexus-text-secondary);
  border-top: 1px solid var(--nexus-border-color);
  font-size: 0.875rem;
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.footer a {
  color: var(--nexus-primary);
  font-weight: 500;
}
.footer a:hover {
  color: var(--nexus-primary-text-hover);
}

[data-bs-theme=dark] .footer {
  background-color: var(--nexus-content-bg);
  color: var(--nexus-text-secondary);
}
[data-bs-theme=dark] .footer a {
  color: var(--nexus-primary);
}
[data-bs-theme=dark] .footer a:hover {
  color: var(--nexus-primary-text-hover);
}

.btn {
  font-weight: 500;
  border-radius: var(--nexus-border-radius);
  padding: 0.6rem 1.2rem;
  transition: var(--nexus-transition-base);
  letter-spacing: 0.025em;
}
.btn:focus {
  box-shadow: 0 0 0 0.2rem rgba(var(--nexus-primary-rgb), 0.35) !important;
}

.btn-lg {
  padding: 0.75rem 1.5rem;
  font-size: 1.1rem;
}

.btn-primary {
  background-color: var(--nexus-primary);
  border-color: var(--nexus-primary);
  color: #fff;
}
.btn-primary:hover, .btn-primary:focus, .btn-primary:active {
  color: #fff;
  background-color: var(--nexus-primary-bg-darken-7);
  border-color: var(--nexus-primary-border-darken-9);
}

.btn-outline-primary {
  color: var(--nexus-primary);
  border-color: var(--nexus-primary);
}
.btn-outline-primary:hover, .btn-outline-primary:focus, .btn-outline-primary:active {
  color: #fff;
  background-color: var(--nexus-primary);
  border-color: var(--nexus-primary);
}

.btn-subtle {
  background-color: var(--nexus-content-bg);
  border: 1px solid var(--nexus-border-color);
  color: var(--nexus-text-secondary);
}
.btn-subtle:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-color: var(--nexus-border-color-darken-7);
  color: var(--nexus-text-primary);
}

.card {
  border: 1px solid var(--nexus-border-color);
  border-radius: var(--nexus-border-radius-lg);
  box-shadow: var(--nexus-shadow-sm);
  margin-bottom: 1.75rem;
  background-color: var(--nexus-content-bg);
  overflow: hidden;
}

.card-header {
  background-color: var(--nexus-content-bg);
  border-bottom: 1px solid var(--nexus-border-color);
  font-family: var(--nexus-font-heading);
  font-weight: 500;
  font-size: 1.1rem;
  color: var(--nexus-text-primary);
  padding: 0.85rem 1.25rem;
}
.card-header .bi {
  margin-right: 0.6rem;
  color: var(--nexus-primary);
  font-size: 1.2em;
}

.card-footer {
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-top: 1px solid var(--nexus-border-color);
  padding: 0.75rem 1.25rem;
}
.card-footer a:not(.btn) {
  color: var(--nexus-text-secondary);
}
.card-footer a:not(.btn):hover {
  color: var(--nexus-primary);
}

.form-control, .form-select {
  border-radius: var(--nexus-border-radius);
  border-color: var(--nexus-border-color);
  padding: 0.5rem 0.85rem;
  transition: var(--nexus-transition-base);
  background-color: var(--nexus-content-bg);
  color: var(--nexus-text-primary);
}
.form-control:focus, .form-select:focus {
  border-color: var(--nexus-primary);
  box-shadow: 0 0 0 0.2rem rgba(var(--nexus-primary-rgb), 0.25);
  background-color: var(--nexus-content-bg);
}
.form-control::placeholder, .form-select::placeholder {
  color: var(--nexus-text-secondary);
  opacity: 0.7;
}

.form-label {
  font-weight: 500;
  margin-bottom: 0.35rem;
  font-size: 0.9rem;
  color: var(--nexus-text-secondary);
}

.form-control-lg {
  padding: 0.65rem 1rem;
  font-size: 1.05rem;
}

.table {
  border-color: var(--nexus-border-color);
}
.table th {
  font-family: var(--nexus-font-heading);
  font-weight: 500;
  color: var(--nexus-text-primary);
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-bottom-width: 2px;
}
.table td, .table th {
  vertical-align: middle;
  padding: 0.85rem;
}
.table.table-hover > tbody > tr:hover > * {
  --bs-table-accent-bg: rgba(var(--nexus-primary-rgb), 0.075);
}

.nexus-swal-popup {
  border-radius: var(--nexus-border-radius-lg) !important;
  background-color: var(--nexus-content-bg) !important;
  border: 1px solid var(--nexus-border-color) !important;
  box-shadow: var(--nexus-shadow-lg) !important;
}

.nexus-swal-title {
  font-family: var(--nexus-font-heading) !important;
  color: var(--nexus-text-primary) !important;
  font-weight: 600 !important;
}

.nexus-swal-html-container {
  color: var(--nexus-text-secondary) !important;
  font-family: var(--nexus-font-sans-serif) !important;
}

.nexus-swal-button.btn-primary {
  background-color: var(--nexus-primary) !important;
  border-color: var(--nexus-primary) !important;
}
.nexus-swal-button.btn-primary:hover, .nexus-swal-button.btn-primary:focus {
  background-color: var(--nexus-primary-bg-darken-7) !important;
  border-color: var(--nexus-primary-border-darken-9) !important;
}

.dashboard-stat-card {
  transition: var(--nexus-transition-base);
}
.dashboard-stat-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--nexus-shadow);
}
.dashboard-stat-card .stat-content .card-subtitle {
  font-weight: 600;
  letter-spacing: 0.03em;
}
.dashboard-stat-card .stat-content .card-text {
  color: var(--nexus-text-primary);
}
.dashboard-stat-card .card-footer {
  font-size: 0.85rem;
  transition: var(--nexus-transition-base);
}
.dashboard-stat-card .card-footer:hover {
  background-color: var(--dashboard-stat-card-footer-hover-bg) !important;
  color: var(--nexus-primary) !important;
}

.dashboard-quick-links .list-group-item {
  background-color: transparent;
  border-color: var(--nexus-border-color);
  color: var(--nexus-text-secondary);
  transition: var(--nexus-transition-base);
  padding: 0.85rem 1.25rem;
}
.dashboard-quick-links .list-group-item:hover {
  background-color: rgba(var(--nexus-primary-rgb), 0.05);
  color: var(--nexus-primary);
  border-left: 3px solid var(--nexus-primary);
  padding-left: calc(1.25rem - 3px);
}
.dashboard-quick-links .list-group-item .bi {
  margin-right: 0.75rem;
  color: var(--nexus-primary);
}

.chart-container {
  position: relative;
  height: 300px;
  width: 100%;
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-radius: var(--nexus-border-radius);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--nexus-text-secondary);
  border: 1px dashed var(--nexus-border-color);
}

.cursor-pointer {
  cursor: pointer;
}

.text-small {
  font-size: 0.875em;
}

.font-heading {
  font-family: var(--nexus-font-heading);
}

.font-body {
  font-family: var(--nexus-font-sans-serif);
}

.icon-lg {
  font-size: 1.5rem;
}

.icon-xl {
  font-size: 2rem;
}

.hover-bg-light:hover {
  background-color: var(--nexus-sidebar-link-hover-bg) !important;
}

.auth-form-container {
  max-width: 480px;
  margin: 3rem auto;
}
.auth-form-container .card {
  border: none;
  box-shadow: var(--nexus-shadow-lg) !important;
}
.auth-form-container .card-body {
  padding: 2rem 2.5rem;
}
.auth-form-container .auth-form-logo {
  max-width: 120px;
  margin-bottom: 1.5rem;
}

@media (max-width: 767.98px) {
  .nexus-sidebar {
    padding-top: 56px;
  }
  .nexus-main-content, .nexus-main-content-full {
    padding: 1rem;
  }
  .page-title {
    font-size: 1.5rem;
  }
  .display-4 {
    font-size: 2.5rem;
  }
  .display-6 {
    font-size: 1.75rem;
  }
}
.asset-card {
  display: flex;
  flex-direction: column;
  transition: var(--nexus-transition-base);
  border-radius: var(--nexus-border-radius-lg);
}
.asset-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--nexus-shadow);
}
.asset-card .asset-card-img-placeholder {
  height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.asset-card .asset-card-img-placeholder .bi {
  opacity: 0.6;
}
.asset-card .card-title a {
  color: var(--nexus-text-primary);
}
.asset-card .card-title a:hover {
  color: var(--nexus-primary);
}
.asset-card .card-title a.pe-none {
  color: var(--nexus-text-primary) !important;
  cursor: default;
}
.asset-card .card-title a.pe-none:hover {
  text-decoration: none !important;
}
.asset-card .card-body {
  padding: 1rem;
}
.asset-card .fs-08rem {
  font-size: 0.8rem;
}
.asset-card .card-footer {
  padding: 0.75rem 1rem;
  font-size: 0.85rem;
}
.asset-card .card-footer .asset-actions .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.85rem;
  line-height: 1;
}
.asset-card .card-footer .asset-actions .btn .bi {
  vertical-align: middle;
}

#assetFilters .form-label {
  font-size: 0.8rem;
  margin-bottom: 0.25rem;
}

#assetFilters .form-select-sm, #assetFilters .form-control-sm {
  font-size: 0.875rem;
}

.page-item.active .page-link {
  background-color: var(--nexus-primary);
  border-color: var(--nexus-primary);
}

.page-link {
  color: var(--nexus-primary);
}
.page-link:hover {
  color: var(--nexus-primary-text-hover);
}
.page-link:focus {
  box-shadow: none;
}

[data-bs-theme=dark] .page-item.active .page-link {
  background-color: var(--nexus-primary);
  border-color: var(--nexus-primary);
}
[data-bs-theme=dark] .page-link {
  background-color: var(--nexus-content-bg);
  border-color: var(--nexus-border-color);
  color: var(--nexus-primary);
}
[data-bs-theme=dark] .page-link:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
  color: var(--nexus-primary-text-hover);
}
[data-bs-theme=dark] .page-item.disabled .page-link {
  background-color: var(--nexus-content-bg);
  border-color: var(--nexus-border-color);
  color: var(--nexus-text-secondary);
}

.asset-report-item {
  transition: var(--nexus-transition-base);
  border-left-width: 4px;
  border-left-color: var(--nexus-border-color);
}
.asset-report-item:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
}
.asset-report-item.status-pending {
  border-left-color: var(--nexus-warning);
}
.asset-report-item.status-in-progress {
  border-left-color: var(--nexus-info);
}
.asset-report-item.status-resolved {
  border-left-color: var(--nexus-success);
}
.asset-report-item.status-rejected {
  border-left-color: var(--nexus-danger);
}
.asset-report-item .font-heading {
  font-family: var(--nexus-font-heading);
}
.asset-report-item .badge {
  font-size: 0.85rem;
}

.notification-item {
  border-left-width: 4px;
  border-left-color: transparent;
  transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
}
.notification-item .notification-icon .badge {
  width: 40px;
  height: 40px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.notification-item .notification-title {
  font-weight: 500;
  color: var(--nexus-text-primary);
}
.notification-item .notification-timestamp {
  font-size: 0.8em;
}
.notification-item .notification-text {
  font-size: 0.9em;
  color: var(--nexus-text-secondary);
  line-height: 1.4;
}
.notification-item.unread-notification, .notification-item.list-group-item-primary {
  border-left-color: var(--nexus-primary) !important;
}
.notification-item.unread-notification .notification-title, .notification-item.list-group-item-primary .notification-title {
  font-weight: 600;
}
.notification-item:hover {
  background-color: var(--nexus-sidebar-link-hover-bg) !important;
}

.notification-list-full .notification-item {
  margin-bottom: 0.5rem;
  border-radius: var(--nexus-border-radius);
}
.notification-list-full .notification-item:last-child {
  margin-bottom: 0;
  border-bottom: 0 !important;
}

.contact-list-item-clickable {
  transition: var(--nexus-transition-base);
}
.contact-list-item-clickable:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
}
.contact-list-item-clickable:hover .font-heading {
  color: var(--nexus-primary);
}
.contact-list-item-clickable:hover .bi-send-plus-fill, .contact-list-item-clickable:hover .bi-chat-fill {
  transform: scale(1.1);
  opacity: 1;
}
.contact-list-item-clickable .bi-send-plus-fill, .contact-list-item-clickable .bi-chat-fill {
  transition: var(--nexus-transition-base);
}

.chat-message .message-bubble {
  border-radius: 1.25rem;
  word-wrap: break-word;
  max-width: 100%;
  font-size: 0.95rem;
  line-height: 1.5;
}
.chat-message .message-bubble p:last-child {
  margin-bottom: 0;
}
.chat-message.sent .message-bubble {
  background-color: var(--nexus-primary);
  color: #fff;
  border-bottom-right-radius: 0.5rem;
}
.chat-message.received .message-bubble {
  background-color: var(--nexus-content-bg);
  color: var(--nexus-text-primary);
  border: 1px solid var(--nexus-border-color);
  border-bottom-left-radius: 0.5rem;
}
[data-bs-theme=dark] .chat-message.received .message-bubble {
  background-color: var(--nexus-light);
  color: var(--nexus-text-primary);
  border-color: var(--nexus-border-color);
}
.chat-message .message-timestamp {
  font-size: 0.75rem;
  opacity: 0.8;
}

.chat-input-area textarea#chatMessageInput {
  max-height: 120px;
  overflow-y: auto;
}
.chat-input-area .btn-primary i.bi-send-fill {
  font-size: 1.1rem;
}
.chat-input-area #typingIndicator {
  font-size: 0.8rem;
  font-style: italic;
  color: var(--nexus-text-secondary);
  min-height: 1.2em;
  transition: opacity 0.3s ease-in-out;
}

.contact-list-item-clickable .contact-name {
  font-weight: 500;
}
.contact-list-item-clickable .contact-role, .contact-list-item-clickable .contact-last-active, .contact-list-item-clickable .contact-last-message-snippet {
  font-size: 0.85rem;
}
.contact-list-item-clickable .contact-action-icon {
  transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
}

.sticky-top {
  background-color: var(--nexus-content-bg) !important;
}
[data-bs-theme=dark] .sticky-top {
  background-color: var(--nexus-content-bg) !important;
}

.social-post-item .card-header {
  background-color: var(--nexus-content-bg) !important;
  border-bottom: 1px solid var(--nexus-border-color) !important;
}
.social-post-item .post-content-text {
  font-size: 1rem;
  line-height: 1.6;
  color: var(--nexus-text-primary);
  white-space: pre-wrap;
}
.social-post-item .post-attachment img, .social-post-item .post-attachment video {
  border: 1px solid var(--nexus-border-color);
}
.social-post-item .post-attachment .d-flex.align-items-center.p-2 {
  border: 1px solid var(--nexus-border-color);
  border-radius: var(--nexus-border-radius);
  background-color: var(--nexus-sidebar-link-hover-bg);
}
.social-post-item .post-attachment .d-flex.align-items-center.p-2 a {
  font-weight: 500;
}
.social-post-item .post-actions .btn.reaction-btn {
  padding: 0.25rem 0.6rem;
  font-size: 0.85rem;
  color: var(--nexus-text-secondary);
  border-color: var(--nexus-border-color);
}
.social-post-item .post-actions .btn.reaction-btn:hover, .social-post-item .post-actions .btn.reaction-btn.active {
  color: var(--nexus-primary);
  border-color: var(--nexus-primary);
  background-color: rgba(var(--nexus-primary-rgb), 0.1);
}
.social-post-item .post-actions .btn.reaction-btn.active {
  color: var(--nexus-primary);
  font-weight: 600;
}
.social-post-item .post-actions .btn.reaction-btn.active i.bi {
  color: var(--nexus-primary) !important;
}
.social-post-item .post-actions .btn.reaction-btn i.bi {
  vertical-align: text-bottom;
  margin-right: 0.25rem;
  font-size: 1em;
}
.social-post-item .post-actions .btn.reaction-btn .reaction-count {
  font-size: 0.9em;
  margin-left: 0.2rem;
}
.social-post-item .post-actions .comment-toggle-btn {
  color: var(--nexus-text-secondary);
  border-color: var(--nexus-border-color);
}
.social-post-item .post-actions .comment-toggle-btn:hover {
  color: var(--nexus-primary);
  border-color: var(--nexus-primary);
  background-color: rgba(var(--nexus-primary-rgb), 0.1);
}
.social-post-item .comments-section {
  background-color: var(--nexus-body-bg);
  padding-top: 0.5rem;
}
.social-post-item .comments-section .comment-form textarea.comment-input {
  font-size: 0.9rem;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.social-post-item .comments-section .comment-form .comment-submit-btn {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.social-comment-item .comment-bubble {
  font-size: 0.9rem;
  line-height: 1.45;
}
.social-comment-item .comment-actions .btn-link {
  color: var(--nexus-text-secondary);
}
.social-comment-item .comment-actions .btn-link:hover {
  color: var(--nexus-primary);
}
.social-comment-item .comment-timestamp {
  font-size: 0.75rem;
}
.social-comment-item .comment-content-text {
  white-space: pre-wrap;
}

.social-content-form-card .card-body {
  padding: 1rem;
}
.social-content-form-card .post-content-textarea {
  min-height: 80px;
  font-size: 1rem;
  line-height: 1.5;
  resize: vertical;
}
.social-content-form-card .post-attachment-area .form-control-sm {
  font-size: 0.875rem;
}
.social-content-form-card .post-submit-btn {
  font-weight: 500;
}

.channel-card {
  transition: var(--nexus-transition-base);
  border-radius: var(--nexus-border-radius-lg);
}
.channel-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--nexus-shadow);
}
.channel-card .channel-card-image-link {
  display: block;
}
.channel-card .channel-card-img-placeholder {
  border-top-left-radius: var(--nexus-border-radius-lg);
  border-top-right-radius: var(--nexus-border-radius-lg);
}
.channel-card .channel-card-img-placeholder .bi {
  opacity: 0.6;
}
.channel-card img.img-fluid {
  border-top-left-radius: var(--nexus-border-radius-lg);
  border-top-right-radius: var(--nexus-border-radius-lg);
}
.channel-card .card-body {
  padding: 1rem 1.25rem;
}
.channel-card .card-body .card-title a {
  color: var(--nexus-text-primary);
}
.channel-card .card-body .card-title a:hover {
  color: var(--nexus-primary);
}
.channel-card .card-footer {
  font-size: 0.85rem;
}
.channel-card .card-footer .channel-action-btn {
  font-size: 0.8rem;
  padding: 0.3rem 0.6rem;
}

.nav-tabs {
  border-bottom-color: var(--nexus-border-color);
}
.nav-tabs .nav-link {
  color: var(--nexus-text-secondary);
  font-weight: 500;
  border-bottom-width: 2px;
  padding: 0.75rem 1.25rem;
}
.nav-tabs .nav-link:hover {
  border-color: var(--nexus-sidebar-link-hover-bg) var(--nexus-sidebar-link-hover-bg) var(--nexus-border-color);
  color: var(--nexus-primary);
}
.nav-tabs .nav-link.active {
  color: var(--nexus-primary);
  background-color: var(--nexus-content-bg);
  border-color: var(--nexus-border-color) var(--nexus-border-color) var(--nexus-content-bg);
  font-weight: 600;
}

[data-bs-theme=dark] .nav-tabs .nav-link {
  color: var(--nexus-text-secondary);
}
[data-bs-theme=dark] .nav-tabs .nav-link:hover {
  border-color: var(--nexus-sidebar-link-hover-bg) var(--nexus-sidebar-link-hover-bg) var(--nexus-border-color);
  color: var(--nexus-primary);
}
[data-bs-theme=dark] .nav-tabs .nav-link.active {
  color: var(--nexus-primary);
  background-color: var(--nexus-content-bg);
  border-color: var(--nexus-border-color) var(--nexus-border-color) var(--nexus-content-bg);
}

.group-card {
  transition: var(--nexus-transition-base);
  border-radius: var(--nexus-border-radius-lg);
}
.group-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--nexus-shadow);
}
.group-card .group-card-img-placeholder {
  border-top-left-radius: var(--nexus-border-radius-lg);
  border-top-right-radius: var(--nexus-border-radius-lg);
}
.group-card .group-card-img-placeholder .bi {
  opacity: 0.6;
}
.group-card img.img-fluid {
  border-top-left-radius: var(--nexus-border-radius-lg);
  border-top-right-radius: var(--nexus-border-radius-lg);
}
.group-card .card-title a {
  color: var(--nexus-text-primary);
}
.group-card .card-title a:hover {
  color: var(--nexus-primary);
}
.group-card .card-footer {
  font-size: 0.85rem;
}
.group-card .card-footer .group-action-btn {
  font-size: 0.8rem;
  padding: 0.3rem 0.6rem;
}

.group-chat-input-area .social-content-form-card {
  margin-bottom: 0 !important;
  border: none;
  box-shadow: none;
}

.table .form-select-sm {
  min-width: 120px;
  font-size: 0.85rem;
}

.filepond--root {
  font-family: var(--nexus-font-sans-serif);
  border-radius: var(--nexus-border-radius);
  margin-bottom: 0.5rem;
}

.filepond--panel-root {
  background-color: var(--nexus-sidebar-link-hover-bg);
  border: 1px dashed var(--nexus-border-color);
}
[data-bs-theme=dark] .filepond--panel-root {
  background-color: var(--nexus-light);
  border: 1px dashed var(--nexus-border-color);
}

.filepond--drop-label {
  color: var(--nexus-text-secondary);
}
.filepond--drop-label label {
  font-size: 0.95rem;
}

.filepond--label-action {
  color: var(--nexus-primary);
  font-weight: 500;
  text-decoration-color: var(--nexus-primary);
}

.filepond-errors span {
  font-size: 0.875em;
  color: var(--nexus-danger);
}

.talent-club-card {
  transition: var(--nexus-transition-base);
  border-radius: var(--nexus-border-radius-lg);
  border-left: 4px solid transparent;
}
.talent-club-card.status-active {
  border-left-color: var(--nexus-success);
}
.talent-club-card.status-pending-review {
  border-left-color: var(--nexus-warning);
}
.talent-club-card:hover {
  transform: translateY(-5px);
  box-shadow: var(--nexus-shadow);
  border-left-color: var(--nexus-primary);
}
.talent-club-card .tc-club-card-image-link {
  display: block;
}
.talent-club-card .tc-club-card-img-placeholder {
  border-top-left-radius: calc(var(--nexus-border-radius-lg) - 1px);
  border-top-right-radius: calc(var(--nexus-border-radius-lg) - 1px);
}
.talent-club-card .tc-club-card-img-placeholder .bi {
  opacity: 0.65;
}
.talent-club-card img.img-fluid {
  border-top-left-radius: calc(var(--nexus-border-radius-lg) - 1px);
  border-top-right-radius: calc(var(--nexus-border-radius-lg) - 1px);
}
.talent-club-card .card-title a {
  color: var(--nexus-text-primary);
  font-weight: 600;
}
.talent-club-card .card-title a:hover {
  color: var(--nexus-primary);
}
.talent-club-card .badge {
  font-size: 0.75rem;
  font-weight: 500;
}
.talent-club-card .card-footer {
  font-size: 0.85rem;
}
.talent-club-card .card-footer .tc-action-btn {
  font-size: 0.8rem;
  padding: 0.35rem 0.7rem;
}

.tc-proposal-item {
  transition: var(--nexus-transition-base);
  border-left-width: 4px;
  border-left-color: var(--nexus-border-color);
}
.tc-proposal-item:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-left-color: var(--nexus-primary);
}
.tc-proposal-item .font-heading {
  font-family: var(--nexus-font-heading);
}
.tc-proposal-item .badge {
  font-size: 0.8rem;
}

.feature-card-hover {
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.feature-card-hover:hover {
  transform: translateY(-5px);
  box-shadow: var(--nexus-shadow);
}
.feature-card-hover .card-body .bi {
  transition: transform 0.3s ease-out;
}
.feature-card-hover:hover .card-body .bi {
  transform: scale(1.1);
}

.tc-community-input-area .social-content-form-card {
  margin-bottom: 0 !important;
  border: none;
  box-shadow: none;
}

.tc-proposal-item .btn-sm {
  font-size: 0.75rem;
  padding: 0.2rem 0.4rem;
}

#reviewProposalForm dl.row dt {
  font-weight: 500;
  color: var(--nexus-text-secondary);
}
#reviewProposalForm dl.row dd {
  margin-bottom: 0.75rem;
}
#reviewProposalForm .blockquote {
  font-size: 0.95rem;
  border-left: 3px solid var(--nexus-border-color);
}
#reviewProposalForm .list-group-item img {
  margin-right: 0.75rem;
}
@media (min-width: 992px) {
  #reviewProposalForm .sticky-lg-top {
    top: calc(56px + 1.5rem);
  }
}

.tc-club-management-table th, .tc-club-management-table td, .tc-member-management-table th, .tc-member-management-table td {
  font-size: 0.9rem;
}
.tc-club-management-table .badge, .tc-member-management-table .badge {
  font-size: 0.75rem;
  font-weight: 500;
}
.tc-club-management-table .btn-sm i.fs-6, .tc-member-management-table .btn-sm i.fs-6 {
  vertical-align: -0.1em;
}
.tc-club-management-table .form-select-sm, .tc-member-management-table .form-select-sm {
  min-width: 120px;
  font-size: 0.85rem;
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.list-group-item-light {
  font-size: 0.9rem;
}
.list-group-item-light img {
  border: 1px solid var(--nexus-border-color);
}

.task-list-item {
  transition: var(--nexus-transition-base);
  border-left-width: 4px;
  border-left-color: var(--nexus-border-color);
}
.task-list-item:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-left-color: var(--nexus-primary);
}
.task-list-item .task-title {
  font-weight: 500;
  color: var(--nexus-text-primary);
}
.task-list-item .task-description {
  color: var(--nexus-text-secondary);
}
.task-list-item .task-due-date, .task-list-item .task-creator {
  font-size: 0.85rem;
}
.task-list-item .badge {
  font-size: 0.75rem;
  font-weight: 500;
  padding: 0.3em 0.6em;
}

#userTaskDetailContainer .dl-row dt {
  font-weight: 500;
  color: var(--nexus-text-secondary);
}
#userTaskDetailContainer .dl-row dd {
  margin-bottom: 0.85rem;
}
#userTaskDetailContainer .card-header h5.font-heading {
  font-size: 1.15rem;
}

.task-history-entry {
  font-size: 0.9rem;
  border-bottom: 1px solid var(--nexus-border-color);
}
.task-history-entry:last-child {
  border-bottom: none;
}
.task-history-entry .history-timestamp, .task-history-entry .history-actor {
  font-size: 0.8rem;
  opacity: 0.8;
}
.task-history-entry .history-action .badge {
  font-size: 0.75rem;
  padding: 0.2em 0.5em;
  vertical-align: middle;
}
.task-history-entry .history-notes {
  background-color: var(--nexus-sidebar-link-hover-bg);
  padding: 0.3rem 0.5rem;
  border-radius: var(--nexus-border-radius);
  font-size: 0.85rem;
  color: var(--nexus-text-secondary);
}

.task-creator-view-item .badge {
  font-size: 0.75rem;
  font-weight: 500;
}

.user-task-assignment-item .assignee-name {
  font-weight: 500;
}
.user-task-assignment-item .assignment-notes {
  font-size: 0.85rem;
}
.user-task-assignment-item .assignment-notes strong {
  font-weight: 600;
}
.user-task-assignment-item .badge.fs-08rem {
  font-size: 0.8rem;
}

.request-list-item {
  transition: var(--nexus-transition-base);
  border-left-width: 4px;
  border-left-color: var(--nexus-border-color);
}
.request-list-item:hover {
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-left-color: var(--nexus-primary);
}
.request-list-item .request-title {
  font-weight: 500;
  color: var(--nexus-text-primary);
}
.request-list-item .request-last-updated, .request-list-item .request-meta, .request-list-item .request-status, .request-list-item .request-description {
  font-size: 0.875rem;
}
.request-list-item .request-meta .badge, .request-list-item .request-status .badge {
  font-size: 0.75rem;
  font-weight: 500;
}

.request-detail-view dl.row dt {
  font-weight: 500;
  color: var(--nexus-text-secondary);
}
.request-detail-view dl.row dd {
  margin-bottom: 0.85rem;
  color: var(--nexus-text-primary);
}
.request-detail-view .blockquote {
  font-size: 0.95rem;
  border-left: 3px solid var(--nexus-border-color);
}

.request-history-item {
  font-size: 0.9rem;
  border-bottom: 1px solid var(--nexus-border-color);
}
.request-history-item:last-child {
  border-bottom: none;
}
.request-history-item .history-timestamp, .request-history-item .history-actor {
  font-size: 0.8rem;
  opacity: 0.8;
}
.request-history-item .history-action .badge {
  font-size: 0.75rem;
  padding: 0.2em 0.5em;
  vertical-align: middle;
}
.request-history-item .history-notes {
  background-color: var(--nexus-sidebar-link-hover-bg);
  padding: 0.5rem 0.75rem;
  border-radius: var(--nexus-border-radius);
  font-size: 0.875rem;
  color: var(--nexus-text-secondary);
  white-space: pre-wrap;
  border-left-width: 3px !important;
}

.assignment-section-sub {
  border-left: 3px solid var(--nexus-info);
  padding: 1rem;
  margin-bottom: 1rem;
  background-color: rgba(var(--nexus-info-rgb), 0.05);
  border-radius: var(--nexus-border-radius);
}

[data-bs-theme=dark] .assignment-section-sub {
  background-color: rgba(var(--nexus-info-rgb), 0.1);
  border-left-color: var(--nexus-info);
}

.list-group-item-action h5.font-heading {
  color: var(--nexus-primary);
  transition: var(--nexus-transition-base);
}
.list-group-item-action:hover h5.font-heading {
  color: var(--nexus-primary-text-hover);
}
.list-group-item-action .bi-chevron-right {
  transition: transform 0.2s ease-in-out;
}
.list-group-item-action:hover .bi-chevron-right {
  transform: translateX(3px);
}

.student-roster-table th, .student-roster-table td {
  font-size: 0.9rem;
}
.student-roster-table .btn-sm i.fs-6 {
  vertical-align: -0.1em;
}
.student-roster-table td a {
  font-weight: 500;
}
.student-roster-table .bi-star-fill, .student-roster-table .bi-trophy-fill {
  font-size: 1.1em;
}

.chart-container {
  position: relative;
  min-height: 250px;
  height: 300px;
  width: 100%;
  background-color: var(--nexus-sidebar-link-hover-bg);
  border-radius: var(--nexus-border-radius);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px dashed var(--nexus-border-color);
  padding: 0.5rem;
}
.chart-container canvas {
  max-width: 100%;
  max-height: 100%;
}
.chart-container .content-placeholder {
  border: none;
  background-color: transparent;
  padding: 1rem;
}

[data-bs-theme=dark] .chart-container {
  background-color: var(--nexus-light);
  border-color: var(--nexus-border-color);
}

/*# sourceMappingURL=style.css.map */
/* --- START: Sidebar Enhancement Styles --- */

.nexus-sidebar {
    /* transform: translateX(0); Default: visible, JS will manage initial state */
    transition: transform 0.3s ease-in-out !important;
    /* z-index: 1020; is already set in your original CSS for nexus-sidebar, which is good */
}

.nexus-sidebar.collapsed {
    transform: translateX(-100%); /* Moves sidebar fully to the left */
}

/* Adjust main content margin when sidebar is collapsed on larger screens */
@media (min-width: 768px) {
    /* Default state (sidebar visible):
       .nexus-main-content { margin-left: var(--nexus-sidebar-width); }
       This is already handled by your existing CSS.
    */

    /* When sidebar is collapsed */
    body.sidebar-is-collapsed .nexus-main-content {
        margin-left: 0;
    }
}

/* Style for the close button if needed, Bootstrap's .btn-close usually adapts */
#sidebarCloseButton {
    /* Base styling, if any specific needed */
}
[data-bs-theme=dark] #sidebarCloseButton {
    filter: invert(1) grayscale(100%) brightness(200%); /* Makes it white for dark backgrounds */
}

/* --- THIS IS THE KEY FIX FOR THE HAMBURGER BUTTON --- */
#sidebarToggle {
    display: block !important; /* Force display, overriding Bootstrap's hide on md+ */
    /* If the button looks off (e.g. too wide or misaligned), you might experiment with:
       display: inline-block !important;
       or adjust margins/paddings on its parent or itself.
       For now, 'block !important' is the most direct way to make it show.
    */
}

/* --- END: Sidebar Enhancement Styles --- */
/* TomSelect Dropdown Specific Styles */
.ts-dropdown {
    z-index: 1060; /* Ensure it's above most elements; Bootstrap modals are ~1050 */
    /* width: 100%; */ /* Usually inherits width from control or set via JS */
}

.ts-dropdown .ts-dropdown-content {
    max-height: 200px; /* Adjust for desired scroll height */
    overflow-y: auto;
    background-color: var(--nexus-content-bg); /* Use your theme variable */
    border: 1px solid var(--nexus-border-color); /* Use your theme variable */
    box-shadow: var(--nexus-shadow-sm); /* Use your theme variable */
    border-radius: var(--nexus-border-radius);
}

.ts-dropdown .option {
    padding: 0.375rem 0.75rem; /* Bootstrap-like padding */
    color: var(--nexus-text-primary);
    font-size: 0.9rem; /* Slightly smaller if needed */
}

.ts-dropdown .option:hover,
.ts-dropdown .option.active {
    background-color: var(--nexus-primary-bg-darken-7); /* Or your hover color */
    color: #fff; /* Or your hover text color */
}

[data-bs-theme=dark] .ts-dropdown .option:hover,
[data-bs-theme=dark] .ts-dropdown .option.active {
    background-color: var(--nexus-primary-bg-darken-7); /* Adjust for dark theme if needed */
    color: var(--nexus-dark); /* Adjust text color for dark theme */
}
/* =================================================================== */
/*   CONTACTS LIST & CHAT STYLING (for app.py)                         */
/* =================================================================== */

/* Main Page Layout & Card Styling */
.card-header {
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.accordion-button:not(.collapsed) {
    color: var(--bs-primary); /* Use Bootstrap primary color for active accordion headers */
    background-color: var(--bs-primary-bg-subtle);
}

.accordion-button:focus {
    box-shadow: 0 0 0 0.25rem rgba(var(--bs-primary-rgb), 0.25);
}

/* Specific styling for the list items to ensure visibility and spacing */
.list-group-item {
    color: var(--bs-body-color); /* Ensures text is visible on both light/dark themes */
    background-color: var(--bs-body-bg); /* Ensures background matches the page */
}

a.list-group-item {
    transition: background-color 0.2s ease-in-out;
}

/* Hover effect for contact items */
a.list-group-item:hover, a.list-group-item:focus {
    background-color: var(--bs-secondary-bg); /* A subtle hover color from Bootstrap */
    color: var(--bs-emphasis-color);
}

/* Unread message badge */
.badge.bg-danger {
    font-size: 0.75em;
    padding: 0.4em 0.6em;
}

/* Search bar styling for TC member view */
#tcMemberSearch {
    padding: 0.75rem 1rem;
    font-size: 1rem;
}
#tcMemberSearch:focus {
    box-shadow: 0 0 0 0.25rem rgba(var(--bs-primary-rgb), 0.25);
    border-color: var(--bs-primary);
}
#tcMemberSearch + .input-group-text {
    border-right: 0;
}

/* Ensure avatar images are consistent */
.list-group-item img.rounded-circle {
    object-fit: cover;
    border: 2px solid var(--bs-tertiary-bg);
}

/* Minor adjustments for headers */
.card-header h5 {
    font-weight: 500;
}

.list-group h6.list-group-item {
    font-size: 0.8rem;
    letter-spacing: 0.5px;
    color: var(--bs-secondary-color);
}


#createTaskForm {
    fieldset {
        border: 1px solid var(--nexus-border-color);
        padding: 1.5rem;
        border-radius: var(--nexus-border-radius-lg);
        background-color: var(--nexus-content-bg); // Ensure consistent bg if body-bg is different

        legend {
            font-size: 1.25rem; // Make legends a bit smaller than page-title
            font-weight: 500; // Poppins Medium
            padding: 0 0.5rem; // Give some breathing room
            width: auto; // Allow legend to size to its content
            color: var(--nexus-primary);
        }
    }

    .assignment-section {
        // Styles for the individual and group assignment sections
        // display: none; by default in HTML, JS toggles
        border: 1px dashed var(--nexus-border-color);
        padding: 1rem;
        border-radius: var(--nexus-border-radius);
        background-color: var(--nexus-sidebar-link-hover-bg); // Slightly different bg
    }

    .role-checkbox-group, .grade-section-checkbox-group {
        // Styles for the checkbox list containers
        .form-check {
            margin-bottom: 0.5rem;
            label {
                font-weight: normal; // Regular weight for checkbox labels
                font-size: 0.9rem;
            }
        }
    }

    // TomSelect styling for user picker (general TomSelect styles should apply)
    // .tom-select-user-picker .ts-control { ... }
}
-e 

===== static/css/style.css.map =====
{"version":3,"sourceRoot":"","sources":["style.scss"],"names":[],"mappings":"AA4BA;EAEI;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EAKA;EAGA;EACA;EACA;EAGA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EAGA;;;AAIJ;EACI;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EAKA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAEA;EAA0B;;AAC1B;EAAyB;;AAEzB;EACI;EACA;;AAEJ;EACI;EACA;EACA;EACA;EACA;;;AAKJ;EAA0B;;AAC1B;EAAyB;;;AAM7B;EACI;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;AAGJ;EACI;EACA;EACA;EACA;EACA;EACA;;;AAEJ;EACI;EACA;EACA;EACA;;;AAGJ;EACI;EACA;EACA;;AACA;EACI;;;AAIR;EAAkB;;;AAIlB;EACI;EACA;EACA;;AACA;EACI;EACA;EACA;EACA;;AAEJ;EACI;;AACA;EACI;;AAEJ;EACI;EACA;;AAGR;EACI;EACA;EACA;;AACA;EACI;EACA;;AAEJ;EACI;;AACA;EACI;EACA;;AAEJ;EACK;EACA;;AAGT;EACI;;AAGP;EACG;EACA;;AACA;EACI;EACA;EACA;;;AAIZ;EACI;;;AAIJ;EACI;EAAiB;EAAQ;EAAW;EACpC;EACA;EAAY;EACZ;EACA;EACA;EACA;EACA;;AAEA;EAAkB;EAAmB;;AACrC;EACI;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAEA;EACI;EACA;EACA;EACA;EACA;;AAGJ;EACI;EACA;EACA;;AACA;EAAM;;AAEV;EACI;EACA;EACA;EACA;;AACA;EAAM;;AAGd;EACI;EACA;EACA;EACA;EACA;EACA;;;AAIR;EACI;EACA;EACA;EACA;EACA;;;AAEJ;EACI;IACI;;;AAKR;EACI;EACA;EACA;EACA;EACA;EACA;;AACA;EACI;EACA;;AACA;EAAU;;;AAGlB;EACI;EACA;;AACC;EAAI;;AACD;EAAU;;;AAOlB;EACI;EACA;EACA;EACA;EACA;;AACA;EACI;;;AAGR;EACI;EACA;;;AAEJ;EACI;EACA;EACA;;AACA;EACI;EACA;EACA;;;AAGR;EACI;EACA;;AACA;EACI;EACA;EACA;;;AAGR;EACI;EACA;EACA;;AACA;EACI;EACA;EACA;;;AAIR;EACI;EACA;EACA;EACA;EACA;EACA;;;AAEJ;EACI;EACA;EACA;EACA;EACA;EACA;EACA;;AACA;EAAM;EAAsB;EAA6B;;;AAE7D;EACI;EACA;EACA;;AACA;EACI;;AACA;EAAU;;;AAIlB;EACI;EACA;EACA;EACA;EACA;EACA;;AACA;EACI;EACA;EACA;;AAEJ;EACI;EACA;;;AAGR;EACI;EACA;EACA;EACA;;;AAEJ;EACI;EACA;;;AAIJ;EACI;;AACA;EACI;EACA;EACA;EACA;EACA;;AAEJ;EACI;EACA;;AAEJ;EACE;;;AAKN;EACI;EACA;EACA;EACA;;;AAEJ;EACI;EACA;EACA;;;AAEJ;EACI;EACA;;;AAEJ;EACI;EACA;;AACA;EACI;EACA;;;AAOR;EACI;;AACA;EACI;EACA;;AAIA;EACI;EACA;;AAEJ;EACI;;AAGR;EACI;EACA;;AACA;EACI;EACA;;;AAMR;EACI;EACA;EACA;EACA;EACA;;AACA;EACI;EACA;EACA;EACA;;AAEJ;EACI;EACA;;;AAMZ;EACI;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;AAMJ;EAAkB;;;AAClB;EAAc;;;AACd;EAAgB;;;AAChB;EAAa;;;AACb;EAAW;;;AACX;EAAW;;;AACX;EACI;;;AAKJ;EACI;EACA;;AACA;EACI;EACA;;AAEJ;EAAa;;AACb;EAAkB;EAAkB;;;AAKxC;EACI;IACI;;EAEJ;IACI;;EAEJ;IACI;;EAEJ;IAAa;;EACb;IAAa;;;AAOjB;EACI;EACA;EACA;EACA;;AAEA;EACI;EACA;;AAGJ;EACI;EACA;EACA;EACA;;AACA;EACI;;AAIR;EACI;;AACA;EACI;;AAGP;EACG;EACA;;AACA;EACI;;AAIR;EACI;;AAGJ;EACI;;AAGJ;EACI;EACA;;AACA;EACI;EACA;EACA;;AACC;EACG;;;AAOhB;EACI;EACA;;;AAEJ;EACI;;;AAOJ;EACI;EACA;;;AAEJ;EACI;;AACA;EACI;;AAEJ;EACI;;;AAIJ;EACI;EACA;;AAEJ;EACI;EACA;EACA;;AACA;EACI;EACA;;AAGP;EACG;EACA;EACA;;;AAQR;EACI;EACA;EACA;;AAEA;EACI;;AAGJ;EAAmB;;AACnB;EAAuB;;AACvB;EAAoB;;AACpB;EAAoB;;AAEpB;EACI;;AAEJ;EACI;;;AAOR;EACI;EACA;EACA;;AAGI;EACI;EACA;EACA;EACA;EACA;;AAIR;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;EACA;EACA;;AAGJ;EACI;;AACA;EACI;;AAIR;EACI;;;AAKJ;EACI;EACA;;AACA;EACI;EACA;;;AAKZ;EACI;;AACA;EACI;;AACA;EACI;;AAEJ;EACI;EACA;;AAGP;EACG;;;AAQJ;EACI;EACA;EACA;EACA;EACA;;AAEA;EACI;;AAKJ;EACI;EACA;EACA;;AAIJ;EACI;EACA;EACA;EACA;;AAEJ;EACK;EACA;EACA;;AAGT;EACI;EACA;;;AAKJ;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;EACA;EACA;EACA;EACA;;;AAKJ;EACI;;AAEJ;EACI;;AAEJ;EACI;;;AAIR;EACI;;AACA;EACI;;;AAQJ;EACI;EACA;;AAGJ;EACI;EACA;EACA;EACA;;AAGA;EACI;;AAEJ;EACI;EACA;EACA;;AACA;EACI;;AAMR;EACI;EACA;EACA;EACA;;AACA;EACI;EACA;EACA;;AAEJ;EACK;EACA;;AACA;EACI;;AAGT;EACI;EACA;EACA;;AAEJ;EACI;EACA;;AAGR;EACK;EACA;;AACA;EACG;EACA;EACA;;AAKZ;EACI;EACA;;AAEI;EACI;EACA;EACA;;AAEJ;EACI;EACA;;;AAOZ;EACI;EACA;;AAEJ;EACI;;AACA;EAAU;;AAEd;EACI;;AAEH;EACG;;;AAKJ;EACI;;AAEJ;EACI;EACA;EACA;EACA;;AAGA;EACI;;AAGR;EACI;;;AAOR;EACI;EACA;;AAEA;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;EACA;;AACA;EACI;;AAGR;EACI;EACA;;AAGJ;EACI;;AACA;EACI;;AACA;EAAU;;AAIlB;EACI;;AACA;EACI;EACA;;;AAKZ;EACI;;AACA;EACI;EACA;EACA;EACA;;AACA;EACI;EACA;;AAEJ;EACI;EACA;EACA;EACA;;;AAKP;EACG;;AACA;EACK;EACA;;AAEJ;EACG;EACA;EACA;;;AAiBZ;EACI;EACA;;AAEA;EACI;EACA;;AAEJ;EACI;EACA;;AACA;EAAM;;AAEV;EACI;EACA;;AAEJ;EACI;;AACA;EAAU;;AAEd;EACI;;AACA;EACI;EACA;;;AAQR;EACI;EACA;EACA;;;AAOJ;EACI;EACA;;;AAMR;EACI;EACA;EACA;;;AAEJ;EACI;EACA;;AACA;EACI;EACA;;;AAGR;EACI;;AACA;EACI;;;AAGR;EACI;EACA;EACA;;;AAEJ;EACI;EACA;;;AAKJ;EACI;EACA;EACA;;AAEA;EAAkB;;AAClB;EAA0B;;AAE1B;EACI;EACA;EACA;;AAEJ;EAA2B;;AAC3B;EACI;EACA;;AACA;EAAM;;AAEV;EACI;EACA;;AAGJ;EACI;EACA;;AACA;EAAU;;AAEd;EACI;EACA;;AAGJ;EACI;;AACA;EACI;EACA;;;AAgBZ;EACI;EACA;EACA;;AAEA;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;;;AAIR;EACI;;AACA;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;;;AAUJ;EACI;EACA;EACA;;;AAOJ;EACI;EACA;;;AAMJ;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;EACA;;AAGA;EAAM;;AAEV;EACI;IACG;;;;AAQP;EACI;;AAEJ;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;EACA;EACA;EACA;;;AAMR;EACI;;AACA;EACI;;;AASR;EACI;EACA;EACA;;AACA;EACI;EACA;;AAEJ;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;;AAEJ;EACI;EACA;EACA;;;AAKJ;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;;;AAIR;EACI;EACA;;AACA;EACI;;AAEJ;EACI;EACA;;AAGA;EACI;EACA;EACA;;AAGR;EACI;EACA;EACA;EACA;EACA;;;AAOJ;EACI;EACA;;;AAIJ;EACI;;AAEJ;EACI;;AACA;EAAS;;AAEb;EACI;;;AAMR;EACI;EACA;EACA;;AACA;EACI;EACA;;AAEJ;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;EACA;;;AAKJ;EACI;EACA;;AAEJ;EACI;EACA;;AAEJ;EACI;EACA;;;AAIR;EACI;EACA;;AACA;EACI;;AAEJ;EACI;EACA;;AAEJ;EACI;EACA;EACA;;AAEJ;EACI;EACA;EACA;EACA;EACA;EACA;EACA;;;AAMR;EACI;EACA;EACA;EACA;EACA;;;AAEJ;EACI;EACA;;;AAMA;EACI;EACA;;AAEJ;EACI;;AAEJ;EACI;;AAEJ;EACI;;;AAKJ;EACI;;AAEJ;EACI;;AAEJ;EACI;;AAEJ;EACI;;;AAMR;EACI;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AACA;EACI;EACA;;AAEJ;EACI;EACA;EACA;;;AAIR;EACI;EACA","file":"style.css"}-e 

===== templates/layout/_flash_messages.html =====
{# This container is where toast notifications will be dynamically added #}
<div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 1080">
    {# Toasts will be generated here by JavaScript #}
</div>

{# This script captures flashed messages and generates the toasts #}
{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const toastContainer = document.querySelector('.toast-container');
        if (!toastContainer) return;

        const categoryToIcon = {
          'success': '<i class="bi bi-check-circle-fill me-2"></i>',
          'danger': '<i class="bi bi-exclamation-triangle-fill me-2"></i>',
          'warning': '<i class="bi bi-exclamation-triangle-fill me-2"></i>',
          'info': '<i class="bi bi-info-circle-fill me-2"></i>'
        };

        const categoryToClass = {
          'success': 'text-bg-success',
          'danger': 'text-bg-danger',
          'warning': 'text-bg-warning',
          'info': 'text-bg-info'
        };

        {% for category, message in messages %}
          (function() {
            const toastEl = document.createElement('div');
            toastEl.classList.add('toast', 'align-items-center', 'border-0');
            toastEl.classList.add(categoryToClass['{{ category }}'] || 'text-bg-secondary');
            toastEl.setAttribute('role', 'alert');
            toastEl.setAttribute('aria-live', 'assertive');
            toastEl.setAttribute('aria-atomic', 'true');

            const iconHtml = categoryToIcon['{{ category }}'] || '';
            const messageText = `{{ message|escape|safe }}`.replace(/\n/g, '<br>');

            toastEl.innerHTML = `
              <div class="d-flex">
                <div class="toast-body">
                  ${iconHtml}
                  ${messageText}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
              </div>
            `;
            
            toastContainer.appendChild(toastEl);
            const toast = new bootstrap.Toast(toastEl, { delay: 6000 }); // 6-second delay
            toast.show();
            toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
          })();
        {% endfor %}
      });
    </script>
  {% endif %}
{% endwith %}-e 

===== templates/layout/base.html =====
<!DOCTYPE html>
<html lang="en" data-bs-theme="light"> {# Default theme, can be changed by JS #}
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    {# CSRF Token for AJAX POST requests - ensure Flask-WTF's csrf_token() is available in context #}
    <meta name="csrf-token" content="{{ get_csrf_token_value() if get_csrf_token_value else '' }}">

    <title>{% block page_title %}Nexus School Management{% endblock %} - Nexus</title>

    <!-- Favicon -->
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">

    <!-- Google Fonts: Poppins for headings, Open Sans for body -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
          {# ... other CSS links ... #}
    <!-- FilePond CSS -->
    <link href="https://unpkg.com/filepond/dist/filepond.min.css" rel="stylesheet">
    <link href="https://unpkg.com/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.min.css" rel="stylesheet">
    <link href="https://unpkg.com/filepond-plugin-file-poster/dist/filepond-plugin-file-poster.min.css" rel="stylesheet" />
    {# ... your custom CSS link ... #}
    <!-- Bootstrap 5.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <!-- Bootstrap Icons CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- Flatpickr CSS (for date/time pickers) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

    <!-- Tom Select CSS (for enhanced select boxes) -->
    <link href="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/css/tom-select.bootstrap5.min.css" rel="stylesheet">

    <!-- SweetAlert2 CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">

    <!-- Custom App CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}?v={{ range(1, 100000) | random }}"> <!-- Cache busting -->

    {% block head_css %}{% endblock %} {# For page-specific CSS links #}
</head>
<body class="d-flex flex-column min-vh-100 nexus-body"> {# Added nexus-body class for global styling #}

    {% block navbar_block %}
        {# The _navbar.html will be included here by default if this block is not overridden #}
        {# This allows pages like login/register to potentially have no navbar or a different one #}
        {% include 'layout/_navbar.html' %}
    {% endblock navbar_block %}

    <div class="container-fluid flex-grow-1 main-container">
        <div class="row h-100">
            {% if current_user.is_authenticated and not no_sidebar %} {# no_sidebar can be set in child templates #}
            <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block sidebar collapse nexus-sidebar">
                {% include 'layout/_sidebar.html' %}
            </nav>
            <main role="main" class="col-md-9 ms-sm-auto col-lg-10 px-md-4 py-4 nexus-main-content">
            {% else %}
            <main role="main" class="col-12 px-md-4 py-4 nexus-main-content-full"> {# For pages without sidebar like login #}
            {% endif %}
                {% include 'layout/_flash_messages.html' %}
                {% block content_header %}{% endblock %} {# For optional page headers/titles #}
                {% block content %}{% endblock %}
            </main>
        </div>
    </div>

    {% include 'layout/_footer.html' %}

    <!-- Core JS Libraries -->
    <!-- JQuery (required by some libraries like DataTables, or for convenience if preferred, but aiming for Vanilla JS first) -->
    <!-- <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script> -->

    <!-- Bootstrap 5.3 JS Bundle (includes Popper) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <!-- Flatpickr JS -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <!-- Tom Select JS -->
    <script src="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.complete.min.js"></script>

    <!-- SweetAlert2 JS -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.all.min.js"></script>

    <!-- Chart.js (optional, include if used globally, or per-page) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- Custom App JS -->
    <script src="{{ url_for('static', filename='js/utils.js') }}?v={{ range(1, 100000) | random }}"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}?v={{ range(1, 100000) | random }}"></script>
        {# ... other JS library links ... #}
    <!-- FilePond JS -->
    <script src="https://unpkg.com/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.min.js"></script>
    <script src="https://unpkg.com/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.min.js"></script>
    <script src="https://unpkg.com/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.min.js"></script>
    <script src="https://unpkg.com/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.min.js"></script>
    <script src="https://unpkg.com/filepond-plugin-file-poster/dist/filepond-plugin-file-poster.min.js"></script>
    <script src="https://unpkg.com/filepond/dist/filepond.min.js"></script>
    {# Remove ALL old script tags, like jQuery, Popper, Bootstrap JS, analytics.js, etc. #}
    {# ... #}

    <!-- Bootstrap JS Bundle (still required for components like dropdowns) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <!-- Alpine.js (Lightweight component framework) -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

<!-- If socketHandlers.js is not part of the main app_js bundle -->
    
    <script src="{{ url_for('static', filename='js/socketHandlers.js') }}?v={{ range(1, 100000) | random }}"> </script> -->

    <!-- Our Application's Bundled & Minified JavaScript -->
    {% assets "app_js" %}
        <script type="module" src="{{ ASSET_URL }}"></script>
    {% endassets %}
</body>
</html>-e 

===== templates/layout/_footer.html =====
<footer class="footer mt-auto py-3 bg-light border-top">
  <div class="container-fluid">
    <div class="row align-items-center">
      <div class="col-md-6 text-center text-md-start mb-2 mb-md-0">
        <span class="text-muted">
           {{ current_year }} Nexus - Kechene Debre Selam G.S.S. All rights reserved.
        </span>
      </div>
      <div class="col-md-6 text-center text-md-end">
        <a href="{{ url_for('home') }}" class="text-muted text-decoration-none me-3">Home</a>
        <a href="#" class="text-muted text-decoration-none me-3">Privacy Policy</a>
        <a href="#" class="text-muted text-decoration-none">Terms of Service</a>
      </div>
    </div>
  </div>
</footer>-e 

===== templates/layout/_navbar.html =====
{# templates/layout/_navbar.html - Nexus School Management System #}
{# Gemini 3 Pro Preview - Phase A.2 #}
{# MODIFIED FOR COLLAPSIBLE SIDEBAR #}

<nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark nexus-navbar shadow-sm">
    <div class="container-fluid">
        <a class="navbar-brand d-flex align-items-center" href="{{ url_for('home') }}">
            {# Logos for light/dark theme - visibility controlled by CSS #}
            <img src="{{ url_for('static', filename='img/logo_light.png') }}" alt="Nexus Logo" class="navbar-brand-img-light me-2" style="height: 35px;">
            <img src="{{ url_for('static', filename='img/logo_dark.png') }}" alt="Nexus Logo Dark" class="navbar-brand-img-dark me-2" style="height: 35px; display: none;">
            <span class="fw-bold">Nexus</span>
        </a>

        {# Sidebar Toggle Button (shows if sidebar exists for the page/user) #}
        {% if current_user.is_authenticated and not no_sidebar %}
        <button class="navbar-toggler" id="sidebarToggle" type="button" aria-controls="sidebarMenu" aria-expanded="false" aria-label="Toggle sidebar">
            <span class="navbar-toggler-icon"></span>
        </button>
        {% endif %}

        <div class="collapse navbar-collapse" id="navbarMainCollapse">
            <ul class="navbar-nav ms-auto mb-2 mb-md-0 align-items-center">
                {% if current_user.is_authenticated %}
                    {# Notifications Dropdown - Placeholder, will be dynamic with AJAX later #}
                    <li class="nav-item dropdown">
                        <a class="nav-link position-relative" href="#" id="notificationsDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false" title="Notifications">
                            <i class="bi bi-bell-fill fs-5"></i>
                            {% if unread_notifications_count and unread_notifications_count > 0 %}
                                <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger">
                                    {{ unread_notifications_count }}
                                    <span class="visually-hidden">unread notifications</span>
                                </span>
                            {% endif %}
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end dropdown-menu-dark shadow-lg mt-2" aria-labelledby="notificationsDropdown" style="min-width: 300px;">
                            <li><h6 class="dropdown-header">Notifications</h6></li>
                            <li><hr class="dropdown-divider"></li>
                            {# Placeholder for actual notifications - will be populated dynamically #}
                            <li id="notification-items-container">
                                <a class="dropdown-item text-wrap" href="#">
                                    <small class="d-block text-muted">No new notifications</small>
                                </a>
                            </li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item text-center" href="{{ url_for('view_notifications') }}">View All Notifications</a></li>
                        </ul>
                    </li>

                    {# Messages Dropdown - Placeholder #}
                     <li class="nav-item dropdown ms-md-2">
                        <a class="nav-link position-relative" href="#" id="messagesDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false" title="Messages">
                            <i class="bi bi-chat-left-text-fill fs-5"></i>
                             {% if unread_messages_count and unread_messages_count > 0 %}
                                <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger">
                                    {{ unread_messages_count }}
                                    <span class="visually-hidden">unread messages</span>
                                </span>
                            {% endif %}
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end dropdown-menu-dark shadow-lg mt-2" aria-labelledby="messagesDropdown" style="min-width: 300px;">
                            <li><h6 class="dropdown-header">Recent Messages</h6></li>
                            <li><hr class="dropdown-divider"></li>
                            {# Placeholder for actual messages #}
                            <li id="message-items-container">
                                <a class="dropdown-item text-wrap" href="#">
                                    <small class="d-block text-muted">No new messages</small>
                                </a>
                            </li>
                             <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item text-center" href="{{ url_for('contacts_list') }}">View All Chats</a></li>
                        </ul>
                    </li>

                    {# User Profile Dropdown #}
                    <li class="nav-item dropdown ms-md-2">
                        <a class="nav-link dropdown-toggle d-flex align-items-center" href="#" id="userDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            {% if current_user.profile_photo_url %}
                                <img src="{{ url_for('static', filename=current_user.profile_photo_url) }}" alt="{{ current_user.username }}" class="rounded-circle me-2" style="width: 32px; height: 32px; object-fit: cover;">
                            {% else %}
                                <i class="bi bi-person-circle fs-4 me-2"></i>
                            {% endif %}
                            <span class="d-none d-md-inline">{{ current_user.username }}</span>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end dropdown-menu-dark shadow-lg mt-2" aria-labelledby="userDropdown">
                            <li><h6 class="dropdown-header">Hi, {{ current_user.full_name or current_user.username }}!</h6></li>
                            <li><p class="dropdown-item-text px-3 mb-0"><small>{{ current_user.role.name.replace('_', ' ') | title if current_user.role else 'No Role' }}</small></p></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="{{ url_for('role_redirect') }}"><i class="bi bi-speedometer2 me-2"></i>Dashboard</a></li>
                            <li><a class="dropdown-item" href="{{ url_for('settings') }}"><i class="bi bi-gear-fill me-2"></i>Settings</a></li>
                            <li><a class="dropdown-item" href="{{ url_for('change_password') }}"><i class="bi bi-shield-lock-fill me-2"></i>Change Password</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li>
                                <form action="{{ url_for('logout') }}" method="GET" class="d-inline w-100"> {# GET for simplicity, POST is more secure #}
                                    <button type="submit" class="dropdown-item"><i class="bi bi-box-arrow-right me-2"></i>Logout</button>
                                </form>
                            </li>
                        </ul>
                    </li>
                {% else %}
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'login' else '' }}" href="{{ url_for('login') }}">Login</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'pre_register' else '' }}" href="{{ url_for('pre_register') }}">Register</a>
                    </li>
                {% endif %}

                 {# Theme Switcher Button #}
                <li class="nav-item ms-md-2">
                    <button class="btn btn-outline-secondary btn-sm" id="themeSwitcher" type="button" title="Toggle theme">
                        <i class="bi bi-moon-stars-fill"></i> {# Icon will be updated by JS #}
                    </button>
                </li>
            </ul>
        </div>
    </div>
</nav>-e 

===== templates/layout/_sidebar.html =====
{# templates/layout/_sidebar.html - Nexus School Management System #}
{# Gemini 3 Pro Preview - Phase A.2 #}
{# MODIFIED FOR COLLAPSIBLE SIDEBAR #}
{# This is a base sidebar structure. Content will be dynamically generated by the backend #}
{# or a more specific _sidebar_[role].html partial can be included by base.html based on current_user.role #}

<nav id="sidebarMenu" class="nexus-sidebar"> {# <<<< ID ADDED HERE #}
    <div class="sidebar-sticky pt-3">
        {# <<<< CLOSE BUTTON ADDED HERE >>>> #}
        <button type="button" class="btn-close float-end mb-2 me-2" id="sidebarCloseButton" aria-label="Close sidebar"></button>
        <div style="clear:both;"></div> {# Ensure content after floated button is cleared #}

        {% if current_user.is_authenticated %}
            {# Profile Info Mini #}
            <div class="px-3 mb-3 text-center">
                 {% if current_user.profile_photo_url %}
                    <img src="{{ url_for('static', filename=current_user.profile_photo_url) }}" alt="{{ current_user.username }}" class="rounded-circle mb-2" style="width: 80px; height: 80px; object-fit: cover; border: 2px solid var(--nexus-border-color);">
                {% else %}
                    <i class="bi bi-person-circle text-secondary" style="font-size: 80px;"></i>
                {% endif %}
                <h6 class="mb-0 mt-2 font-heading">{{ current_user.full_name or current_user.username }}</h6>
                <small class="text-muted">{{ current_user.role.name.replace('_', ' ') | title if current_user.role else 'N/A' }}</small>
            </div>
            <hr class="mx-3 my-2">

            <ul class="nav flex-column">
                <li class="nav-item">
                    <a class="nav-link {{ 'active' if request.endpoint == 'role_redirect' or request.endpoint.endswith('_dashboard') else '' }}" href="{{ url_for('role_redirect') }}">
                        <i class="bi bi-speedometer2"></i>
                        Dashboard
                    </a>
                </li>

                {# --- Common Links for most roles --- #}
                <li class="nav-item">
                    <a class="nav-link {{ 'active' if request.endpoint == 'contacts_list' or request.endpoint == 'universal_chat' else '' }}" href="{{ url_for('contacts_list') }}">
                        <i class="bi bi-chat-dots-fill"></i>
                        Chat / Contacts
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link {{ 'active' if request.endpoint == 'view_notifications' else '' }}" href="{{ url_for('view_notifications') }}">
                        <i class="bi bi-bell-fill"></i>
                        Notifications
                        {% if unread_notifications_count and unread_notifications_count > 0 %}
                            <span class="badge bg-danger rounded-pill ms-auto">{{ unread_notifications_count }}</span>
                        {% endif %}
                    </a>
                </li>
                {# templates/layout/_sidebar.html #}
{# ... existing sidebar code before common links ... #}

        <ul class="nav flex-column">
            {# ... existing Dashboard link ... #}
            
            {# --- NEW: Social Core Heading & Links (Universal) --- #}
            <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                <span>Engage & Connect</span>
            </li>
            <li class="nav-item">
                <a class="nav-link {{ 'active' if request.endpoint == 'view_global_feed' else '' }}" href="{{ url_for('view_global_feed') }}"> {# Assuming 'view_global_feed' will be the route name #}
                    <i class="bi bi-globe2"></i> {# Or bi-megaphone-fill #}
                    Nexus Pulse
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link {{ 'active' if request.endpoint == 'contacts_list' or request.endpoint == 'universal_chat' else '' }}" href="{{ url_for('contacts_list') }}">
                    <i class="bi bi-chat-dots-fill"></i>
                    Chat / Contacts
                </a>
            </li>
             <li class="nav-item">
                <a class="nav-link {{ 'active' if request.endpoint == 'view_notifications' else '' }}" href="{{ url_for('view_notifications') }}">
                    <i class="bi bi-bell-fill"></i>
                    Notifications
                    {% if unread_notifications_count and unread_notifications_count > 0 %}
                        <span class="badge bg-danger rounded-pill ms-auto">{{ unread_notifications_count }}</span>
                    {% endif %}
                </a>
            </li>
            {# --- END NEW: Social Core Heading & Links --- #}

            {# Existing Role Specific Sections for Social (Channels, Groups, TC for Student) - These are good #}
            {# Student Specific #}
            {% if current_user.role.name == 'student' %}
                {# ... other student links ... #}
                 <li class="nav-item">
                    <a class="nav-link {{ 'active' if request.endpoint.startswith('social_channel_') or request.endpoint == 'view_my_channel_organization' else '' }}" href="{{ url_for('social_channel_list') }}"> {# Point to main list, organization page will be linked from there or settings #}
                        <i class="bi bi-broadcast-pin"></i> Channels
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link {{ 'active' if request.endpoint.startswith('social_group_') else '' }}" href="{{ url_for('social_group_list') }}">
                        <i class="bi bi-people-fill"></i> Groups
                    </a>
                </li>
                {# ... existing TC link for student ... #}
            {% endif %}

            {# Teacher/Admin/Other roles that can create/manage channels/groups will access them via their dashboards or a dedicated "Social Management" area if created #}
            
            {# --- NEW: Social Preferences (Universal, to be made visible after login) --- #}
            {# This could also be a sub-menu under "Settings" #}
            <li class="nav-item">
                <a class="nav-link {{ 'active' if request.endpoint == 'view_saved_items' else '' }}" href="{{ url_for('view_saved_items') }}"> {# Assuming 'view_saved_items' route #}
                    <i class="bi bi-bookmark-star-fill"></i>
                    Saved Items
                </a>
            </li>
            {# Link to "Channel Organization" can be here or within a "My Channels" management page accessible from social_channel_list #}
            {# For Phase 0, let's add a placeholder. Its final location might be debated with Wonder Proposal. #}
            <li class="nav-item">
                 <a class="nav-link {{ 'active' if request.endpoint == 'view_my_channel_organization' else '' }}" href="{{ url_for('view_my_channel_organization') }}"> {# Assuming 'view_my_channel_organization' route #}
                    <i class="bi bi-diagram-3-fill"></i>
                    Organize Channels
                </a>
            </li>
             {# --- END NEW: Social Preferences --- #}

            {# ... rest of existing role-specific links and common settings/logout links ... #}
        </ul>
    {% endif %}
{# ... rest of sidebar ... #}

                {# --- Role Specific Sections --- #}
                {# Student Specific #}
                {% if current_user.role.name == 'student' %}
                    <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>My Academics</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'view_library' else '' }}" href="{{ url_for('view_library') }}">
                            <i class="bi bi-book-half"></i> My Borrowed Books
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'view_student_behavior_records' and request.view_args.get('user_id') == current_user.id else '' }}" href="{{ url_for('view_student_behavior_records', user_id=current_user.id) }}">
                            <i class="bi bi-clipboard2-check-fill"></i> My Behavior Records
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'my_tasks' else '' }}" href="{{ url_for('my_tasks') }}">
                            <i class="bi bi-list-task"></i> My Tasks
                        </a>
                    </li>

                    {# Social Media & Talent Club for Students #}
                     <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Social & Clubs</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint.startswith('social_channel_') else '' }}" href="{{ url_for('social_channel_list') }}">
                            <i class="bi bi-broadcast-pin"></i> Channels
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint.startswith('social_group_') else '' }}" href="{{ url_for('social_group_list') }}">
                            <i class="bi bi-people-fill"></i> Groups
                        </a>
                    </li>
                    {% if current_user.is_tc_member %}
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint.startswith('talent_club_') or request.endpoint == 'talent_club_dashboard' else '' }}" href="{{ url_for('talent_club_dashboard') }}">
                            <i class="bi bi-trophy-fill"></i> Talent Club
                        </a>
                    </li>
                    {% endif %}
                {% endif %}

                {# Teacher Specific #}
                {% if current_user.role.name == 'teacher' %}
                     <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Teaching Tools</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'enter_marks' else '' }}" href="{{ url_for('enter_marks') }}">
                            <i class="bi bi-pencil-square"></i> Enter Marks
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'mark_attendance' else '' }}" href="{{ url_for('mark_attendance') }}">
                            <i class="bi bi-calendar-check-fill"></i> Mark Attendance
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'teacher_lab_equipment' else '' }}" href="{{ url_for('teacher_lab_equipment') }}">
                            <i class="bi bi-binoculars-fill"></i> My Lab Equipment
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'student_database_index' or request.endpoint == 'student_database_block' else '' }}" href="{{ url_for('student_database_index') }}"> {# Teachers can view their class lists #}
                            <i class="bi bi-person-lines-fill"></i> Student Database
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'my_tasks' else '' }}" href="{{ url_for('my_tasks') }}">
                            <i class="bi bi-list-task"></i> My Tasks
                        </a>
                    </li>
                {% endif %}

                {# Librarian Specific #}
                {% if current_user.role.name == 'librarian' %}
                     <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Library Management</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'checkout_book' else '' }}" href="{{ url_for('checkout_book') }}">
                            <i class="bi bi-journal-arrow-up"></i> Checkout Book
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'list_checkouts' else '' }}" href="{{ url_for('list_checkouts') }}">
                            <i class="bi bi-journals"></i> All Checkouts
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'librarian_attendance' else '' }}" href="{{ url_for('librarian_attendance') }}">
                            <i class="bi bi-calendar3-week-fill"></i> Student Attendance
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'my_tasks' else '' }}" href="{{ url_for('my_tasks') }}">
                            <i class="bi bi-list-task"></i> My Tasks
                        </a>
                    </li>
                {% endif %}

                {# HR/CEO Specific #}
                {% if current_user.role.name == 'hr_ceo' %}
                    <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Management</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'list_pending_assets' else '' }}" href="{{ url_for('list_pending_assets') }}">
                            <i class="bi bi-box-seam-fill"></i> Pending Assets
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'list_all_assets' else '' }}" href="{{ url_for('list_all_assets') }}">
                            <i class="bi bi-boxes"></i> All Assets
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'list_asset_reports' else '' }}" href="{{ url_for('list_asset_reports') }}">
                            <i class="bi bi-flag-fill"></i> Asset Reports
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'manage_asset_categories' else '' }}" href="{{ url_for('manage_asset_categories') }}">
                            <i class="bi bi-tags-fill"></i> Asset Categories
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'student_database_index' else '' }}" href="{{ url_for('student_database_index') }}">
                            <i class="bi bi-person-lines-fill"></i> Student Database
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'manage_student_leaders' else '' }}" href="{{ url_for('manage_student_leaders') }}">
                            <i class="bi bi-person-check-fill"></i> Student Leaders
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'manage_system_tc_leader' else '' }}" href="{{ url_for('manage_system_tc_leader') }}">
                            <i class="bi bi-trophy-fill"></i> TC Leader Admin
                        </a>
                    </li>
                    <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Tasks & Requests</span>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'create_task' else '' }}" href="{{ url_for('create_task') }}">
                            <i class="bi bi-plus-square-dotted"></i> Create Task
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'my_assigned_tasks' else '' }}" href="{{ url_for('my_assigned_tasks') }}">
                            <i class="bi bi-card-list"></i> Assigned Tasks
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'requests_inbox' else '' }}" href="{{ url_for('requests_inbox') }}">
                            <i class="bi bi-envelope-paper-fill"></i> Requests Inbox
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'hr_ceo_initiate_request' else '' }}" href="{{ url_for('hr_ceo_initiate_request') }}">
                            <i class="bi bi-send-plus-fill"></i> Initiate Request
                        </a>
                    </li>
                     <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Analytics</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'attendance_analytics' else '' }}" href="#" onclick="fetchAnalyticsData('attendance', 'Attendance Overview'); return false;">
                            <i class="bi bi-graph-up"></i> Attendance Data
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'performance_analytics' else '' }}" href="#" onclick="fetchAnalyticsData('performance', 'Performance Overview'); return false;">
                            <i class="bi bi-bar-chart-line-fill"></i> Performance Data
                        </a>
                    </li>
                    {# More analytics links can be added here #}
                {% endif %}

                {# System Admin Specific (add more as needed) #}
                {% if current_user.role.name == 'system_admin' %}
                    <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>System Admin</span>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link" href="#"> {# Placeholder for User Management #}
                            <i class="bi bi-people-fill"></i> User Management
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link" href="#"> {# Placeholder for System Logs #}
                            <i class="bi bi-hdd-stack-fill"></i> System Logs
                        </a>
                    </li>
                    {# HR/CEO links are often relevant for SysAdmin too #}
                    {# Consider duplicating or creating a helper macro for shared links #}
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'list_pending_assets' else '' }}" href="{{ url_for('list_pending_assets') }}">
                            <i class="bi bi-box-seam-fill"></i> Pending Assets
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'list_all_assets' else '' }}" href="{{ url_for('list_all_assets') }}">
                            <i class="bi bi-boxes"></i> All Assets
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'manage_asset_categories' else '' }}" href="{{ url_for('manage_asset_categories') }}">
                            <i class="bi bi-tags-fill"></i> Asset Categories
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'create_task' else '' }}" href="{{ url_for('create_task') }}">
                            <i class="bi bi-plus-square-dotted"></i> Create Task
                        </a>
                    </li>
                {% endif %}

                {# Common for users who can submit things #}
                {% if current_user.role.name in ['student', 'teacher', 'librarian', 'talent_club'] %}
                    <li class="sidebar-heading px-3 mt-4 mb-1 text-muted text-uppercase">
                        <span>Submissions</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'my_assets' else '' }}" href="{{ url_for('my_assets') }}">
                            <i class="bi bi-folder-symlink-fill"></i> My Added Assets
                        </a>
                    </li>
                     <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'report_asset_general' else '' }}" href="{{ url_for('report_asset_general') }}">
                            <i class="bi bi-exclamation-triangle-fill"></i> Report General Issue
                        </a>
                    </li>
                    {% if permissions and permissions.can_create_request %} {# Check from get_request_permissions #}
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'submit_request' else '' }}" href="{{ url_for('submit_request') }}">
                            <i class="bi bi-file-earmark-plus-fill"></i> Submit Request
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {{ 'active' if request.endpoint == 'my_requests' else '' }}" href="{{ url_for('my_requests') }}">
                            <i class="bi bi-folder-check"></i> My Requests
                        </a>
                    </li>
                    {% endif %}
                {% endif %}


                {# Global Settings Link #}
                <li class="nav-item mt-auto mb-2"> {# Pushes to bottom if sidebar is tall #}
                     <hr class="mx-3 my-2">
                    <a class="nav-link {{ 'active' if request.endpoint == 'settings' else '' }}" href="{{ url_for('settings') }}">
                        <i class="bi bi-gear-wide-connected"></i>
                        Settings
                    </a>
                </li>
                <li class="nav-item">
                    <form action="{{ url_for('logout') }}" method="GET" class="d-inline w-100">
                         <button type="submit" class="nav-link border-0 bg-transparent w-100 text-start">
                            <i class="bi bi-box-arrow-left"></i>
                            Logout
                        </button>
                    </form>
                </li>
            </ul>
        {% endif %}
    </div>
</nav>-e 

===== templates/errors/500.html =====
{% extends "layout/base.html" %}

{% block page_title %}Server Error (500){% endblock %}

{% block content %}
{% set no_sidebar = True if not current_user or not current_user.is_authenticated else False %} {# Show sidebar if user is logged in #}

<div class="container text-center py-5">
    <div class="row justify-content-center">
        <div class="col-lg-8 col-md-10">
            <i class="bi bi-exclamation-octagon-fill text-danger display-1 mb-4"></i>
            <h1 class="display-4 font-heading text-danger">Internal Server Error</h1>
            <p class="lead text-muted">
                We apologize for the inconvenience. Something went wrong on our end.
            </p>
            <p class="text-muted">
                Our team has been notified and we are working to resolve the issue as soon as possible.
            </p>
            <hr class="my-4">
            <p class="mb-1">
                Please try again later. If the problem persists, you can contact support.
            </p>
            <p class="text-muted small">
                (Error Code: 500 Internal Server Error)
            </p>
            <div class="mt-4">
                 {% if current_user.is_authenticated %}
                    <a href="{{ url_for('role_redirect') }}" class="btn btn-primary btn-lg me-2">
                        <i class="bi bi-house-door-fill me-2"></i>Go to Dashboard
                    </a>
                {% else %}
                     <a href="{{ url_for('home') }}" class="btn btn-primary btn-lg me-2">
                        <i class="bi bi-house-door-fill me-2"></i>Go to Homepage
                    </a>
                {% endif %}
                <a href="javascript:location.reload();" class="btn btn-outline-secondary btn-lg">
                    <i class="bi bi-arrow-clockwise me-2"></i>Try Again
                </a>
            </div>
        </div>
    </div>
</div>
{% endblock %}-e 

===== templates/errors/403.html =====
{% extends "layout/base.html" %}

{% block page_title %}Access Denied (403){% endblock %}

{% block content %}
{% set no_sidebar = True if not current_user or not current_user.is_authenticated else False %} {# Show sidebar if user is logged in #}

<div class="container text-center py-5">
    <div class="row justify-content-center">
        <div class="col-lg-8 col-md-10">
            <i class="bi bi-shield-lock-fill text-danger display-1 mb-4"></i>
            <h1 class="display-4 font-heading text-danger">Access Denied</h1>
            <p class="lead text-muted">
                Oops! It seems you don't have permission to access this page or resource.
            </p>
            <hr class="my-4">
            <p class="mb-1">
                If you believe you should have access, please contact the system administrator or your designated superior.
            </p>
            <p class="text-muted small">
                (Error Code: 403 Forbidden)
            </p>
            <div class="mt-4">
                {% if current_user.is_authenticated %}
                    <a href="{{ url_for('role_redirect') }}" class="btn btn-primary btn-lg me-2">
                        <i class="bi bi-house-door-fill me-2"></i>Go to Dashboard
                    </a>
                {% else %}
                    <a href="{{ url_for('login') }}" class="btn btn-primary btn-lg me-2">
                        <i class="bi bi-box-arrow-in-right me-2"></i>Login
                    </a>
                {% endif %}
                <a href="javascript:history.back()" class="btn btn-outline-secondary btn-lg">
                    <i class="bi bi-arrow-left-circle-fill me-2"></i>Go Back
                </a>
            </div>
        </div>
    </div>
</div>
{% endblock %}-e 

===== templates/errors/404.html =====
{% extends "layout/base.html" %}

{% block page_title %}Page Not Found (404){% endblock %}

{% block content %}
{% set no_sidebar = True if not current_user or not current_user.is_authenticated else False %} {# Show sidebar if user is logged in #}

<div class="container text-center py-5">
    <div class="row justify-content-center">
        <div class="col-lg-8 col-md-10">
            <i class="bi bi-compass-fill text-warning display-1 mb-4"></i>
            <h1 class="display-4 font-heading text-warning">Page Not Found</h1>
            <p class="lead text-muted">
                We're sorry, but the page you were looking for could not be found.
            </p>
            <p class="text-muted">
                It might have been removed, had its name changed, or is temporarily unavailable.
            </p>
            <hr class="my-4">
            <p class="mb-1">
                Please check the URL for any typos, or try navigating from the main dashboard.
            </p>
            <p class="text-muted small">
                (Error Code: 404 Not Found)
            </p>
            <div class="mt-4">
                {% if current_user.is_authenticated %}
                    <a href="{{ url_for('role_redirect') }}" class="btn btn-primary btn-lg me-2">
                        <i class="bi bi-house-door-fill me-2"></i>Go to Dashboard
                    </a>
                {% else %}
                     <a href="{{ url_for('home') }}" class="btn btn-primary btn-lg me-2">
                        <i class="bi bi-house-door-fill me-2"></i>Go to Homepage
                    </a>
                {% endif %}
                <a href="javascript:history.back()" class="btn btn-outline-secondary btn-lg">
                    <i class="bi bi-arrow-left-circle-fill me-2"></i>Go Back
                </a>
            </div>
        </div>
    </div>
</div>
{% endblock %}-e 

===== templates/index.html =====
{% extends "layout/base.html" %}

{% block page_title %}Welcome to Nexus - Kechene Debre Selam G.S.S.{% endblock %}

{% block content %}
{% set no_sidebar = True %} {# No sidebar for the public landing page #}

<style>
    .hero-section {
        background: linear-gradient(135deg, var(--nexus-primary) 0%, var(--nexus-secondary) 100%);
        color: var(--nexus-light);
        padding: 6rem 1.5rem;
        text-align: center;
        border-bottom-left-radius: 50% 20%;
        border-bottom-right-radius: 50% 20%;
        margin-bottom: -1px; /* To overlap slight rendering gaps with cards */
    }
    .hero-section h1 {
        font-size: 2.8rem;
        font-weight: 700; /* Poppins Bold */
        color: #fff; /* Ensure high contrast on gradient */
        margin-bottom: 0.5rem;
    }
    .hero-section .lead {
        font-size: 1.3rem;
        font-weight: 300; /* Poppins Light */
        color: rgba(255, 255, 255, 0.85);
        margin-bottom: 2rem;
        max-width: 700px;
        margin-left: auto;
        margin-right: auto;
    }
    .hero-section .btn-lg {
        padding: 0.8rem 2rem;
        font-size: 1.1rem;
    }
    .features-section {
        padding: 4rem 1.5rem;
    }
    .feature-icon {
        font-size: 3rem;
        color: var(--nexus-primary);
        margin-bottom: 1rem;
        display: inline-block;
        padding: 1rem;
        background-color: rgba(var(--nexus-primary-rgb), 0.1); /* Assuming --nexus-primary-rgb is defined or use lighten */
        border-radius: 50%;
    }
     .login-form-section {
        padding: 3rem 1.5rem;
        background-color: var(--nexus-body-bg); /* Match body background */
    }
    .login-form-section .card {
        border: none; /* Remove card border for seamless look */
    }
</style>

{# Hero Section #}
<div class="hero-section">
    <div class="container">
        <img src="{{ url_for('static', filename='img/logo_light.png') }}" alt="Kechene Debre Selam G.S.S. Logo" class="mb-4" style="max-height: 80px;">
        <h1 class="display-4 font-heading">Welcome to Kechene Debre Selam G.S.S.</h1>
        <p class="lead">Powered by <strong>Nexus School Management</strong> - Your integrated platform for seamless school operations and enhanced learning experiences.</p>
        <div class="d-grid gap-2 d-sm-flex justify-content-sm-center">
            <a href="{{ url_for('login') }}" class="btn btn-light btn-lg px-4 gap-3"><i class="bi bi-box-arrow-in-right me-2"></i>Login</a>
            <a href="{{ url_for('pre_register') }}" class="btn btn-outline-light btn-lg px-4"><i class="bi bi-person-plus-fill me-2"></i>Register</a>
        </div>
    </div>
</div>

{# Login Form Section - Placed prominently after hero for easy access #}
<section class="login-form-section">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-lg-5 col-md-7">
                 <div class="card shadow-lg">
                    <div class="card-body p-4 p-md-5">
                        <h3 class="card-title text-center font-heading mb-4">Secure Login</h3>
                        {% include 'layout/_flash_messages.html' %} {# Include flash messages here too #}
                        <form method="POST" action="{{ url_for('login', next=request.args.get('next')) }}" novalidate>
                            {{ form.hidden_tag() if form.hidden_tag }}
                            <div class="mb-3">
                                {{ form.username.label(class="form-label") }}
                                {{ form.username(class="form-control form-control-lg" + (" is-invalid" if form.username.errors else ""), placeholder="Username") }}
                                {% if form.username.errors %}
                                    <div class="invalid-feedback">
                                        {% for error in form.username.errors %}<span>{{ error }}</span>{% endfor %}
                                    </div>
                                {% endif %}
                            </div>
                            <div class="mb-3">
                                {{ form.password.label(class="form-label") }}
                                {{ form.password(class="form-control form-control-lg" + (" is-invalid" if form.password.errors else ""), placeholder="Password") }}
                                {% if form.password.errors %}
                                    <div class="invalid-feedback">
                                        {% for error in form.password.errors %}<span>{{ error }}</span>{% endfor %}
                                    </div>
                                {% endif %}
                            </div>
                            <div class="d-grid">
                                {{ form.submit(class="btn btn-primary btn-lg w-100") }}
                            </div>
                            <div class="text-center mt-3">
                                <small><a href="{{ url_for('pre_register') }}" class="text-muted">Need an account? Register</a></small>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>


{# Features Section - Optional, can be expanded or removed #}
<section class="features-section text-center">
    <div class="container">
        <h2 class="mb-5 font-heading">Why Choose Nexus?</h2>
        <div class="row">
            <div class="col-md-4 mb-4">
                <div class="p-3">
                    <span class="feature-icon"><i class="bi bi-people-fill"></i></span>
                    <h4 class="font-heading mt-3">Centralized Management</h4>
                    <p class="text-muted">Streamline all administrative, academic, and communication tasks in one powerful platform.</p>
                </div>
            </div>
            <div class="col-md-4 mb-4">
                 <div class="p-3">
                    <span class="feature-icon"><i class="bi bi-bar-chart-line-fill"></i></span>
                    <h4 class="font-heading mt-3">Data-Driven Insights</h4>
                    <p class="text-muted">Access real-time analytics to monitor progress, identify trends, and make informed decisions.</p>
                </div>
            </div>
            <div class="col-md-4 mb-4">
                 <div class="p-3">
                    <span class="feature-icon"><i class="bi bi-shield-check"></i></span>
                    <h4 class="font-heading mt-3">Secure & Reliable</h4>
                    <p class="text-muted">Built with security at its core to protect your data and ensure dependable performance.</p>
                </div>
            </div>
        </div>
    </div>
</section>

{# Call to Action / Contact Section - Optional #}
{# <section class="py-5 bg-light">
    <div class="container text-center">
        <h3 class="font-heading">Ready to Transform Your School?</h3>
        <p class="lead text-muted">Contact us today to learn more about Nexus for Kechene Debre Selam G.S.S.</p>
        <a href="#" class="btn btn-info btn-lg mt-3">Get in Touch</a> {# Placeholder link #}
    {# </div>
</section> #}

{% endblock %}

{% block body_scripts %}
<script>
    // Any page-specific JavaScript for index.html can go here.
    // For instance, animations or interactive elements for the hero/features.
</script>
{% endblock %}-e 

===== templates/dashboard_fallback.html =====
{% extends "layout/base.html" %}

{% block page_title %}Dashboard{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <div class="col-12">
            <div class="page-title-container d-flex justify-content-between align-items-center mb-4">
                <h1 class="page-title font-heading mb-0">Welcome, {{ current_user.full_name or current_user.username }}!</h1>
            </div>

            {% include 'layout/_flash_messages.html' %} {# Show any specific flash messages #}

            <div class="card shadow-sm">
                <div class="card-header bg-secondary text-white">
                    <h5 class="mb-0 font-heading"><i class="bi bi-info-circle-fill me-2"></i>Generic Dashboard</h5>
                </div>
                <div class="card-body">
                    <p class="lead">
                        This is a fallback dashboard. Your role-specific dashboard may not be fully configured yet.
                    </p>
                    <p>
                        You can access common features like your settings, notifications, and chat via the navigation menus.
                    </p>
                    <hr>
                    <p class="mb-0">
                        If you believe you should have access to more specific features, please contact the system administrator.
                    </p>
                </div>
            </div>

            <div class="row mt-4">
                <div class="col-md-6 col-lg-4 mb-3">
                    <div class="card dashboard-stat-card h-100">
                        <div class="card-body">
                            <div class="stat-icon text-primary">
                                <i class="bi bi-bell-fill"></i>
                            </div>
                            <div>
                                <div class="stat-value">
                                    {{ unread_notifications_count if unread_notifications_count != "N/A" else 0 }}
                                </div>
                                <div class="stat-label">Unread Notifications</div>
                            </div>
                        </div>
                         <a href="{{ url_for('view_notifications') }}" class="card-footer text-decoration-none text-muted small">
                            View All <i class="bi bi-arrow-right-short"></i>
                        </a>
                    </div>
                </div>
                 <div class="col-md-6 col-lg-4 mb-3">
                    <div class="card dashboard-stat-card h-100">
                        <div class="card-body">
                            <div class="stat-icon text-success">
                                <i class="bi bi-chat-dots-fill"></i>
                            </div>
                            <div>
                                <div class="stat-value">
                                     {{ unread_messages_count if unread_messages_count != "N/A" else 0 }}
                                </div>
                                <div class="stat-label">Unread Messages</div>
                            </div>
                        </div>
                         <a href="{{ url_for('contacts_list') }}" class="card-footer text-decoration-none text-muted small">
                            Go to Chats <i class="bi bi-arrow-right-short"></i>
                        </a>
                    </div>
                </div>
                 <div class="col-md-12 col-lg-4 mb-3">
                    <div class="card dashboard-stat-card h-100">
                        <div class="card-body">
                            <div class="stat-icon text-info">
                                <i class="bi bi-gear-fill"></i>
                            </div>
                            <div>
                                <div class="stat-value" style="font-size: 1.5rem;">Profile & Settings</div>
                                <div class="stat-label">Manage your account</div>
                            </div>
                        </div>
                        <a href="{{ url_for('settings') }}" class="card-footer text-decoration-none text-muted small">
                            Go to Settings <i class="bi bi-arrow-right-short"></i>
                        </a>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>
{% endblock %}-e 

===== templates/settings.html =====
{% extends "layout/base.html" %}

{% block page_title %}My Settings{% endblock %}

{% block content_header %}
    <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h1 class="page-title font-heading mb-0">
            <i class="bi bi-person-fill-gear me-2 text-primary"></i>Account Settings & Profile
        </h1>
        {# Optional: Button for a specific action, e.g., View Public Profile #}
        {# <div class="btn-toolbar mb-2 mb-md-0">
            <a href="#" class="btn btn-sm btn-outline-info">
                <i class="bi bi-eye-fill me-1"></i> View My Public Profile
            </a>
        </div> #}
    </div>
{% endblock %}

{% block content %}
<div class="container-fluid px-0">
    <form method="POST" action="{{ url_for('settings') }}" enctype="multipart/form-data" novalidate>
        {{ form.hidden_tag() if form.hidden_tag }} {# CSRF token and other hidden fields #}

        <div class="row g-4">
            {# Left Column: Profile Picture and Basic Info #}
            <div class="col-lg-4 col-xl-3">
                <div class="card shadow-sm mb-4">
                    <div class="card-header">
                        <h5 class="mb-0 font-heading"><i class="bi bi-person-badge me-2"></i>Profile Picture</h5>
                    </div>
                    <div class="card-body text-center">
                        {% if current_user.profile_photo_url %}
                            <img src="{{ url_for('static', filename=current_user.profile_photo_url) }}"
                                 alt="{{ current_user.username }}'s profile photo"
                                 class="img-fluid rounded-circle mb-3 shadow-sm"
                                 style="width: 150px; height: 150px; object-fit: cover; border: 3px solid var(--nexus-border-color);"
                                 id="profileImagePreview">
                        {% else %}
                            <img src="{{ url_for('static', filename='img/placeholders/user_avatar_default.png') }}"
                                 alt="Default profile avatar"
                                 class="img-fluid rounded-circle mb-3 shadow-sm"
                                 style="width: 150px; height: 150px; object-fit: cover; border: 3px solid var(--nexus-border-color);"
                                 id="profileImagePreview">
                        {% endif %}

                        {# Profile Photo Upload Field - from UniversalSettingsForm #}
                        {% if form.profile_photo %}
                            <div class="mb-3">
                                {{ form.profile_photo.label(class="form-label visually-hidden") }} {# Label can be hidden if input is clear #}
                                {{ form.profile_photo(class="form-control form-control-sm" + (" is-invalid" if form.profile_photo.errors else ""), id="profilePhotoInput") }}
                                <small class="form-text text-muted d-block mt-1">Max 2MB. JPG, PNG, GIF, WEBP.</small>
                                {% if form.profile_photo.errors %}
                                    <div class="invalid-feedback d-block">
                                        {% for error in form.profile_photo.errors %}<span>{{ error }}</span>{% endfor %}
                                    </div>
                                {% endif %}
                            </div>
                        {% elif form.profile_photo_url %} {# Fallback to URL if FileField isn't on the form #}
                             <div class="mb-3">
                                {{ form.profile_photo_url.label(class="form-label") }}
                                {{ form.profile_photo_url(class="form-control" + (" is-invalid" if form.profile_photo_url.errors else ""), placeholder="http://example.com/photo.jpg (Optional)") }}
                                <small class="form-text text-muted">Direct link to an image (e.g., .jpg, .png).</small>
                                {% if form.profile_photo_url.errors %}
                                    <div class="invalid-feedback">
                                        {% for error in form.profile_photo_url.errors %}<span>{{ error }}</span>{% endfor %}
                                    </div>
                                {% endif %}
                            </div>
                        {% endif %}
                        <p class="text-muted small">Changes to profile picture may require a page refresh to update everywhere.</p>
                    </div>
                </div>

                <div class="card shadow-sm">
                    <div class="card-header">
                         <h5 class="mb-0 font-heading"><i class="bi bi-person-lines-fill me-2"></i>Role & Status</h5>
                    </div>
                    <ul class="list-group list-group-flush">
                        <li class="list-group-item"><strong>Role:</strong> {{ current_user.role.name.replace('_', ' ') | title if current_user.role else 'N/A' }}</li>
                        <li class="list-group-item"><strong>Status:</strong> <span class="badge {{ 'bg-success-subtle text-success-emphasis' if current_user.is_active else 'bg-danger-subtle text-danger-emphasis' }}">{{ 'Active' if current_user.is_active else 'Inactive' }}</span></li>
                        {% if current_user.role.name == 'student' %}
                        <li class="list-group-item"><strong>Grade:</strong> {{ current_user.grade or 'N/A' }}</li>
                        <li class="list-group-item"><strong>Section:</strong> {{ current_user.section or 'N/A' }}</li>
                        <li class="list-group-item">
                            <strong>TC Member:</strong>
                            {{ form.is_tc_member_display(class="form-check-input ms-2", disabled=True, role="switch") if form.is_tc_member_display else ('Yes' if current_user.is_tc_member else 'No') }}
                        </li>
                        {% endif %}
                    </ul>
                </div>
            </div>

            {# Right Column: Form Sections #}
            <div class="col-lg-8 col-xl-9">
                {% include 'layout/_flash_messages.html' %}

                {# Personal Information Section #}
                <div class="card shadow-sm mb-4">
                    <div class="card-header">
                        <h5 class="mb-0 font-heading"><i class="bi bi-person-vcard-fill me-2"></i>Personal Information</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            {{ form.full_name.label(class="form-label") }}
                            {{ form.full_name(class="form-control" + (" is-invalid" if form.full_name.errors else ""), placeholder="Your Full Name") }}
                            {% if form.full_name.errors %}<div class="invalid-feedback">{% for e in form.full_name.errors %}{{e}}{% endfor %}</div>{% endif %}
                        </div>
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                {{ form.age.label(class="form-label") }}
                                {{ form.age(class="form-control" + (" is-invalid" if form.age.errors else ""), placeholder="e.g., 16") }}
                                {% if form.age.errors %}<div class="invalid-feedback">{% for e in form.age.errors %}{{e}}{% endfor %}</div>{% endif %}
                            </div>
                            <div class="col-md-6 mb-3">
                                {{ form.sex.label(class="form-label") }}
                                {{ form.sex(class="form-select" + (" is-invalid" if form.sex.errors else "")) }}
                                {% if form.sex.errors %}<div class="invalid-feedback">{% for e in form.sex.errors %}{{e}}{% endfor %}</div>{% endif %}
                            </div>
                        </div>
                        {# Additional personal fields from User model if added to form #}
                        {# e.g., form.date_of_birth, form.phone, form.address #}
                    </div>
                </div>

                {# Account Information Section #}
                <div class="card shadow-sm mb-4">
                    <div class="card-header">
                        <h5 class="mb-0 font-heading"><i class="bi bi-shield-lock me-2"></i>Account Credentials</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                {{ form.username.label(class="form-label") }}
                                {{ form.username(class="form-control" + (" is-invalid" if form.username.errors else ""), placeholder="Your Username") }}
                                {% if form.username.errors %}<div class="invalid-feedback">{% for e in form.username.errors %}{{e}}{% endfor %}</div>{% endif %}
                            </div>
                            <div class="col-md-6 mb-3">
                                {{ form.email.label(class="form-label") }}
                                {{ form.email(class="form-control" + (" is-invalid" if form.email.errors else ""), placeholder="your.email@example.com") }}
                                {% if form.email.errors %}<div class="invalid-feedback">{% for e in form.email.errors %}{{e}}{% endfor %}</div>{% endif %}
                            </div>
                        </div>
                        <a href="{{ url_for('change_password') }}" class="btn btn-outline-secondary"><i class="bi bi-key-fill me-1"></i>Change My Password</a>
                    </div>
                </div>

                {# Notification Preferences Section (Placeholder) #}
                <div class="card shadow-sm mb-4">
                    <div class="card-header">
                        <h5 class="mb-0 font-heading"><i class="bi bi-bell-slash-fill me-2"></i>Notification Preferences</h5>
                    </div>
                    <div class="card-body">
                        <p class="text-muted">Manage how you receive notifications from Nexus.</p>
                        {# Example form fields if they exist on UniversalSettingsForm and User model #}
                        {# {% if form.email_notifications %}
                        <div class="form-check form-switch mb-2">
                            {{ form.email_notifications(class="form-check-input" + (" is-invalid" if form.email_notifications.errors else ""), role="switch", id="emailNotificationsSwitch") }}
                            {{ form.email_notifications.label(class="form-check-label", for="emailNotificationsSwitch") }}
                            {% if form.email_notifications.errors %}<div class="invalid-feedback d-block">{% for e in form.email_notifications.errors %}{{e}}{% endfor %}</div>{% endif %}
                        </div>
                        {% endif %} #}
                        <div class="content-placeholder">
                            <i class="bi bi-tools fs-1 mb-2"></i>
                            <p>Notification settings will be available here soon.</p>
                        </div>
                    </div>
                </div>

                {# Other Settings Sections (Placeholders) - e.g., Appearance, Privacy #}

                <div class="mt-4 d-flex justify-content-end">
                    <button type="submit" class="btn btn-primary btn-lg px-4">
                        <i class="bi bi-save-fill me-2"></i>Save All Changes
                    </button>
                </div>
            </div>
        </div>
    </form>
</div>
{% endblock %}

{% block body_scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        console.log('Settings Page JS loaded.');

        const profilePhotoInput = document.getElementById('profilePhotoInput');
        const profileImagePreview = document.getElementById('profileImagePreview');

        if (profilePhotoInput && profileImagePreview) {
            profilePhotoInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        profileImagePreview.src = e.target.result;
                    }
                    reader.readAsDataURL(file);
                } else {
                    // If no file selected, or selection cancelled, revert to original or default
                    // This might need to fetch the original URL from a data attribute on the preview img
                    // For simplicity, not implemented here. The backend will handle no-change.
                }
            });
        }

        // Initialize TomSelect for any .tom-select elements if used on this page
        // (e.g., if a 'preferred_language' select field was enhanced)
        // initializeTomSelect(); // Assuming initializeTomSelect is in main.js or utils.js
    });
</script>
{% endblock %}